<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/src/mem5.c"><comment type="block">/*
** 2007 October 14
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains the C functions that implement a memory
** allocation subsystem for use by SQLite. 
**
** This version of the memory allocation subsystem omits all
** use of malloc(). The application gives SQLite a block of memory
** before calling sqlite3_initialize() from which allocations
** are made and returned by the xMalloc() and xRealloc() 
** implementations. Once sqlite3_initialize() has been called,
** the amount of memory available to SQLite is fixed and cannot
** be changed.
**
** This version of the memory allocation subsystem is included
** in the build only if SQLITE_ENABLE_MEMSYS5 is defined.
**
** This memory allocator uses the following algorithm:
**
**   1.  All memory allocation sizes are rounded up to a power of 2.
**
**   2.  If two adjacent free blocks are the halves of a larger block,
**       then the two blocks are coalesced into the single larger block.
**
**   3.  New memory is allocated from the first available free block.
**
** This algorithm is described in: J. M. Robson. "Bounds for Some Functions
** Concerning Dynamic Storage Allocation". Journal of the Association for
** Computing Machinery, Volume 21, Number 8, July 1974, pages 491-499.
** 
** Let n be the size of the largest allocation divided by the minimum
** allocation size (after rounding all sizes up to a power of 2.)  Let M
** be the maximum amount of memory ever outstanding at one time.  Let
** N be the total amount of memory available for allocation.  Robson
** proved that this memory allocator will never breakdown due to 
** fragmentation as long as the following constraint holds:
**
**      N &gt;=  M*(1 + log2(n)/2) - n + 1
**
** The sqlite3_status() logic tracks the maximum values of n and M so
** that an application can, at any time, verify this constraint.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** This version of the memory allocator is used only when 
** SQLITE_ENABLE_MEMSYS5 is defined.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_MEMSYS5</name></cpp:ifdef>

<comment type="block">/*
** A minimum allocation is an instance of the following structure.
** Larger allocations are an array of these structures where the
** size of the array is a power of 2.
**
** The size of this object must be a power of two.  That fact is
** verified in memsys5Init().
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>Mem5Link</name></name></type> <name>Mem5Link</name>;</typedef>
<struct>struct <name>Mem5Link</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>next</name></decl>;</decl_stmt>       <comment type="block">/* Index of next free chunk */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>prev</name></decl>;</decl_stmt>       <comment type="block">/* Index of previous free chunk */</comment>
}</block>;</struct>

<comment type="block">/*
** Maximum size of any allocation is ((1&lt;&lt;LOGMAX)*mem5.szAtom). Since
** mem5.szAtom is always at least 8 and 32-bit integers are used,
** it is not actually possible to reach this limit.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOGMAX</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define>

<comment type="block">/*
** Masks used for mem5.aCtrl[] elements.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTRL_LOGSIZE</name></cpp:macro>  <cpp:value>0x1f</cpp:value></cpp:define>    <comment type="block">/* Log2 Size of this block */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTRL_FREE</name></cpp:macro>     <cpp:value>0x20</cpp:value></cpp:define>    <comment type="block">/* True if not checked out */</comment>

<comment type="block">/*
** All of the static variables used by this module are collected
** into a single structure named "mem5".  This is to keep the
** static variables organized and to reduce namespace pollution
** when this module is combined with other in the amalgamation.
*/</comment>
<expr_stmt><expr><specifier>static</specifier> <name>SQLITE_WSD</name> struct <name>Mem5Global</name> <block>{
  <comment type="block">/*
  ** Memory available for allocation
  */</comment>
  <expr><name>int</name> <name>szAtom</name></expr>;      <comment type="block">/* Smallest possible allocation in bytes */</comment>
  <expr><name>int</name> <name>nBlock</name></expr>;      <comment type="block">/* Number of szAtom sized blocks in zPool */</comment>
  <expr><name>u8</name> <operator>*</operator><name>zPool</name></expr>;       <comment type="block">/* Memory available to be allocated */</comment>
  
  <comment type="block">/*
  ** Mutex to control access to the memory allocation subsystem.
  */</comment>
  <expr><name>sqlite3_mutex</name> <operator>*</operator><name>mutex</name></expr>;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/*
  ** Performance statistics
  */</comment>
  <expr><name>u64</name> <name>nAlloc</name></expr>;         <comment type="block">/* Total number of calls to malloc */</comment>
  <expr><name>u64</name> <name>totalAlloc</name></expr>;     <comment type="block">/* Total of all malloc calls - includes internal frag */</comment>
  <expr><name>u64</name> <name>totalExcess</name></expr>;    <comment type="block">/* Total internal fragmentation */</comment>
  <expr><name>u32</name> <name>currentOut</name></expr>;     <comment type="block">/* Current checkout, including internal fragmentation */</comment>
  <expr><name>u32</name> <name>currentCount</name></expr>;   <comment type="block">/* Current number of distinct checkouts */</comment>
  <expr><name>u32</name> <name>maxOut</name></expr>;         <comment type="block">/* Maximum instantaneous currentOut */</comment>
  <expr><name>u32</name> <name>maxCount</name></expr>;       <comment type="block">/* Maximum instantaneous currentCount */</comment>
  <expr><name>u32</name> <name>maxRequest</name></expr>;     <comment type="block">/* Largest allocation (exclusive of internal frag) */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <comment type="block">/*
  ** Lists of free blocks.  aiFreelist[0] is a list of free blocks of
  ** size mem5.szAtom.  aiFreelist[1] holds blocks of size szAtom*2.
  ** aiFreelist[2] holds free blocks of size szAtom*4.  And so forth.
  */</comment>
  <expr><name>int</name> <name><name>aiFreelist</name><index>[<expr><name>LOGMAX</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;

  <comment type="block">/*
  ** Space for tracking which blocks are checked out and the size
  ** of each block.  One byte per block.
  */</comment>
  <expr><name>u8</name> <operator>*</operator><name>aCtrl</name></expr>;

}</block> <name>mem5</name></expr>;</expr_stmt>

<comment type="block">/*
** Access the static variable through a macro for SQLITE_OMIT_WSD.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mem5</name></cpp:macro> <cpp:value>GLOBAL(struct Mem5Global, mem5)</cpp:value></cpp:define>

<comment type="block">/*
** Assuming mem5.zPool is divided up into an array of Mem5Link
** structures, return a pointer to the idx-th such link.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MEM5LINK</name><parameter_list>(<parameter><type><name>idx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((Mem5Link *)(&amp;mem5.zPool[(idx)*mem5.szAtom]))</cpp:value></cpp:define>

<comment type="block">/*
** Unlink the chunk at mem5.aPool[i] from list it is currently
** on.  It should be found on mem5.aiFreelist[iLogsize].
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>memsys5Unlink</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLogsize</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>next</name></decl>, <decl><type ref="prev"/><name>prev</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>mem5</name><operator>.</operator><name>nBlock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLogsize</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iLogsize</name><operator>&lt;=</operator><name>LOGMAX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>mem5</name><operator>.</operator><name>aCtrl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>CTRL_LOGSIZE</name><operator>)</operator><operator>==</operator><name>iLogsize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>MEM5LINK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>MEM5LINK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>prev</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>prev</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>aiFreelist</name><index>[<expr><name>iLogsize</name></expr>]</index></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>MEM5LINK</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>next</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>MEM5LINK</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>prev</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Link the chunk at mem5.aPool[i] so that is on the iLogsize
** free list.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>memsys5Link</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLogsize</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>mem5</name><operator>.</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>mem5</name><operator>.</operator><name>nBlock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLogsize</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iLogsize</name><operator>&lt;=</operator><name>LOGMAX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>mem5</name><operator>.</operator><name>aCtrl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>CTRL_LOGSIZE</name><operator>)</operator><operator>==</operator><name>iLogsize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>MEM5LINK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name> <operator>=</operator> <name><name>mem5</name><operator>.</operator><name>aiFreelist</name><index>[<expr><name>iLogsize</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>MEM5LINK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>prev</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>x</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>x</name><operator>&lt;</operator><name><name>mem5</name><operator>.</operator><name>nBlock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MEM5LINK</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>prev</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>aiFreelist</name><index>[<expr><name>iLogsize</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Obtain or release the mutex needed to access global data structures.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>memsys5Enter</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>mem5</name><operator>.</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>memsys5Leave</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>mem5</name><operator>.</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the size of an outstanding allocation, in bytes.
** This only works for chunks that are currently checked out.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>memsys5Size</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iSize</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>p</name><operator>-</operator><name><name>mem5</name><operator>.</operator><name>zPool</name></name><operator>)</operator><operator>/</operator><name><name>mem5</name><operator>.</operator><name>szAtom</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>mem5</name><operator>.</operator><name>nBlock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iSize</name> <operator>=</operator> <name><name>mem5</name><operator>.</operator><name>szAtom</name></name> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name><name>mem5</name><operator>.</operator><name>aCtrl</name><index>[<expr><name>i</name></expr>]</index></name><operator>&amp;</operator><name>CTRL_LOGSIZE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>iSize</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a block of memory of at least nBytes in size.
** Return NULL if unable.  Return NULL if nBytes==0.
**
** The caller guarantees that nByte is positive.
**
** The caller has obtained a mutex prior to invoking this
** routine so there is never any chance that two or more
** threads can be in this routine at the same time.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>memsys5MallocUnsafe</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>           <comment type="block">/* Index of a mem5.aPool[] slot */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iBin</name></decl>;</decl_stmt>        <comment type="block">/* Index into mem5.aiFreelist[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iFullSz</name></decl>;</decl_stmt>     <comment type="block">/* Size of allocation rounded up to power of 2 */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLogsize</name></decl>;</decl_stmt>    <comment type="block">/* Log2 of iFullSz/POW2_MIN */</comment>

  <comment type="block">/* nByte must be a positive */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* No more than 1GiB per allocation */</comment>
  <if_stmt><if>if<condition>( <expr><name>nByte</name> <operator>&gt;</operator> <literal type="number">0x40000000</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/* Keep track of the maximum allocation request.  Even unfulfilled
  ** requests are counted */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>u32</name><operator>)</operator><name>nByte</name><operator>&gt;</operator><name><name>mem5</name><operator>.</operator><name>maxRequest</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>maxRequest</name></name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


  <comment type="block">/* Round nByte up to the next valid power of two */</comment>
  <for>for<control>(<init><expr><name>iFullSz</name><operator>=</operator><name><name>mem5</name><operator>.</operator><name>szAtom</name></name></expr><operator>,</operator><expr><name>iLogsize</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iFullSz</name><operator>&lt;</operator><name>nByte</name></expr>;</condition> <incr><expr><name>iFullSz</name><operator>*=</operator><literal type="number">2</literal></expr><operator>,</operator><expr><name>iLogsize</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>

  <comment type="block">/* Make sure mem5.aiFreelist[iLogsize] contains at least one free
  ** block.  If not, then split a block of the next larger power of
  ** two in order to create a new free block of size iLogsize.
  */</comment>
  <for>for<control>(<init><expr><name>iBin</name><operator>=</operator><name>iLogsize</name></expr>;</init> <condition><expr><name>iBin</name><operator>&lt;=</operator><name>LOGMAX</name> <operator>&amp;&amp;</operator> <name><name>mem5</name><operator>.</operator><name>aiFreelist</name><index>[<expr><name>iBin</name></expr>]</index></name><operator>&lt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>iBin</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>iBin</name><operator>&gt;</operator><name>LOGMAX</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>xLog</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_NOMEM</name></expr></argument>, <argument><expr><literal type="string">"failed to allocate %u bytes"</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>mem5</name><operator>.</operator><name>aiFreelist</name><index>[<expr><name>iBin</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memsys5Unlink</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>iBin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>iBin</name><operator>&gt;</operator><name>iLogsize</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>newSize</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>iBin</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>newSize</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>iBin</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>aCtrl</name><index>[<expr><name>i</name><operator>+</operator><name>newSize</name></expr>]</index></name> <operator>=</operator> <name>CTRL_FREE</name> <operator>|</operator> <name>iBin</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memsys5Link</name><argument_list>(<argument><expr><name>i</name><operator>+</operator><name>newSize</name></expr></argument>, <argument><expr><name>iBin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>aCtrl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>iLogsize</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/* Update allocator performance statistics. */</comment>
  <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>nAlloc</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>totalAlloc</name></name> <operator>+=</operator> <name>iFullSz</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>totalExcess</name></name> <operator>+=</operator> <name>iFullSz</name> <operator>-</operator> <name>nByte</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>currentCount</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>currentOut</name></name> <operator>+=</operator> <name>iFullSz</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>mem5</name><operator>.</operator><name>maxCount</name></name><operator>&lt;</operator><name><name>mem5</name><operator>.</operator><name>currentCount</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>maxCount</name></name> <operator>=</operator> <name><name>mem5</name><operator>.</operator><name>currentCount</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>mem5</name><operator>.</operator><name>maxOut</name></name><operator>&lt;</operator><name><name>mem5</name><operator>.</operator><name>currentOut</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>maxOut</name></name> <operator>=</operator> <name><name>mem5</name><operator>.</operator><name>currentOut</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* Make sure the allocated memory does not assume that it is set to zero
  ** or retains a value from a previous allocation */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mem5</name><operator>.</operator><name>zPool</name><index>[<expr><name>i</name><operator>*</operator><name><name>mem5</name><operator>.</operator><name>szAtom</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0xAA</literal></expr></argument>, <argument><expr><name>iFullSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Return a pointer to the allocated memory. */</comment>
  <return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>mem5</name><operator>.</operator><name>zPool</name><index>[<expr><name>i</name><operator>*</operator><name><name>mem5</name><operator>.</operator><name>szAtom</name></name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free an outstanding memory allocation.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>memsys5FreeUnsafe</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pOld</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>iLogsize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iBlock</name></decl>;</decl_stmt>

  <comment type="block">/* Set iBlock to the index of the block pointed to by pOld in 
  ** the array of mem5.szAtom byte blocks pointed to by mem5.zPool.
  */</comment>
  <expr_stmt><expr><name>iBlock</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>pOld</name><operator>-</operator><name><name>mem5</name><operator>.</operator><name>zPool</name></name><operator>)</operator><operator>/</operator><name><name>mem5</name><operator>.</operator><name>szAtom</name></name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* Check that the pointer pOld points to a valid, non-free block. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iBlock</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iBlock</name><operator>&lt;</operator><name><name>mem5</name><operator>.</operator><name>nBlock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>pOld</name><operator>-</operator><name><name>mem5</name><operator>.</operator><name>zPool</name></name><operator>)</operator><operator>%</operator><name><name>mem5</name><operator>.</operator><name>szAtom</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>mem5</name><operator>.</operator><name>aCtrl</name><index>[<expr><name>iBlock</name></expr>]</index></name> <operator>&amp;</operator> <name>CTRL_FREE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iLogsize</name> <operator>=</operator> <name><name>mem5</name><operator>.</operator><name>aCtrl</name><index>[<expr><name>iBlock</name></expr>]</index></name> <operator>&amp;</operator> <name>CTRL_LOGSIZE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal><operator>&lt;&lt;</operator><name>iLogsize</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iBlock</name><operator>+</operator><name>size</name><operator>-</operator><literal type="number">1</literal><operator>&lt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name><name>mem5</name><operator>.</operator><name>nBlock</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>aCtrl</name><index>[<expr><name>iBlock</name></expr>]</index></name> <operator>|=</operator> <name>CTRL_FREE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>aCtrl</name><index>[<expr><name>iBlock</name><operator>+</operator><name>size</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <name>CTRL_FREE</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>mem5</name><operator>.</operator><name>currentCount</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>mem5</name><operator>.</operator><name>currentOut</name></name><operator>&gt;=</operator><operator>(</operator><name>size</name><operator>*</operator><name><name>mem5</name><operator>.</operator><name>szAtom</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>currentCount</name></name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>currentOut</name></name> <operator>-=</operator> <name>size</name><operator>*</operator><name><name>mem5</name><operator>.</operator><name>szAtom</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>mem5</name><operator>.</operator><name>currentOut</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>mem5</name><operator>.</operator><name>currentCount</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>mem5</name><operator>.</operator><name>currentCount</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>mem5</name><operator>.</operator><name>currentOut</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>aCtrl</name><index>[<expr><name>iBlock</name></expr>]</index></name> <operator>=</operator> <name>CTRL_FREE</name> <operator>|</operator> <name>iLogsize</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>iLogsize</name><operator>&lt;</operator><name>LOGMAX</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iBuddy</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iBlock</name><operator>&gt;&gt;</operator><name>iLogsize</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iBuddy</name> <operator>=</operator> <name>iBlock</name> <operator>-</operator> <name>size</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iBuddy</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iBuddy</name> <operator>=</operator> <name>iBlock</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iBuddy</name><operator>&gt;=</operator><name><name>mem5</name><operator>.</operator><name>nBlock</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>mem5</name><operator>.</operator><name>aCtrl</name><index>[<expr><name>iBuddy</name></expr>]</index></name><operator>!=</operator><operator>(</operator><name>CTRL_FREE</name> <operator>|</operator> <name>iLogsize</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memsys5Unlink</name><argument_list>(<argument><expr><name>iBuddy</name></expr></argument>, <argument><expr><name>iLogsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iLogsize</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iBuddy</name><operator>&lt;</operator><name>iBlock</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>aCtrl</name><index>[<expr><name>iBuddy</name></expr>]</index></name> <operator>=</operator> <name>CTRL_FREE</name> <operator>|</operator> <name>iLogsize</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>aCtrl</name><index>[<expr><name>iBlock</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>iBlock</name> <operator>=</operator> <name>iBuddy</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>aCtrl</name><index>[<expr><name>iBlock</name></expr>]</index></name> <operator>=</operator> <name>CTRL_FREE</name> <operator>|</operator> <name>iLogsize</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>aCtrl</name><index>[<expr><name>iBuddy</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>size</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></while>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <comment type="block">/* Overwrite freed memory with the 0x55 bit pattern to verify that it is
  ** not used after being freed */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mem5</name><operator>.</operator><name>zPool</name><index>[<expr><name>iBlock</name><operator>*</operator><name><name>mem5</name><operator>.</operator><name>szAtom</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0x55</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>memsys5Link</name><argument_list>(<argument><expr><name>iBlock</name></expr></argument>, <argument><expr><name>iLogsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Allocate nBytes of memory.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>memsys5Malloc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nBytes</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>nBytes</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memsys5Enter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>memsys5MallocUnsafe</name><argument_list>(<argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memsys5Leave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>p</name></expr>;</return> 
</block_content>}</block></function>

<comment type="block">/*
** Free memory.
**
** The outer layer memory allocator prevents this routine from
** being called with pPrior==0.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>memsys5Free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pPrior</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPrior</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memsys5Enter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memsys5FreeUnsafe</name><argument_list>(<argument><expr><name>pPrior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memsys5Leave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  
</block_content>}</block></function>

<comment type="block">/*
** Change the size of an existing memory allocation.
**
** The outer layer memory allocator prevents this routine from
** being called with pPrior==0.  
**
** nBytes is always a value obtained from a prior call to
** memsys5Round().  Hence nBytes is always a non-negative power
** of two.  If nBytes==0 that means that an oversize allocation
** (an allocation larger than 0x40000000) was requested and this
** routine should return 0 without freeing pPrior.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>memsys5Realloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pPrior</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nBytes</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nOld</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPrior</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>nBytes</name><operator>&amp;</operator><operator>(</operator><name>nBytes</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* EV: R-46199-30249 */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nBytes</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nBytes</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nOld</name> <operator>=</operator> <call><name>memsys5Size</name><argument_list>(<argument><expr><name>pPrior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nBytes</name><operator>&lt;=</operator><name>nOld</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>pPrior</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>memsys5Malloc</name><argument_list>(<argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pPrior</name></expr></argument>, <argument><expr><name>nOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memsys5Free</name><argument_list>(<argument><expr><name>pPrior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Round up a request size to the next valid allocation size.  If
** the allocation is too large to be handled by this allocation system,
** return 0.
**
** All allocations must be a power of two and must be expressed by a
** 32-bit signed integer.  Hence the largest allocation is 0x40000000
** or 1073741824 bytes.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>memsys5Roundup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iFullSz</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name> <operator>&gt;</operator> <literal type="number">0x40000000</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>iFullSz</name><operator>=</operator><name><name>mem5</name><operator>.</operator><name>szAtom</name></name></expr>;</init> <condition><expr><name>iFullSz</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>iFullSz</name> <operator>*=</operator> <literal type="number">2</literal></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <return>return <expr><name>iFullSz</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the ceiling of the logarithm base 2 of iValue.
**
** Examples:   memsys5Log(1) -&gt; 0
**             memsys5Log(2) -&gt; 1
**             memsys5Log(4) -&gt; 2
**             memsys5Log(5) -&gt; 3
**             memsys5Log(8) -&gt; 3
**             memsys5Log(9) -&gt; 4
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>memsys5Log</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>iValue</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iLog</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>iLog</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>iLog</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">8</literal><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>iLog</name><operator>)</operator><operator>&lt;</operator><name>iValue</name></expr>;</condition> <incr><expr><name>iLog</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <return>return <expr><name>iLog</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize the memory allocator.
**
** This routine is not threadsafe.  The caller must be holding a mutex
** to prevent multiple threads from entering at the same time.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>memsys5Init</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>            <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nByte</name></decl>;</decl_stmt>         <comment type="block">/* Number of bytes of memory available to this allocator */</comment>
  <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>zByte</name></decl>;</decl_stmt>         <comment type="block">/* Memory usable by this allocator */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nMinLog</name></decl>;</decl_stmt>       <comment type="block">/* Log base 2 of minimum allocation size in bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iOffset</name></decl>;</decl_stmt>       <comment type="block">/* An offset into mem5.aCtrl[] */</comment>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* For the purposes of this routine, disable the mutex */</comment>
  <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>mutex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* The size of a Mem5Link object must be a power of two.  Verify that
  ** this is case.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Mem5Link</name></expr></argument>)</argument_list></sizeof><operator>&amp;</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Mem5Link</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>nByte</name> <operator>=</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>nHeap</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zByte</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pHeap</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zByte</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* sqlite3_config() does not allow otherwise */</comment>

  <comment type="block">/* boundaries on sqlite3GlobalConfig.mnReq are enforced in sqlite3_config() */</comment>
  <expr_stmt><expr><name>nMinLog</name> <operator>=</operator> <call><name>memsys5Log</name><argument_list>(<argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mnReq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>szAtom</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>nMinLog</name><operator>)</operator></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Mem5Link</name></expr></argument>)</argument_list></sizeof><operator>&gt;</operator><name><name>mem5</name><operator>.</operator><name>szAtom</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>szAtom</name></name> <operator>=</operator> <name><name>mem5</name><operator>.</operator><name>szAtom</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>nBlock</name></name> <operator>=</operator> <operator>(</operator><name>nByte</name> <operator>/</operator> <operator>(</operator><name><name>mem5</name><operator>.</operator><name>szAtom</name></name><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>u8</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>zPool</name></name> <operator>=</operator> <name>zByte</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>aCtrl</name></name> <operator>=</operator> <operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>mem5</name><operator>.</operator><name>zPool</name><index>[<expr><name><name>mem5</name><operator>.</operator><name>nBlock</name></name><operator>*</operator><name><name>mem5</name><operator>.</operator><name>szAtom</name></name></expr>]</index></name></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name><operator>&lt;=</operator><name>LOGMAX</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>aiFreelist</name><index>[<expr><name>ii</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name>iOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>ii</name><operator>=</operator><name>LOGMAX</name></expr>;</init> <condition><expr><name>ii</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>ii</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name> <init>= <expr><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ii</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iOffset</name><operator>+</operator><name>nAlloc</name><operator>)</operator><operator>&lt;=</operator><name><name>mem5</name><operator>.</operator><name>nBlock</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>aCtrl</name><index>[<expr><name>iOffset</name></expr>]</index></name> <operator>=</operator> <name>ii</name> <operator>|</operator> <name>CTRL_FREE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memsys5Link</name><argument_list>(<argument><expr><name>iOffset</name></expr></argument>, <argument><expr><name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iOffset</name> <operator>+=</operator> <name>nAlloc</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>iOffset</name><operator>+</operator><name>nAlloc</name><operator>)</operator><operator>&gt;</operator><name><name>mem5</name><operator>.</operator><name>nBlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* If a mutex is required for normal operation, allocate one */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>bMemstat</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>mutex</name></name> <operator>=</operator> <call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_MEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Deinitialize this module.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>memsys5Shutdown</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>NotUsed</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mem5</name><operator>.</operator><name>mutex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<comment type="block">/*
** Open the file indicated and write a log of all unfreed memory 
** allocations into that log.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3Memsys5Dump</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nMinLog</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>zFilename</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>zFilename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>out</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>out</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"** Unable to output memory debug output log: %s **\n"</literal></expr></argument>,
                      <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>memsys5Enter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nMinLog</name> <operator>=</operator> <call><name>memsys5Log</name><argument_list>(<argument><expr><name><name>mem5</name><operator>.</operator><name>szAtom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>LOGMAX</name> <operator>&amp;&amp;</operator> <name>i</name><operator>+</operator><name>nMinLog</name><operator>&lt;</operator><literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <for>for<control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><name><name>mem5</name><operator>.</operator><name>aiFreelist</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name> <operator>=</operator> <call><name>MEM5LINK</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name></expr><operator>,</operator> <expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"freelist items of size %d: %d\n"</literal></expr></argument>, <argument><expr><name><name>mem5</name><operator>.</operator><name>szAtom</name></name> <operator>&lt;&lt;</operator> <name>i</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"mem5.nAlloc       = %llu\n"</literal></expr></argument>, <argument><expr><name><name>mem5</name><operator>.</operator><name>nAlloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"mem5.totalAlloc   = %llu\n"</literal></expr></argument>, <argument><expr><name><name>mem5</name><operator>.</operator><name>totalAlloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"mem5.totalExcess  = %llu\n"</literal></expr></argument>, <argument><expr><name><name>mem5</name><operator>.</operator><name>totalExcess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"mem5.currentOut   = %u\n"</literal></expr></argument>, <argument><expr><name><name>mem5</name><operator>.</operator><name>currentOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"mem5.currentCount = %u\n"</literal></expr></argument>, <argument><expr><name><name>mem5</name><operator>.</operator><name>currentCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"mem5.maxOut       = %u\n"</literal></expr></argument>, <argument><expr><name><name>mem5</name><operator>.</operator><name>maxOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"mem5.maxCount     = %u\n"</literal></expr></argument>, <argument><expr><name><name>mem5</name><operator>.</operator><name>maxCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"mem5.maxRequest   = %u\n"</literal></expr></argument>, <argument><expr><name><name>mem5</name><operator>.</operator><name>maxRequest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memsys5Leave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>out</name><operator>==</operator><name>stdout</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This routine is the only routine in this file with external 
** linkage. It returns a pointer to a static sqlite3_mem_methods
** struct populated with the memsys5 methods.
*/</comment>
<function><type><specifier>const</specifier> <name>sqlite3_mem_methods</name> <modifier>*</modifier></type><name>sqlite3MemGetMemsys5</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_mem_methods</name></type> <name>memsys5Methods</name> <init>= <expr><block>{
     <expr><name>memsys5Malloc</name></expr>,
     <expr><name>memsys5Free</name></expr>,
     <expr><name>memsys5Realloc</name></expr>,
     <expr><name>memsys5Size</name></expr>,
     <expr><name>memsys5Roundup</name></expr>,
     <expr><name>memsys5Init</name></expr>,
     <expr><name>memsys5Shutdown</name></expr>,
     <expr><literal type="number">0</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <return>return <expr><operator>&amp;</operator><name>memsys5Methods</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_ENABLE_MEMSYS5 */</comment>
</unit>
