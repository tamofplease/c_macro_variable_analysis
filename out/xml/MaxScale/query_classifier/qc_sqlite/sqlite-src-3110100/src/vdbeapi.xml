<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/src/vdbeapi.c"><comment type="block">/*
** 2004 May 26
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains code use to implement APIs that are part of the
** VDBE.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vdbeInt.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DEPRECATED</name></cpp:ifndef>
<comment type="block">/*
** Return TRUE (non-zero) of the statement supplied as an argument needs
** to be recompiled.  A statement needs to be recompiled whenever the
** execution environment changes in a way that would alter the program
** that sqlite3_prepare() generates.  For example, if new functions or
** collating sequences are registered or if an authorizer function is
** added or changed.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_expired</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Vdbe</name><operator>*</operator><operator>)</operator><name>pStmt</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name>p</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>expired</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Check on a Vdbe to make sure it has not been finalized.  Log
** an error and return true if it has been finalized (or is otherwise
** invalid).  Return false if it is ok.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSafety</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_MISUSE</name></expr></argument>, <argument><expr><literal type="string">"API called with finalized prepared statement"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vdbeSafetyNotNull</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_MISUSE</name></expr></argument>, <argument><expr><literal type="string">"API called with NULL prepared statement"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><call><name>vdbeSafety</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
<comment type="block">/*
** Invoke the profile callback.  This routine is only called if we already
** know that the profile callback is defined and needs to be invoked.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name></type> <name>invokeProfileCallback</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iNow</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>startTime</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>xProfile</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3OsCurrentTimeInt64</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>db</name><operator>-&gt;</operator><name>xProfile</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pProfileArg</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr></argument>, <argument><expr><operator>(</operator><name>iNow</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>startTime</name></name><operator>)</operator><operator>*</operator><literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>startTime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
** The checkProfileCallback(DB,P) macro checks to see if a profile callback
** is needed, and it invokes the callback if it is needed.
*/</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>checkProfileCallback</name><parameter_list>(<parameter><type><name>DB</name></type></parameter>,<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro> \
   <cpp:value>if( ((P)-&gt;startTime)&gt;0 ){ invokeProfileCallback(DB,P); }</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>checkProfileCallback</name><parameter_list>(<parameter><type><name>DB</name></type></parameter>,<parameter><type><name>P</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>  <comment type="block">/*no-op*/</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** The following routine destroys a virtual machine that is created by
** the sqlite3_compile() routine. The integer returned is an SQLITE_
** success/failure code that describes the result of executing the virtual
** machine.
**
** This routine sets the error code and string returned by
** sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_finalize</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pStmt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* IMPLEMENTATION-OF: R-57228-12904 Invoking sqlite3_finalize() on a NULL
    ** pointer is a harmless no-op. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>Vdbe</name><operator>*</operator><operator>)</operator><name>pStmt</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>vdbeSafety</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>checkProfileCallback</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeFinalize</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3LeaveMutexAndCloseZombie</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Terminate the current execution of an SQL statement and reset it
** back to its starting state so that it can be reused. A success code from
** the prior execution is returned.
**
** This routine sets the error code and string returned by
** sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_reset</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pStmt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>Vdbe</name><operator>*</operator><operator>)</operator><name>pStmt</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>checkProfileCallback</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeReset</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeRewind</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>rc</name> <operator>&amp;</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>errMask</name></name><operator>)</operator><operator>)</operator><operator>==</operator><name>rc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set all the parameters in the compiled SQL statement to NULL.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_clear_bindings</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Vdbe</name><operator>*</operator><operator>)</operator><name>pStmt</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_THREADSAFE</name></expr></cpp:if>
  <decl_stmt><decl><type><name>sqlite3_mutex</name> <modifier>*</modifier></type><name>mutex</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Vdbe</name><operator>*</operator><operator>)</operator><name>pStmt</name><operator>)</operator><operator>-&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nVar</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aVar</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aVar</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name>MEM_Null</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>isPrepareV2</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>expmask</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>expired</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**************************** sqlite3_value_  *******************************
** The following routines extract information from a Mem or sqlite3_value
** structure.
*/</comment>
<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlite3_value_blob</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><name>pVal</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MEM_Blob</name><operator>|</operator><name>MEM_Str</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemExpandBlob</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>==</operator><name>MEM_Null</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>z</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Blob</name></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_value_bytes</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3ValueBytes</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_value_bytes16</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3ValueBytes</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>SQLITE_UTF16NATIVE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>double</name></type> <name>sqlite3_value_double</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3VdbeRealValue</name><argument_list>(<argument><expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_value_int</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>sqlite_int64</name></type> <name>sqlite3_value_int64</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3VdbeIntValue</name><argument_list>(<argument><expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><name>pVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>int</name></type> <name>sqlite3_value_subtype</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name> <init>= <expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><name>pVal</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Subtype</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>pMem</name><operator>-&gt;</operator><name>eSubtype</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sqlite3_value_text</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3ValueText</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlite3_value_text16</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier></type> <name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3ValueText</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>SQLITE_UTF16NATIVE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlite3_value_text16be</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3ValueText</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>SQLITE_UTF16BE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlite3_value_text16le</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3ValueText</name><argument_list>(<argument><expr><name>pVal</name></expr></argument>, <argument><expr><name>SQLITE_UTF16LE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>
<comment type="block">/* EVIDENCE-OF: R-12793-43283 Every value in SQLite has one of five
** fundamental datatypes: 64-bit signed integer 64-bit IEEE floating
** point number string BLOB NULL
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_value_type</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier></type> <name>pVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u8</name></type> <name><name>aType</name><index>[]</index></name> <init>= <expr><block>{
     <expr><name>SQLITE_BLOB</name></expr>,     <comment type="block">/* 0x00 */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x01 */</comment>
     <expr><name>SQLITE_TEXT</name></expr>,     <comment type="block">/* 0x02 */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x03 */</comment>
     <expr><name>SQLITE_INTEGER</name></expr>,  <comment type="block">/* 0x04 */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x05 */</comment>
     <expr><name>SQLITE_INTEGER</name></expr>,  <comment type="block">/* 0x06 */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x07 */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x08 */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x09 */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x0a */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x0b */</comment>
     <expr><name>SQLITE_INTEGER</name></expr>,  <comment type="block">/* 0x0c */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x0d */</comment>
     <expr><name>SQLITE_INTEGER</name></expr>,  <comment type="block">/* 0x0e */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x0f */</comment>
     <expr><name>SQLITE_BLOB</name></expr>,     <comment type="block">/* 0x10 */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x11 */</comment>
     <expr><name>SQLITE_TEXT</name></expr>,     <comment type="block">/* 0x12 */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x13 */</comment>
     <expr><name>SQLITE_INTEGER</name></expr>,  <comment type="block">/* 0x14 */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x15 */</comment>
     <expr><name>SQLITE_INTEGER</name></expr>,  <comment type="block">/* 0x16 */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x17 */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x18 */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x19 */</comment>
     <expr><name>SQLITE_FLOAT</name></expr>,    <comment type="block">/* 0x1a */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x1b */</comment>
     <expr><name>SQLITE_INTEGER</name></expr>,  <comment type="block">/* 0x1c */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x1d */</comment>
     <expr><name>SQLITE_INTEGER</name></expr>,  <comment type="block">/* 0x1e */</comment>
     <expr><name>SQLITE_NULL</name></expr>,     <comment type="block">/* 0x1f */</comment>
  }</block></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>aType</name><index>[<expr><name><name>pVal</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_AffMask</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Make a copy of an sqlite3_value object
*/</comment>
<function><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>sqlite3_value_dup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>sqlite3_value</name> <modifier>*</modifier></type><name>pOrig</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pOrig</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><name>pOrig</name></expr></argument>, <argument><expr><name>MEMCELLSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MEM_Dyn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><operator>(</operator><name>MEM_Str</name><operator>|</operator><name>MEM_Blob</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>MEM_Static</name><operator>|</operator><name>MEM_Dyn</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Ephem</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemMakeWriteable</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Destroy an sqlite3_value object previously obtained from
** sqlite3_value_dup().
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_value_free</name><parameter_list>(<parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pOld</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3ValueFree</name><argument_list>(<argument><expr><name>pOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
  

<comment type="block" format="doxygen">/**************************** sqlite3_result_  *******************************
** The following routines are used by user-defined functions to specify
** the function result.
**
** The setStrOrError() function calls sqlite3VdbeMemSetStr() to store the
** result as a string or blob but if the string or blob is too large, it
** then sets the error code to SQLITE_TOOBIG
**
** The invokeValueDestructor(P,X) routine invokes destructor function X()
** on value P is not going to be used and need to be destroyed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setResultStrOrError</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,  <comment type="block">/* Function context */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>,          <comment type="block">/* String pointer */</comment>
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,                  <comment type="block">/* Bytes in string, or negative */</comment>
  <parameter><decl><type><name>u8</name></type> <name>enc</name></decl></parameter>,                 <comment type="block">/* Encoding of z.  0 for BLOBs */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>     <comment type="block">/* Destructor function */</comment>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_TOOBIG</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_toobig</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>invokeValueDestructor</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,             <comment type="block">/* Value to destroy */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,       <comment type="block">/* The destructor */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>      <comment type="block">/* Set a SQLITE_TOOBIG error if no NULL */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>xDel</name><operator>!=</operator><name>SQLITE_DYNAMIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>xDel</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* noop */</comment>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>xDel</name><operator>==</operator><name>SQLITE_TRANSIENT</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* noop */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>xDel</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCtx</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_result_error_toobig</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>SQLITE_TOOBIG</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_blob</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, 
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setResultStrOrError</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_blob64</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_uint64</name></type> <name>n</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>xDel</name><operator>!=</operator><name>SQLITE_DYNAMIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0x7fffffff</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>invokeValueDestructor</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>setResultStrOrError</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_double</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>rVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetDouble</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>rVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_error</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>fErrorOrAux</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<function><type><name>void</name></type> <name>sqlite3_result_error16</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>fErrorOrAux</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_UTF16NATIVE</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>void</name></type> <name>sqlite3_result_int</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><operator>(</operator><name>i64</name><operator>)</operator><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_int64</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetInt64</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_null</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_subtype</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>eSubtype</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>eSubtype</name></name> <operator>=</operator> <name>eSubtype</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Subtype</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_text</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setResultStrOrError</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_text64</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_uint64</name></type> <name>n</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>enc</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>xDel</name><operator>!=</operator><name>SQLITE_DYNAMIC</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>enc</name><operator>==</operator><name>SQLITE_UTF16</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>enc</name> <operator>=</operator> <name>SQLITE_UTF16NATIVE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0x7fffffff</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>invokeValueDestructor</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>setResultStrOrError</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>n</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<function><type><name>void</name></type> <name>sqlite3_result_text16</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, 
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setResultStrOrError</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_UTF16NATIVE</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_text16be</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, 
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setResultStrOrError</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_UTF16BE</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_text16le</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, 
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDel</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setResultStrOrError</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>SQLITE_UTF16LE</name></expr></argument>, <argument><expr><name>xDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>
<function><type><name>void</name></type> <name>sqlite3_result_value</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemCopy</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_zeroblob</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetZeroBlob</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_result_zeroblob64</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>u64</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><operator>(</operator><name>u64</name><operator>)</operator><name><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_TOOBIG</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetZeroBlob</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3_result_error_code</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errCode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name> <operator>=</operator> <name>errCode</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>fErrorOrAux</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pVdbe</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pVdbe</name><operator>-&gt;</operator><name>rcApp</name></name> <operator>=</operator> <name>errCode</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Null</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><call><name>sqlite3ErrStr</name><argument_list>(<argument><expr><name>errCode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, 
                         <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Force an SQLITE_TOOBIG error. */</comment>
<function><type><name>void</name></type> <name>sqlite3_result_error_toobig</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name> <operator>=</operator> <name>SQLITE_TOOBIG</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>fErrorOrAux</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetStr</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><literal type="string">"string or blob too big"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, 
                       <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* An SQLITE_NOMEM error. */</comment>
<function><type><name>void</name></type> <name>sqlite3_result_error_nomem</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>fErrorOrAux</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is called after a transaction has been committed. It 
** invokes callbacks registered with sqlite3_wal_hook() as required.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>doWalCallbacks</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nDb</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>Btree</name> <modifier>*</modifier></type><name>pBt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pBt</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pBt</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nEntry</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3BtreeEnter</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nEntry</name> <operator>=</operator> <call><name>sqlite3PagerWalCallback</name><argument_list>(<argument><expr><call><name>sqlite3BtreePager</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3BtreeLeave</name><argument_list>(<argument><expr><name>pBt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xWalCallback</name></name> <operator>&amp;&amp;</operator> <name>nEntry</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>db</name><operator>-&gt;</operator><name>xWalCallback</name></name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pWalArg</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name>nEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Execute the statement pStmt, either until a row of data is ready, the
** statement is completely executed or an error occurs.
**
** This routine implements the bulk of the logic behind the sqlite_step()
** API.  The only thing omitted is the automatic recompile if a 
** schema change has occurred.  That detail is handled by the
** outer sqlite3_step() wrapper procedure.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sqlite3Step</name><parameter_list>(<parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>magic</name></name><operator>!=</operator><name>VDBE_MAGIC_RUN</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* We used to require that sqlite3_reset() be called before retrying
    ** sqlite3_step() after any error or after SQLITE_DONE.  But beginning
    ** with version 3.7.0, we changed this so that sqlite3_reset() would
    ** be called automatically instead of throwing the SQLITE_MISUSE error.
    ** This "automatic-reset" change is not technically an incompatibility, 
    ** since any application that receives an SQLITE_MISUSE is broken by
    ** definition.
    **
    ** Nevertheless, some published applications that were originally written
    ** for version 3.6.23 or earlier do in fact depend on SQLITE_MISUSE 
    ** returns, and those were broken by the automatic-reset change.  As a
    ** a work-around, the SQLITE_OMIT_AUTORESET compile-time restores the
    ** legacy behavior of returning SQLITE_MISUSE for cases where the 
    ** previous sqlite3_step() returned something other than a SQLITE_LOCKED
    ** or SQLITE_BUSY error.
    */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_OMIT_AUTORESET</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_BUSY</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_LOCKED</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_stmt</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_stmt</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check that malloc() has not failed. If it has, return early. */</comment>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name><operator>&lt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>expired</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_SCHEMA</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>end_of_step</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* If there are no other statements currently running, then
    ** reset the interrupt flag.  This prevents a call to sqlite3_interrupt
    ** from interrupting a statement that has not yet started.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>isInterrupted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeWrite</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>autoCommit</name></name><operator>==</operator><literal type="number">0</literal> 
        <operator>||</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>nDeferredCons</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>nDeferredImmCons</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>xProfile</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>zSql</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OsCurrentTimeInt64</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>startTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>startTime</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeActive</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>readOnly</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeWrite</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bIsReader</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeRead</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rcApp</name></name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_EXPLAIN</name></cpp:ifndef>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>explain</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_EXPLAIN */</comment>
  <block>{<block_content>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeExec</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeExec</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVdbeExec</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_TRACE</name></cpp:ifndef>
  <comment type="block">/* If the statement completed successfully, invoke the profile callback */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>checkProfileCallback</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <call><name>doWalCallbacks</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>errCode</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_NOMEM</name><operator>==</operator><call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<label><name>end_of_step</name>:</label>
  <comment type="block">/* At this point local variable rc holds the value that should be 
  ** returned if this statement was compiled using the legacy 
  ** sqlite3_prepare() interface. According to the docs, this can only
  ** be one of the values in the first assert() below. Variable p-&gt;rc 
  ** contains the value that would be returned if sqlite3_finalize() 
  ** were called on statement p.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name>  <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_DONE</name>   <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_ERROR</name> 
       <operator>||</operator> <operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>SQLITE_BUSY</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_MISUSE</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>!=</operator><name>SQLITE_ROW</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>!=</operator><name>SQLITE_DONE</name><operator>)</operator> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>rc</name></name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>rcApp</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>isPrepareV2</name></name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_ROW</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If this statement was prepared using sqlite3_prepare_v2(), and an
    ** error has occurred, then return the error code in p-&gt;rc to the
    ** caller. Set the error code in the database handle to the same value.
    */</comment> 
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VdbeTransferError</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>rc</name><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>errMask</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is the top-level implementation of sqlite3_step().  Call
** sqlite3Step() to do most of the work.  If a schema error occurs,
** call sqlite3Reprepare() and try again.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_step</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>      <comment type="block">/* Result from sqlite3Step() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc2</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Result from sqlite3Reprepare() */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>Vdbe</name><operator>*</operator><operator>)</operator><name>pStmt</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* the prepared statement */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Counter to prevent infinite loop of reprepares */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>             <comment type="block">/* The database connection */</comment>

  <if_stmt><if>if<condition>( <expr><call><name>vdbeSafetyNotNull</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>doingRerun</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3Step</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>SQLITE_SCHEMA</name>
         <operator>&amp;&amp;</operator> <name>cnt</name><operator>++</operator> <operator>&lt;</operator> <name>SQLITE_MAX_SCHEMA_RETRY</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>savedPc</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>pc</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc2</name> <operator>=</operator> <name>rc</name> <operator>=</operator> <call><name>sqlite3Reprepare</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>savedPc</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>doingRerun</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>v</name><operator>-&gt;</operator><name>expired</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>rc2</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* This case occurs after failing to recompile an sql statement. 
    ** The error message from the SQL compiler has already been loaded 
    ** into the database handle. This block copies the error message 
    ** from the database handle into the statement and sets the statement
    ** program counter to 0 to ensure that when the statement is 
    ** finalized or reset the parser error message is available via
    ** sqlite3_errmsg() and sqlite3_errcode().
    */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>pErr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc2</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Extract the user data from a sqlite3_context structure and return a
** pointer to it.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_user_data</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pFunc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>pFunc</name><operator>-&gt;</operator><name>pUserData</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Extract the user data from a sqlite3_context structure and return a
** pointer to it.
**
** IMPLEMENTATION-OF: R-46798-50301 The sqlite3_context_db_handle() interface
** returns a copy of the pointer to the database connection (the 1st
** parameter) of the sqlite3_create_function() and
** sqlite3_create_function16() routines that originally registered the
** application defined function.
*/</comment>
<function><type><name>sqlite3</name> <modifier>*</modifier></type><name>sqlite3_context_db_handle</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the current time for a statement.  If the current time
** is requested more than once within the same run of a single prepared
** statement, the exact same time is returned for each invocation regardless
** of the amount of time that elapses between invocations.  In other words,
** the time returned is always the time of the first call.
*/</comment>
<function><type><name>sqlite3_int64</name></type> <name>sqlite3StmtCurrentTime</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_ENABLE_STAT3_OR_STAT4</name></cpp:ifndef>
  <decl_stmt><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piTime</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pVdbe</name><operator>-&gt;</operator><name>iCurrentTime</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piTime</name> <init>= <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>!=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pVdbe</name><operator>-&gt;</operator><name>iCurrentTime</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name>iTime</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>piTime</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3OsCurrentTimeInt64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><name>piTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>piTime</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>*</operator><name>piTime</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The following is the implementation of an SQL function that always
** fails with an error message stating that the function is used in the
** wrong context.  The sqlite3_overload_function() API might construct
** SQL function that use this routine so that the functions will exist
** for name resolution but are actually overloaded by the xFindFunction
** method of virtual tables.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3InvalidFunction</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,  <comment type="block">/* The function calling context */</comment>
  <parameter><decl><type><name>int</name></type> <name>NotUsed</name></decl></parameter>,               <comment type="block">/* Number of arguments to the function */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>NotUsed2</name></decl></parameter>   <comment type="block">/* Value of each argument */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>pFunc</name><operator>-&gt;</operator><name>zName</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>, <argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(
      <argument><expr><literal type="string">"unable to use function %s in the requested context"</literal></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Create a new aggregate context for p and return a pointer to
** its pMem-&gt;z element.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>void</name> <modifier>*</modifier></type><name>createAggContext</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pMem</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pMem</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Agg</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemSetNull</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3VdbeMemClearAndResize</name><argument_list>(<argument><expr><name>pMem</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>MEM_Agg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMem</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>pDef</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pFunc</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Allocate or return the aggregate context for a user function.  A new
** context is allocated on the first call.  Subsequent calls return the
** same context that was returned on prior calls.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_aggregate_context</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pFunc</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pFunc</name><operator>-&gt;</operator><name>xFinalize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nByte</name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pMem</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MEM_Agg</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>createAggContext</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>pMem</name><operator>-&gt;</operator><name>z</name></name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the auxiliary data pointer, if any, for the iArg'th argument to
** the user-function defined by pCtx.
*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>sqlite3_get_auxdata</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>AuxData</name> <modifier>*</modifier></type><name>pAuxData</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_ENABLE_STAT3_OR_STAT4</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <for>for<control>(<init><expr><name>pAuxData</name><operator>=</operator><name><name>pCtx</name><operator>-&gt;</operator><name>pVdbe</name><operator>-&gt;</operator><name>pAuxData</name></name></expr>;</init> <condition><expr><name>pAuxData</name></expr>;</condition> <incr><expr><name>pAuxData</name><operator>=</operator><name><name>pAuxData</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pAuxData</name><operator>-&gt;</operator><name>iOp</name></name><operator>==</operator><name><name>pCtx</name><operator>-&gt;</operator><name>iOp</name></name> <operator>&amp;&amp;</operator> <name><name>pAuxData</name><operator>-&gt;</operator><name>iArg</name></name><operator>==</operator><name>iArg</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><operator>(</operator><ternary><condition><expr><name>pAuxData</name></expr> ?</condition><then> <expr><name><name>pAuxData</name><operator>-&gt;</operator><name>pAux</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Set the auxiliary data pointer and delete function, for the iArg'th
** argument to the user-function defined by pCtx. Any previous value is
** deleted by calling the delete function specified when it was set.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3_set_auxdata</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>iArg</name></decl></parameter>, 
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>, 
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDelete</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>AuxData</name> <modifier>*</modifier></type><name>pAuxData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pVdbe</name> <init>= <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pCtx</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iArg</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_STAT3_OR_STAT4</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>pVdbe</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pVdbe</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <for>for<control>(<init><expr><name>pAuxData</name><operator>=</operator><name><name>pVdbe</name><operator>-&gt;</operator><name>pAuxData</name></name></expr>;</init> <condition><expr><name>pAuxData</name></expr>;</condition> <incr><expr><name>pAuxData</name><operator>=</operator><name><name>pAuxData</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pAuxData</name><operator>-&gt;</operator><name>iOp</name></name><operator>==</operator><name><name>pCtx</name><operator>-&gt;</operator><name>iOp</name></name> <operator>&amp;&amp;</operator> <name><name>pAuxData</name><operator>-&gt;</operator><name>iArg</name></name><operator>==</operator><name>iArg</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>pAuxData</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pAuxData</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name><name>pVdbe</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AuxData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pAuxData</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pAuxData</name><operator>-&gt;</operator><name>iOp</name></name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>iOp</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pAuxData</name><operator>-&gt;</operator><name>iArg</name></name> <operator>=</operator> <name>iArg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pAuxData</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pVdbe</name><operator>-&gt;</operator><name>pAuxData</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pVdbe</name><operator>-&gt;</operator><name>pAuxData</name></name> <operator>=</operator> <name>pAuxData</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>fErrorOrAux</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>isError</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>fErrorOrAux</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pAuxData</name><operator>-&gt;</operator><name>xDelete</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>pAuxData</name><operator>-&gt;</operator><name>xDelete</name></name><argument_list>(<argument><expr><name><name>pAuxData</name><operator>-&gt;</operator><name>pAux</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pAuxData</name><operator>-&gt;</operator><name>pAux</name></name> <operator>=</operator> <name>pAux</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pAuxData</name><operator>-&gt;</operator><name>xDelete</name></name> <operator>=</operator> <name>xDelete</name></expr>;</expr_stmt>
  <return>return;</return>

<label><name>failed</name>:</label>
  <if_stmt><if>if<condition>( <expr><name>xDelete</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>xDelete</name><argument_list>(<argument><expr><name>pAux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DEPRECATED</name></cpp:ifndef>
<comment type="block">/*
** Return the number of times the Step function of an aggregate has been 
** called.
**
** This function is deprecated.  Do not use it for new code.  It is
** provide only to avoid breaking legacy code.  New aggregate function
** implementations should keep their own counts within their aggregate
** context.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_aggregate_count</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pMem</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pFunc</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pFunc</name><operator>-&gt;</operator><name>xFinalize</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>pMem</name><operator>-&gt;</operator><name>n</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return the number of columns in the result set for the statement pStmt.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_column_count</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pVm</name> <init>= <expr><operator>(</operator><name>Vdbe</name> <operator>*</operator><operator>)</operator><name>pStmt</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><ternary><condition><expr><name>pVm</name></expr> ?</condition><then> <expr><name><name>pVm</name><operator>-&gt;</operator><name>nResColumn</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of values available from the current row of the
** currently executing statement pStmt.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_data_count</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pVm</name> <init>= <expr><operator>(</operator><name>Vdbe</name> <operator>*</operator><operator>)</operator><name>pStmt</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pVm</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pVm</name><operator>-&gt;</operator><name>pResultSet</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name><name>pVm</name><operator>-&gt;</operator><name>nResColumn</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a pointer to static memory containing an SQL NULL value.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>Mem</name> <modifier>*</modifier></type><name>columnNullValue</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* Even though the Mem structure contains an element
  ** of type i64, on certain architectures (x86) with certain compiler
  ** switches (-Os), gcc may align this Mem object on a 4-byte boundary
  ** instead of an 8-byte one. This all works fine, except that when
  ** running with SQLITE_DEBUG defined the SQLite code sometimes assert()s
  ** that a Mem structure is located on an 8-byte boundary. To prevent
  ** these assert()s from failing, when building with SQLITE_DEBUG defined
  ** using gcc, we force nullMem to be 8-byte aligned using the magical
  ** __attribute__((aligned(8))) macro.  */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Mem</name> <name>nullMem</name></type> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><call><name>aligned</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <init>= <expr><block>{
        <comment type="block">/* .u          = */</comment> <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>,
        <comment type="block">/* .flags      = */</comment> <expr><operator>(</operator><name>u16</name><operator>)</operator><name>MEM_Null</name></expr>,
        <comment type="block">/* .enc        = */</comment> <expr><operator>(</operator><name>u8</name><operator>)</operator><literal type="number">0</literal></expr>,
        <comment type="block">/* .eSubtype   = */</comment> <expr><operator>(</operator><name>u8</name><operator>)</operator><literal type="number">0</literal></expr>,
        <comment type="block">/* .n          = */</comment> <expr><operator>(</operator><name>int</name><operator>)</operator><literal type="number">0</literal></expr>,
        <comment type="block">/* .z          = */</comment> <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>,
        <comment type="block">/* .zMalloc    = */</comment> <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>,
        <comment type="block">/* .szMalloc   = */</comment> <expr><operator>(</operator><name>int</name><operator>)</operator><literal type="number">0</literal></expr>,
        <comment type="block">/* .uTemp      = */</comment> <expr><operator>(</operator><name>u32</name><operator>)</operator><literal type="number">0</literal></expr>,
        <comment type="block">/* .db         = */</comment> <expr><operator>(</operator><name>sqlite3</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>,
        <comment type="block">/* .xDel       = */</comment> <expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><literal type="number">0</literal></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
        <comment type="block">/* .pScopyFrom = */</comment> <expr><operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>,
        <comment type="block">/* .pFiller    = */</comment> <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }</block></expr></init></decl>;</decl_stmt>
  <return>return <expr><operator>&amp;</operator><name>nullMem</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check to see if column iCol of the given statement is valid.  If
** it is, return a pointer to the Mem for the value of that column.
** If iCol is not valid, return a pointer to a Mem which has a value
** of NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>Mem</name> <modifier>*</modifier></type><name>columnMem</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>pVm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pOut</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pVm</name> <operator>=</operator> <operator>(</operator><name>Vdbe</name> <operator>*</operator><operator>)</operator><name>pStmt</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pVm</name> <operator>&amp;&amp;</operator> <name><name>pVm</name><operator>-&gt;</operator><name>pResultSet</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>pVm</name><operator>-&gt;</operator><name>nResColumn</name></name> <operator>&amp;&amp;</operator> <name>i</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>pVm</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>&amp;</operator><name><name>pVm</name><operator>-&gt;</operator><name>pResultSet</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pVm</name> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pVm</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>pVm</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name><name>pVm</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_RANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pOut</name> <operator>=</operator> <operator>(</operator><name>Mem</name><operator>*</operator><operator>)</operator><call><name>columnNullValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>pOut</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is called after invoking an sqlite3_value_XXX function on a 
** column value (i.e. a value returned by evaluating an SQL expression in the
** select list of a SELECT statement) that may cause a malloc() failure. If 
** malloc() has failed, the threads mallocFailed flag is cleared and the result
** code of statement pStmt set to SQLITE_NOMEM.
**
** Specifically, this is called from within:
**
**     sqlite3_column_int()
**     sqlite3_column_int64()
**     sqlite3_column_text()
**     sqlite3_column_text16()
**     sqlite3_column_real()
**     sqlite3_column_bytes()
**     sqlite3_column_bytes16()
**     sqiite3_column_blob()
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>columnMallocFailure</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* If malloc() failed during an encoding conversion within an
  ** sqlite3_column_XXX API, then set the return code of the statement to
  ** SQLITE_NOMEM. The next call to _step() (if any) will return SQLITE_ERROR
  ** and _finalize() will return NOMEM.
  */</comment>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Vdbe</name> <operator>*</operator><operator>)</operator><name>pStmt</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**************************** sqlite3_column_  *******************************
** The following routines are used to access elements of the current row
** in the result set.
*/</comment>
<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlite3_column_blob</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>sqlite3_value_blob</name><argument_list>( <argument><expr><call><name>columnMem</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Even though there is no encoding conversion, value_blob() might
  ** need to call malloc() to expand the result of a zeroblob() 
  ** expression. 
  */</comment>
  <expr_stmt><expr><call><name>columnMallocFailure</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_column_bytes</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>( <argument><expr><call><name>columnMem</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>columnMallocFailure</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_column_bytes16</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><call><name>sqlite3_value_bytes16</name><argument_list>( <argument><expr><call><name>columnMem</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>columnMallocFailure</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>double</name></type> <name>sqlite3_column_double</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type> <name>val</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>( <argument><expr><call><name>columnMem</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>columnMallocFailure</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sqlite3_column_int</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><call><name>sqlite3_value_int</name><argument_list>( <argument><expr><call><name>columnMem</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>columnMallocFailure</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>sqlite_int64</name></type> <name>sqlite3_column_int64</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>val</name> <init>= <expr><call><name>sqlite3_value_int64</name><argument_list>( <argument><expr><call><name>columnMem</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>columnMallocFailure</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sqlite3_column_text</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>sqlite3_value_text</name><argument_list>( <argument><expr><call><name>columnMem</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>columnMallocFailure</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>sqlite3_column_value</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pOut</name> <init>= <expr><call><name>columnMem</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>MEM_Static</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MEM_Static</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pOut</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MEM_Ephem</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>columnMallocFailure</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>sqlite3_value</name> <operator>*</operator><operator>)</operator><name>pOut</name></expr>;</return>
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlite3_column_text16</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>sqlite3_value_text16</name><argument_list>( <argument><expr><call><name>columnMem</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>columnMallocFailure</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_UTF16 */</comment>
<function><type><name>int</name></type> <name>sqlite3_column_type</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iType</name> <init>= <expr><call><name>sqlite3_value_type</name><argument_list>( <argument><expr><call><name>columnMem</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>columnMallocFailure</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>iType</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert the N-th element of pStmt-&gt;pColName[] into a string using
** xFunc() then return that string.  If N is out of range, return 0.
**
** There are up to 5 names for each column.  useType determines which
** name is returned.  Here are the names:
**
**    0      The column name as it should be displayed for output
**    1      The datatype name for the column
**    2      The name of the database that the column derives from
**    3      The name of the table that the column derives from
**    4      The name of the table column that the result column derives from
**
** If the result is not a simple column reference (if it is an expression
** or a constant) then useTypes 2, 3, and 4 return NULL.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>columnName</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>,
  <parameter><function_decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>xFunc</name>)<parameter_list>(<parameter><decl><type><name>Mem</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>useType</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>pStmt</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>Vdbe</name> <operator>*</operator><operator>)</operator><name>pStmt</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_column_count</name><argument_list>(<argument><expr><name>pStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>N</name><operator>&lt;</operator><name>n</name> <operator>&amp;&amp;</operator> <name>N</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>N</name> <operator>+=</operator> <name>useType</name><operator>*</operator><name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>xFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aColName</name><index>[<expr><name>N</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <comment type="block">/* A malloc may have failed inside of the xFunc() call. If this
    ** is the case, clear the mallocFailed flag and return NULL.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OomClear</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the name of the Nth column of the result set returned by SQL
** statement pStmt.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlite3_column_name</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>columnName</name><argument_list>(
      <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name><operator>*</operator><call>(<modifier>*</modifier>)<argument_list>(<argument><expr><name>Mem</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>sqlite3_value_text</name></expr></argument>, <argument><expr><name>COLNAME_NAME</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_UTF16</name></cpp:ifndef>
<function><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sqlite3_column_name16</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>columnName</name><argument_list>(
      <argument><expr><name>pStmt</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name><operator>*</operator><call>(<modifier>*</modifier>)<argument_list>(<argument><expr><name>Mem</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>sqlite3_value_text16</name></expr></argument>, <argument><expr><name>COLNAME_NAME</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Constraint:  If you have ENABLE_COLUMN_METADATA then you must
** not define OMIT_DECLTYPE.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_DECLTYPE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_COLUMN_METADATA</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> <cpp:literal>"Must not define both SQLITE_OMIT_DECLTYPE \</cpp:literal></cpp:error>
         <expr><name>and</name> <name>SQLITE_ENABLE_COLUMN_METADATA</name><literal type="string">"
#endif

#ifndef SQLITE_OMIT_DECLTYPE
/*
** Return the column declaration type (if applicable) of the 'i'th column
** of the result set of SQL statement pStmt.
*/
const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int N){
  return columnName(
      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_DECLTYPE);
}
#ifndef SQLITE_OMIT_UTF16
const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){
  return columnName(
      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_DECLTYPE);
}
#endif /* SQLITE_OMIT_UTF16 */
#endif /* SQLITE_OMIT_DECLTYPE */

#ifdef SQLITE_ENABLE_COLUMN_METADATA
/*
** Return the name of the database from which a result column derives.
** NULL is returned if the result column is an expression or constant or
** anything else which is not an unambiguous reference to a database column.
*/
const char *sqlite3_column_database_name(sqlite3_stmt *pStmt, int N){
  return columnName(
      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_DATABASE);
}
#ifndef SQLITE_OMIT_UTF16
const void *sqlite3_column_database_name16(sqlite3_stmt *pStmt, int N){
  return columnName(
      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_DATABASE);
}
#endif /* SQLITE_OMIT_UTF16 */

/*
** Return the name of the table from which a result column derives.
** NULL is returned if the result column is an expression or constant or
** anything else which is not an unambiguous reference to a database column.
*/
const char *sqlite3_column_table_name(sqlite3_stmt *pStmt, int N){
  return columnName(
      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_TABLE);
}
#ifndef SQLITE_OMIT_UTF16
const void *sqlite3_column_table_name16(sqlite3_stmt *pStmt, int N){
  return columnName(
      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_TABLE);
}
#endif /* SQLITE_OMIT_UTF16 */

/*
** Return the name of the table column from which a result column derives.
** NULL is returned if the result column is an expression or constant or
** anything else which is not an unambiguous reference to a database column.
*/
const char *sqlite3_column_origin_name(sqlite3_stmt *pStmt, int N){
  return columnName(
      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_COLUMN);
}
#ifndef SQLITE_OMIT_UTF16
const void *sqlite3_column_origin_name16(sqlite3_stmt *pStmt, int N){
  return columnName(
      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_COLUMN);
}
#endif /* SQLITE_OMIT_UTF16 */
#endif /* SQLITE_ENABLE_COLUMN_METADATA */


/******************************* sqlite3_bind_  ***************************
** 
** Routines used to attach values to wildcards in a compiled SQL statement.
*/
/*
** Unbind the value bound to variable i in virtual machine p. This is the 
** the same as binding a NULL value to the column. If the "</literal><name>i</name><literal type="string">" parameter is
** out of range, then SQLITE_RANGE is returned. Othewise SQLITE_OK.
**
** A successful evaluation of this routine acquires the mutex on p.
** the mutex is released if any kind of error occurs.
**
** The error code stored in database p-&gt;db is overwritten with the return
** value in any case.
*/
static int vdbeUnbind(Vdbe *p, int i){
  Mem *pVar;
  if( vdbeSafetyNotNull(p) ){
    return SQLITE_MISUSE_BKPT;
  }
  sqlite3_mutex_enter(p-&gt;db-&gt;mutex);
  if( p-&gt;magic!=VDBE_MAGIC_RUN || p-&gt;pc&gt;=0 ){
    sqlite3Error(p-&gt;db, SQLITE_MISUSE);
    sqlite3_mutex_leave(p-&gt;db-&gt;mutex);
    sqlite3_log(SQLITE_MISUSE, 
        "</literal><name>bind</name> <name>on</name> <name>a</name> <name>busy</name> <name>prepared</name> <name>statement</name><operator>:</operator> <index>[<expr><operator>%</operator><name>s</name></expr>]</index><literal type="string">"</literal></expr>, p-&gt;zSql);
    return SQLITE_MISUSE_BKPT;
  }
  if( i&lt;1 || i&gt;p-&gt;nVar ){
    sqlite3Error(p-&gt;db, SQLITE_RANGE);
    sqlite3_mutex_leave(p-&gt;db-&gt;mutex);
    return SQLITE_RANGE;
  }
  i--;
  pVar = &amp;p-&gt;aVar[i];
  sqlite3VdbeMemRelease(pVar);
  pVar-&gt;flags = MEM_Null;
  sqlite3Error(p-&gt;db, SQLITE_OK);

  /* If the bit corresponding to this variable in Vdbe.expmask is set, then 
  ** binding a new value to this variable invalidates the current query plan.
  **
  ** IMPLEMENTATION-OF: R-48440-37595 If the specific value bound to host
  ** parameter in the WHERE clause might influence the choice of query plan
  ** for a statement, then the statement will be automatically recompiled,
  ** as if there had been a schema change, on the first sqlite3_step() call
  ** following any change to the bindings of that parameter.
  */
  if( p-&gt;isPrepareV2 &amp;&amp;
     ((i&lt;32 &amp;&amp; p-&gt;expmask &amp; ((u32)1 &lt;&lt; i)) || p-&gt;expmask==0xffffffff)
  ){
    p-&gt;expired = 1;
  }
  return SQLITE_OK;
}

/*
** Bind a text or BLOB value.
*/
static int bindText(
  sqlite3_stmt *pStmt,   /* The statement to bind against */
  int i,                 /* Index of the parameter to bind */
  const void *zData,     /* Pointer to the data to be bound */
  int nData,             /* Number of bytes of data to be bound */
  void (*xDel)(void*),   /* Destructor for the data */
  u8 encoding            /* Encoding for the data */
){
  Vdbe *p = (Vdbe *)pStmt;
  Mem *pVar;
  int rc;

  rc = vdbeUnbind(p, i);
  if( rc==SQLITE_OK ){
    if( zData!=0 ){
      pVar = &amp;p-&gt;aVar[i-1];
      rc = sqlite3VdbeMemSetStr(pVar, zData, nData, encoding, xDel);
      if( rc==SQLITE_OK &amp;&amp; encoding!=0 ){
        rc = sqlite3VdbeChangeEncoding(pVar, ENC(p-&gt;db));
      }
      sqlite3Error(p-&gt;db, rc);
      rc = sqlite3ApiExit(p-&gt;db, rc);
    }
    sqlite3_mutex_leave(p-&gt;db-&gt;mutex);
  }else if( xDel!=SQLITE_STATIC &amp;&amp; xDel!=SQLITE_TRANSIENT ){
    xDel((void*)zData);
  }
  return rc;
}


/*
** Bind a blob value to an SQL statement variable.
*/
int sqlite3_bind_blob(
  sqlite3_stmt *pStmt, 
  int i, 
  const void *zData, 
  int nData, 
  void (*xDel)(void*)
){
  return bindText(pStmt, i, zData, nData, xDel, 0);
}
int sqlite3_bind_blob64(
  sqlite3_stmt *pStmt, 
  int i, 
  const void *zData, 
  sqlite3_uint64 nData, 
  void (*xDel)(void*)
){
  assert( xDel!=SQLITE_DYNAMIC );
  if( nData&gt;0x7fffffff ){
    return invokeValueDestructor(zData, xDel, 0);
  }else{
    return bindText(pStmt, i, zData, (int)nData, xDel, 0);
  }
}
int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  if( rc==SQLITE_OK ){
    sqlite3VdbeMemSetDouble(&amp;p-&gt;aVar[i-1], rValue);
    sqlite3_mutex_leave(p-&gt;db-&gt;mutex);
  }
  return rc;
}
int sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue){
  return sqlite3_bind_int64(p, i, (i64)iValue);
}
int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  if( rc==SQLITE_OK ){
    sqlite3VdbeMemSetInt64(&amp;p-&gt;aVar[i-1], iValue);
    sqlite3_mutex_leave(p-&gt;db-&gt;mutex);
  }
  return rc;
}
int sqlite3_bind_null(sqlite3_stmt *pStmt, int i){
  int rc;
  Vdbe *p = (Vdbe*)pStmt;
  rc = vdbeUnbind(p, i);
  if( rc==SQLITE_OK ){
    sqlite3_mutex_leave(p-&gt;db-&gt;mutex);
  }
  return rc;
}
int sqlite3_bind_text( 
  sqlite3_stmt *pStmt, 
  int i, 
  const char *zData, 
  int nData, 
  void (*xDel)(void*)
){
  return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF8);
}
int sqlite3_bind_text64( 
  sqlite3_stmt *pStmt, 
  int i, 
  const char *zData, 
  sqlite3_uint64 nData, 
  void (*xDel)(void*),
  unsigned char enc
){
  assert( xDel!=SQLITE_DYNAMIC );
  if( nData&gt;0x7fffffff ){
    return invokeValueDestructor(zData, xDel, 0);
  }else{
    if( enc==SQLITE_UTF16 ) enc = SQLITE_UTF16NATIVE;
    return bindText(pStmt, i, zData, (int)nData, xDel, enc);
  }
}
#ifndef SQLITE_OMIT_UTF16
int sqlite3_bind_text16(
  sqlite3_stmt *pStmt, 
  int i, 
  const void *zData, 
  int nData, 
  void (*xDel)(void*)
){
  return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF16NATIVE);
}
#endif /* SQLITE_OMIT_UTF16 */
int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue){
  int rc;
  switch( sqlite3_value_type((sqlite3_value*)pValue) ){
    case SQLITE_INTEGER: {
      rc = sqlite3_bind_int64(pStmt, i, pValue-&gt;u.i);
      break;
    }
    case SQLITE_FLOAT: {
      rc = sqlite3_bind_double(pStmt, i, pValue-&gt;u.r);
      break;
    }
    case SQLITE_BLOB: {
      if( pValue-&gt;flags &amp; MEM_Zero ){
        rc = sqlite3_bind_zeroblob(pStmt, i, pValue-&gt;u.nZero);
      }else{
        rc = sqlite3_bind_blob(pStmt, i, pValue-&gt;z, pValue-&gt;n,SQLITE_TRANSIENT);
      }
      break;
    }
    case SQLITE_TEXT: {
      rc = bindText(pStmt,i,  pValue-&gt;z, pValue-&gt;n, SQLITE_TRANSIENT,
                              pValue-&gt;enc);
      break;
    }
    default: {
      rc = sqlite3_bind_null(pStmt, i);
      break;
    }
  }
  return rc;
}
int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  if( rc==SQLITE_OK ){
    sqlite3VdbeMemSetZeroBlob(&amp;p-&gt;aVar[i-1], n);
    sqlite3_mutex_leave(p-&gt;db-&gt;mutex);
  }
  return rc;
}
int sqlite3_bind_zeroblob64(sqlite3_stmt *pStmt, int i, sqlite3_uint64 n){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  sqlite3_mutex_enter(p-&gt;db-&gt;mutex);
  if( n&gt;(u64)p-&gt;db-&gt;aLimit[SQLITE_LIMIT_LENGTH] ){
    rc = SQLITE_TOOBIG;
  }else{
    assert( (n &amp; 0x7FFFFFFF)==n );
    rc = sqlite3_bind_zeroblob(pStmt, i, n);
  }
  rc = sqlite3ApiExit(p-&gt;db, rc);
  sqlite3_mutex_leave(p-&gt;db-&gt;mutex);
  return rc;
}

/*
** Return the number of wildcards that can be potentially bound to.
** This routine is added to support DBD::SQLite.  
*/
int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe*)pStmt;
  return p ? p-&gt;nVar : 0;
}

/*
** Return the name of a wildcard parameter.  Return NULL if the index
** is out of range or if the wildcard is unnamed.
**
** The result is always UTF-8.
*/
const char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i){
  Vdbe *p = (Vdbe*)pStmt;
  if( p==0 || i&lt;1 || i&gt;p-&gt;nzVar ){
    return 0;
  }
  return p-&gt;azVar[i-1];
}

/*
** Given a wildcard parameter name, return the index of the variable
** with that name.  If there is no variable with the given name,
** return 0.
*/
int sqlite3VdbeParameterIndex(Vdbe *p, const char *zName, int nName){
  int i;
  if( p==0 ){
    return 0;
  }
  if( zName ){
    for(i=0; i&lt;p-&gt;nzVar; i++){
      const char *z = p-&gt;azVar[i];
      if( z &amp;&amp; strncmp(z,zName,nName)==0 &amp;&amp; z[nName]==0 ){
        return i+1;
      }
    }
  }
  return 0;
}
int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName){
  return sqlite3VdbeParameterIndex((Vdbe*)pStmt, zName, sqlite3Strlen30(zName));
}

/*
** Transfer all bindings from the first statement over to the second.
*/
int sqlite3TransferBindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){
  Vdbe *pFrom = (Vdbe*)pFromStmt;
  Vdbe *pTo = (Vdbe*)pToStmt;
  int i;
  assert( pTo-&gt;db==pFrom-&gt;db );
  assert( pTo-&gt;nVar==pFrom-&gt;nVar );
  sqlite3_mutex_enter(pTo-&gt;db-&gt;mutex);
  for(i=0; i&lt;pFrom-&gt;nVar; i++){
    sqlite3VdbeMemMove(&amp;pTo-&gt;aVar[i], &amp;pFrom-&gt;aVar[i]);
  }
  sqlite3_mutex_leave(pTo-&gt;db-&gt;mutex);
  return SQLITE_OK;
}

#ifndef SQLITE_OMIT_DEPRECATED
/*
** Deprecated external interface.  Internal/core SQLite code
** should call sqlite3TransferBindings.
**
** It is misuse to call this routine with statements from different
** database connections.  But as this is a deprecated interface, we
** will not bother to check for that condition.
**
** If the two statements contain a different number of bindings, then
** an SQLITE_ERROR is returned.  Nothing else can go wrong, so otherwise
** SQLITE_OK is returned.
*/
int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){
  Vdbe *pFrom = (Vdbe*)pFromStmt;
  Vdbe *pTo = (Vdbe*)pToStmt;
  if( pFrom-&gt;nVar!=pTo-&gt;nVar ){
    return SQLITE_ERROR;
  }
  if( pTo-&gt;isPrepareV2 &amp;&amp; pTo-&gt;expmask ){
    pTo-&gt;expired = 1;
  }
  if( pFrom-&gt;isPrepareV2 &amp;&amp; pFrom-&gt;expmask ){
    pFrom-&gt;expired = 1;
  }
  return sqlite3TransferBindings(pFromStmt, pToStmt);
}
#endif

/*
** Return the sqlite3* database handle to which the prepared statement given
** in the argument belongs.  This is the same database handle that was
** the first argument to the sqlite3_prepare() that was used to create
** the statement in the first place.
*/
sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){
  return pStmt ? ((Vdbe*)pStmt)-&gt;db : 0;
}

/*
** Return true if the prepared statement is guaranteed to not modify the
** database.
*/
int sqlite3_stmt_readonly(sqlite3_stmt *pStmt){
  return pStmt ? ((Vdbe*)pStmt)-&gt;readOnly : 1;
}

/*
** Return true if the prepared statement is in need of being reset.
*/
int sqlite3_stmt_busy(sqlite3_stmt *pStmt){
  Vdbe *v = (Vdbe*)pStmt;
  return v!=0 &amp;&amp; v-&gt;pc&gt;=0 &amp;&amp; v-&gt;magic==VDBE_MAGIC_RUN;
}

/*
** Return a pointer to the next prepared statement after pStmt associated
** with database connection pDb.  If pStmt is NULL, return the first
** prepared statement for the database connection.  Return NULL if there
** are no more.
*/
sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt){
  sqlite3_stmt *pNext;
#ifdef SQLITE_ENABLE_API_ARMOR
  if( !sqlite3SafetyCheckOk(pDb) ){
    (void)SQLITE_MISUSE_BKPT;
    return 0;
  }
#endif
  sqlite3_mutex_enter(pDb-&gt;mutex);
  if( pStmt==0 ){
    pNext = (sqlite3_stmt*)pDb-&gt;pVdbe;
  }else{
    pNext = (sqlite3_stmt*)((Vdbe*)pStmt)-&gt;pNext;
  }
  sqlite3_mutex_leave(pDb-&gt;mutex);
  return pNext;
}

/*
** Return the value of a status counter for a prepared statement
*/
int sqlite3_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag){
  Vdbe *pVdbe = (Vdbe*)pStmt;
  u32 v;
#ifdef SQLITE_ENABLE_API_ARMOR
  if( !pStmt ){
    (void)SQLITE_MISUSE_BKPT;
    return 0;
  }
#endif
  v = pVdbe-&gt;aCounter[op];
  if( resetFlag ) pVdbe-&gt;aCounter[op] = 0;
  return (int)v;
}

#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
/*
** Return status data for a single loop within query pStmt.
*/
int sqlite3_stmt_scanstatus(
  sqlite3_stmt *pStmt,            /* Prepared statement being queried */
  int idx,                        /* Index of loop to report on */
  int iScanStatusOp,              /* Which metric to return */
  void *pOut                      /* OUT: Write the answer here */
){
  Vdbe *p = (Vdbe*)pStmt;
  ScanStatus *pScan;
  if( idx&lt;0 || idx&gt;=p-&gt;nScan ) return 1;
  pScan = &amp;p-&gt;aScan[idx];
  switch( iScanStatusOp ){
    case SQLITE_SCANSTAT_NLOOP: {
      *(sqlite3_int64*)pOut = p-&gt;anExec[pScan-&gt;addrLoop];
      break;
    }
    case SQLITE_SCANSTAT_NVISIT: {
      *(sqlite3_int64*)pOut = p-&gt;anExec[pScan-&gt;addrVisit];
      break;
    }
    case SQLITE_SCANSTAT_EST: {
      double r = 1.0;
      LogEst x = pScan-&gt;nEst;
      while( x&lt;100 ){
        x += 10;
        r *= 0.5;
      }
      *(double*)pOut = r*sqlite3LogEstToInt(x);
      break;
    }
    case SQLITE_SCANSTAT_NAME: {
      *(const char**)pOut = pScan-&gt;zName;
      break;
    }
    case SQLITE_SCANSTAT_EXPLAIN: {
      if( pScan-&gt;addrExplain ){
        *(const char**)pOut = p-&gt;aOp[ pScan-&gt;addrExplain ].p4.z;
      }else{
        *(const char**)pOut = 0;
      }
      break;
    }
    case SQLITE_SCANSTAT_SELECTID: {
      if( pScan-&gt;addrExplain ){
        *(int*)pOut = p-&gt;aOp[ pScan-&gt;addrExplain ].p1;
      }else{
        *(int*)pOut = -1;
      }
      break;
    }
    default: {
      return 1;
    }
  }
  return 0;
}

/*
** Zero all counters associated with the sqlite3_stmt_scanstatus() data.
*/
void sqlite3_stmt_scanstatus_reset(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe*)pStmt;
  memset(p-&gt;anExec, 0, p-&gt;nOp * sizeof(i64));
}
#endif /* SQLITE_ENABLE_STMT_SCANSTATUS */
</unit>
