<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/src/pcache.c"><comment type="block">/*
** 2008 August 05
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file implements that page cache.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** A complete page cache is an instance of this structure.
*/</comment>
<struct>struct <name>PCache</name> <block>{
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pDirty</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pDirtyTail</name></decl>;</decl_stmt>         <comment type="block">/* List of dirty pages in LRU order */</comment>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pSynced</name></decl>;</decl_stmt>                     <comment type="block">/* Last synced page in dirty page list */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRefSum</name></decl>;</decl_stmt>                        <comment type="block">/* Sum of ref counts over all pages */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szCache</name></decl>;</decl_stmt>                        <comment type="block">/* Configured cache size */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szSpill</name></decl>;</decl_stmt>                        <comment type="block">/* Size before spilling occurs */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szPage</name></decl>;</decl_stmt>                         <comment type="block">/* Size of every page in this cache */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>szExtra</name></decl>;</decl_stmt>                        <comment type="block">/* Size of extra space for each page */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bPurgeable</name></decl>;</decl_stmt>                      <comment type="block">/* True if pages are on backing store */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>eCreate</name></decl>;</decl_stmt>                         <comment type="block">/* eCreate value for for xFetch() */</comment>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xStress</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>PgHdr</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>       <comment type="block">/* Call to try make a page clean */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pStress</name></decl>;</decl_stmt>                      <comment type="block">/* Argument to xStress */</comment>
  <decl_stmt><decl><type><name>sqlite3_pcache</name> <modifier>*</modifier></type><name>pCache</name></decl>;</decl_stmt>             <comment type="block">/* Pluggable cache module */</comment>
}</block>;</struct>

<comment type="block" format="doxygen">/********************************** Linked List Management ********************/</comment>

<comment type="block">/* Allowed values for second argument to pcacheManageDirtyList() */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCACHE_DIRTYLIST_REMOVE</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>    <comment type="block">/* Remove pPage from dirty list */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCACHE_DIRTYLIST_ADD</name></cpp:macro>      <cpp:value>2</cpp:value></cpp:define>    <comment type="block">/* Add pPage to the dirty list */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCACHE_DIRTYLIST_FRONT</name></cpp:macro>    <cpp:value>3</cpp:value></cpp:define>    <comment type="block">/* Move pPage to the front of the list */</comment>

<comment type="block">/*
** Manage pPage's participation on the dirty list.  Bits of the addRemove
** argument determines what operation to do.  The 0x01 bit means first
** remove pPage from the dirty list.  The 0x02 means add pPage back to
** the dirty list.  Doing both moves pPage to the front of the dirty list.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pcacheManageDirtyList</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>addRemove</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PCache</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pCache</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>addRemove</name> <operator>&amp;</operator> <name>PCACHE_DIRTYLIST_REMOVE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDirtyNext</name></name> <operator>||</operator> <name>pPage</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pDirtyTail</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDirtyPrev</name></name> <operator>||</operator> <name>pPage</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
    <comment type="block">/* Update the PCache1.pSynced variable if necessary. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pSynced</name></name><operator>==</operator><name>pPage</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pSynced</name> <init>= <expr><name><name>pPage</name><operator>-&gt;</operator><name>pDirtyPrev</name></name></expr></init></decl>;</decl_stmt>
      <while>while<condition>( <expr><name>pSynced</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pSynced</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_NEED_SYNC</name><operator>)</operator></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pSynced</name> <operator>=</operator> <name><name>pSynced</name><operator>-&gt;</operator><name>pDirtyPrev</name></name></expr>;</expr_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pSynced</name></name> <operator>=</operator> <name>pSynced</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
    <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>pDirtyNext</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDirtyNext</name><operator>-&gt;</operator><name>pDirtyPrev</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pDirtyPrev</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pDirtyTail</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pDirtyTail</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pDirtyPrev</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>pDirtyPrev</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDirtyPrev</name><operator>-&gt;</operator><name>pDirtyNext</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pDirtyNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pDirtyNext</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>bPurgeable</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eCreate</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eCreate</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDirtyNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDirtyPrev</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>addRemove</name> <operator>&amp;</operator> <name>PCACHE_DIRTYLIST_ADD</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDirtyNext</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pDirtyPrev</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name><operator>!=</operator><name>pPage</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
    <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDirtyNext</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pPage</name><operator>-&gt;</operator><name>pDirtyNext</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDirtyNext</name><operator>-&gt;</operator><name>pDirtyPrev</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pPage</name><operator>-&gt;</operator><name>pDirtyNext</name><operator>-&gt;</operator><name>pDirtyPrev</name></name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pDirtyTail</name></name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bPurgeable</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>eCreate</name></name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eCreate</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>pSynced</name></name> <operator>&amp;&amp;</operator> <literal type="number">0</literal><operator>==</operator><operator>(</operator><name><name>pPage</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_NEED_SYNC</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pSynced</name></name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Wrapper around the pluggable caches xUnpin method. If the cache is
** being used for an in-memory database, this function is a no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pcacheUnpin</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pCache</name><operator>-&gt;</operator><name>bPurgeable</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>xUnpin</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Compute the number of pages of cache requested.   p-&gt;szCache is the
** cache size requested by the "PRAGMA cache_size" statement.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>numberOfCachePages</name><parameter_list>(<parameter><decl><type><name>PCache</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>szCache</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* IMPLEMENTATION-OF: R-42059-47211 If the argument N is positive then the
    ** suggested cache size is set to N. */</comment>
    <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>szCache</name></name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* IMPLEMENTATION-OF: R-61436-13639 If the argument N is negative, then
    ** the number of cache pages is adjusted to use approximately abs(N*1024)
    ** bytes of memory. */</comment>
    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>-</operator><literal type="number">1024</literal><operator>*</operator><operator>(</operator><name>i64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>szCache</name></name><operator>)</operator><operator>/</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>szPage</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>szExtra</name></name><operator>)</operator><operator>)</operator></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*************************************************** General Interfaces ******
**
** Initialize and shutdown the page cache subsystem. Neither of these 
** functions are threadsafe.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PcacheInitialize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>xInit</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* IMPLEMENTATION-OF: R-26801-64137 If the xInit() method is NULL, then the
    ** built-in default page cache is used instead of the application defined
    ** page cache. */</comment>
    <expr_stmt><expr><call><name>sqlite3PCacheSetDefault</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>xInit</name></name><argument_list>(<argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>pArg</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>sqlite3PcacheShutdown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>xShutdown</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* IMPLEMENTATION-OF: R-26000-56589 The xShutdown() method may be NULL. */</comment>
    <expr_stmt><expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>xShutdown</name></name><argument_list>(<argument><expr><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>pArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the size in bytes of a PCache object.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PcacheSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>PCache</name></expr></argument>)</argument_list></sizeof></expr>;</return> </block_content>}</block></function>

<comment type="block">/*
** Create a new PCache object. Storage space to hold the object
** has already been allocated and is passed in as the p pointer. 
** The caller discovers how much space needs to be allocated by 
** calling sqlite3PcacheSize().
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PcacheOpen</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>szPage</name></decl></parameter>,                  <comment type="block">/* Size of every page */</comment>
  <parameter><decl><type><name>int</name></type> <name>szExtra</name></decl></parameter>,                 <comment type="block">/* Extra space associated with each page */</comment>
  <parameter><decl><type><name>int</name></type> <name>bPurgeable</name></decl></parameter>,              <comment type="block">/* True if pages are on backing store */</comment>
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xStress</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>PgHdr</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,<comment type="block">/* Call to try to make pages clean */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pStress</name></decl></parameter>,               <comment type="block">/* Argument to xStress */</comment>
  <parameter><decl><type><name>PCache</name> <modifier>*</modifier></type><name>p</name></decl></parameter>                    <comment type="block">/* Preallocated space for the PCache */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PCache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>szPage</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>szExtra</name></name> <operator>=</operator> <name>szExtra</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bPurgeable</name></name> <operator>=</operator> <name>bPurgeable</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eCreate</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>xStress</name></name> <operator>=</operator> <name>xStress</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pStress</name></name> <operator>=</operator> <name>pStress</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>szCache</name></name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>szSpill</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3PcacheSetPageSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>szPage</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Change the page size for PCache object. The caller must ensure that there
** are no outstanding page references when this function is called.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PcacheSetPageSize</name><parameter_list>(<parameter><decl><type><name>PCache</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>szPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>nRefSum</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCache</name><operator>-&gt;</operator><name>pDirty</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCache</name><operator>-&gt;</operator><name>szPage</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_pcache</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>xCreate</name></name><argument_list>(
                <argument><expr><name>szPage</name></expr></argument>, <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>szExtra</name></name> <operator>+</operator> <call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>bPurgeable</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>xCachesize</name></name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><call><name>numberOfCachePages</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>xDestroy</name></name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>szPage</name></name> <operator>=</operator> <name>szPage</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Try to obtain a page from the cache.
**
** This routine returns a pointer to an sqlite3_pcache_page object if
** such an object is already in cache, or if a new one is created.
** This routine returns a NULL pointer if the object was not in cache
** and could not be created.
**
** The createFlags should be 0 to check for existing pages and should
** be 3 (not 1, but 3) to try to create a new page.
**
** If the createFlag is 0, then NULL is always returned if the page
** is not already in the cache.  If createFlag is 1, then a new page
** is created only if that can be done without spilling dirty pages
** and without exceeding the cache size limit.
**
** The caller needs to invoke sqlite3PcacheFetchFinish() to properly
** initialize the sqlite3_pcache_page object and convert it into a
** PgHdr object.  The sqlite3PcacheFetch() and sqlite3PcacheFetchFinish()
** routines are split this way for performance reasons. When separated
** they can both (usually) operate without having to push values to
** the stack on entry and pop them back off on exit, which saves a
** lot of pushing and popping.
*/</comment>
<function><type><name>sqlite3_pcache_page</name> <modifier>*</modifier></type><name>sqlite3PcacheFetch</name><parameter_list>(
  <parameter><decl><type><name>PCache</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>,       <comment type="block">/* Obtain the page from this cache */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>,            <comment type="block">/* Page number to obtain */</comment>
  <parameter><decl><type><name>int</name></type> <name>createFlag</name></decl></parameter>        <comment type="block">/* If true, create page if it does not exist already */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>eCreate</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pCache</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>createFlag</name><operator>==</operator><literal type="number">3</literal> <operator>||</operator> <name>createFlag</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pgno</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* eCreate defines what to do if the page does not exist.
  **    0     Do not allocate a new page.  (createFlag==0)
  **    1     Allocate a new page if doing so is inexpensive.
  **          (createFlag==1 AND bPurgeable AND pDirty)
  **    2     Allocate a new page even it doing so is difficult.
  **          (createFlag==1 AND !(bPurgeable AND pDirty)
  */</comment>
  <expr_stmt><expr><name>eCreate</name> <operator>=</operator> <name>createFlag</name> <operator>&amp;</operator> <name><name>pCache</name><operator>-&gt;</operator><name>eCreate</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eCreate</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>eCreate</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>eCreate</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>createFlag</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pCache</name><operator>-&gt;</operator><name>eCreate</name></name><operator>==</operator><name>eCreate</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>createFlag</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>eCreate</name><operator>==</operator><literal type="number">1</literal><operator>+</operator><operator>(</operator><operator>!</operator><name><name>pCache</name><operator>-&gt;</operator><name>bPurgeable</name></name><operator>||</operator><operator>!</operator><name><name>pCache</name><operator>-&gt;</operator><name>pDirty</name></name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>xFetch</name></name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>eCreate</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the sqlite3PcacheFetch() routine is unable to allocate a new
** page because new clean pages are available for reuse and the cache
** size limit has been reached, then this routine can be invoked to 
** try harder to allocate a page.  This routine might invoke the stress
** callback to spill dirty pages to the journal.  It will then try to
** allocate the new page and will only fail to allocate a new page on
** an OOM error.
**
** This routine should be invoked only after sqlite3PcacheFetch() fails.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PcacheFetchStress</name><parameter_list>(
  <parameter><decl><type><name>PCache</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>,                 <comment type="block">/* Obtain the page from this cache */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>,                      <comment type="block">/* Page number to obtain */</comment>
  <parameter><decl><type><name>sqlite3_pcache_page</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppPage</name></decl></parameter>    <comment type="block">/* Write result here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPg</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pCache</name><operator>-&gt;</operator><name>eCreate</name></name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3PcachePagecount</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>)</argument_list></call><operator>&gt;</operator><name><name>pCache</name><operator>-&gt;</operator><name>szSpill</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Find a dirty page to write-out and recycle. First try to find a 
    ** page that does not require a journal-sync (one with PGHDR_NEED_SYNC
    ** cleared), but if that is not possible settle for any other 
    ** unreferenced dirty page.
    */</comment>
    <for>for<control>(<init><expr><name>pPg</name><operator>=</operator><name><name>pCache</name><operator>-&gt;</operator><name>pSynced</name></name></expr>;</init> 
        <condition><expr><name>pPg</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>nRef</name></name> <operator>||</operator> <operator>(</operator><name><name>pPg</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_NEED_SYNC</name><operator>)</operator><operator>)</operator></expr>;</condition> 
        <incr><expr><name>pPg</name><operator>=</operator><name><name>pPg</name><operator>-&gt;</operator><name>pDirtyPrev</name></name></expr></incr>
    )</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>pSynced</name></name> <operator>=</operator> <name>pPg</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pPg</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>pPg</name><operator>=</operator><name><name>pCache</name><operator>-&gt;</operator><name>pDirtyTail</name></name></expr>;</init> <condition><expr><name>pPg</name> <operator>&amp;&amp;</operator> <name><name>pPg</name><operator>-&gt;</operator><name>nRef</name></name></expr>;</condition> <incr><expr><name>pPg</name><operator>=</operator><name><name>pPg</name><operator>-&gt;</operator><name>pDirtyPrev</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pPg</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_LOG_CACHE_SPILL</name></cpp:ifdef>
      <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_FULL</name></expr></argument>, 
                  <argument><expr><literal type="string">"spill page %d making room for %d - cache used: %d/%d"</literal></expr></argument>,
                  <argument><expr><name><name>pPg</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>,
                  <argument><expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache</name><operator>.</operator><name>xPagecount</name></name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>numberOfCachePages</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pCache</name><operator>-&gt;</operator><name>xStress</name></name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pStress</name></name></expr></argument>, <argument><expr><name>pPg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_BUSY</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppPage</name> <operator>=</operator> <call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>xFetch</name></name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><operator>*</operator><name>ppPage</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>SQLITE_NOMEM</name></expr> </then><else>: <expr><name>SQLITE_OK</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is a helper routine for sqlite3PcacheFetchFinish()
**
** In the uncommon case where the page being fetched has not been
** initialized, this routine is invoked to do the initialization.
** This routine is broken out into a separate function since it
** requires extra stack manipulation that can be avoided in the common
** case.
*/</comment>
<function><type><specifier>static</specifier> <name>SQLITE_NOINLINE</name> <name>PgHdr</name> <modifier>*</modifier></type><name>pcacheFetchFinishWithInit</name><parameter_list>(
  <parameter><decl><type><name>PCache</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>,             <comment type="block">/* Obtain the page from this cache */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>,                  <comment type="block">/* Page number obtained */</comment>
  <parameter><decl><type><name>sqlite3_pcache_page</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>  <comment type="block">/* Page obtained by prior PcacheFetch() call */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPgHdr</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPgHdr</name> <operator>=</operator> <operator>(</operator><name>PgHdr</name><operator>*</operator><operator>)</operator><name><name>pPage</name><operator>-&gt;</operator><name>pExtra</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pPgHdr</name><operator>-&gt;</operator><name>pPage</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pPgHdr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPgHdr</name><operator>-&gt;</operator><name>pPage</name></name> <operator>=</operator> <name>pPage</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPgHdr</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <name><name>pPage</name><operator>-&gt;</operator><name>pBuf</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPgHdr</name><operator>-&gt;</operator><name>pExtra</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pPgHdr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pPgHdr</name><operator>-&gt;</operator><name>pExtra</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>szExtra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPgHdr</name><operator>-&gt;</operator><name>pCache</name></name> <operator>=</operator> <name>pCache</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPgHdr</name><operator>-&gt;</operator><name>pgno</name></name> <operator>=</operator> <name>pgno</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPgHdr</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>PGHDR_CLEAN</name></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3PcacheFetchFinish</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>,<argument><expr><name>pgno</name></expr></argument>,<argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine converts the sqlite3_pcache_page object returned by
** sqlite3PcacheFetch() into an initialized PgHdr object.  This routine
** must be called after sqlite3PcacheFetch() in order to get a usable
** result.
*/</comment>
<function><type><name>PgHdr</name> <modifier>*</modifier></type><name>sqlite3PcacheFetchFinish</name><parameter_list>(
  <parameter><decl><type><name>PCache</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>,             <comment type="block">/* Obtain the page from this cache */</comment>
  <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>,                  <comment type="block">/* Page number obtained */</comment>
  <parameter><decl><type><name>sqlite3_pcache_page</name> <modifier>*</modifier></type><name>pPage</name></decl></parameter>  <comment type="block">/* Page obtained by prior PcacheFetch() call */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pPgHdr</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pPage</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pPgHdr</name> <operator>=</operator> <operator>(</operator><name>PgHdr</name> <operator>*</operator><operator>)</operator><name><name>pPage</name><operator>-&gt;</operator><name>pExtra</name></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pPgHdr</name><operator>-&gt;</operator><name>pPage</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>pcacheFetchFinishWithInit</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><name>pPage</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>nRefSum</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pPgHdr</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>pPgHdr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Decrement the reference count on a page. If the page is clean and the
** reference count drops to 0, then it is made eligible for recycling.
*/</comment>
<function><type><name>void</name> <name>SQLITE_NOINLINE</name></type> <name>sqlite3PcacheRelease</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pCache</name><operator>-&gt;</operator><name>nRefSum</name></name><operator>--</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><operator>--</operator><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_CLEAN</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>pcacheUnpin</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pDirtyPrev</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Move the page to the head of the dirty list. */</comment>
      <expr_stmt><expr><call><name>pcacheManageDirtyList</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>PCACHE_DIRTYLIST_FRONT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Increase the reference count of a supplied page by 1.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheRef</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pCache</name><operator>-&gt;</operator><name>nRefSum</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Drop a page from the cache. There must be exactly one reference to the
** page. This function deletes that reference, so after it returns the
** page pointed to by p is invalid.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheDrop</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_DIRTY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>pcacheManageDirtyList</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>PCACHE_DIRTYLIST_REMOVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pCache</name><operator>-&gt;</operator><name>nRefSum</name></name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>xUnpin</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Make sure the page is marked as dirty. If it isn't dirty already,
** make it so.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheMakeDirty</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>PGHDR_CLEAN</name><operator>|</operator><name>PGHDR_DONT_WRITE</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>PGHDR_DONT_WRITE</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGHDR_CLEAN</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>^=</operator> <operator>(</operator><name>PGHDR_DIRTY</name><operator>|</operator><name>PGHDR_CLEAN</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>PGHDR_DIRTY</name><operator>|</operator><name>PGHDR_CLEAN</name><operator>)</operator><operator>)</operator><operator>==</operator><name>PGHDR_DIRTY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pcacheManageDirtyList</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>PCACHE_DIRTYLIST_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Make sure the page is marked as clean. If it isn't clean already,
** make it so.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheMakeClean</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGHDR_DIRTY</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PGHDR_CLEAN</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcacheManageDirtyList</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>PCACHE_DIRTYLIST_REMOVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>PGHDR_DIRTY</name><operator>|</operator><name>PGHDR_NEED_SYNC</name><operator>|</operator><name>PGHDR_WRITEABLE</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PGHDR_CLEAN</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>pcacheUnpin</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Make every page in the cache clean.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheCleanAll</name><parameter_list>(<parameter><decl><type><name>PCache</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>p</name> <operator>=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>pDirty</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3PcacheMakeClean</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
** Clear the PGHDR_NEED_SYNC flag from all dirty pages.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheClearSyncFlags</name><parameter_list>(<parameter><decl><type><name>PCache</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pCache</name><operator>-&gt;</operator><name>pDirty</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pDirtyNext</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>PGHDR_NEED_SYNC</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>pSynced</name></name> <operator>=</operator> <name><name>pCache</name><operator>-&gt;</operator><name>pDirtyTail</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Change the page number of page p to newPgno. 
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheMove</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>newPgno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PCache</name> <modifier>*</modifier></type><name>pCache</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pCache</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>newPgno</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>xRekey</name></name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pPage</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pgno</name></name></expr></argument>,<argument><expr><name>newPgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pgno</name></name> <operator>=</operator> <name>newPgno</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_DIRTY</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_NEED_SYNC</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>pcacheManageDirtyList</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>PCACHE_DIRTYLIST_FRONT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Drop every cache entry whose page number is greater than "pgno". The
** caller must ensure that there are no outstanding references to any pages
** other than page 1 with a page number greater than pgno.
**
** If there is a reference to page 1 and the pgno parameter passed to this
** function is 0, then the data area associated with page 1 is zeroed, but
** the page object is not dropped.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheTruncate</name><parameter_list>(<parameter><decl><type><name>PCache</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>, <parameter><decl><type><name>Pgno</name></type> <name>pgno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pCache</name><operator>-&gt;</operator><name>pDirty</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name>pNext</name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>pNext</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pDirtyNext</name></name></expr>;</expr_stmt>
      <comment type="block">/* This routine never gets call with a positive pgno except right
      ** after sqlite3PcacheCleanAll().  So if there are dirty pages,
      ** it must be that pgno==0.
      */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pgno</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pgno</name></name><operator>&gt;</operator><name>pgno</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name></name><operator>&amp;</operator><name>PGHDR_DIRTY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3PcacheMakeClean</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>pgno</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pCache</name><operator>-&gt;</operator><name>nRefSum</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_pcache_page</name> <modifier>*</modifier></type><name>pPage1</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>pPage1</name> <operator>=</operator> <call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>xFetch</name></name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pPage1</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>  <comment type="block">/* Page 1 is always available in cache, because
                             ** pCache-&gt;nRefSum&gt;0 */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pPage1</name><operator>-&gt;</operator><name>pBuf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>szPage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pgno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>xTruncate</name></name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name></expr></argument>, <argument><expr><name>pgno</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Close a cache.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheClose</name><parameter_list>(<parameter><decl><type><name>PCache</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>xDestroy</name></name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
** Discard the contents of the cache.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheClear</name><parameter_list>(<parameter><decl><type><name>PCache</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3PcacheTruncate</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Merge two lists of pages connected by pDirty and in pgno order.
** Do not both fixing the pDirtyPrev pointers.
*/</comment>
<function><type><specifier>static</specifier> <name>PgHdr</name> <modifier>*</modifier></type><name>pcacheMergeDirtyList</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pA</name></decl></parameter>, <parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pB</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PgHdr</name></type> <name>result</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pTail</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pTail</name> <operator>=</operator> <operator>&amp;</operator><name>result</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pA</name> <operator>&amp;&amp;</operator> <name>pB</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pA</name><operator>-&gt;</operator><name>pgno</name></name><operator>&lt;</operator><name><name>pB</name><operator>-&gt;</operator><name>pgno</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pDirty</name></name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTail</name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pA</name> <operator>=</operator> <name><name>pA</name><operator>-&gt;</operator><name>pDirty</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pDirty</name></name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pTail</name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pB</name> <operator>=</operator> <name><name>pB</name><operator>-&gt;</operator><name>pDirty</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>pA</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pDirty</name></name> <operator>=</operator> <name>pA</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pB</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pDirty</name></name> <operator>=</operator> <name>pB</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pTail</name><operator>-&gt;</operator><name>pDirty</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name><name>result</name><operator>.</operator><name>pDirty</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Sort the list of pages in accending order by pgno.  Pages are
** connected by pDirty pointers.  The pDirtyPrev pointers are
** corrupted by this sort.
**
** Since there cannot be more than 2^31 distinct pages in a database,
** there cannot be more than 31 buckets required by the merge sorter.
** One extra bucket is added to catch overflow in case something
** ever changes to make the previous sentence incorrect.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_SORT_BUCKET</name></cpp:macro>  <cpp:value>32</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>PgHdr</name> <modifier>*</modifier></type><name>pcacheSortDirtyList</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name><name>a</name><index>[<expr><name>N_SORT_BUCKET</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>pIn</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pIn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pIn</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>i</name><operator>&lt;</operator><name>N_SORT_BUCKET</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>pcacheMergeDirtyList</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>i</name><operator>==</operator><name>N_SORT_BUCKET</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* To get here, there need to be 2^(N_SORT_BUCKET) elements in
      ** the input list.  But that is impossible.
      */</comment>
      <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pcacheMergeDirtyList</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>N_SORT_BUCKET</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>pcacheMergeDirtyList</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a list of all dirty pages in the cache, sorted by page number.
*/</comment>
<function><type><name>PgHdr</name> <modifier>*</modifier></type><name>sqlite3PcacheDirtyList</name><parameter_list>(<parameter><decl><type><name>PCache</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pCache</name><operator>-&gt;</operator><name>pDirty</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pDirtyNext</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pDirty</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pDirtyNext</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><call><name>pcacheSortDirtyList</name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pDirty</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Return the total number of references to all pages held by the cache.
**
** This is not the total number of pages referenced, but the sum of the
** reference count for all pages.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PcacheRefCount</name><parameter_list>(<parameter><decl><type><name>PCache</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pCache</name><operator>-&gt;</operator><name>nRefSum</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the number of references to the page supplied as an argument.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PcachePageRefcount</name><parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
** Return the total number of pages in the cache.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PcachePagecount</name><parameter_list>(<parameter><decl><type><name>PCache</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>xPagecount</name></name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<comment type="block">/*
** Get the suggested cache-size value.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PcacheGetCachesize</name><parameter_list>(<parameter><decl><type><name>PCache</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>numberOfCachePages</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Set the suggested cache-size value.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheSetCachesize</name><parameter_list>(<parameter><decl><type><name>PCache</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mxPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCache</name><operator>-&gt;</operator><name>szCache</name></name> <operator>=</operator> <name>mxPage</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>xCachesize</name></name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name></expr></argument>,
                                         <argument><expr><call><name>numberOfCachePages</name><argument_list>(<argument><expr><name>pCache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the suggested cache-spill value.  Make no changes if if the
** argument is zero.  Return the effective cache-spill size, which will
** be the larger of the szSpill and szCache.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3PcacheSetSpillsize</name><parameter_list>(<parameter><decl><type><name>PCache</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mxPage</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pCache</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>mxPage</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>mxPage</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>mxPage</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>-</operator><literal type="number">1024</literal><operator>*</operator><operator>(</operator><name>i64</name><operator>)</operator><name>mxPage</name><operator>)</operator><operator>/</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>szPage</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>szExtra</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>szSpill</name></name> <operator>=</operator> <name>mxPage</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>numberOfCachePages</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>szSpill</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>szSpill</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt> 
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free up as much memory as possible from the page cache.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheShrink</name><parameter_list>(<parameter><decl><type><name>PCache</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>pcache2</name><operator>.</operator><name>xShrink</name></name><argument_list>(<argument><expr><name><name>pCache</name><operator>-&gt;</operator><name>pCache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the size of the header added by this middleware layer
** in the page-cache hierarchy.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3HeaderSizePcache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content> <return>return <expr><call><name>ROUND8</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PgHdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_CHECK_PAGES</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** For all dirty pages currently in the cache, invoke the specified
** callback. This is only used if the SQLITE_CHECK_PAGES macro is
** defined.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3PcacheIterateDirty</name><parameter_list>(<parameter><decl><type><name>PCache</name> <modifier>*</modifier></type><name>pCache</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xIter</name>)<parameter_list>(<parameter><decl><type><name>PgHdr</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PgHdr</name> <modifier>*</modifier></type><name>pDirty</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>pDirty</name><operator>=</operator><name><name>pCache</name><operator>-&gt;</operator><name>pDirty</name></name></expr>;</init> <condition><expr><name>pDirty</name></expr>;</condition> <incr><expr><name>pDirty</name><operator>=</operator><name><name>pDirty</name><operator>-&gt;</operator><name>pDirtyNext</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>xIter</name><argument_list>(<argument><expr><name>pDirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
