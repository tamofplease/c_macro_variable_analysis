<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/src/os_win.c"><comment type="block">/*
** 2004 May 22
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This file contains code that is specific to Windows.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WIN</name></expr></cpp:if>               <comment type="block">/* This file is used for Windows only */</comment>

<comment type="block">/*
** Include code that is common to all os_*.c files
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"os_common.h"</cpp:file></cpp:include>

<comment type="block">/*
** Include the header file for the Windows VFS.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"os_win.h"</cpp:file></cpp:include>

<comment type="block">/*
** Compiling and using WAL mode requires several APIs that are only
** available in Windows platforms based on the NT kernel.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_OS_WINNT</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_WAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#  <cpp:directive>error</cpp:directive> <cpp:literal>"WAL mode requires support from the Windows NT kernel, compile\</cpp:literal></cpp:error>
 <expr_stmt><expr><name>with</name> <name><name>SQLITE_OMIT_WAL</name><operator>.</operator><name/></name>"
#endif

#if !SQLITE_OS_WINNT &amp;&amp; SQLITE_MAX_MMAP_SIZE&gt;0
#  error "<name>Memory</name> <name>mapped</name> <name>files</name> <name>require</name> <name>support</name> <name>from</name> <name>the</name> <name>Windows</name> <name>NT</name> <name>kernel</name></expr><operator>,</operator>\
 <expr><name>compile</name> <name>with</name> <name>SQLITE_MAX_MMAP_SIZE</name><operator>=</operator><literal type="number">0.</literal><literal type="string">"
#endif

/*
** Are most of the Win32 ANSI APIs available (i.e. with certain exceptions
** based on the sub-platform)?
*/
#if !SQLITE_OS_WINCE &amp;&amp; !SQLITE_OS_WINRT &amp;&amp; !defined(SQLITE_WIN32_NO_ANSI)
#  define SQLITE_WIN32_HAS_ANSI
#endif

/*
** Are most of the Win32 Unicode APIs available (i.e. with certain exceptions
** based on the sub-platform)?
*/
#if (SQLITE_OS_WINCE || SQLITE_OS_WINNT || SQLITE_OS_WINRT) &amp;&amp; \
    !defined(SQLITE_WIN32_NO_WIDE)
#  define SQLITE_WIN32_HAS_WIDE
#endif

/*
** Make sure at least one set of Win32 APIs is available.
*/
#if !defined(SQLITE_WIN32_HAS_ANSI) &amp;&amp; !defined(SQLITE_WIN32_HAS_WIDE)
#  error "</literal><name>At</name> <name>least</name> <name>one</name> <name>of</name> <name>SQLITE_WIN32_HAS_ANSI</name> <name>and</name> <name>SQLITE_WIN32_HAS_WIDE</name>\
 <name>must</name> <name>be</name> <name><name>defined</name><operator>.</operator><name/></name>"
#endif

/*
** Define the required Windows SDK version constants if they are not
** already available.
*/
#ifndef NTDDI_WIN8
#  define NTDDI_WIN8                        0x06020000
#endif

#ifndef NTDDI_WINBLUE
#  define NTDDI_WINBLUE                     0x06030000
#endif

#ifndef NTDDI_WINTHRESHOLD
#  define NTDDI_WINTHRESHOLD                0x06040000
#endif

/*
** Check to see if the GetVersionEx[AW] functions are deprecated on the
** target system.  GetVersionEx was first deprecated in Win8.1.
*/
#ifndef SQLITE_WIN32_GETVERSIONEX
#  if defined(NTDDI_VERSION) &amp;&amp; NTDDI_VERSION &gt;= NTDDI_WINBLUE
#    define SQLITE_WIN32_GETVERSIONEX   0   /* GetVersionEx() is deprecated */
#  else
#    define SQLITE_WIN32_GETVERSIONEX   1   /* GetVersionEx() is current */
#  endif
#endif

/*
** Check to see if the CreateFileMappingA function is supported on the
** target system.  It is unavailable when using "<name><name>mincore</name><operator>.</operator><name>lib</name></name><literal type="string">" on Win10.
** When compiling for Windows 10, always assume "</literal><name><name>mincore</name><operator>.</operator><name>lib</name></name><literal type="string">" is in use.
*/
#ifndef SQLITE_WIN32_CREATEFILEMAPPINGA
#  if defined(NTDDI_VERSION) &amp;&amp; NTDDI_VERSION &gt;= NTDDI_WINTHRESHOLD
#    define SQLITE_WIN32_CREATEFILEMAPPINGA   0
#  else
#    define SQLITE_WIN32_CREATEFILEMAPPINGA   1
#  endif
#endif

/*
** This constant should already be defined (in the "</literal><name><name>WinDef</name><operator>.</operator><name>h</name></name><literal type="string">" SDK file).
*/
#ifndef MAX_PATH
#  define MAX_PATH                      (260)
#endif

/*
** Maximum pathname length (in chars) for Win32.  This should normally be
** MAX_PATH.
*/
#ifndef SQLITE_WIN32_MAX_PATH_CHARS
#  define SQLITE_WIN32_MAX_PATH_CHARS   (MAX_PATH)
#endif

/*
** This constant should already be defined (in the "</literal><name><name>WinNT</name><operator>.</operator><name>h</name></name><literal type="string">" SDK file).
*/
#ifndef UNICODE_STRING_MAX_CHARS
#  define UNICODE_STRING_MAX_CHARS      (32767)
#endif

/*
** Maximum pathname length (in chars) for WinNT.  This should normally be
** UNICODE_STRING_MAX_CHARS.
*/
#ifndef SQLITE_WINNT_MAX_PATH_CHARS
#  define SQLITE_WINNT_MAX_PATH_CHARS   (UNICODE_STRING_MAX_CHARS)
#endif

/*
** Maximum pathname length (in bytes) for Win32.  The MAX_PATH macro is in
** characters, so we allocate 4 bytes per character assuming worst-case of
** 4-bytes-per-character for UTF8.
*/
#ifndef SQLITE_WIN32_MAX_PATH_BYTES
#  define SQLITE_WIN32_MAX_PATH_BYTES   (SQLITE_WIN32_MAX_PATH_CHARS*4)
#endif

/*
** Maximum pathname length (in bytes) for WinNT.  This should normally be
** UNICODE_STRING_MAX_CHARS * sizeof(WCHAR).
*/
#ifndef SQLITE_WINNT_MAX_PATH_BYTES
#  define SQLITE_WINNT_MAX_PATH_BYTES   \
                            (sizeof(WCHAR) * SQLITE_WINNT_MAX_PATH_CHARS)
#endif

/*
** Maximum error message length (in chars) for WinRT.
*/
#ifndef SQLITE_WIN32_MAX_ERRMSG_CHARS
#  define SQLITE_WIN32_MAX_ERRMSG_CHARS (1024)
#endif

/*
** Returns non-zero if the character should be treated as a directory
** separator.
*/
#ifndef winIsDirSep
#  define winIsDirSep(a)                (((a) == '/') || ((a) == '\\'))
#endif

/*
** This macro is used when a local variable is set to a value that is
** [sometimes] not used by the code (e.g. via conditional compilation).
*/
#ifndef UNUSED_VARIABLE_VALUE
#  define UNUSED_VARIABLE_VALUE(x)      (void)(x)
#endif

/*
** Returns the character that should be used as the directory separator.
*/
#ifndef winGetDirSep
#  define winGetDirSep()                '\\'
#endif

/*
** Do we need to manually define the Win32 file mapping APIs for use with WAL
** mode or memory mapped files (e.g. these APIs are available in the Windows
** CE SDK; however, they are not present in the header file)?
*/
#if SQLITE_WIN32_FILEMAPPING_API &amp;&amp; \
        (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE&gt;0)
/*
** Two of the file mapping APIs are different under WinRT.  Figure out which
** set we need.
*/
#if SQLITE_OS_WINRT
WINBASEAPI HANDLE WINAPI CreateFileMappingFromApp(HANDLE, \
        LPSECURITY_ATTRIBUTES, ULONG, ULONG64, LPCWSTR);

WINBASEAPI LPVOID WINAPI MapViewOfFileFromApp(HANDLE, ULONG, ULONG64, SIZE_T);
#else
#if defined(SQLITE_WIN32_HAS_ANSI)
WINBASEAPI HANDLE WINAPI CreateFileMappingA(HANDLE, LPSECURITY_ATTRIBUTES, \
        DWORD, DWORD, DWORD, LPCSTR);
#endif /* defined(SQLITE_WIN32_HAS_ANSI) */

#if defined(SQLITE_WIN32_HAS_WIDE)
WINBASEAPI HANDLE WINAPI CreateFileMappingW(HANDLE, LPSECURITY_ATTRIBUTES, \
        DWORD, DWORD, DWORD, LPCWSTR);
#endif /* defined(SQLITE_WIN32_HAS_WIDE) */

WINBASEAPI LPVOID WINAPI MapViewOfFile(HANDLE, DWORD, DWORD, DWORD, SIZE_T);
#endif /* SQLITE_OS_WINRT */

/*
** These file mapping APIs are common to both Win32 and WinRT.
*/

WINBASEAPI BOOL WINAPI FlushViewOfFile(LPCVOID, SIZE_T);
WINBASEAPI BOOL WINAPI UnmapViewOfFile(LPCVOID);
#endif /* SQLITE_WIN32_FILEMAPPING_API */

/*
** Some Microsoft compilers lack this definition.
*/
#ifndef INVALID_FILE_ATTRIBUTES
# define INVALID_FILE_ATTRIBUTES ((DWORD)-1)
#endif

#ifndef FILE_FLAG_MASK
# define FILE_FLAG_MASK          (0xFF3C0000)
#endif

#ifndef FILE_ATTRIBUTE_MASK
# define FILE_ATTRIBUTE_MASK     (0x0003FFF7)
#endif

#ifndef SQLITE_OMIT_WAL
/* Forward references to structures used for WAL */
typedef struct winShm winShm;           /* A connection to shared-memory */
typedef struct winShmNode winShmNode;   /* A region of shared-memory */
#endif

/*
** WinCE lacks native support for file locking so we have to fake it
** with some code of our own.
*/
#if SQLITE_OS_WINCE
typedef struct winceLock {
  int nReaders;       /* Number of reader locks obtained */
  BOOL bPending;      /* Indicates a pending lock has been obtained */
  BOOL bReserved;     /* Indicates a reserved lock has been obtained */
  BOOL bExclusive;    /* Indicates an exclusive lock has been obtained */
} winceLock;
#endif

/*
** The winFile structure is a subclass of sqlite3_file* specific to the win32
** portability layer.
*/
typedef struct winFile winFile;
struct winFile {
  const sqlite3_io_methods *pMethod; /*** Must be first ***/
  sqlite3_vfs *pVfs;      /* The VFS used to open this file */
  HANDLE h;               /* Handle for accessing the file */
  u8 locktype;            /* Type of lock currently held on this file */
  short sharedLockByte;   /* Randomly chosen byte used as a shared lock */
  u8 ctrlFlags;           /* Flags.  See WINFILE_* below */
  DWORD lastErrno;        /* The Windows errno from the last I/O error */
#ifndef SQLITE_OMIT_WAL
  winShm *pShm;           /* Instance of shared memory on this file */
#endif
  const char *zPath;      /* Full pathname of this file */
  int szChunk;            /* Chunk size configured by FCNTL_CHUNK_SIZE */
#if SQLITE_OS_WINCE
  LPWSTR zDeleteOnClose;  /* Name of file to delete when closing */
  HANDLE hMutex;          /* Mutex used to control access to shared lock */
  HANDLE hShared;         /* Shared memory segment used for locking */
  winceLock local;        /* Locks obtained by this instance of winFile */
  winceLock *shared;      /* Global shared lock memory for the file  */
#endif
#if SQLITE_MAX_MMAP_SIZE&gt;0
  int nFetchOut;                /* Number of outstanding xFetch references */
  HANDLE hMap;                  /* Handle for accessing memory mapping */
  void *pMapRegion;             /* Area memory mapped */
  sqlite3_int64 mmapSize;       /* Usable size of mapped region */
  sqlite3_int64 mmapSizeActual; /* Actual size of mapped region */
  sqlite3_int64 mmapSizeMax;    /* Configured FCNTL_MMAP_SIZE value */
#endif
};

/*
** Allowed values for winFile.ctrlFlags
*/
#define WINFILE_RDONLY          0x02   /* Connection is read only */
#define WINFILE_PERSIST_WAL     0x04   /* Persistent WAL mode */
#define WINFILE_PSOW            0x10   /* SQLITE_IOCAP_POWERSAFE_OVERWRITE */

/*
 * The size of the buffer used by sqlite3_win32_write_debug().
 */
#ifndef SQLITE_WIN32_DBG_BUF_SIZE
#  define SQLITE_WIN32_DBG_BUF_SIZE   ((int)(4096-sizeof(DWORD)))
#endif

/*
 * The value used with sqlite3_win32_set_directory() to specify that
 * the data directory should be changed.
 */
#ifndef SQLITE_WIN32_DATA_DIRECTORY_TYPE
#  define SQLITE_WIN32_DATA_DIRECTORY_TYPE (1)
#endif

/*
 * The value used with sqlite3_win32_set_directory() to specify that
 * the temporary directory should be changed.
 */
#ifndef SQLITE_WIN32_TEMP_DIRECTORY_TYPE
#  define SQLITE_WIN32_TEMP_DIRECTORY_TYPE (2)
#endif

/*
 * If compiled with SQLITE_WIN32_MALLOC on Windows, we will use the
 * various Win32 API heap functions instead of our own.
 */
#ifdef SQLITE_WIN32_MALLOC

/*
 * If this is non-zero, an isolated heap will be created by the native Win32
 * allocator subsystem; otherwise, the default process heap will be used.  This
 * setting has no effect when compiling for WinRT.  By default, this is enabled
 * and an isolated heap will be created to store all allocated data.
 *
 ******************************************************************************
 * WARNING: It is important to note that when this setting is non-zero and the
 *          winMemShutdown function is called (e.g. by the sqlite3_shutdown
 *          function), all data that was allocated using the isolated heap will
 *          be freed immediately and any attempt to access any of that freed
 *          data will almost certainly result in an immediate access violation.
 ******************************************************************************
 */
#ifndef SQLITE_WIN32_HEAP_CREATE
#  define SQLITE_WIN32_HEAP_CREATE    (TRUE)
#endif

/*
 * The initial size of the Win32-specific heap.  This value may be zero.
 */
#ifndef SQLITE_WIN32_HEAP_INIT_SIZE
#  define SQLITE_WIN32_HEAP_INIT_SIZE ((SQLITE_DEFAULT_CACHE_SIZE) * \
                                       (SQLITE_DEFAULT_PAGE_SIZE) + 4194304)
#endif

/*
 * The maximum size of the Win32-specific heap.  This value may be zero.
 */
#ifndef SQLITE_WIN32_HEAP_MAX_SIZE
#  define SQLITE_WIN32_HEAP_MAX_SIZE  (0)
#endif

/*
 * The extra flags to use in calls to the Win32 heap APIs.  This value may be
 * zero for the default behavior.
 */
#ifndef SQLITE_WIN32_HEAP_FLAGS
#  define SQLITE_WIN32_HEAP_FLAGS     (0)
#endif


/*
** The winMemData structure stores information required by the Win32-specific
** sqlite3_mem_methods implementation.
*/
typedef struct winMemData winMemData;
struct winMemData {
#ifndef NDEBUG
  u32 magic1;   /* Magic number to detect structure corruption. */
#endif
  HANDLE hHeap; /* The handle to our heap. */
  BOOL bOwned;  /* Do we own the heap (i.e. destroy it on shutdown)? */
#ifndef NDEBUG
  u32 magic2;   /* Magic number to detect structure corruption. */
#endif
};

#ifndef NDEBUG
#define WINMEM_MAGIC1     0x42b2830b
#define WINMEM_MAGIC2     0xbd4d7cf4
#endif

static struct winMemData win_mem_data = {
#ifndef NDEBUG
  WINMEM_MAGIC1,
#endif
  NULL, FALSE
#ifndef NDEBUG
  ,WINMEM_MAGIC2
#endif
};

#ifndef NDEBUG
#define winMemAssertMagic1() assert( win_mem_data.magic1==WINMEM_MAGIC1 )
#define winMemAssertMagic2() assert( win_mem_data.magic2==WINMEM_MAGIC2 )
#define winMemAssertMagic()  winMemAssertMagic1(); winMemAssertMagic2();
#else
#define winMemAssertMagic()
#endif

#define winMemGetDataPtr()  &amp;win_mem_data
#define winMemGetHeap()     win_mem_data.hHeap
#define winMemGetOwned()    win_mem_data.bOwned

static void *winMemMalloc(int nBytes);
static void winMemFree(void *pPrior);
static void *winMemRealloc(void *pPrior, int nBytes);
static int winMemSize(void *p);
static int winMemRoundup(int n);
static int winMemInit(void *pAppData);
static void winMemShutdown(void *pAppData);

const sqlite3_mem_methods *sqlite3MemGetWin32(void);
#endif /* SQLITE_WIN32_MALLOC */

/*
** The following variable is (normally) set once and never changes
** thereafter.  It records whether the operating system is Win9x
** or WinNT.
**
** 0:   Operating system unknown.
** 1:   Operating system is Win9x.
** 2:   Operating system is WinNT.
**
** In order to facilitate testing on a WinNT system, the test fixture
** can manually set this value to 1 to emulate Win98 behavior.
*/
#ifdef SQLITE_TEST
LONG SQLITE_WIN32_VOLATILE sqlite3_os_type = 0;
#else
static LONG SQLITE_WIN32_VOLATILE sqlite3_os_type = 0;
#endif

#ifndef SYSCALL
#  define SYSCALL sqlite3_syscall_ptr
#endif

/*
** This function is not available on Windows CE or WinRT.
 */

#if SQLITE_OS_WINCE || SQLITE_OS_WINRT
#  define osAreFileApisANSI()       1
#endif

/*
** Many system calls are accessed through pointer-to-functions so that
** they may be overridden at runtime to facilitate fault injection during
** testing and sandboxing.  The following array holds the names and pointers
** to all overrideable system calls.
*/
static struct win_syscall {
  const char *zName;            /* Name of the system call */
  sqlite3_syscall_ptr pCurrent; /* Current value of the system call */
  sqlite3_syscall_ptr pDefault; /* Default value */
} aSyscall[] = {
#if !SQLITE_OS_WINCE &amp;&amp; !SQLITE_OS_WINRT
  { "</literal><name>AreFileApisANSI</name><literal type="string">",         (SYSCALL)AreFileApisANSI,         0 },
#else
  { "</literal><name>AreFileApisANSI</name><literal type="string">",         (SYSCALL)0,                       0 },
#endif

#ifndef osAreFileApisANSI
#define osAreFileApisANSI ((BOOL(WINAPI*)(VOID))aSyscall[0].pCurrent)
#endif

#if SQLITE_OS_WINCE &amp;&amp; defined(SQLITE_WIN32_HAS_WIDE)
  { "</literal><name>CharLowerW</name><literal type="string">",              (SYSCALL)CharLowerW,              0 },
#else
  { "</literal><name>CharLowerW</name><literal type="string">",              (SYSCALL)0,                       0 },
#endif

#define osCharLowerW ((LPWSTR(WINAPI*)(LPWSTR))aSyscall[1].pCurrent)

#if SQLITE_OS_WINCE &amp;&amp; defined(SQLITE_WIN32_HAS_WIDE)
  { "</literal><name>CharUpperW</name><literal type="string">",              (SYSCALL)CharUpperW,              0 },
#else
  { "</literal><name>CharUpperW</name><literal type="string">",              (SYSCALL)0,                       0 },
#endif

#define osCharUpperW ((LPWSTR(WINAPI*)(LPWSTR))aSyscall[2].pCurrent)

  { "</literal><name>CloseHandle</name><literal type="string">",             (SYSCALL)CloseHandle,             0 },

#define osCloseHandle ((BOOL(WINAPI*)(HANDLE))aSyscall[3].pCurrent)

#if defined(SQLITE_WIN32_HAS_ANSI)
  { "</literal><name>CreateFileA</name><literal type="string">",             (SYSCALL)CreateFileA,             0 },
#else
  { "</literal><name>CreateFileA</name><literal type="string">",             (SYSCALL)0,                       0 },
#endif

#define osCreateFileA ((HANDLE(WINAPI*)(LPCSTR,DWORD,DWORD, \
        LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE))aSyscall[4].pCurrent)

#if !SQLITE_OS_WINRT &amp;&amp; defined(SQLITE_WIN32_HAS_WIDE)
  { "</literal><name>CreateFileW</name><literal type="string">",             (SYSCALL)CreateFileW,             0 },
#else
  { "</literal><name>CreateFileW</name><literal type="string">",             (SYSCALL)0,                       0 },
#endif

#define osCreateFileW ((HANDLE(WINAPI*)(LPCWSTR,DWORD,DWORD, \
        LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE))aSyscall[5].pCurrent)

#if !SQLITE_OS_WINRT &amp;&amp; defined(SQLITE_WIN32_HAS_ANSI) &amp;&amp; \
        (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE&gt;0) &amp;&amp; \
        SQLITE_WIN32_CREATEFILEMAPPINGA
  { "</literal><name>CreateFileMappingA</name><literal type="string">",      (SYSCALL)CreateFileMappingA,      0 },
#else
  { "</literal><name>CreateFileMappingA</name><literal type="string">",      (SYSCALL)0,                       0 },
#endif

#define osCreateFileMappingA ((HANDLE(WINAPI*)(HANDLE,LPSECURITY_ATTRIBUTES, \
        DWORD,DWORD,DWORD,LPCSTR))aSyscall[6].pCurrent)

#if SQLITE_OS_WINCE || (!SQLITE_OS_WINRT &amp;&amp; defined(SQLITE_WIN32_HAS_WIDE) &amp;&amp; \
        (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE&gt;0))
  { "</literal><name>CreateFileMappingW</name><literal type="string">",      (SYSCALL)CreateFileMappingW,      0 },
#else
  { "</literal><name>CreateFileMappingW</name><literal type="string">",      (SYSCALL)0,                       0 },
#endif

#define osCreateFileMappingW ((HANDLE(WINAPI*)(HANDLE,LPSECURITY_ATTRIBUTES, \
        DWORD,DWORD,DWORD,LPCWSTR))aSyscall[7].pCurrent)

#if !SQLITE_OS_WINRT &amp;&amp; defined(SQLITE_WIN32_HAS_WIDE)
  { "</literal><name>CreateMutexW</name><literal type="string">",            (SYSCALL)CreateMutexW,            0 },
#else
  { "</literal><name>CreateMutexW</name><literal type="string">",            (SYSCALL)0,                       0 },
#endif

#define osCreateMutexW ((HANDLE(WINAPI*)(LPSECURITY_ATTRIBUTES,BOOL, \
        LPCWSTR))aSyscall[8].pCurrent)

#if defined(SQLITE_WIN32_HAS_ANSI)
  { "</literal><name>DeleteFileA</name><literal type="string">",             (SYSCALL)DeleteFileA,             0 },
#else
  { "</literal><name>DeleteFileA</name><literal type="string">",             (SYSCALL)0,                       0 },
#endif

#define osDeleteFileA ((BOOL(WINAPI*)(LPCSTR))aSyscall[9].pCurrent)

#if defined(SQLITE_WIN32_HAS_WIDE)
  { "</literal><name>DeleteFileW</name><literal type="string">",             (SYSCALL)DeleteFileW,             0 },
#else
  { "</literal><name>DeleteFileW</name><literal type="string">",             (SYSCALL)0,                       0 },
#endif

#define osDeleteFileW ((BOOL(WINAPI*)(LPCWSTR))aSyscall[10].pCurrent)

#if SQLITE_OS_WINCE
  { "</literal><name>FileTimeToLocalFileTime</name><literal type="string">", (SYSCALL)FileTimeToLocalFileTime, 0 },
#else
  { "</literal><name>FileTimeToLocalFileTime</name><literal type="string">", (SYSCALL)0,                       0 },
#endif

#define osFileTimeToLocalFileTime ((BOOL(WINAPI*)(CONST FILETIME*, \
        LPFILETIME))aSyscall[11].pCurrent)

#if SQLITE_OS_WINCE
  { "</literal><name>FileTimeToSystemTime</name><literal type="string">",    (SYSCALL)FileTimeToSystemTime,    0 },
#else
  { "</literal><name>FileTimeToSystemTime</name><literal type="string">",    (SYSCALL)0,                       0 },
#endif

#define osFileTimeToSystemTime ((BOOL(WINAPI*)(CONST FILETIME*, \
        LPSYSTEMTIME))aSyscall[12].pCurrent)

  { "</literal><name>FlushFileBuffers</name><literal type="string">",        (SYSCALL)FlushFileBuffers,        0 },

#define osFlushFileBuffers ((BOOL(WINAPI*)(HANDLE))aSyscall[13].pCurrent)

#if defined(SQLITE_WIN32_HAS_ANSI)
  { "</literal><name>FormatMessageA</name><literal type="string">",          (SYSCALL)FormatMessageA,          0 },
#else
  { "</literal><name>FormatMessageA</name><literal type="string">",          (SYSCALL)0,                       0 },
#endif

#define osFormatMessageA ((DWORD(WINAPI*)(DWORD,LPCVOID,DWORD,DWORD,LPSTR, \
        DWORD,va_list*))aSyscall[14].pCurrent)

#if defined(SQLITE_WIN32_HAS_WIDE)
  { "</literal><name>FormatMessageW</name><literal type="string">",          (SYSCALL)FormatMessageW,          0 },
#else
  { "</literal><name>FormatMessageW</name><literal type="string">",          (SYSCALL)0,                       0 },
#endif

#define osFormatMessageW ((DWORD(WINAPI*)(DWORD,LPCVOID,DWORD,DWORD,LPWSTR, \
        DWORD,va_list*))aSyscall[15].pCurrent)

#if !defined(SQLITE_OMIT_LOAD_EXTENSION)
  { "</literal><name>FreeLibrary</name><literal type="string">",             (SYSCALL)FreeLibrary,             0 },
#else
  { "</literal><name>FreeLibrary</name><literal type="string">",             (SYSCALL)0,                       0 },
#endif

#define osFreeLibrary ((BOOL(WINAPI*)(HMODULE))aSyscall[16].pCurrent)

  { "</literal><name>GetCurrentProcessId</name><literal type="string">",     (SYSCALL)GetCurrentProcessId,     0 },

#define osGetCurrentProcessId ((DWORD(WINAPI*)(VOID))aSyscall[17].pCurrent)

#if !SQLITE_OS_WINCE &amp;&amp; defined(SQLITE_WIN32_HAS_ANSI)
  { "</literal><name>GetDiskFreeSpaceA</name><literal type="string">",       (SYSCALL)GetDiskFreeSpaceA,       0 },
#else
  { "</literal><name>GetDiskFreeSpaceA</name><literal type="string">",       (SYSCALL)0,                       0 },
#endif

#define osGetDiskFreeSpaceA ((BOOL(WINAPI*)(LPCSTR,LPDWORD,LPDWORD,LPDWORD, \
        LPDWORD))aSyscall[18].pCurrent)

#if !SQLITE_OS_WINCE &amp;&amp; !SQLITE_OS_WINRT &amp;&amp; defined(SQLITE_WIN32_HAS_WIDE)
  { "</literal><name>GetDiskFreeSpaceW</name><literal type="string">",       (SYSCALL)GetDiskFreeSpaceW,       0 },
#else
  { "</literal><name>GetDiskFreeSpaceW</name><literal type="string">",       (SYSCALL)0,                       0 },
#endif

#define osGetDiskFreeSpaceW ((BOOL(WINAPI*)(LPCWSTR,LPDWORD,LPDWORD,LPDWORD, \
        LPDWORD))aSyscall[19].pCurrent)

#if defined(SQLITE_WIN32_HAS_ANSI)
  { "</literal><name>GetFileAttributesA</name><literal type="string">",      (SYSCALL)GetFileAttributesA,      0 },
#else
  { "</literal><name>GetFileAttributesA</name><literal type="string">",      (SYSCALL)0,                       0 },
#endif

#define osGetFileAttributesA ((DWORD(WINAPI*)(LPCSTR))aSyscall[20].pCurrent)

#if !SQLITE_OS_WINRT &amp;&amp; defined(SQLITE_WIN32_HAS_WIDE)
  { "</literal><name>GetFileAttributesW</name><literal type="string">",      (SYSCALL)GetFileAttributesW,      0 },
#else
  { "</literal><name>GetFileAttributesW</name><literal type="string">",      (SYSCALL)0,                       0 },
#endif

#define osGetFileAttributesW ((DWORD(WINAPI*)(LPCWSTR))aSyscall[21].pCurrent)

#if defined(SQLITE_WIN32_HAS_WIDE)
  { "</literal><name>GetFileAttributesExW</name><literal type="string">",    (SYSCALL)GetFileAttributesExW,    0 },
#else
  { "</literal><name>GetFileAttributesExW</name><literal type="string">",    (SYSCALL)0,                       0 },
#endif

#define osGetFileAttributesExW ((BOOL(WINAPI*)(LPCWSTR,GET_FILEEX_INFO_LEVELS, \
        LPVOID))aSyscall[22].pCurrent)

#if !SQLITE_OS_WINRT
  { "</literal><name>GetFileSize</name><literal type="string">",             (SYSCALL)GetFileSize,             0 },
#else
  { "</literal><name>GetFileSize</name><literal type="string">",             (SYSCALL)0,                       0 },
#endif

#define osGetFileSize ((DWORD(WINAPI*)(HANDLE,LPDWORD))aSyscall[23].pCurrent)

#if !SQLITE_OS_WINCE &amp;&amp; defined(SQLITE_WIN32_HAS_ANSI)
  { "</literal><name>GetFullPathNameA</name><literal type="string">",        (SYSCALL)GetFullPathNameA,        0 },
#else
  { "</literal><name>GetFullPathNameA</name><literal type="string">",        (SYSCALL)0,                       0 },
#endif

#define osGetFullPathNameA ((DWORD(WINAPI*)(LPCSTR,DWORD,LPSTR, \
        LPSTR*))aSyscall[24].pCurrent)

#if !SQLITE_OS_WINCE &amp;&amp; !SQLITE_OS_WINRT &amp;&amp; defined(SQLITE_WIN32_HAS_WIDE)
  { "</literal><name>GetFullPathNameW</name><literal type="string">",        (SYSCALL)GetFullPathNameW,        0 },
#else
  { "</literal><name>GetFullPathNameW</name><literal type="string">",        (SYSCALL)0,                       0 },
#endif

#define osGetFullPathNameW ((DWORD(WINAPI*)(LPCWSTR,DWORD,LPWSTR, \
        LPWSTR*))aSyscall[25].pCurrent)

  { "</literal><name>GetLastError</name><literal type="string">",            (SYSCALL)GetLastError,            0 },

#define osGetLastError ((DWORD(WINAPI*)(VOID))aSyscall[26].pCurrent)

#if !defined(SQLITE_OMIT_LOAD_EXTENSION)
#if SQLITE_OS_WINCE
  /* The GetProcAddressA() routine is only available on Windows CE. */
  { "</literal><name>GetProcAddressA</name><literal type="string">",         (SYSCALL)GetProcAddressA,         0 },
#else
  /* All other Windows platforms expect GetProcAddress() to take
  ** an ANSI string regardless of the _UNICODE setting */
  { "</literal><name>GetProcAddressA</name><literal type="string">",         (SYSCALL)GetProcAddress,          0 },
#endif
#else
  { "</literal><name>GetProcAddressA</name><literal type="string">",         (SYSCALL)0,                       0 },
#endif

#define osGetProcAddressA ((FARPROC(WINAPI*)(HMODULE, \
        LPCSTR))aSyscall[27].pCurrent)

#if !SQLITE_OS_WINRT
  { "</literal><name>GetSystemInfo</name><literal type="string">",           (SYSCALL)GetSystemInfo,           0 },
#else
  { "</literal><name>GetSystemInfo</name><literal type="string">",           (SYSCALL)0,                       0 },
#endif

#define osGetSystemInfo ((VOID(WINAPI*)(LPSYSTEM_INFO))aSyscall[28].pCurrent)

  { "</literal><name>GetSystemTime</name><literal type="string">",           (SYSCALL)GetSystemTime,           0 },

#define osGetSystemTime ((VOID(WINAPI*)(LPSYSTEMTIME))aSyscall[29].pCurrent)

#if !SQLITE_OS_WINCE
  { "</literal><name>GetSystemTimeAsFileTime</name><literal type="string">", (SYSCALL)GetSystemTimeAsFileTime, 0 },
#else
  { "</literal><name>GetSystemTimeAsFileTime</name><literal type="string">", (SYSCALL)0,                       0 },
#endif

#define osGetSystemTimeAsFileTime ((VOID(WINAPI*)( \
        LPFILETIME))aSyscall[30].pCurrent)

#if defined(SQLITE_WIN32_HAS_ANSI)
  { "</literal><name>GetTempPathA</name><literal type="string">",            (SYSCALL)GetTempPathA,            0 },
#else
  { "</literal><name>GetTempPathA</name><literal type="string">",            (SYSCALL)0,                       0 },
#endif

#define osGetTempPathA ((DWORD(WINAPI*)(DWORD,LPSTR))aSyscall[31].pCurrent)

#if !SQLITE_OS_WINRT &amp;&amp; defined(SQLITE_WIN32_HAS_WIDE)
  { "</literal><name>GetTempPathW</name><literal type="string">",            (SYSCALL)GetTempPathW,            0 },
#else
  { "</literal><name>GetTempPathW</name><literal type="string">",            (SYSCALL)0,                       0 },
#endif

#define osGetTempPathW ((DWORD(WINAPI*)(DWORD,LPWSTR))aSyscall[32].pCurrent)

#if !SQLITE_OS_WINRT
  { "</literal><name>GetTickCount</name><literal type="string">",            (SYSCALL)GetTickCount,            0 },
#else
  { "</literal><name>GetTickCount</name><literal type="string">",            (SYSCALL)0,                       0 },
#endif

#define osGetTickCount ((DWORD(WINAPI*)(VOID))aSyscall[33].pCurrent)

#if defined(SQLITE_WIN32_HAS_ANSI) &amp;&amp; SQLITE_WIN32_GETVERSIONEX
  { "</literal><name>GetVersionExA</name><literal type="string">",           (SYSCALL)GetVersionExA,           0 },
#else
  { "</literal><name>GetVersionExA</name><literal type="string">",           (SYSCALL)0,                       0 },
#endif

#define osGetVersionExA ((BOOL(WINAPI*)( \
        LPOSVERSIONINFOA))aSyscall[34].pCurrent)

#if !SQLITE_OS_WINRT &amp;&amp; defined(SQLITE_WIN32_HAS_WIDE) &amp;&amp; \
        SQLITE_WIN32_GETVERSIONEX
  { "</literal><name>GetVersionExW</name><literal type="string">",           (SYSCALL)GetVersionExW,           0 },
#else
  { "</literal><name>GetVersionExW</name><literal type="string">",           (SYSCALL)0,                       0 },
#endif

#define osGetVersionExW ((BOOL(WINAPI*)( \
        LPOSVERSIONINFOW))aSyscall[35].pCurrent)

  { "</literal><name>HeapAlloc</name><literal type="string">",               (SYSCALL)HeapAlloc,               0 },

#define osHeapAlloc ((LPVOID(WINAPI*)(HANDLE,DWORD, \
        SIZE_T))aSyscall[36].pCurrent)

#if !SQLITE_OS_WINRT
  { "</literal><name>HeapCreate</name><literal type="string">",              (SYSCALL)HeapCreate,              0 },
#else
  { "</literal><name>HeapCreate</name><literal type="string">",              (SYSCALL)0,                       0 },
#endif

#define osHeapCreate ((HANDLE(WINAPI*)(DWORD,SIZE_T, \
        SIZE_T))aSyscall[37].pCurrent)

#if !SQLITE_OS_WINRT
  { "</literal><name>HeapDestroy</name><literal type="string">",             (SYSCALL)HeapDestroy,             0 },
#else
  { "</literal><name>HeapDestroy</name><literal type="string">",             (SYSCALL)0,                       0 },
#endif

#define osHeapDestroy ((BOOL(WINAPI*)(HANDLE))aSyscall[38].pCurrent)

  { "</literal><name>HeapFree</name><literal type="string">",                (SYSCALL)HeapFree,                0 },

#define osHeapFree ((BOOL(WINAPI*)(HANDLE,DWORD,LPVOID))aSyscall[39].pCurrent)

  { "</literal><name>HeapReAlloc</name><literal type="string">",             (SYSCALL)HeapReAlloc,             0 },

#define osHeapReAlloc ((LPVOID(WINAPI*)(HANDLE,DWORD,LPVOID, \
        SIZE_T))aSyscall[40].pCurrent)

  { "</literal><name>HeapSize</name><literal type="string">",                (SYSCALL)HeapSize,                0 },

#define osHeapSize ((SIZE_T(WINAPI*)(HANDLE,DWORD, \
        LPCVOID))aSyscall[41].pCurrent)

#if !SQLITE_OS_WINRT
  { "</literal><name>HeapValidate</name><literal type="string">",            (SYSCALL)HeapValidate,            0 },
#else
  { "</literal><name>HeapValidate</name><literal type="string">",            (SYSCALL)0,                       0 },
#endif

#define osHeapValidate ((BOOL(WINAPI*)(HANDLE,DWORD, \
        LPCVOID))aSyscall[42].pCurrent)

#if !SQLITE_OS_WINCE &amp;&amp; !SQLITE_OS_WINRT
  { "</literal><name>HeapCompact</name><literal type="string">",             (SYSCALL)HeapCompact,             0 },
#else
  { "</literal><name>HeapCompact</name><literal type="string">",             (SYSCALL)0,                       0 },
#endif

#define osHeapCompact ((UINT(WINAPI*)(HANDLE,DWORD))aSyscall[43].pCurrent)

#if defined(SQLITE_WIN32_HAS_ANSI) &amp;&amp; !defined(SQLITE_OMIT_LOAD_EXTENSION)
  { "</literal><name>LoadLibraryA</name><literal type="string">",            (SYSCALL)LoadLibraryA,            0 },
#else
  { "</literal><name>LoadLibraryA</name><literal type="string">",            (SYSCALL)0,                       0 },
#endif

#define osLoadLibraryA ((HMODULE(WINAPI*)(LPCSTR))aSyscall[44].pCurrent)

#if !SQLITE_OS_WINRT &amp;&amp; defined(SQLITE_WIN32_HAS_WIDE) &amp;&amp; \
        !defined(SQLITE_OMIT_LOAD_EXTENSION)
  { "</literal><name>LoadLibraryW</name><literal type="string">",            (SYSCALL)LoadLibraryW,            0 },
#else
  { "</literal><name>LoadLibraryW</name><literal type="string">",            (SYSCALL)0,                       0 },
#endif

#define osLoadLibraryW ((HMODULE(WINAPI*)(LPCWSTR))aSyscall[45].pCurrent)

#if !SQLITE_OS_WINRT
  { "</literal><name>LocalFree</name><literal type="string">",               (SYSCALL)LocalFree,               0 },
#else
  { "</literal><name>LocalFree</name><literal type="string">",               (SYSCALL)0,                       0 },
#endif

#define osLocalFree ((HLOCAL(WINAPI*)(HLOCAL))aSyscall[46].pCurrent)

#if !SQLITE_OS_WINCE &amp;&amp; !SQLITE_OS_WINRT
  { "</literal><name>LockFile</name><literal type="string">",                (SYSCALL)LockFile,                0 },
#else
  { "</literal><name>LockFile</name><literal type="string">",                (SYSCALL)0,                       0 },
#endif

#ifndef osLockFile
#define osLockFile ((BOOL(WINAPI*)(HANDLE,DWORD,DWORD,DWORD, \
        DWORD))aSyscall[47].pCurrent)
#endif

#if !SQLITE_OS_WINCE
  { "</literal><name>LockFileEx</name><literal type="string">",              (SYSCALL)LockFileEx,              0 },
#else
  { "</literal><name>LockFileEx</name><literal type="string">",              (SYSCALL)0,                       0 },
#endif

#ifndef osLockFileEx
#define osLockFileEx ((BOOL(WINAPI*)(HANDLE,DWORD,DWORD,DWORD,DWORD, \
        LPOVERLAPPED))aSyscall[48].pCurrent)
#endif

#if SQLITE_OS_WINCE || (!SQLITE_OS_WINRT &amp;&amp; \
        (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE&gt;0))
  { "</literal><name>MapViewOfFile</name><literal type="string">",           (SYSCALL)MapViewOfFile,           0 },
#else
  { "</literal><name>MapViewOfFile</name><literal type="string">",           (SYSCALL)0,                       0 },
#endif

#define osMapViewOfFile ((LPVOID(WINAPI*)(HANDLE,DWORD,DWORD,DWORD, \
        SIZE_T))aSyscall[49].pCurrent)

  { "</literal><name>MultiByteToWideChar</name><literal type="string">",     (SYSCALL)MultiByteToWideChar,     0 },

#define osMultiByteToWideChar ((int(WINAPI*)(UINT,DWORD,LPCSTR,int,LPWSTR, \
        int))aSyscall[50].pCurrent)

  { "</literal><name>QueryPerformanceCounter</name><literal type="string">", (SYSCALL)QueryPerformanceCounter, 0 },

#define osQueryPerformanceCounter ((BOOL(WINAPI*)( \
        LARGE_INTEGER*))aSyscall[51].pCurrent)

  { "</literal><name>ReadFile</name><literal type="string">",                (SYSCALL)ReadFile,                0 },

#define osReadFile ((BOOL(WINAPI*)(HANDLE,LPVOID,DWORD,LPDWORD, \
        LPOVERLAPPED))aSyscall[52].pCurrent)

  { "</literal><name>SetEndOfFile</name><literal type="string">",            (SYSCALL)SetEndOfFile,            0 },

#define osSetEndOfFile ((BOOL(WINAPI*)(HANDLE))aSyscall[53].pCurrent)

#if !SQLITE_OS_WINRT
  { "</literal><name>SetFilePointer</name><literal type="string">",          (SYSCALL)SetFilePointer,          0 },
#else
  { "</literal><name>SetFilePointer</name><literal type="string">",          (SYSCALL)0,                       0 },
#endif

#define osSetFilePointer ((DWORD(WINAPI*)(HANDLE,LONG,PLONG, \
        DWORD))aSyscall[54].pCurrent)

#if !SQLITE_OS_WINRT
  { "</literal><name>Sleep</name><literal type="string">",                   (SYSCALL)Sleep,                   0 },
#else
  { "</literal><name>Sleep</name><literal type="string">",                   (SYSCALL)0,                       0 },
#endif

#define osSleep ((VOID(WINAPI*)(DWORD))aSyscall[55].pCurrent)

  { "</literal><name>SystemTimeToFileTime</name><literal type="string">",    (SYSCALL)SystemTimeToFileTime,    0 },

#define osSystemTimeToFileTime ((BOOL(WINAPI*)(CONST SYSTEMTIME*, \
        LPFILETIME))aSyscall[56].pCurrent)

#if !SQLITE_OS_WINCE &amp;&amp; !SQLITE_OS_WINRT
  { "</literal><name>UnlockFile</name><literal type="string">",              (SYSCALL)UnlockFile,              0 },
#else
  { "</literal><name>UnlockFile</name><literal type="string">",              (SYSCALL)0,                       0 },
#endif

#ifndef osUnlockFile
#define osUnlockFile ((BOOL(WINAPI*)(HANDLE,DWORD,DWORD,DWORD, \
        DWORD))aSyscall[57].pCurrent)
#endif

#if !SQLITE_OS_WINCE
  { "</literal><name>UnlockFileEx</name><literal type="string">",            (SYSCALL)UnlockFileEx,            0 },
#else
  { "</literal><name>UnlockFileEx</name><literal type="string">",            (SYSCALL)0,                       0 },
#endif

#define osUnlockFileEx ((BOOL(WINAPI*)(HANDLE,DWORD,DWORD,DWORD, \
        LPOVERLAPPED))aSyscall[58].pCurrent)

#if SQLITE_OS_WINCE || !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE&gt;0
  { "</literal><name>UnmapViewOfFile</name><literal type="string">",         (SYSCALL)UnmapViewOfFile,         0 },
#else
  { "</literal><name>UnmapViewOfFile</name><literal type="string">",         (SYSCALL)0,                       0 },
#endif

#define osUnmapViewOfFile ((BOOL(WINAPI*)(LPCVOID))aSyscall[59].pCurrent)

  { "</literal><name>WideCharToMultiByte</name><literal type="string">",     (SYSCALL)WideCharToMultiByte,     0 },

#define osWideCharToMultiByte ((int(WINAPI*)(UINT,DWORD,LPCWSTR,int,LPSTR,int, \
        LPCSTR,LPBOOL))aSyscall[60].pCurrent)

  { "</literal><name>WriteFile</name><literal type="string">",               (SYSCALL)WriteFile,               0 },

#define osWriteFile ((BOOL(WINAPI*)(HANDLE,LPCVOID,DWORD,LPDWORD, \
        LPOVERLAPPED))aSyscall[61].pCurrent)

#if SQLITE_OS_WINRT
  { "</literal><name>CreateEventExW</name><literal type="string">",          (SYSCALL)CreateEventExW,          0 },
#else
  { "</literal><name>CreateEventExW</name><literal type="string">",          (SYSCALL)0,                       0 },
#endif

#define osCreateEventExW ((HANDLE(WINAPI*)(LPSECURITY_ATTRIBUTES,LPCWSTR, \
        DWORD,DWORD))aSyscall[62].pCurrent)

#if !SQLITE_OS_WINRT
  { "</literal><name>WaitForSingleObject</name><literal type="string">",     (SYSCALL)WaitForSingleObject,     0 },
#else
  { "</literal><name>WaitForSingleObject</name><literal type="string">",     (SYSCALL)0,                       0 },
#endif

#define osWaitForSingleObject ((DWORD(WINAPI*)(HANDLE, \
        DWORD))aSyscall[63].pCurrent)

#if !SQLITE_OS_WINCE
  { "</literal><name>WaitForSingleObjectEx</name><literal type="string">",   (SYSCALL)WaitForSingleObjectEx,   0 },
#else
  { "</literal><name>WaitForSingleObjectEx</name><literal type="string">",   (SYSCALL)0,                       0 },
#endif

#define osWaitForSingleObjectEx ((DWORD(WINAPI*)(HANDLE,DWORD, \
        BOOL))aSyscall[64].pCurrent)

#if SQLITE_OS_WINRT
  { "</literal><name>SetFilePointerEx</name><literal type="string">",        (SYSCALL)SetFilePointerEx,        0 },
#else
  { "</literal><name>SetFilePointerEx</name><literal type="string">",        (SYSCALL)0,                       0 },
#endif

#define osSetFilePointerEx ((BOOL(WINAPI*)(HANDLE,LARGE_INTEGER, \
        PLARGE_INTEGER,DWORD))aSyscall[65].pCurrent)

#if SQLITE_OS_WINRT
  { "</literal><name>GetFileInformationByHandleEx</name><literal type="string">", (SYSCALL)GetFileInformationByHandleEx, 0 },
#else
  { "</literal><name>GetFileInformationByHandleEx</name><literal type="string">", (SYSCALL)0,                  0 },
#endif

#define osGetFileInformationByHandleEx ((BOOL(WINAPI*)(HANDLE, \
        FILE_INFO_BY_HANDLE_CLASS,LPVOID,DWORD))aSyscall[66].pCurrent)

#if SQLITE_OS_WINRT &amp;&amp; (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE&gt;0)
  { "</literal><name>MapViewOfFileFromApp</name><literal type="string">",    (SYSCALL)MapViewOfFileFromApp,    0 },
#else
  { "</literal><name>MapViewOfFileFromApp</name><literal type="string">",    (SYSCALL)0,                       0 },
#endif

#define osMapViewOfFileFromApp ((LPVOID(WINAPI*)(HANDLE,ULONG,ULONG64, \
        SIZE_T))aSyscall[67].pCurrent)

#if SQLITE_OS_WINRT
  { "</literal><name>CreateFile2</name><literal type="string">",             (SYSCALL)CreateFile2,             0 },
#else
  { "</literal><name>CreateFile2</name><literal type="string">",             (SYSCALL)0,                       0 },
#endif

#define osCreateFile2 ((HANDLE(WINAPI*)(LPCWSTR,DWORD,DWORD,DWORD, \
        LPCREATEFILE2_EXTENDED_PARAMETERS))aSyscall[68].pCurrent)

#if SQLITE_OS_WINRT &amp;&amp; !defined(SQLITE_OMIT_LOAD_EXTENSION)
  { "</literal><name>LoadPackagedLibrary</name><literal type="string">",     (SYSCALL)LoadPackagedLibrary,     0 },
#else
  { "</literal><name>LoadPackagedLibrary</name><literal type="string">",     (SYSCALL)0,                       0 },
#endif

#define osLoadPackagedLibrary ((HMODULE(WINAPI*)(LPCWSTR, \
        DWORD))aSyscall[69].pCurrent)

#if SQLITE_OS_WINRT
  { "</literal><name>GetTickCount64</name><literal type="string">",          (SYSCALL)GetTickCount64,          0 },
#else
  { "</literal><name>GetTickCount64</name><literal type="string">",          (SYSCALL)0,                       0 },
#endif

#define osGetTickCount64 ((ULONGLONG(WINAPI*)(VOID))aSyscall[70].pCurrent)

#if SQLITE_OS_WINRT
  { "</literal><name>GetNativeSystemInfo</name><literal type="string">",     (SYSCALL)GetNativeSystemInfo,     0 },
#else
  { "</literal><name>GetNativeSystemInfo</name><literal type="string">",     (SYSCALL)0,                       0 },
#endif

#define osGetNativeSystemInfo ((VOID(WINAPI*)( \
        LPSYSTEM_INFO))aSyscall[71].pCurrent)

#if defined(SQLITE_WIN32_HAS_ANSI)
  { "</literal><name>OutputDebugStringA</name><literal type="string">",      (SYSCALL)OutputDebugStringA,      0 },
#else
  { "</literal><name>OutputDebugStringA</name><literal type="string">",      (SYSCALL)0,                       0 },
#endif

#define osOutputDebugStringA ((VOID(WINAPI*)(LPCSTR))aSyscall[72].pCurrent)

#if defined(SQLITE_WIN32_HAS_WIDE)
  { "</literal><name>OutputDebugStringW</name><literal type="string">",      (SYSCALL)OutputDebugStringW,      0 },
#else
  { "</literal><name>OutputDebugStringW</name><literal type="string">",      (SYSCALL)0,                       0 },
#endif

#define osOutputDebugStringW ((VOID(WINAPI*)(LPCWSTR))aSyscall[73].pCurrent)

  { "</literal><name>GetProcessHeap</name><literal type="string">",          (SYSCALL)GetProcessHeap,          0 },

#define osGetProcessHeap ((HANDLE(WINAPI*)(VOID))aSyscall[74].pCurrent)

#if SQLITE_OS_WINRT &amp;&amp; (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE&gt;0)
  { "</literal><name>CreateFileMappingFromApp</name><literal type="string">", (SYSCALL)CreateFileMappingFromApp, 0 },
#else
  { "</literal><name>CreateFileMappingFromApp</name><literal type="string">", (SYSCALL)0,                      0 },
#endif

#define osCreateFileMappingFromApp ((HANDLE(WINAPI*)(HANDLE, \
        LPSECURITY_ATTRIBUTES,ULONG,ULONG64,LPCWSTR))aSyscall[75].pCurrent)

/*
** NOTE: On some sub-platforms, the InterlockedCompareExchange "</literal><name>function</name><literal type="string">"
**       is really just a macro that uses a compiler intrinsic (e.g. x64).
**       So do not try to make this is into a redefinable interface.
*/
#if defined(InterlockedCompareExchange)
  { "</literal><name>InterlockedCompareExchange</name><literal type="string">", (SYSCALL)0,                    0 },

#define osInterlockedCompareExchange InterlockedCompareExchange
#else
  { "</literal><name>InterlockedCompareExchange</name><literal type="string">", (SYSCALL)InterlockedCompareExchange, 0 },

#define osInterlockedCompareExchange ((LONG(WINAPI*)(LONG \
        SQLITE_WIN32_VOLATILE*, LONG,LONG))aSyscall[76].pCurrent)
#endif /* defined(InterlockedCompareExchange) */

#if !SQLITE_OS_WINCE &amp;&amp; !SQLITE_OS_WINRT &amp;&amp; SQLITE_WIN32_USE_UUID
  { "</literal><name>UuidCreate</name><literal type="string">",               (SYSCALL)UuidCreate,             0 },
#else
  { "</literal><name>UuidCreate</name><literal type="string">",               (SYSCALL)0,                      0 },
#endif

#define osUuidCreate ((RPC_STATUS(RPC_ENTRY*)(UUID*))aSyscall[77].pCurrent)

#if !SQLITE_OS_WINCE &amp;&amp; !SQLITE_OS_WINRT &amp;&amp; SQLITE_WIN32_USE_UUID
  { "</literal><name>UuidCreateSequential</name><literal type="string">",     (SYSCALL)UuidCreateSequential,   0 },
#else
  { "</literal><name>UuidCreateSequential</name><literal type="string">",     (SYSCALL)0,                      0 },
#endif

#define osUuidCreateSequential \
        ((RPC_STATUS(RPC_ENTRY*)(UUID*))aSyscall[78].pCurrent)

#if !defined(SQLITE_NO_SYNC) &amp;&amp; SQLITE_MAX_MMAP_SIZE&gt;0
  { "</literal><name>FlushViewOfFile</name><literal type="string">",          (SYSCALL)FlushViewOfFile,        0 },
#else
  { "</literal><name>FlushViewOfFile</name><literal type="string">",          (SYSCALL)0,                      0 },
#endif

#define osFlushViewOfFile \
        ((BOOL(WINAPI*)(LPCVOID,SIZE_T))aSyscall[79].pCurrent)

}; /* End of the overrideable system calls */

/*
** This is the xSetSystemCall() method of sqlite3_vfs for all of the
** "</literal><name>win32</name><literal type="string">" VFSes.  Return SQLITE_OK opon successfully updating the
** system call pointer, or SQLITE_NOTFOUND if there is no configurable
** system call named zName.
*/
static int winSetSystemCall(
  sqlite3_vfs *pNotUsed,        /* The VFS pointer.  Not used */
  const char *zName,            /* Name of system call to override */
  sqlite3_syscall_ptr pNewFunc  /* Pointer to new system call value */
){
  unsigned int i;
  int rc = SQLITE_NOTFOUND;

  UNUSED_PARAMETER(pNotUsed);
  if( zName==0 ){
    /* If no zName is given, restore all system calls to their default
    ** settings and return NULL
    */
    rc = SQLITE_OK;
    for(i=0; i&lt;sizeof(aSyscall)/sizeof(aSyscall[0]); i++){
      if( aSyscall[i].pDefault ){
        aSyscall[i].pCurrent = aSyscall[i].pDefault;
      }
    }
  }else{
    /* If zName is specified, operate on only the one system call
    ** specified.
    */
    for(i=0; i&lt;sizeof(aSyscall)/sizeof(aSyscall[0]); i++){
      if( strcmp(zName, aSyscall[i].zName)==0 ){
        if( aSyscall[i].pDefault==0 ){
          aSyscall[i].pDefault = aSyscall[i].pCurrent;
        }
        rc = SQLITE_OK;
        if( pNewFunc==0 ) pNewFunc = aSyscall[i].pDefault;
        aSyscall[i].pCurrent = pNewFunc;
        break;
      }
    }
  }
  return rc;
}

/*
** Return the value of a system call.  Return NULL if zName is not a
** recognized system call name.  NULL is also returned if the system call
** is currently undefined.
*/
static sqlite3_syscall_ptr winGetSystemCall(
  sqlite3_vfs *pNotUsed,
  const char *zName
){
  unsigned int i;

  UNUSED_PARAMETER(pNotUsed);
  for(i=0; i&lt;sizeof(aSyscall)/sizeof(aSyscall[0]); i++){
    if( strcmp(zName, aSyscall[i].zName)==0 ) return aSyscall[i].pCurrent;
  }
  return 0;
}

/*
** Return the name of the first system call after zName.  If zName==NULL
** then return the name of the first system call.  Return NULL if zName
** is the last system call or if zName is not the name of a valid
** system call.
*/
static const char *winNextSystemCall(sqlite3_vfs *p, const char *zName){
  int i = -1;

  UNUSED_PARAMETER(p);
  if( zName ){
    for(i=0; i&lt;ArraySize(aSyscall)-1; i++){
      if( strcmp(zName, aSyscall[i].zName)==0 ) break;
    }
  }
  for(i++; i&lt;ArraySize(aSyscall); i++){
    if( aSyscall[i].pCurrent!=0 ) return aSyscall[i].zName;
  }
  return 0;
}

#ifdef SQLITE_WIN32_MALLOC
/*
** If a Win32 native heap has been configured, this function will attempt to
** compact it.  Upon success, SQLITE_OK will be returned.  Upon failure, one
** of SQLITE_NOMEM, SQLITE_ERROR, or SQLITE_NOTFOUND will be returned.  The
** "</literal><name>pnLargest</name><literal type="string">" argument, if non-zero, will be used to return the size of the
** largest committed free block in the heap, in bytes.
*/
int sqlite3_win32_compact_heap(LPUINT pnLargest){
  int rc = SQLITE_OK;
  UINT nLargest = 0;
  HANDLE hHeap;

  winMemAssertMagic();
  hHeap = winMemGetHeap();
  assert( hHeap!=0 );
  assert( hHeap!=INVALID_HANDLE_VALUE );
#if !SQLITE_OS_WINRT &amp;&amp; defined(SQLITE_WIN32_MALLOC_VALIDATE)
  assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) );
#endif
#if !SQLITE_OS_WINCE &amp;&amp; !SQLITE_OS_WINRT
  if( (nLargest=osHeapCompact(hHeap, SQLITE_WIN32_HEAP_FLAGS))==0 ){
    DWORD lastErrno = osGetLastError();
    if( lastErrno==NO_ERROR ){
      sqlite3_log(SQLITE_NOMEM, "</literal><name>failed</name> <name>to</name> <macro><name>HeapCompact</name> <argument_list>(<argument>no space</argument>)</argument_list></macro></expr><operator>,</operator> <expr><name>heap</name><operator>=</operator><operator>%</operator><name>p</name><literal type="string">",
                  (void*)hHeap);
      rc = SQLITE_NOMEM;
    }else{
      sqlite3_log(SQLITE_ERROR, "</literal><name>failed</name> <name>to</name> <call><name>HeapCompact</name> <argument_list>(<argument><expr><operator>%</operator><name>lu</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>heap</name><operator>=</operator><operator>%</operator><name>p</name><literal type="string">",
                  osGetLastError(), (void*)hHeap);
      rc = SQLITE_ERROR;
    }
  }
#else
  sqlite3_log(SQLITE_NOTFOUND, "</literal><name>failed</name> <name>to</name> <name>HeapCompact</name></expr><operator>,</operator> <expr><name>heap</name><operator>=</operator><operator>%</operator><name>p</name><literal type="string">",
              (void*)hHeap);
  rc = SQLITE_NOTFOUND;
#endif
  if( pnLargest ) *pnLargest = nLargest;
  return rc;
}

/*
** If a Win32 native heap has been configured, this function will attempt to
** destroy and recreate it.  If the Win32 native heap is not isolated and/or
** the sqlite3_memory_used() function does not return zero, SQLITE_BUSY will
** be returned and no changes will be made to the Win32 native heap.
*/
int sqlite3_win32_reset_heap(){
  int rc;
  MUTEX_LOGIC( sqlite3_mutex *pMaster; ) /* The main static mutex */
  MUTEX_LOGIC( sqlite3_mutex *pMem; )    /* The memsys static mutex */
  MUTEX_LOGIC( pMaster = sqlite3_mutex_alloc(SQLITE_MUTEX_STATIC_MASTER); )
  MUTEX_LOGIC( pMem = sqlite3_mutex_alloc(SQLITE_MUTEX_STATIC_MEM); )
  sqlite3_mutex_enter(pMaster);
  sqlite3_mutex_enter(pMem);
  winMemAssertMagic();
  if( winMemGetHeap()!=NULL &amp;&amp; winMemGetOwned() &amp;&amp; sqlite3_memory_used()==0 ){
    /*
    ** At this point, there should be no outstanding memory allocations on
    ** the heap.  Also, since both the master and memsys locks are currently
    ** being held by us, no other function (i.e. from another thread) should
    ** be able to even access the heap.  Attempt to destroy and recreate our
    ** isolated Win32 native heap now.
    */
    assert( winMemGetHeap()!=NULL );
    assert( winMemGetOwned() );
    assert( sqlite3_memory_used()==0 );
    winMemShutdown(winMemGetDataPtr());
    assert( winMemGetHeap()==NULL );
    assert( !winMemGetOwned() );
    assert( sqlite3_memory_used()==0 );
    rc = winMemInit(winMemGetDataPtr());
    assert( rc!=SQLITE_OK || winMemGetHeap()!=NULL );
    assert( rc!=SQLITE_OK || winMemGetOwned() );
    assert( rc!=SQLITE_OK || sqlite3_memory_used()==0 );
  }else{
    /*
    ** The Win32 native heap cannot be modified because it may be in use.
    */
    rc = SQLITE_BUSY;
  }
  sqlite3_mutex_leave(pMem);
  sqlite3_mutex_leave(pMaster);
  return rc;
}
#endif /* SQLITE_WIN32_MALLOC */

/*
** This function outputs the specified (ANSI) string to the Win32 debugger
** (if available).
*/

void sqlite3_win32_write_debug(const char *zBuf, int nBuf){
  char zDbgBuf[SQLITE_WIN32_DBG_BUF_SIZE];
  int nMin = MIN(nBuf, (SQLITE_WIN32_DBG_BUF_SIZE - 1)); /* may be negative. */
  if( nMin&lt;-1 ) nMin = -1; /* all negative values become -1. */
  assert( nMin==-1 || nMin==0 || nMin&lt;SQLITE_WIN32_DBG_BUF_SIZE );
#if defined(SQLITE_WIN32_HAS_ANSI)
  if( nMin&gt;0 ){
    memset(zDbgBuf, 0, SQLITE_WIN32_DBG_BUF_SIZE);
    memcpy(zDbgBuf, zBuf, nMin);
    osOutputDebugStringA(zDbgBuf);
  }else{
    osOutputDebugStringA(zBuf);
  }
#elif defined(SQLITE_WIN32_HAS_WIDE)
  memset(zDbgBuf, 0, SQLITE_WIN32_DBG_BUF_SIZE);
  if ( osMultiByteToWideChar(
          osAreFileApisANSI() ? CP_ACP : CP_OEMCP, 0, zBuf,
          nMin, (LPWSTR)zDbgBuf, SQLITE_WIN32_DBG_BUF_SIZE/sizeof(WCHAR))&lt;=0 ){
    return;
  }
  osOutputDebugStringW((LPCWSTR)zDbgBuf);
#else
  if( nMin&gt;0 ){
    memset(zDbgBuf, 0, SQLITE_WIN32_DBG_BUF_SIZE);
    memcpy(zDbgBuf, zBuf, nMin);
    fprintf(stderr, "</literal><operator>%</operator><name>s</name><literal type="string">", zDbgBuf);
  }else{
    fprintf(stderr, "</literal><operator>%</operator><name>s</name><literal type="string">", zBuf);
  }
#endif
}

/*
** The following routine suspends the current thread for at least ms
** milliseconds.  This is equivalent to the Win32 Sleep() interface.
*/
#if SQLITE_OS_WINRT
static HANDLE sleepObj = NULL;
#endif

void sqlite3_win32_sleep(DWORD milliseconds){
#if SQLITE_OS_WINRT
  if ( sleepObj==NULL ){
    sleepObj = osCreateEventExW(NULL, NULL, CREATE_EVENT_MANUAL_RESET,
                                SYNCHRONIZE);
  }
  assert( sleepObj!=NULL );
  osWaitForSingleObjectEx(sleepObj, milliseconds, FALSE);
#else
  osSleep(milliseconds);
#endif
}

#if SQLITE_MAX_WORKER_THREADS&gt;0 &amp;&amp; !SQLITE_OS_WINCE &amp;&amp; !SQLITE_OS_WINRT &amp;&amp; \
        SQLITE_THREADSAFE&gt;0
DWORD sqlite3Win32Wait(HANDLE hObject){
  DWORD rc;
  while( (rc = osWaitForSingleObjectEx(hObject, INFINITE,
                                       TRUE))==WAIT_IO_COMPLETION ){}
  return rc;
}
#endif

/*
** Return true (non-zero) if we are running under WinNT, Win2K, WinXP,
** or WinCE.  Return false (zero) for Win95, Win98, or WinME.
**
** Here is an interesting observation:  Win95, Win98, and WinME lack
** the LockFileEx() API.  But we can still statically link against that
** API as long as we don't call it when running Win95/98/ME.  A call to
** this routine is used to determine if the host is Win95/98/ME or
** WinNT/2K/XP so that we will know whether or not we can safely call
** the LockFileEx() API.
*/

#if !SQLITE_WIN32_GETVERSIONEX
# define osIsNT()  (1)
#elif SQLITE_OS_WINCE || SQLITE_OS_WINRT || !defined(SQLITE_WIN32_HAS_ANSI)
# define osIsNT()  (1)
#elif !defined(SQLITE_WIN32_HAS_WIDE)
# define osIsNT()  (0)
#else
# define osIsNT()  ((sqlite3_os_type==2) || sqlite3_win32_is_nt())
#endif

/*
** This function determines if the machine is running a version of Windows
** based on the NT kernel.
*/
int sqlite3_win32_is_nt(void){
#if SQLITE_OS_WINRT
  /*
  ** NOTE: The WinRT sub-platform is always assumed to be based on the NT
  **       kernel.
  */
  return 1;
#elif SQLITE_WIN32_GETVERSIONEX
  if( osInterlockedCompareExchange(&amp;sqlite3_os_type, 0, 0)==0 ){
#if defined(SQLITE_WIN32_HAS_ANSI)
    OSVERSIONINFOA sInfo;
    sInfo.dwOSVersionInfoSize = sizeof(sInfo);
    osGetVersionExA(&amp;sInfo);
    osInterlockedCompareExchange(&amp;sqlite3_os_type,
        (sInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) ? 2 : 1, 0);
#elif defined(SQLITE_WIN32_HAS_WIDE)
    OSVERSIONINFOW sInfo;
    sInfo.dwOSVersionInfoSize = sizeof(sInfo);
    osGetVersionExW(&amp;sInfo);
    osInterlockedCompareExchange(&amp;sqlite3_os_type,
        (sInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) ? 2 : 1, 0);
#endif
  }
  return osInterlockedCompareExchange(&amp;sqlite3_os_type, 2, 2)==2;
#elif SQLITE_TEST
  return osInterlockedCompareExchange(&amp;sqlite3_os_type, 2, 2)==2;
#else
  /*
  ** NOTE: All sub-platforms where the GetVersionEx[AW] functions are
  **       deprecated are always assumed to be based on the NT kernel.
  */
  return 1;
#endif
}

#ifdef SQLITE_WIN32_MALLOC
/*
** Allocate nBytes of memory.
*/
static void *winMemMalloc(int nBytes){
  HANDLE hHeap;
  void *p;

  winMemAssertMagic();
  hHeap = winMemGetHeap();
  assert( hHeap!=0 );
  assert( hHeap!=INVALID_HANDLE_VALUE );
#if !SQLITE_OS_WINRT &amp;&amp; defined(SQLITE_WIN32_MALLOC_VALIDATE)
  assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) );
#endif
  assert( nBytes&gt;=0 );
  p = osHeapAlloc(hHeap, SQLITE_WIN32_HEAP_FLAGS, (SIZE_T)nBytes);
  if( !p ){
    sqlite3_log(SQLITE_NOMEM, "</literal><name>failed</name> <name>to</name> <name>HeapAlloc</name> <operator>%</operator><name>u</name> <call><name>bytes</name> <argument_list>(<argument><expr><operator>%</operator><name>lu</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>heap</name><operator>=</operator><operator>%</operator><name>p</name><literal type="string">",
                nBytes, osGetLastError(), (void*)hHeap);
  }
  return p;
}

/*
** Free memory.
*/
static void winMemFree(void *pPrior){
  HANDLE hHeap;

  winMemAssertMagic();
  hHeap = winMemGetHeap();
  assert( hHeap!=0 );
  assert( hHeap!=INVALID_HANDLE_VALUE );
#if !SQLITE_OS_WINRT &amp;&amp; defined(SQLITE_WIN32_MALLOC_VALIDATE)
  assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior) );
#endif
  if( !pPrior ) return; /* Passing NULL to HeapFree is undefined. */
  if( !osHeapFree(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior) ){
    sqlite3_log(SQLITE_NOMEM, "</literal><name>failed</name> <name>to</name> <name>HeapFree</name> <name>block</name> <operator>%</operator><call><name>p</name> <argument_list>(<argument><expr><operator>%</operator><name>lu</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>heap</name><operator>=</operator><operator>%</operator><name>p</name><literal type="string">",
                pPrior, osGetLastError(), (void*)hHeap);
  }
}

/*
** Change the size of an existing memory allocation
*/
static void *winMemRealloc(void *pPrior, int nBytes){
  HANDLE hHeap;
  void *p;

  winMemAssertMagic();
  hHeap = winMemGetHeap();
  assert( hHeap!=0 );
  assert( hHeap!=INVALID_HANDLE_VALUE );
#if !SQLITE_OS_WINRT &amp;&amp; defined(SQLITE_WIN32_MALLOC_VALIDATE)
  assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior) );
#endif
  assert( nBytes&gt;=0 );
  if( !pPrior ){
    p = osHeapAlloc(hHeap, SQLITE_WIN32_HEAP_FLAGS, (SIZE_T)nBytes);
  }else{
    p = osHeapReAlloc(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior, (SIZE_T)nBytes);
  }
  if( !p ){
    sqlite3_log(SQLITE_NOMEM, "</literal><name>failed</name> <name>to</name> <operator>%</operator><name>s</name> <operator>%</operator><name>u</name> <call><name>bytes</name> <argument_list>(<argument><expr><operator>%</operator><name>lu</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>heap</name><operator>=</operator><operator>%</operator><name>p</name><literal type="string">",
                pPrior ? "</literal><name>HeapReAlloc</name><literal type="string">" : "</literal><name>HeapAlloc</name><literal type="string">", nBytes, osGetLastError(),
                (void*)hHeap);
  }
  return p;
}

/*
** Return the size of an outstanding allocation, in bytes.
*/
static int winMemSize(void *p){
  HANDLE hHeap;
  SIZE_T n;

  winMemAssertMagic();
  hHeap = winMemGetHeap();
  assert( hHeap!=0 );
  assert( hHeap!=INVALID_HANDLE_VALUE );
#if !SQLITE_OS_WINRT &amp;&amp; defined(SQLITE_WIN32_MALLOC_VALIDATE)
  assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, p) );
#endif
  if( !p ) return 0;
  n = osHeapSize(hHeap, SQLITE_WIN32_HEAP_FLAGS, p);
  if( n==(SIZE_T)-1 ){
    sqlite3_log(SQLITE_NOMEM, "</literal><name>failed</name> <name>to</name> <name>HeapSize</name> <name>block</name> <operator>%</operator><call><name>p</name> <argument_list>(<argument><expr><operator>%</operator><name>lu</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>heap</name><operator>=</operator><operator>%</operator><name>p</name><literal type="string">",
                p, osGetLastError(), (void*)hHeap);
    return 0;
  }
  return (int)n;
}

/*
** Round up a request size to the next valid allocation size.
*/
static int winMemRoundup(int n){
  return n;
}

/*
** Initialize this module.
*/
static int winMemInit(void *pAppData){
  winMemData *pWinMemData = (winMemData *)pAppData;

  if( !pWinMemData ) return SQLITE_ERROR;
  assert( pWinMemData-&gt;magic1==WINMEM_MAGIC1 );
  assert( pWinMemData-&gt;magic2==WINMEM_MAGIC2 );

#if !SQLITE_OS_WINRT &amp;&amp; SQLITE_WIN32_HEAP_CREATE
  if( !pWinMemData-&gt;hHeap ){
    DWORD dwInitialSize = SQLITE_WIN32_HEAP_INIT_SIZE;
    DWORD dwMaximumSize = (DWORD)sqlite3GlobalConfig.nHeap;
    if( dwMaximumSize==0 ){
      dwMaximumSize = SQLITE_WIN32_HEAP_MAX_SIZE;
    }else if( dwInitialSize&gt;dwMaximumSize ){
      dwInitialSize = dwMaximumSize;
    }
    pWinMemData-&gt;hHeap = osHeapCreate(SQLITE_WIN32_HEAP_FLAGS,
                                      dwInitialSize, dwMaximumSize);
    if( !pWinMemData-&gt;hHeap ){
      sqlite3_log(SQLITE_NOMEM,
          "</literal><name>failed</name> <name>to</name> <call><name>HeapCreate</name> <argument_list>(<argument><expr><operator>%</operator><name>lu</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>flags</name><operator>=</operator><operator>%</operator><name>u</name></expr><operator>,</operator> <expr><name>initSize</name><operator>=</operator><operator>%</operator><name>lu</name></expr><operator>,</operator> <expr><name>maxSize</name><operator>=</operator><operator>%</operator><name>lu</name><literal type="string">",
          osGetLastError(), SQLITE_WIN32_HEAP_FLAGS, dwInitialSize,
          dwMaximumSize);
      return SQLITE_NOMEM;
    }
    pWinMemData-&gt;bOwned = TRUE;
    assert( pWinMemData-&gt;bOwned );
  }
#else
  pWinMemData-&gt;hHeap = osGetProcessHeap();
  if( !pWinMemData-&gt;hHeap ){
    sqlite3_log(SQLITE_NOMEM,
        "</literal><name>failed</name> <name>to</name> <call><name>GetProcessHeap</name> <argument_list>(<argument><expr><operator>%</operator><name>lu</name></expr></argument>)</argument_list></call><literal type="string">", osGetLastError());
    return SQLITE_NOMEM;
  }
  pWinMemData-&gt;bOwned = FALSE;
  assert( !pWinMemData-&gt;bOwned );
#endif
  assert( pWinMemData-&gt;hHeap!=0 );
  assert( pWinMemData-&gt;hHeap!=INVALID_HANDLE_VALUE );
#if !SQLITE_OS_WINRT &amp;&amp; defined(SQLITE_WIN32_MALLOC_VALIDATE)
  assert( osHeapValidate(pWinMemData-&gt;hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) );
#endif
  return SQLITE_OK;
}

/*
** Deinitialize this module.
*/
static void winMemShutdown(void *pAppData){
  winMemData *pWinMemData = (winMemData *)pAppData;

  if( !pWinMemData ) return;
  assert( pWinMemData-&gt;magic1==WINMEM_MAGIC1 );
  assert( pWinMemData-&gt;magic2==WINMEM_MAGIC2 );

  if( pWinMemData-&gt;hHeap ){
    assert( pWinMemData-&gt;hHeap!=INVALID_HANDLE_VALUE );
#if !SQLITE_OS_WINRT &amp;&amp; defined(SQLITE_WIN32_MALLOC_VALIDATE)
    assert( osHeapValidate(pWinMemData-&gt;hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) );
#endif
    if( pWinMemData-&gt;bOwned ){
      if( !osHeapDestroy(pWinMemData-&gt;hHeap) ){
        sqlite3_log(SQLITE_NOMEM, "</literal><name>failed</name> <name>to</name> <call><name>HeapDestroy</name> <argument_list>(<argument><expr><operator>%</operator><name>lu</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>heap</name><operator>=</operator><operator>%</operator><name>p</name><literal type="string">",
                    osGetLastError(), (void*)pWinMemData-&gt;hHeap);
      }
      pWinMemData-&gt;bOwned = FALSE;
    }
    pWinMemData-&gt;hHeap = NULL;
  }
}

/*
** Populate the low-level memory allocation function pointers in
** sqlite3GlobalConfig.m with pointers to the routines in this file. The
** arguments specify the block of memory to manage.
**
** This routine is only called by sqlite3_config(), and therefore
** is not required to be threadsafe (it is not).
*/
const sqlite3_mem_methods *sqlite3MemGetWin32(void){
  static const sqlite3_mem_methods winMemMethods = {
    winMemMalloc,
    winMemFree,
    winMemRealloc,
    winMemSize,
    winMemRoundup,
    winMemInit,
    winMemShutdown,
    &amp;win_mem_data
  };
  return &amp;winMemMethods;
}

void sqlite3MemSetDefault(void){
  sqlite3_config(SQLITE_CONFIG_MALLOC, sqlite3MemGetWin32());
}
#endif /* SQLITE_WIN32_MALLOC */

/*
** Convert a UTF-8 string to Microsoft Unicode (UTF-16?).
**
** Space to hold the returned string is obtained from malloc.
*/
static LPWSTR winUtf8ToUnicode(const char *zFilename){
  int nChar;
  LPWSTR zWideFilename;

  nChar = osMultiByteToWideChar(CP_UTF8, 0, zFilename, -1, NULL, 0);
  if( nChar==0 ){
    return 0;
  }
  zWideFilename = sqlite3MallocZero( nChar*sizeof(zWideFilename[0]) );
  if( zWideFilename==0 ){
    return 0;
  }
  nChar = osMultiByteToWideChar(CP_UTF8, 0, zFilename, -1, zWideFilename,
                                nChar);
  if( nChar==0 ){
    sqlite3_free(zWideFilename);
    zWideFilename = 0;
  }
  return zWideFilename;
}

/*
** Convert Microsoft Unicode to UTF-8.  Space to hold the returned string is
** obtained from sqlite3_malloc().
*/
static char *winUnicodeToUtf8(LPCWSTR zWideFilename){
  int nByte;
  char *zFilename;

  nByte = osWideCharToMultiByte(CP_UTF8, 0, zWideFilename, -1, 0, 0, 0, 0);
  if( nByte == 0 ){
    return 0;
  }
  zFilename = sqlite3MallocZero( nByte );
  if( zFilename==0 ){
    return 0;
  }
  nByte = osWideCharToMultiByte(CP_UTF8, 0, zWideFilename, -1, zFilename, nByte,
                                0, 0);
  if( nByte == 0 ){
    sqlite3_free(zFilename);
    zFilename = 0;
  }
  return zFilename;
}

/*
** Convert an ANSI string to Microsoft Unicode, based on the
** current codepage settings for file apis.
**
** Space to hold the returned string is obtained
** from sqlite3_malloc.
*/
static LPWSTR winMbcsToUnicode(const char *zFilename){
  int nByte;
  LPWSTR zMbcsFilename;
  int codepage = osAreFileApisANSI() ? CP_ACP : CP_OEMCP;

  nByte = osMultiByteToWideChar(codepage, 0, zFilename, -1, NULL,
                                0)*sizeof(WCHAR);
  if( nByte==0 ){
    return 0;
  }
  zMbcsFilename = sqlite3MallocZero( nByte*sizeof(zMbcsFilename[0]) );
  if( zMbcsFilename==0 ){
    return 0;
  }
  nByte = osMultiByteToWideChar(codepage, 0, zFilename, -1, zMbcsFilename,
                                nByte);
  if( nByte==0 ){
    sqlite3_free(zMbcsFilename);
    zMbcsFilename = 0;
  }
  return zMbcsFilename;
}

/*
** Convert Microsoft Unicode to multi-byte character string, based on the
** user's ANSI codepage.
**
** Space to hold the returned string is obtained from
** sqlite3_malloc().
*/
static char *winUnicodeToMbcs(LPCWSTR zWideFilename){
  int nByte;
  char *zFilename;
  int codepage = osAreFileApisANSI() ? CP_ACP : CP_OEMCP;

  nByte = osWideCharToMultiByte(codepage, 0, zWideFilename, -1, 0, 0, 0, 0);
  if( nByte == 0 ){
    return 0;
  }
  zFilename = sqlite3MallocZero( nByte );
  if( zFilename==0 ){
    return 0;
  }
  nByte = osWideCharToMultiByte(codepage, 0, zWideFilename, -1, zFilename,
                                nByte, 0, 0);
  if( nByte == 0 ){
    sqlite3_free(zFilename);
    zFilename = 0;
  }
  return zFilename;
}

/*
** Convert multibyte character string to UTF-8.  Space to hold the
** returned string is obtained from sqlite3_malloc().
*/
char *sqlite3_win32_mbcs_to_utf8(const char *zFilename){
  char *zFilenameUtf8;
  LPWSTR zTmpWide;

  zTmpWide = winMbcsToUnicode(zFilename);
  if( zTmpWide==0 ){
    return 0;
  }
  zFilenameUtf8 = winUnicodeToUtf8(zTmpWide);
  sqlite3_free(zTmpWide);
  return zFilenameUtf8;
}

/*
** Convert UTF-8 to multibyte character string.  Space to hold the
** returned string is obtained from sqlite3_malloc().
*/
char *sqlite3_win32_utf8_to_mbcs(const char *zFilename){
  char *zFilenameMbcs;
  LPWSTR zTmpWide;

  zTmpWide = winUtf8ToUnicode(zFilename);
  if( zTmpWide==0 ){
    return 0;
  }
  zFilenameMbcs = winUnicodeToMbcs(zTmpWide);
  sqlite3_free(zTmpWide);
  return zFilenameMbcs;
}

/*
** This function sets the data directory or the temporary directory based on
** the provided arguments.  The type argument must be 1 in order to set the
** data directory or 2 in order to set the temporary directory.  The zValue
** argument is the name of the directory to use.  The return value will be
** SQLITE_OK if successful.
*/
int sqlite3_win32_set_directory(DWORD type, LPCWSTR zValue){
  char **ppDirectory = 0;
#ifndef SQLITE_OMIT_AUTOINIT
  int rc = sqlite3_initialize();
  if( rc ) return rc;
#endif
  if( type==SQLITE_WIN32_DATA_DIRECTORY_TYPE ){
    ppDirectory = &amp;sqlite3_data_directory;
  }else if( type==SQLITE_WIN32_TEMP_DIRECTORY_TYPE ){
    ppDirectory = &amp;sqlite3_temp_directory;
  }
  assert( !ppDirectory || type==SQLITE_WIN32_DATA_DIRECTORY_TYPE
          || type==SQLITE_WIN32_TEMP_DIRECTORY_TYPE
  );
  assert( !ppDirectory || sqlite3MemdebugHasType(*ppDirectory, MEMTYPE_HEAP) );
  if( ppDirectory ){
    char *zValueUtf8 = 0;
    if( zValue &amp;&amp; zValue[0] ){
      zValueUtf8 = winUnicodeToUtf8(zValue);
      if ( zValueUtf8==0 ){
        return SQLITE_NOMEM;
      }
    }
    sqlite3_free(*ppDirectory);
    *ppDirectory = zValueUtf8;
    return SQLITE_OK;
  }
  return SQLITE_ERROR;
}

/*
** The return value of winGetLastErrorMsg
** is zero if the error message fits in the buffer, or non-zero
** otherwise (if the message was truncated).
*/
static int winGetLastErrorMsg(DWORD lastErrno, int nBuf, char *zBuf){
  /* FormatMessage returns 0 on failure.  Otherwise it
  ** returns the number of TCHARs written to the output
  ** buffer, excluding the terminating null char.
  */
  DWORD dwLen = 0;
  char *zOut = 0;

  if( osIsNT() ){
#if SQLITE_OS_WINRT
    WCHAR zTempWide[SQLITE_WIN32_MAX_ERRMSG_CHARS+1];
    dwLen = osFormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                             FORMAT_MESSAGE_IGNORE_INSERTS,
                             NULL,
                             lastErrno,
                             0,
                             zTempWide,
                             SQLITE_WIN32_MAX_ERRMSG_CHARS,
                             0);
#else
    LPWSTR zTempWide = NULL;
    dwLen = osFormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                             FORMAT_MESSAGE_FROM_SYSTEM |
                             FORMAT_MESSAGE_IGNORE_INSERTS,
                             NULL,
                             lastErrno,
                             0,
                             (LPWSTR) &amp;zTempWide,
                             0,
                             0);
#endif
    if( dwLen &gt; 0 ){
      /* allocate a buffer and convert to UTF8 */
      sqlite3BeginBenignMalloc();
      zOut = winUnicodeToUtf8(zTempWide);
      sqlite3EndBenignMalloc();
#if !SQLITE_OS_WINRT
      /* free the system buffer allocated by FormatMessage */
      osLocalFree(zTempWide);
#endif
    }
  }
#ifdef SQLITE_WIN32_HAS_ANSI
  else{
    char *zTemp = NULL;
    dwLen = osFormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                             FORMAT_MESSAGE_FROM_SYSTEM |
                             FORMAT_MESSAGE_IGNORE_INSERTS,
                             NULL,
                             lastErrno,
                             0,
                             (LPSTR) &amp;zTemp,
                             0,
                             0);
    if( dwLen &gt; 0 ){
      /* allocate a buffer and convert to UTF8 */
      sqlite3BeginBenignMalloc();
      zOut = sqlite3_win32_mbcs_to_utf8(zTemp);
      sqlite3EndBenignMalloc();
      /* free the system buffer allocated by FormatMessage */
      osLocalFree(zTemp);
    }
  }
#endif
  if( 0 == dwLen ){
    sqlite3_snprintf(nBuf, zBuf, "</literal><name>OsError</name> <literal type="number">0x</literal><operator>%</operator><call><name>lx</name> <argument_list>(<argument><expr><operator>%</operator><name>lu</name></expr></argument>)</argument_list></call><literal type="string">", lastErrno, lastErrno);
  }else{
    /* copy a maximum of nBuf chars to output buffer */
    sqlite3_snprintf(nBuf, zBuf, "</literal><operator>%</operator><name>s</name><literal type="string">", zOut);
    /* free the UTF8 buffer */
    sqlite3_free(zOut);
  }
  return 0;
}

/*
**
** This function - winLogErrorAtLine() - is only ever called via the macro
** winLogError().
**
** This routine is invoked after an error occurs in an OS function.
** It logs a message using sqlite3_log() containing the current value of
** error code and, if possible, the human-readable equivalent from
** FormatMessage.
**
** The first argument passed to the macro should be the error code that
** will be returned to SQLite (e.g. SQLITE_IOERR_DELETE, SQLITE_CANTOPEN).
** The two subsequent arguments should be the name of the OS function that
** failed and the associated file-system path, if any.
*/
#define winLogError(a,b,c,d)   winLogErrorAtLine(a,b,c,d,__LINE__)
static int winLogErrorAtLine(
  int errcode,                    /* SQLite error code */
  DWORD lastErrno,                /* Win32 last error */
  const char *zFunc,              /* Name of OS function that failed */
  const char *zPath,              /* File path associated with error */
  int iLine                       /* Source line number where error occurred */
){
  char zMsg[500];                 /* Human readable error text */
  int i;                          /* Loop counter */

  zMsg[0] = 0;
  winGetLastErrorMsg(lastErrno, sizeof(zMsg), zMsg);
  assert( errcode!=SQLITE_OK );
  if( zPath==0 ) zPath = ""</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zMsg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>zMsg</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <name><name>zMsg</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'\n'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <expr_stmt><expr><name><name>zMsg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>,
      <argument><expr><literal type="string">"os_win.c:%d: (%lu) %s(%s) - %s"</literal></expr></argument>,
      <argument><expr><name>iLine</name></expr></argument>, <argument><expr><name>lastErrno</name></expr></argument>, <argument><expr><name>zFunc</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>errcode</name></expr>;</return>
}

<comment type="block">/*
** The number of times that a ReadFile(), WriteFile(), and DeleteFile()
** will be retried following a locking error - probably caused by
** antivirus software.  Also the initial delay before the first retry.
** The delay increases linearly with each retry.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_WIN32_IOERR_RETRY</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_WIN32_IOERR_RETRY</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_WIN32_IOERR_RETRY_DELAY</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_WIN32_IOERR_RETRY_DELAY</name></cpp:macro> <cpp:value>25</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
static <decl_stmt><decl><type><name>int</name></type> <name>winIoerrRetry</name> <init>= <expr><name>SQLITE_WIN32_IOERR_RETRY</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>winIoerrRetryDelay</name> <init>= <expr><name>SQLITE_WIN32_IOERR_RETRY_DELAY</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** The "winIoerrCanRetry1" macro is used to determine if a particular I/O
** error code obtained via GetLastError() is eligible to be retried.  It
** must accept the error code DWORD as its only argument and should return
** non-zero if the error code is transient in nature and the operation
** responsible for generating the original error might succeed upon being
** retried.  The argument to this macro should be a variable.
**
** Additionally, a macro named "winIoerrCanRetry2" may be defined.  If it
** is defined, it will be consulted only when the macro "winIoerrCanRetry1"
** returns zero.  The "winIoerrCanRetry2" macro is completely optional and
** may be used to include additional error codes in the set that should
** result in the failing I/O operation being retried by the caller.  If
** defined, the "winIoerrCanRetry2" macro must exhibit external semantics
** identical to those of the "winIoerrCanRetry1" macro.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>winIoerrCanRetry1</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>winIoerrCanRetry1</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((a)==ERROR_ACCESS_DENIED)        || \
                              ((a)==ERROR_SHARING_VIOLATION)    || \
                              ((a)==ERROR_LOCK_VIOLATION)       || \
                              ((a)==ERROR_DEV_NOT_EXIST)        || \
                              ((a)==ERROR_NETNAME_DELETED)      || \
                              ((a)==ERROR_SEM_TIMEOUT)          || \
                              ((a)==ERROR_NETWORK_UNREACHABLE))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** If a ReadFile() or WriteFile() error occurs, invoke this routine
** to see if it should be retried.  Return TRUE to retry.  Return FALSE
** to give up with an error.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winRetryIoerr</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnRetry</name></decl></parameter>, <parameter><decl><type><name>DWORD</name> <modifier>*</modifier></type><name>pError</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>e</name> <init>= <expr><call><name>osGetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pnRetry</name><operator>&gt;=</operator><name>winIoerrRetry</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pError</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pError</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>winIoerrCanRetry1</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_win32_sleep</name><argument_list>(<argument><expr><name>winIoerrRetryDelay</name><operator>*</operator><operator>(</operator><literal type="number">1</literal><operator>+</operator><operator>*</operator><name>pnRetry</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>++</operator><operator>*</operator><name>pnRetry</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>winIoerrCanRetry2</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if type="elseif">else if<condition>( <expr><call><name>winIoerrCanRetry2</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_win32_sleep</name><argument_list>(<argument><expr><name>winIoerrRetryDelay</name><operator>*</operator><operator>(</operator><literal type="number">1</literal><operator>+</operator><operator>*</operator><name>pnRetry</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>++</operator><operator>*</operator><name>pnRetry</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>pError</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pError</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Log a I/O error retry episode.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>winLogIoerr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nRetry</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>nRetry</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_NOTICE</name></expr></argument>,
      <argument><expr><literal type="string">"delayed %dms for lock/sharing conflict at line %d"</literal></expr></argument>,
      <argument><expr><name>winIoerrRetryDelay</name><operator>*</operator><name>nRetry</name><operator>*</operator><operator>(</operator><name>nRetry</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>lineno</name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINCE</name></expr></cpp:if>
<comment type="block" format="doxygen">/*************************************************************************
** This section contains code for WinCE only.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_MSVC_LOCALTIME_API</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name>SQLITE_MSVC_LOCALTIME_API</name></expr></cpp:if>
<comment type="block">/*
** The MSVC CRT on Windows CE may not have a localtime() function.  So
** create a substitute.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<function><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier><name>__cdecl</name></type> <name>localtime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>time_t</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>tm</name></name></type> <name>y</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILETIME</name></type> <name>uTm</name></decl>, <decl><type ref="prev"/><name>lTm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SYSTEMTIME</name></type> <name>pTm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>t64</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>t64</name> <operator>=</operator> <operator>*</operator><name>t</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>t64</name> <operator>=</operator> <operator>(</operator><name>t64</name> <operator>+</operator> <literal type="number">11644473600</literal><operator>)</operator><operator>*</operator><literal type="number">10000000</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>uTm</name><operator>.</operator><name>dwLowDateTime</name></name> <operator>=</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><operator>(</operator><name>t64</name> <operator>&amp;</operator> <literal type="number">0xFFFFFFFF</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>uTm</name><operator>.</operator><name>dwHighDateTime</name></name><operator>=</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><operator>(</operator><name>t64</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>osFileTimeToLocalFileTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uTm</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>osFileTimeToSystemTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lTm</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pTm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>y</name><operator>.</operator><name>tm_year</name></name> <operator>=</operator> <name><name>pTm</name><operator>.</operator><name>wYear</name></name> <operator>-</operator> <literal type="number">1900</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>y</name><operator>.</operator><name>tm_mon</name></name> <operator>=</operator> <name><name>pTm</name><operator>.</operator><name>wMonth</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>y</name><operator>.</operator><name>tm_wday</name></name> <operator>=</operator> <name><name>pTm</name><operator>.</operator><name>wDayOfWeek</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>y</name><operator>.</operator><name>tm_mday</name></name> <operator>=</operator> <name><name>pTm</name><operator>.</operator><name>wDay</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>y</name><operator>.</operator><name>tm_hour</name></name> <operator>=</operator> <name><name>pTm</name><operator>.</operator><name>wHour</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>y</name><operator>.</operator><name>tm_min</name></name> <operator>=</operator> <name><name>pTm</name><operator>.</operator><name>wMinute</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>y</name><operator>.</operator><name>tm_sec</name></name> <operator>=</operator> <name><name>pTm</name><operator>.</operator><name>wSecond</name></name></expr>;</expr_stmt>
  <return>return <expr><operator>&amp;</operator><name>y</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HANDLE_TO_WINFILE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(winFile*)&amp;((char*)a)[-(int)offsetof(winFile,h)]</cpp:value></cpp:define>

<comment type="block">/*
** Acquire a lock on the handle h
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>winceMutexAcquire</name><parameter_list>(<parameter><decl><type><name>HANDLE</name></type> <name>h</name></decl></parameter>)</parameter_list><block>{<block_content>
   <decl_stmt><decl><type><name>DWORD</name></type> <name>dwErr</name></decl>;</decl_stmt>
   <do>do <block>{<block_content>
     <expr_stmt><expr><name>dwErr</name> <operator>=</operator> <call><name>osWaitForSingleObject</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block> while <condition>(<expr><name>dwErr</name> <operator>!=</operator> <name>WAIT_OBJECT_0</name> <operator>&amp;&amp;</operator> <name>dwErr</name> <operator>!=</operator> <name>WAIT_ABANDONED</name></expr>)</condition>;</do>
</block_content>}</block></function>
<comment type="block">/*
** Release a lock acquired by winceMutexAcquire()
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>winceMutexRelease</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ReleaseMutex(h)</cpp:value></cpp:define>

<comment type="block">/*
** Create the mutex and shared memory used for locking in the file
** descriptor pFile
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winceCreateLock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>, <parameter><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LPWSTR</name></type> <name>zTok</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LPWSTR</name></type> <name>zName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>lastErrno</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>bLogged</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>bInit</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>zName</name> <operator>=</operator> <call><name>winUtf8ToUnicode</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* out of memory */</comment>
    <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Initialize the local lockdata */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFile</name><operator>-&gt;</operator><name>local</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>local</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Replace the backslashes from the filename and lowercase it
  ** to derive a mutex name. */</comment>
  <expr_stmt><expr><name>zTok</name> <operator>=</operator> <call><name>osCharLowerW</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init>;</init><condition><expr><operator>*</operator><name>zTok</name></expr>;</condition><incr><expr><name>zTok</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>zTok</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>zTok</name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Create/open the named mutex */</comment>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>hMutex</name></name> <operator>=</operator> <call><name>osCreateMutexW</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pFile</name><operator>-&gt;</operator><name>hMutex</name></name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>,
                       <argument><expr><literal type="string">"winceCreateLock1"</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Acquire the mutex before continuing */</comment>
  <expr_stmt><expr><call><name>winceMutexAcquire</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>hMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Since the names of named mutexes, semaphores, file mappings etc are
  ** case-sensitive, take advantage of that by uppercasing the mutex name
  ** and using that as the shared filemapping name.
  */</comment>
  <expr_stmt><expr><call><name>osCharUpperW</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>hShared</name></name> <operator>=</operator> <call><name>osCreateFileMappingW</name><argument_list>(<argument><expr><name>INVALID_HANDLE_VALUE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                        <argument><expr><name>PAGE_READWRITE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>winceLock</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                        <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set a flag that indicates we're the first to create the memory so it
  ** must be zero-initialized */</comment>
  <expr_stmt><expr><name>lastErrno</name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>lastErrno</name> <operator>==</operator> <name>ERROR_ALREADY_EXISTS</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name>bInit</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we succeeded in making the shared memory handle, map it. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>hShared</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>shared</name></name> <operator>=</operator> <operator>(</operator><name>winceLock</name><operator>*</operator><operator>)</operator><call><name>osMapViewOfFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>hShared</name></name></expr></argument>,
             <argument><expr><name>FILE_MAP_READ</name><operator>|</operator><name>FILE_MAP_WRITE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>winceLock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If mapping failed, close the shared memory handle and erase it */</comment>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pFile</name><operator>-&gt;</operator><name>shared</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>,
                  <argument><expr><literal type="string">"winceCreateLock2"</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bLogged</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>osCloseHandle</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>hShared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>hShared</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If shared memory could not be created, then close the mutex and fail */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>hShared</name></name><operator>==</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>bLogged</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>lastErrno</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>,
                  <argument><expr><literal type="string">"winceCreateLock3"</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bLogged</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>winceMutexRelease</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>hMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>osCloseHandle</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>hMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>hMutex</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_IOERR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Initialize the shared memory if we're supposed to */</comment>
  <if_stmt><if>if<condition>( <expr><name>bInit</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>shared</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>winceLock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>winceMutexRelease</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>hMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Destroy the part of winFile that deals with wince locks
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>winceDestroyLock</name><parameter_list>(<parameter><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pFile</name><operator>-&gt;</operator><name>hMutex</name></name></expr>)</condition><block>{<block_content>
    <comment type="block">/* Acquire the mutex */</comment>
    <expr_stmt><expr><call><name>winceMutexAcquire</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>hMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The following blocks should probably assert in debug mode, but they
       are to cleanup in case any locks remained open */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pFile</name><operator>-&gt;</operator><name>local</name><operator>.</operator><name>nReaders</name></name></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>nReaders</name></name> <operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pFile</name><operator>-&gt;</operator><name>local</name><operator>.</operator><name>bReserved</name></name></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>bReserved</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pFile</name><operator>-&gt;</operator><name>local</name><operator>.</operator><name>bPending</name></name></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>bPending</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pFile</name><operator>-&gt;</operator><name>local</name><operator>.</operator><name>bExclusive</name></name></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>bExclusive</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* De-reference and close our copy of the shared memory handle */</comment>
    <expr_stmt><expr><call><name>osUnmapViewOfFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>shared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>osCloseHandle</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>hShared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Done with the mutex */</comment>
    <expr_stmt><expr><call><name>winceMutexRelease</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>hMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>osCloseHandle</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>hMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>hMutex</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** An implementation of the LockFile() API of Windows for CE
*/</comment>
<function><type><specifier>static</specifier> <name>BOOL</name></type> <name>winceLockFile</name><parameter_list>(
  <parameter><decl><type><name>LPHANDLE</name></type> <name>phFile</name></decl></parameter>,
  <parameter><decl><type><name>DWORD</name></type> <name>dwFileOffsetLow</name></decl></parameter>,
  <parameter><decl><type><name>DWORD</name></type> <name>dwFileOffsetHigh</name></decl></parameter>,
  <parameter><decl><type><name>DWORD</name></type> <name>nNumberOfBytesToLockLow</name></decl></parameter>,
  <parameter><decl><type><name>DWORD</name></type> <name>nNumberOfBytesToLockHigh</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><call><name>HANDLE_TO_WINFILE</name><argument_list>(<argument><expr><name>phFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>bReturn</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>dwFileOffsetHigh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nNumberOfBytesToLockHigh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pFile</name><operator>-&gt;</operator><name>hMutex</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>winceMutexAcquire</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>hMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Wanting an exclusive lock? */</comment>
  <if_stmt><if>if <condition>(<expr><name>dwFileOffsetLow</name> <operator>==</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>SHARED_FIRST</name>
       <operator>&amp;&amp;</operator> <name>nNumberOfBytesToLockLow</name> <operator>==</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>SHARED_SIZE</name></expr>)</condition><block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pFile</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>nReaders</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pFile</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>bExclusive</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
       <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>bExclusive</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
       <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>local</name><operator>.</operator><name>bExclusive</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
       <expr_stmt><expr><name>bReturn</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>

  <comment type="block">/* Want a read-only lock? */</comment>
  <if type="elseif">else if <condition>(<expr><name>dwFileOffsetLow</name> <operator>==</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>SHARED_FIRST</name> <operator>&amp;&amp;</operator>
           <name>nNumberOfBytesToLockLow</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pFile</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>bExclusive</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>local</name><operator>.</operator><name>nReaders</name></name> <operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>pFile</name><operator>-&gt;</operator><name>local</name><operator>.</operator><name>nReaders</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>nReaders</name></name> <operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>bReturn</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>

  <comment type="block">/* Want a pending lock? */</comment>
  <if type="elseif">else if <condition>(<expr><name>dwFileOffsetLow</name> <operator>==</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>PENDING_BYTE</name>
           <operator>&amp;&amp;</operator> <name>nNumberOfBytesToLockLow</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block>{<block_content>
    <comment type="block">/* If no pending lock has been acquired, then acquire it */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pFile</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>bPending</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>bPending</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>local</name><operator>.</operator><name>bPending</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>bReturn</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>

  <comment type="block">/* Want a reserved lock? */</comment>
  <if type="elseif">else if <condition>(<expr><name>dwFileOffsetLow</name> <operator>==</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>RESERVED_BYTE</name>
           <operator>&amp;&amp;</operator> <name>nNumberOfBytesToLockLow</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pFile</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>bReserved</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>bReserved</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>local</name><operator>.</operator><name>bReserved</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>bReturn</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>winceMutexRelease</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>hMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>bReturn</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** An implementation of the UnlockFile API of Windows for CE
*/</comment>
<function><type><specifier>static</specifier> <name>BOOL</name></type> <name>winceUnlockFile</name><parameter_list>(
  <parameter><decl><type><name>LPHANDLE</name></type> <name>phFile</name></decl></parameter>,
  <parameter><decl><type><name>DWORD</name></type> <name>dwFileOffsetLow</name></decl></parameter>,
  <parameter><decl><type><name>DWORD</name></type> <name>dwFileOffsetHigh</name></decl></parameter>,
  <parameter><decl><type><name>DWORD</name></type> <name>nNumberOfBytesToUnlockLow</name></decl></parameter>,
  <parameter><decl><type><name>DWORD</name></type> <name>nNumberOfBytesToUnlockHigh</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><call><name>HANDLE_TO_WINFILE</name><argument_list>(<argument><expr><name>phFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>bReturn</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>dwFileOffsetHigh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nNumberOfBytesToUnlockHigh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pFile</name><operator>-&gt;</operator><name>hMutex</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>winceMutexAcquire</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>hMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Releasing a reader lock or an exclusive lock */</comment>
  <if_stmt><if>if <condition>(<expr><name>dwFileOffsetLow</name> <operator>==</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>SHARED_FIRST</name></expr>)</condition><block>{<block_content>
    <comment type="block">/* Did we have an exclusive lock? */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pFile</name><operator>-&gt;</operator><name>local</name><operator>.</operator><name>bExclusive</name></name></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nNumberOfBytesToUnlockLow</name> <operator>==</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>SHARED_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>local</name><operator>.</operator><name>bExclusive</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>bExclusive</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>bReturn</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if>

    <comment type="block">/* Did we just have a reader lock? */</comment>
    <if type="elseif">else if <condition>(<expr><name><name>pFile</name><operator>-&gt;</operator><name>local</name><operator>.</operator><name>nReaders</name></name></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nNumberOfBytesToUnlockLow</name> <operator>==</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>SHARED_SIZE</name>
             <operator>||</operator> <name>nNumberOfBytesToUnlockLow</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>local</name><operator>.</operator><name>nReaders</name></name> <operator>--</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>pFile</name><operator>-&gt;</operator><name>local</name><operator>.</operator><name>nReaders</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
        <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>nReaders</name></name> <operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>bReturn</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>

  <comment type="block">/* Releasing a pending lock */</comment>
  <if type="elseif">else if <condition>(<expr><name>dwFileOffsetLow</name> <operator>==</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>PENDING_BYTE</name>
           <operator>&amp;&amp;</operator> <name>nNumberOfBytesToUnlockLow</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pFile</name><operator>-&gt;</operator><name>local</name><operator>.</operator><name>bPending</name></name></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>local</name><operator>.</operator><name>bPending</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>bPending</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>bReturn</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
  <comment type="block">/* Releasing a reserved lock */</comment>
  <if type="elseif">else if <condition>(<expr><name>dwFileOffsetLow</name> <operator>==</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>RESERVED_BYTE</name>
           <operator>&amp;&amp;</operator> <name>nNumberOfBytesToUnlockLow</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>pFile</name><operator>-&gt;</operator><name>local</name><operator>.</operator><name>bReserved</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>local</name><operator>.</operator><name>bReserved</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>shared</name><operator>-&gt;</operator><name>bReserved</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>bReturn</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>winceMutexRelease</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>hMutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>bReturn</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** End of the special code for wince
*****************************************************************************/</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OS_WINCE */</comment>

<comment type="block">/*
** Lock a file region.
*/</comment>
<function><type><specifier>static</specifier> <name>BOOL</name></type> <name>winLockFile</name><parameter_list>(
  <parameter><decl><type><name>LPHANDLE</name></type> <name>phFile</name></decl></parameter>,
  <parameter><decl><type><name>DWORD</name></type> <name>flags</name></decl></parameter>,
  <parameter><decl><type><name>DWORD</name></type> <name>offsetLow</name></decl></parameter>,
  <parameter><decl><type><name>DWORD</name></type> <name>offsetHigh</name></decl></parameter>,
  <parameter><decl><type><name>DWORD</name></type> <name>numBytesLow</name></decl></parameter>,
  <parameter><decl><type><name>DWORD</name></type> <name>numBytesHigh</name></decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINCE</name></expr></cpp:if>
  <comment type="block">/*
  ** NOTE: Windows CE is handled differently here due its lack of the Win32
  **       API LockFile.
  */</comment>
  <return>return <expr><call><name>winceLockFile</name><argument_list>(<argument><expr><name>phFile</name></expr></argument>, <argument><expr><name>offsetLow</name></expr></argument>, <argument><expr><name>offsetHigh</name></expr></argument>,
                       <argument><expr><name>numBytesLow</name></expr></argument>, <argument><expr><name>numBytesHigh</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if<condition>( <expr><call><name>osIsNT</name><argument_list>()</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>OVERLAPPED</name></type> <name>ovlp</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ovlp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OVERLAPPED</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ovlp</name><operator>.</operator><name>Offset</name></name> <operator>=</operator> <name>offsetLow</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ovlp</name><operator>.</operator><name>OffsetHigh</name></name> <operator>=</operator> <name>offsetHigh</name></expr>;</expr_stmt>
    <return>return <expr><call><name>osLockFileEx</name><argument_list>(<argument><expr><operator>*</operator><name>phFile</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numBytesLow</name></expr></argument>, <argument><expr><name>numBytesHigh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ovlp</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><call><name>osLockFile</name><argument_list>(<argument><expr><operator>*</operator><name>phFile</name></expr></argument>, <argument><expr><name>offsetLow</name></expr></argument>, <argument><expr><name>offsetHigh</name></expr></argument>, <argument><expr><name>numBytesLow</name></expr></argument>,
                      <argument><expr><name>numBytesHigh</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Unlock a file region.
 */</comment>
<function><type><specifier>static</specifier> <name>BOOL</name></type> <name>winUnlockFile</name><parameter_list>(
  <parameter><decl><type><name>LPHANDLE</name></type> <name>phFile</name></decl></parameter>,
  <parameter><decl><type><name>DWORD</name></type> <name>offsetLow</name></decl></parameter>,
  <parameter><decl><type><name>DWORD</name></type> <name>offsetHigh</name></decl></parameter>,
  <parameter><decl><type><name>DWORD</name></type> <name>numBytesLow</name></decl></parameter>,
  <parameter><decl><type><name>DWORD</name></type> <name>numBytesHigh</name></decl></parameter>
)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINCE</name></expr></cpp:if>
  <comment type="block">/*
  ** NOTE: Windows CE is handled differently here due its lack of the Win32
  **       API UnlockFile.
  */</comment>
  <return>return <expr><call><name>winceUnlockFile</name><argument_list>(<argument><expr><name>phFile</name></expr></argument>, <argument><expr><name>offsetLow</name></expr></argument>, <argument><expr><name>offsetHigh</name></expr></argument>,
                         <argument><expr><name>numBytesLow</name></expr></argument>, <argument><expr><name>numBytesHigh</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if<condition>( <expr><call><name>osIsNT</name><argument_list>()</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>OVERLAPPED</name></type> <name>ovlp</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ovlp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OVERLAPPED</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ovlp</name><operator>.</operator><name>Offset</name></name> <operator>=</operator> <name>offsetLow</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ovlp</name><operator>.</operator><name>OffsetHigh</name></name> <operator>=</operator> <name>offsetHigh</name></expr>;</expr_stmt>
    <return>return <expr><call><name>osUnlockFileEx</name><argument_list>(<argument><expr><operator>*</operator><name>phFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numBytesLow</name></expr></argument>, <argument><expr><name>numBytesHigh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ovlp</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><call><name>osUnlockFile</name><argument_list>(<argument><expr><operator>*</operator><name>phFile</name></expr></argument>, <argument><expr><name>offsetLow</name></expr></argument>, <argument><expr><name>offsetHigh</name></expr></argument>, <argument><expr><name>numBytesLow</name></expr></argument>,
                        <argument><expr><name>numBytesHigh</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
** The next group of routines implement the I/O methods specified
** by the sqlite3_io_methods object.
******************************************************************************/</comment>

<comment type="block">/*
** Some Microsoft compilers lack this definition.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>INVALID_SET_FILE_POINTER</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_SET_FILE_POINTER</name></cpp:macro> <cpp:value>((DWORD)-1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Move the current position of the file handle passed as the first
** argument to offset iOffset within the file. If successful, return 0.
** Otherwise, set pFile-&gt;lastErrno and return non-zero.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winSeekFile</name><parameter_list>(<parameter><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>iOffset</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_OS_WINRT</name></expr></cpp:if>
  <decl_stmt><decl><type><name>LONG</name></type> <name>upperBits</name></decl>;</decl_stmt>                 <comment type="block">/* Most sig. 32 bits of new offset */</comment>
  <decl_stmt><decl><type><name>LONG</name></type> <name>lowerBits</name></decl>;</decl_stmt>                 <comment type="block">/* Least sig. 32 bits of new offset */</comment>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>dwRet</name></decl>;</decl_stmt>                    <comment type="block">/* Value returned by SetFilePointer() */</comment>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>lastErrno</name></decl>;</decl_stmt>                <comment type="block">/* Value returned by GetLastError() */</comment>

  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SEEK file=%p, offset=%lld\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>iOffset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>upperBits</name> <operator>=</operator> <operator>(</operator><name>LONG</name><operator>)</operator><operator>(</operator><operator>(</operator><name>iOffset</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7fffffff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>lowerBits</name> <operator>=</operator> <operator>(</operator><name>LONG</name><operator>)</operator><operator>(</operator><name>iOffset</name> <operator>&amp;</operator> <literal type="number">0xffffffff</literal><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* API oddity: If successful, SetFilePointer() returns a dword
  ** containing the lower 32-bits of the new file-offset. Or, if it fails,
  ** it returns INVALID_SET_FILE_POINTER. However according to MSDN,
  ** INVALID_SET_FILE_POINTER may also be a valid new offset. So to determine
  ** whether an error has actually occurred, it is also necessary to call
  ** GetLastError().
  */</comment>
  <expr_stmt><expr><name>dwRet</name> <operator>=</operator> <call><name>osSetFilePointer</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>lowerBits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upperBits</name></expr></argument>, <argument><expr><name>FILE_BEGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>dwRet</name><operator>==</operator><name>INVALID_SET_FILE_POINTER</name>
      <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>lastErrno</name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call><operator>)</operator><operator>!=</operator><name>NO_ERROR</name><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>lastErrno</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_SEEK</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>,
                <argument><expr><literal type="string">"winSeekFile"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SEEK file=%p, rc=SQLITE_IOERR_SEEK\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SEEK file=%p, rc=SQLITE_OK\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/*
  ** Same as above, except that this implementation works for WinRT.
  */</comment>

  <decl_stmt><decl><type><name>LARGE_INTEGER</name></type> <name>x</name></decl>;</decl_stmt>                <comment type="block">/* The new offset */</comment>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>bRet</name></decl>;</decl_stmt>                      <comment type="block">/* Value returned by SetFilePointerEx() */</comment>

  <expr_stmt><expr><name><name>x</name><operator>.</operator><name>QuadPart</name></name> <operator>=</operator> <name>iOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>bRet</name> <operator>=</operator> <call><name>osSetFilePointerEx</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FILE_BEGIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>(<expr><operator>!</operator><name>bRet</name></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_SEEK</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>,
                <argument><expr><literal type="string">"winSeekFile"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SEEK file=%p, rc=SQLITE_IOERR_SEEK\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SEEK file=%p, rc=SQLITE_OK\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/* Forward references to VFS helper methods used for memory mapped files */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>winMapfile</name><parameter_list>(<parameter><decl><type><name>winFile</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>winUnmapfile</name><parameter_list>(<parameter><decl><type><name>winFile</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Close a file.
**
** It is reported that an attempt to close a handle might sometimes
** fail.  This is a very unreasonable result, but Windows is notorious
** for being unreasonable so I do not doubt that it might happen.  If
** the close fails, we pause for 100 milliseconds and try again.  As
** many as MX_CLOSE_ATTEMPT attempts to close the handle are made before
** giving up and returning an error.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MX_CLOSE_ATTEMPT</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>, <decl><type ref="prev"/><name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>id</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>pShm</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>!=</operator><name>NULL</name> <operator>&amp;&amp;</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>!=</operator><name>INVALID_HANDLE_VALUE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"CLOSE pid=%lu, pFile=%p, file=%p\n"</literal><operator>,</operator>
           <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <expr_stmt><expr><call><name>winUnmapfile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <do>do<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>osCloseHandle</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* SimulateIOError( rc=0; cnt=MX_CLOSE_ATTEMPT; ); */</comment>
  </block_content>}</block>while<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>++</operator><name>cnt</name> <operator>&lt;</operator> <name>MX_CLOSE_ATTEMPT</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>sqlite3_win32_sleep</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call><operator>,</operator> <literal type="number">1</literal><operator>)</operator></expr> )</condition>;</do>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINCE</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINCE_DELETION_ATTEMPTS</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
  <expr_stmt><expr><call><name>winceDestroyLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>zDeleteOnClose</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while<condition>(
           <expr><call><name>osDeleteFileW</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zDeleteOnClose</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
        <operator>&amp;&amp;</operator> <call><name>osGetFileAttributesW</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zDeleteOnClose</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0xffffffff</literal>
        <operator>&amp;&amp;</operator> <name>cnt</name><operator>++</operator> <operator>&lt;</operator> <name>WINCE_DELETION_ATTEMPTS</name></expr>
    )</condition><block>{<block_content>
       <expr_stmt><expr><call><name>sqlite3_win32_sleep</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Wait a little before trying again */</comment>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zDeleteOnClose</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>OpenCounter</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"CLOSE pid=%lu, pFile=%p, file=%p, rc=%s\n"</literal><operator>,</operator>
           <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <ternary><condition><expr><name>rc</name></expr> ?</condition><then> <expr><literal type="string">"ok"</literal></expr> </then><else>: <expr><literal type="string">"failed"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name>rc</name></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr>
            </then><else>: <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_CLOSE</name></expr></argument>, <argument><expr><call><name>osGetLastError</name><argument_list>()</argument_list></call></expr></argument>,
                          <argument><expr><literal type="string">"winClose"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Read data from a file into a buffer.  Return SQLITE_OK if all
** bytes were read successfully and SQLITE_IOERR if anything goes
** wrong.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winRead</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>,          <comment type="block">/* File to read from */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,                <comment type="block">/* Write content into this buffer */</comment>
  <parameter><decl><type><name>int</name></type> <name>amt</name></decl></parameter>,                   <comment type="block">/* Number of bytes to read */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>offset</name></decl></parameter>       <comment type="block">/* Begin reading at this offset */</comment>
)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_OS_WINCE</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_WIN32_NO_OVERLAPPED</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>OVERLAPPED</name></type> <name>overlapped</name></decl>;</decl_stmt>          <comment type="block">/* The offset for ReadFile. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* file handle */</comment>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>nRead</name></decl>;</decl_stmt>                    <comment type="block">/* Number of bytes actually read from file */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRetry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Number of retrys */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>id</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>amt</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>offset</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>SimulateIOError</name><argument_list>(<argument>return SQLITE_IOERR_READ</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"READ pid=%lu, pFile=%p, file=%p, buffer=%p, amount=%d, "</literal>
           <literal type="string">"offset=%lld, lock=%d\n"</literal><operator>,</operator> <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator>
           <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>pBuf</name><operator>,</operator> <name>amt</name><operator>,</operator> <name>offset</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <comment type="block">/* Deal with as much of this read request as possible by transfering
  ** data from the memory mapping using memcpy().  */</comment>
  <if_stmt><if>if<condition>( <expr><name>offset</name><operator>&lt;</operator><name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>offset</name><operator>+</operator><name>amt</name> <operator>&lt;=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>pMapRegion</name></name><operator>)</operator><operator>)</operator><index>[<expr><name>offset</name></expr>]</index></expr></argument>, <argument><expr><name>amt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"READ-MMAP pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n"</literal><operator>,</operator>
               <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name> <operator>-</operator> <name>offset</name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>pMapRegion</name></name><operator>)</operator><operator>)</operator><index>[<expr><name>offset</name></expr>]</index></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pBuf</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>pBuf</name><operator>)</operator><index>[<expr><name>nCopy</name></expr>]</index></expr>;</expr_stmt>
      <expr_stmt><expr><name>amt</name> <operator>-=</operator> <name>nCopy</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINCE</name> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_WIN32_NO_OVERLAPPED</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><call><name>winSeekFile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_FULL\n"</literal><operator>,</operator>
             <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_FULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <while>while<condition>( <expr><operator>!</operator><call><name>osReadFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nRead</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>overlapped</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OVERLAPPED</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>overlapped</name><operator>.</operator><name>Offset</name></name> <operator>=</operator> <operator>(</operator><name>LONG</name><operator>)</operator><operator>(</operator><name>offset</name> <operator>&amp;</operator> <literal type="number">0xffffffff</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>overlapped</name><operator>.</operator><name>OffsetHigh</name></name> <operator>=</operator> <operator>(</operator><name>LONG</name><operator>)</operator><operator>(</operator><operator>(</operator><name>offset</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7fffffff</literal><operator>)</operator></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>!</operator><call><name>osReadFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nRead</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>overlapped</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
         <call><name>osGetLastError</name><argument_list>()</argument_list></call><operator>!=</operator><name>ERROR_HANDLE_EOF</name></expr> )</condition><block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>lastErrno</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>winRetryIoerr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nRetry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastErrno</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>lastErrno</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_READ\n"</literal><operator>,</operator>
             <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_READ</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>,
                       <argument><expr><literal type="string">"winRead"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>winLogIoerr</name><argument_list>(<argument><expr><name>nRetry</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nRead</name><operator>&lt;</operator><operator>(</operator><name>DWORD</name><operator>)</operator><name>amt</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Unread parts of the buffer must be zero-filled */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>pBuf</name><operator>)</operator><index>[<expr><name>nRead</name></expr>]</index></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>amt</name><operator>-</operator><name>nRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_SHORT_READ\n"</literal><operator>,</operator>
             <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_IOERR_SHORT_READ</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n"</literal><operator>,</operator>
           <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></while>

<comment type="block">/*
** Write data from a buffer into a file.  Return SQLITE_OK on success
** or some other error code on failure.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winWrite</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>,               <comment type="block">/* File to write into */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pBuf</name></decl></parameter>,               <comment type="block">/* The bytes to be written */</comment>
  <parameter><decl><type><name>int</name></type> <name>amt</name></decl></parameter>,                        <comment type="block">/* Number of bytes to write */</comment>
  <parameter><decl><type><name>sqlite3_int64</name></type> <name>offset</name></decl></parameter>            <comment type="block">/* Offset into the file to begin writing at */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                     <comment type="block">/* True if error has occurred, else false */</comment>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* File handle */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRetry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Number of retries */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>amt</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>SimulateIOError</name><argument_list>(<argument>return SQLITE_IOERR_WRITE</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  <macro><name>SimulateDiskfullError</name><argument_list>(<argument>return SQLITE_FULL</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WRITE pid=%lu, pFile=%p, file=%p, buffer=%p, amount=%d, "</literal>
           <literal type="string">"offset=%lld, lock=%d\n"</literal><operator>,</operator> <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator>
           <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>pBuf</name><operator>,</operator> <name>amt</name><operator>,</operator> <name>offset</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_MMAP_READWRITE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <comment type="block">/* Deal with as much of this write request as possible by transfering
  ** data from the memory mapping using memcpy().  */</comment>
  <if_stmt><if>if<condition>( <expr><name>offset</name><operator>&lt;</operator><name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>offset</name><operator>+</operator><name>amt</name> <operator>&lt;=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>pMapRegion</name></name><operator>)</operator><operator>)</operator><index>[<expr><name>offset</name></expr>]</index></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WRITE-MMAP pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n"</literal><operator>,</operator>
               <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nCopy</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name> <operator>-</operator> <name>offset</name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>pMapRegion</name></name><operator>)</operator><operator>)</operator><index>[<expr><name>offset</name></expr>]</index></expr></argument>, <argument><expr><name>pBuf</name></expr></argument>, <argument><expr><name>nCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pBuf</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>pBuf</name><operator>)</operator><index>[<expr><name>nCopy</name></expr>]</index></expr>;</expr_stmt>
      <expr_stmt><expr><name>amt</name> <operator>-=</operator> <name>nCopy</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>nCopy</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINCE</name> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_WIN32_NO_OVERLAPPED</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winSeekFile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_OS_WINCE</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_WIN32_NO_OVERLAPPED</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><name>OVERLAPPED</name></type> <name>overlapped</name></decl>;</decl_stmt>        <comment type="block">/* The offset for WriteFile. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>aRem</name> <init>= <expr><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name>pBuf</name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Data yet to be written */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nRem</name> <init>= <expr><name>amt</name></expr></init></decl>;</decl_stmt>               <comment type="block">/* Number of bytes yet to be written */</comment>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>nWrite</name></decl>;</decl_stmt>                 <comment type="block">/* Bytes written by each WriteFile() call */</comment>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>lastErrno</name> <init>= <expr><name>NO_ERROR</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Value returned by GetLastError() */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_OS_WINCE</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_WIN32_NO_OVERLAPPED</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>overlapped</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OVERLAPPED</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>overlapped</name><operator>.</operator><name>Offset</name></name> <operator>=</operator> <operator>(</operator><name>LONG</name><operator>)</operator><operator>(</operator><name>offset</name> <operator>&amp;</operator> <literal type="number">0xffffffff</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>overlapped</name><operator>.</operator><name>OffsetHigh</name></name> <operator>=</operator> <operator>(</operator><name>LONG</name><operator>)</operator><operator>(</operator><operator>(</operator><name>offset</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7fffffff</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <while>while<condition>( <expr><name>nRem</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINCE</name> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_WIN32_NO_OVERLAPPED</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>osWriteFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>aRem</name></expr></argument>, <argument><expr><name>nRem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nWrite</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>osWriteFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>aRem</name></expr></argument>, <argument><expr><name>nRem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nWrite</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>overlapped</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if<condition>( <expr><call><name>winRetryIoerr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nRetry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastErrno</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nWrite</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>nWrite</name><operator>&lt;=</operator><operator>(</operator><name>DWORD</name><operator>)</operator><name>nRem</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nWrite</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>nWrite</name><operator>&gt;</operator><operator>(</operator><name>DWORD</name><operator>)</operator><name>nRem</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>lastErrno</name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_OS_WINCE</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_WIN32_NO_OVERLAPPED</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>nWrite</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>overlapped</name><operator>.</operator><name>Offset</name></name> <operator>=</operator> <operator>(</operator><name>LONG</name><operator>)</operator><operator>(</operator><name>offset</name> <operator>&amp;</operator> <literal type="number">0xffffffff</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>overlapped</name><operator>.</operator><name>OffsetHigh</name></name> <operator>=</operator> <operator>(</operator><name>LONG</name><operator>)</operator><operator>(</operator><operator>(</operator><name>offset</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7fffffff</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>aRem</name> <operator>+=</operator> <name>nWrite</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nRem</name> <operator>-=</operator> <name>nWrite</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nRem</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>lastErrno</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>(   <expr><operator>(</operator> <name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name><operator>==</operator><name>ERROR_HANDLE_DISK_FULL</name> <operator>)</operator>
       <operator>||</operator> <operator>(</operator> <name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name><operator>==</operator><name>ERROR_DISK_FULL</name> <operator>)</operator></expr>)</condition><block>{<block_content>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WRITE pid=%lu, pFile=%p, file=%p, rc=SQLITE_FULL\n"</literal><operator>,</operator>
               <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_FULL</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>,
                         <argument><expr><literal type="string">"winWrite1"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WRITE pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_WRITE\n"</literal><operator>,</operator>
             <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_WRITE</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>,
                       <argument><expr><literal type="string">"winWrite2"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>winLogIoerr</name><argument_list>(<argument><expr><name>nRetry</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"WRITE pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n"</literal><operator>,</operator>
           <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/*
** Truncate an open file to a specified size
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winTruncate</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* File handle object */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>             <comment type="block">/* Return code for this function */</comment>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>lastErrno</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>SimulateIOError</name><argument_list>(<argument>return SQLITE_IOERR_TRUNCATE</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TRUNCATE pid=%lu, pFile=%p, file=%p, size=%lld, lock=%d\n"</literal><operator>,</operator>
           <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>nByte</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the user has configured a chunk-size for this file, truncate the
  ** file so that it consists of an integer number of chunks (i.e. the
  ** actual file size after the operation may be larger than the requested
  ** size).
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>szChunk</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>nByte</name> <operator>+</operator> <name><name>pFile</name><operator>-&gt;</operator><name>szChunk</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>/</operator><name><name>pFile</name><operator>-&gt;</operator><name>szChunk</name></name><operator>)</operator> <operator>*</operator> <name><name>pFile</name><operator>-&gt;</operator><name>szChunk</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* SetEndOfFile() returns non-zero when successful, or zero when it fails. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>winSeekFile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_TRUNCATE</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>,
                     <argument><expr><literal type="string">"winTruncate1"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><literal type="number">0</literal><operator>==</operator><call><name>osSetEndOfFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>(</operator><operator>(</operator><name>lastErrno</name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call><operator>)</operator><operator>!=</operator><name>ERROR_USER_MAPPED_FILE</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>lastErrno</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_TRUNCATE</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>,
                     <argument><expr><literal type="string">"winTruncate2"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <comment type="block">/* If the file was truncated to a size smaller than the currently
  ** mapped region, reduce the effective mapping size as well. SQLite will
  ** use read() and write() to access data beyond this point from now on.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>pMapRegion</name></name> <operator>&amp;&amp;</operator> <name>nByte</name><operator>&lt;</operator><name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TRUNCATE pid=%lu, pFile=%p, file=%p, rc=%s\n"</literal><operator>,</operator>
           <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<comment type="block">/*
** Count the number of fullsyncs and normal syncs.  This is used to test
** that syncs and fullsyncs are occuring at the right times.
*/</comment>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_sync_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_fullsync_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Make sure all writes to a particular file are committed to disk.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winSync</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_NO_SYNC</name></cpp:ifndef>
  <comment type="block">/*
  ** Used only when SQLITE_NO_SYNC is not defined.
   */</comment>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>rc</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_NO_SYNC</name></expr></argument>)</argument_list></call> <operator>||</operator> \
    <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_HAVE_OS_TRACE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/*
  ** Used when SQLITE_NO_SYNC is not defined and by the assert() and/or
  ** OSTRACE() macros.
   */</comment>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Check that one of SQLITE_SYNC_NORMAL or FULL was passed */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name><operator>&amp;</operator><literal type="number">0x0F</literal><operator>)</operator><operator>==</operator><name>SQLITE_SYNC_NORMAL</name>
      <operator>||</operator> <operator>(</operator><name>flags</name><operator>&amp;</operator><literal type="number">0x0F</literal><operator>)</operator><operator>==</operator><name>SQLITE_SYNC_FULL</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Unix cannot, but some systems may return SQLITE_FULL from here. This
  ** line is to test that doing so does not cause any problems.
  */</comment>
  <macro><name>SimulateDiskfullError</name><argument_list>( <argument>return SQLITE_FULL</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>

  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SYNC pid=%lu, pFile=%p, file=%p, flags=%x, lock=%d\n"</literal><operator>,</operator>
           <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>flags</name><operator>,</operator>
           <name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifndef>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>flags</name><operator>&amp;</operator><literal type="number">0x0F</literal><operator>)</operator><operator>==</operator><name>SQLITE_SYNC_FULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>sqlite3_fullsync_count</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>sqlite3_sync_count</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If we compiled with the SQLITE_NO_SYNC flag, then syncing is a
  ** no-op
  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_NO_SYNC</name></cpp:ifdef>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SYNC-NOP pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n"</literal><operator>,</operator>
           <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>pMapRegion</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>osFlushViewOfFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>pMapRegion</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SYNC-MMAP pid=%lu, pFile=%p, pMapRegion=%p, "</literal>
               <literal type="string">"rc=SQLITE_OK\n"</literal><operator>,</operator> <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator>
               <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pMapRegion</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SYNC-MMAP pid=%lu, pFile=%p, pMapRegion=%p, "</literal>
               <literal type="string">"rc=SQLITE_IOERR_MMAP\n"</literal><operator>,</operator> <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator>
               <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pMapRegion</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_MMAP</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>,
                         <argument><expr><literal type="string">"winSync1"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>osFlushFileBuffers</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SimulateIOError</name><argument_list>( <argument><expr><name>rc</name><operator>=</operator><name>FALSE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SYNC pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n"</literal><operator>,</operator>
             <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SYNC pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_FSYNC\n"</literal><operator>,</operator>
             <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_FSYNC</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>,
                       <argument><expr><literal type="string">"winSync2"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** Determine the current size of a file in bytes
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winFileSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>pSize</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>id</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pSize</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <macro><name>SimulateIOError</name><argument_list>(<argument>return SQLITE_IOERR_FSTAT</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SIZE file=%p, pSize=%p\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>pSize</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINRT</name></expr></cpp:if>
  <block>{<block_content>
    <decl_stmt><decl><type><name>FILE_STANDARD_INFO</name></type> <name>info</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>osGetFileInformationByHandleEx</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>FileStandardInfo</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pSize</name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>EndOfFile</name><operator>.</operator><name>QuadPart</name></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_FSTAT</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>,
                       <argument><expr><literal type="string">"winFileSize"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <block>{<block_content>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>upperBits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>lowerBits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>lastErrno</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>lowerBits</name> <operator>=</operator> <call><name>osGetFileSize</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upperBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pSize</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>upperBits</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator> <operator>+</operator> <name>lowerBits</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(   <expr><operator>(</operator><name>lowerBits</name> <operator>==</operator> <name>INVALID_FILE_SIZE</name><operator>)</operator>
       <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>lastErrno</name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call><operator>)</operator><operator>!=</operator><name>NO_ERROR</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>lastErrno</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_FSTAT</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>,
                       <argument><expr><literal type="string">"winFileSize"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SIZE file=%p, pSize=%p, *pSize=%lld, rc=%s\n"</literal><operator>,</operator>
           <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>pSize</name><operator>,</operator> <operator>*</operator><name>pSize</name><operator>,</operator> <call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** LOCKFILE_FAIL_IMMEDIATELY is undefined on some Windows systems.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LOCKFILE_FAIL_IMMEDIATELY</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>LOCKFILE_FAIL_IMMEDIATELY</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LOCKFILE_EXCLUSIVE_LOCK</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>LOCKFILE_EXCLUSIVE_LOCK</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Historically, SQLite has used both the LockFile and LockFileEx functions.
** When the LockFile function was used, it was always expected to fail
** immediately if the lock could not be obtained.  Also, it always expected to
** obtain an exclusive lock.  These flags are used with the LockFileEx function
** and reflect those expectations; therefore, they should not be changed.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_LOCKFILE_FLAGS</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_LOCKFILE_FLAGS</name></cpp:macro>   <cpp:value>(LOCKFILE_FAIL_IMMEDIATELY | \
                                  LOCKFILE_EXCLUSIVE_LOCK)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Currently, SQLite never calls the LockFileEx function without wanting the
** call to fail immediately if the lock cannot be obtained.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_LOCKFILEEX_FLAGS</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_LOCKFILEEX_FLAGS</name></cpp:macro> <cpp:value>(LOCKFILE_FAIL_IMMEDIATELY)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Acquire a reader lock.
** Different API routines are called depending on whether or not this
** is Win9x or WinNT.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winGetReadLock</name><parameter_list>(<parameter><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"READ-LOCK file=%p, lock=%d\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>osIsNT</name><argument_list>()</argument_list></call></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINCE</name></expr></cpp:if>
    <comment type="block">/*
    ** NOTE: Windows CE is handled differently here due its lack of the Win32
    **       API LockFileEx.
    */</comment>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>winceLockFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>SHARED_FIRST</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>winLockFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>SQLITE_LOCKFILEEX_FLAGS</name></expr></argument>, <argument><expr><name>SHARED_FIRST</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                      <argument><expr><name>SHARED_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_WIN32_HAS_ANSI</name></cpp:ifdef>
  <else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>lk</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lk</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>lk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>sharedLockByte</name></name> <operator>=</operator> <operator>(</operator><name>short</name><operator>)</operator><operator>(</operator><operator>(</operator><name>lk</name> <operator>&amp;</operator> <literal type="number">0x7fffffff</literal><operator>)</operator><operator>%</operator><operator>(</operator><name>SHARED_SIZE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>winLockFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>SQLITE_LOCKFILE_FLAGS</name></expr></argument>,
                      <argument><expr><name>SHARED_FIRST</name><operator>+</operator><name><name>pFile</name><operator>-&gt;</operator><name>sharedLockByte</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* No need to log a failure to lock */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"READ-LOCK file=%p, result=%d\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>res</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Undo a readlock
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winUnlockReadLock</name><parameter_list>(<parameter><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>lastErrno</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"READ-UNLOCK file=%p, lock=%d\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>osIsNT</name><argument_list>()</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>winUnlockFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>SHARED_FIRST</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SHARED_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_WIN32_HAS_ANSI</name></cpp:ifdef>
  <else>else<block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>winUnlockFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>SHARED_FIRST</name><operator>+</operator><name><name>pFile</name><operator>-&gt;</operator><name>sharedLockByte</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>res</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>lastErrno</name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call><operator>)</operator><operator>!=</operator><name>ERROR_NOT_LOCKED</name><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>lastErrno</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_UNLOCK</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>,
                <argument><expr><literal type="string">"winUnlockReadLock"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"READ-UNLOCK file=%p, result=%d\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>res</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Lock the file with the lock specified by parameter locktype - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -&gt; SHARED
**    SHARED -&gt; RESERVED
**    SHARED -&gt; (PENDING) -&gt; EXCLUSIVE
**    RESERVED -&gt; (PENDING) -&gt; EXCLUSIVE
**    PENDING -&gt; EXCLUSIVE
**
** This routine will only increase a lock.  The winUnlock() routine
** erases all locks at once and returns us immediately to locking level 0.
** It is not possible to lower the locking level one step at a time.  You
** must go straight to locking level 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>locktype</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* Return code from subroutines */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Result of a Windows lock call */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>newLocktype</name></decl>;</decl_stmt>       <comment type="block">/* Set pFile-&gt;locktype to this value before exiting */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>gotPendingLock</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt><comment type="block">/* True if we acquired a PENDING lock this time */</comment>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>lastErrno</name> <init>= <expr><name>NO_ERROR</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>id</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"LOCK file=%p, oldLock=%d(%d), newLock=%d\n"</literal><operator>,</operator>
           <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>sharedLockByte</name></name><operator>,</operator> <name>locktype</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there is already a lock of this type or more restrictive on the
  ** OsFile, do nothing. Don't use the end_lock: exit path, as
  ** sqlite3OsEnterMutex() hasn't been called yet.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>&gt;=</operator><name>locktype</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"LOCK-HELD file=%p, rc=SQLITE_OK\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Do not allow any kind of write-lock on a read-only database
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>&amp;</operator> <name>WINFILE_RDONLY</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>locktype</name><operator>&gt;=</operator><name>RESERVED_LOCK</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_IOERR_LOCK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Make sure the locking sequence is correct
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>!=</operator><name>NO_LOCK</name> <operator>||</operator> <name>locktype</name><operator>==</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>locktype</name><operator>!=</operator><name>PENDING_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>locktype</name><operator>!=</operator><name>RESERVED_LOCK</name> <operator>||</operator> <name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>==</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Lock the PENDING_LOCK byte if we need to acquire a PENDING lock or
  ** a SHARED lock.  If we are acquiring a SHARED lock, the acquisition of
  ** the PENDING_LOCK byte is temporary.
  */</comment>
  <expr_stmt><expr><name>newLocktype</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>(   <expr><operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>==</operator><name>NO_LOCK</name><operator>)</operator>
     <operator>||</operator> <operator>(</operator>   <operator>(</operator><name>locktype</name><operator>==</operator><name>EXCLUSIVE_LOCK</name><operator>)</operator>
         <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>==</operator><name>RESERVED_LOCK</name><operator>)</operator><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name>cnt</name><operator>--</operator><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>res</name> <operator>=</operator> <call><name>winLockFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>SQLITE_LOCKFILE_FLAGS</name></expr></argument>,
                                         <argument><expr><name>PENDING_BYTE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Try 3 times to get the pending lock.  This is needed to work
      ** around problems caused by indexing and/or anti-virus software on
      ** Windows systems.
      ** If you are using this code as a model for alternative VFSes, do not
      ** copy this retry logic.  It is a hack intended for Windows only.
      */</comment>
      <expr_stmt><expr><name>lastErrno</name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"LOCK-PENDING-FAIL file=%p, count=%d, result=%d\n"</literal><operator>,</operator>
               <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>cnt</name><operator>,</operator> <name>res</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>lastErrno</name><operator>==</operator><name>ERROR_INVALID_HANDLE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>lastErrno</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_LOCK</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"LOCK-FAIL file=%p, count=%d, rc=%s\n"</literal><operator>,</operator>
                 <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>cnt</name><operator>,</operator> <call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>cnt</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_win32_sleep</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>gotPendingLock</name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>res</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>lastErrno</name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Acquire a shared lock
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>locktype</name><operator>==</operator><name>SHARED_LOCK</name> <operator>&amp;&amp;</operator> <name>res</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>==</operator><name>NO_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>winGetReadLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>newLocktype</name> <operator>=</operator> <name>SHARED_LOCK</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>lastErrno</name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Acquire a RESERVED lock
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>locktype</name><operator>==</operator><name>RESERVED_LOCK</name> <operator>&amp;&amp;</operator> <name>res</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>==</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>winLockFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>SQLITE_LOCKFILE_FLAGS</name></expr></argument>, <argument><expr><name>RESERVED_BYTE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>newLocktype</name> <operator>=</operator> <name>RESERVED_LOCK</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>lastErrno</name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Acquire a PENDING lock
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>locktype</name><operator>==</operator><name>EXCLUSIVE_LOCK</name> <operator>&amp;&amp;</operator> <name>res</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>newLocktype</name> <operator>=</operator> <name>PENDING_LOCK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>gotPendingLock</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Acquire an EXCLUSIVE lock
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>locktype</name><operator>==</operator><name>EXCLUSIVE_LOCK</name> <operator>&amp;&amp;</operator> <name>res</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>&gt;=</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>winUnlockReadLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>winLockFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>SQLITE_LOCKFILE_FLAGS</name></expr></argument>, <argument><expr><name>SHARED_FIRST</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                      <argument><expr><name>SHARED_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>newLocktype</name> <operator>=</operator> <name>EXCLUSIVE_LOCK</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>lastErrno</name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>winGetReadLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* If we are holding a PENDING lock that ought to be released, then
  ** release it now.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>gotPendingLock</name> <operator>&amp;&amp;</operator> <name>locktype</name><operator>==</operator><name>SHARED_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>winUnlockFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>PENDING_BYTE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Update the state of the lock has held in the file descriptor then
  ** return the appropriate result code.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>lastErrno</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"LOCK-FAIL file=%p, wanted=%d, got=%d\n"</literal><operator>,</operator>
             <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>locktype</name><operator>,</operator> <name>newLocktype</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>newLocktype</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"LOCK file=%p, lock=%d, rc=%s\n"</literal><operator>,</operator>
           <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>,</operator> <call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, return
** non-zero, otherwise zero.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>

  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_CHECKRESERVEDLOCK;</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEST-WR-LOCK file=%p, pResOut=%p\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>pResOut</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>id</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>&gt;=</operator><name>RESERVED_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEST-WR-LOCK file=%p, result=%d (local)\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>res</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>winLockFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>SQLITE_LOCKFILEEX_FLAGS</name></expr></argument>,<argument><expr><name>RESERVED_BYTE</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>res</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>winUnlockFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>RESERVED_BYTE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>!</operator><name>res</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEST-WR-LOCK file=%p, result=%d (remote)\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>res</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEST-WR-LOCK file=%p, pResOut=%p, *pResOut=%d, rc=SQLITE_OK\n"</literal><operator>,</operator>
           <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>pResOut</name><operator>,</operator> <operator>*</operator><name>pResOut</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Lower the locking level on file descriptor id to locktype.  locktype
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
**
** It is not possible for this routine to fail if the second argument
** is NO_LOCK.  If the second argument is SHARED_LOCK then this routine
** might return SQLITE_IOERR;
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>locktype</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>locktype</name><operator>&lt;=</operator><name>SHARED_LOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"UNLOCK file=%p, oldLock=%d(%d), newLock=%d\n"</literal><operator>,</operator>
           <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>sharedLockByte</name></name><operator>,</operator> <name>locktype</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>type</name><operator>&gt;=</operator><name>EXCLUSIVE_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>winUnlockFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>SHARED_FIRST</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SHARED_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>locktype</name><operator>==</operator><name>SHARED_LOCK</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>winGetReadLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <comment type="block">/* This should never happen.  We should always be able to
      ** reacquire the read lock */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_UNLOCK</name></expr></argument>, <argument><expr><call><name>osGetLastError</name><argument_list>()</argument_list></call></expr></argument>,
                       <argument><expr><literal type="string">"winUnlock"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>type</name><operator>&gt;=</operator><name>RESERVED_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>winUnlockFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>RESERVED_BYTE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>locktype</name><operator>==</operator><name>NO_LOCK</name> <operator>&amp;&amp;</operator> <name>type</name><operator>&gt;=</operator><name>SHARED_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>winUnlockReadLock</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>type</name><operator>&gt;=</operator><name>PENDING_LOCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>winUnlockFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>PENDING_BYTE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>locktype</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"UNLOCK file=%p, lock=%d, rc=%s\n"</literal><operator>,</operator>
           <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name><operator>,</operator> <call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If *pArg is initially negative then this is a query.  Set *pArg to
** 1 or 0 depending on whether or not bit mask of pFile-&gt;ctrlFlags is set.
**
** If *pArg is 0 or 1, then clear or set the mask bit of pFile-&gt;ctrlFlags.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>winModeBit</name><parameter_list>(<parameter><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pArg</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pArg</name> <operator>=</operator> <operator>(</operator><name><name>pFile</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><operator>*</operator><name>pArg</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>|=</operator> <name>mask</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Forward references to VFS helper methods used for temporary files */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>winGetTempname</name><argument_list>(<argument><expr><name>sqlite3_vfs</name> <operator>*</operator></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>winIsDir</name><argument_list>(<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>winIsDriveLetterAndColon</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<comment type="block">/*
** Control and query of the open file handle.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winFileControl</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FCNTL file=%p, op=%d, pArg=%p\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <name>op</name><operator>,</operator> <name>pArg</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_FCNTL_LOCKSTATE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>locktype</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FCNTL file=%p, rc=SQLITE_OK\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_LAST_ERRNO</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FCNTL file=%p, rc=SQLITE_OK\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_FCNTL_CHUNK_SIZE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>szChunk</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>pArg</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FCNTL file=%p, rc=SQLITE_OK\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_FCNTL_SIZE_HINT</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>szChunk</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>oldSz</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>winFileSize</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldSz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>newSz</name> <init>= <expr><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>newSz</name><operator>&gt;</operator><name>oldSz</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>SimulateIOErrorBenign</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winTruncate</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>newSz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SimulateIOErrorBenign</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FCNTL file=%p, rc=%s\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FCNTL file=%p, rc=SQLITE_OK\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_FCNTL_PERSIST_WAL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>winModeBit</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>WINFILE_PERSIST_WAL</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FCNTL file=%p, rc=SQLITE_OK\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_FCNTL_POWERSAFE_OVERWRITE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>winModeBit</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><name>WINFILE_PSOW</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FCNTL file=%p, rc=SQLITE_OK\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_FCNTL_VFSNAME</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>pVfs</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FCNTL file=%p, rc=SQLITE_OK\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_FCNTL_WIN32_AV_RETRY</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>winIoerrRetry</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>winIoerrRetry</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>winIoerrRetryDelay</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>winIoerrRetryDelay</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FCNTL file=%p, rc=SQLITE_OK\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
    <case>case <expr><name>SQLITE_FCNTL_WIN32_SET_HANDLE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>LPHANDLE</name></type> <name>phFile</name> <init>= <expr><operator>(</operator><name>LPHANDLE</name><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>HANDLE</name></type> <name>hOldFile</name> <init>= <expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <operator>*</operator><name>phFile</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>phFile</name> <operator>=</operator> <name>hOldFile</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FCNTL oldFile=%p, newFile=%p, rc=SQLITE_OK\n"</literal><operator>,</operator>
               <name>hOldFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>SQLITE_FCNTL_TEMPFILENAME</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTFile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>winGetTempname</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zTFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <name>zTFile</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FCNTL file=%p, rc=%s\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
    <case>case <expr><name>SQLITE_FCNTL_MMAP_SIZE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>newLimit</name> <init>= <expr><operator>*</operator><operator>(</operator><name>i64</name><operator>*</operator><operator>)</operator><name>pArg</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>newLimit</name><operator>&gt;</operator><name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mxMmap</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>newLimit</name> <operator>=</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>mxMmap</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>i64</name><operator>*</operator><operator>)</operator><name>pArg</name> <operator>=</operator> <name><name>pFile</name><operator>-&gt;</operator><name>mmapSizeMax</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>newLimit</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>newLimit</name><operator>!=</operator><name><name>pFile</name><operator>-&gt;</operator><name>mmapSizeMax</name></name> <operator>&amp;&amp;</operator> <name><name>pFile</name><operator>-&gt;</operator><name>nFetchOut</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>mmapSizeMax</name></name> <operator>=</operator> <name>newLimit</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>winUnmapfile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winMapfile</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FCNTL file=%p, rc=%s\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>,</operator> <call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FCNTL file=%p, rc=SQLITE_NOTFOUND\n"</literal><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the sector size in bytes of the underlying block device for
** the specified file. This is almost always 512 bytes, but may be
** larger for some devices.
**
** SQLite code assumes this function cannot fail. It also assumes that
** if two files are created in the same file-system directory (i.e.
** a database and its journal file) that the sector size will be the
** same for both.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winSectorSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>id</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_DEFAULT_SECTOR_SIZE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return a vector of device characteristics.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winDeviceCharacteristics</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name>SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN</name> <operator>|</operator>
         <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>&amp;</operator> <name>WINFILE_PSOW</name><operator>)</operator></expr>?</condition><then><expr><name>SQLITE_IOCAP_POWERSAFE_OVERWRITE</name></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Windows will only let you create file view mappings
** on allocation size granularity boundaries.
** During sqlite3_os_init() we do a GetSystemInfo()
** to get the granularity size.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SYSTEM_INFO</name></type> <name>winSysInfo</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_WAL</name></cpp:ifndef>

<comment type="block">/*
** Helper functions to obtain and relinquish the global mutex. The
** global mutex is used to protect the winLockInfo objects used by
** this file, all of which may be shared by multiple threads.
**
** Function winShmMutexHeld() is used to assert() that the global mutex
** is held when required. This function is only used as part of assert()
** statements. e.g.
**
**   winShmEnterMutex()
**     assert( winShmMutexHeld() );
**   winShmLeaveMutex()
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>winShmEnterMutex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_VFS1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>winShmLeaveMutex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_VFS1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winShmMutexHeld</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><call><name>sqlite3MutexAlloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_STATIC_VFS1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Object used to represent a single file opened and mmapped to provide
** shared memory.  When multiple threads all reference the same
** log-summary, each thread has its own winFile object, but they all
** point to a single instance of this object.  In other words, each
** log-summary is opened only once per process.
**
** winShmMutexHeld() must be true when creating or destroying
** this object or while reading or writing the following fields:
**
**      nRef
**      pNext
**
** The following fields are read-only after the object is created:
**
**      fid
**      zFilename
**
** Either winShmNode.mutex must be held or winShmNode.nRef==0 and
** winShmMutexHeld() is true when reading or writing any other field
** in this structure.
**
*/</comment>
<struct>struct <name>winShmNode</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_mutex</name> <modifier>*</modifier></type><name>mutex</name></decl>;</decl_stmt>      <comment type="block">/* Mutex to access this object */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl>;</decl_stmt>           <comment type="block">/* Name of the file */</comment>
  <decl_stmt><decl><type><name>winFile</name></type> <name>hFile</name></decl>;</decl_stmt>             <comment type="block">/* File handle from winOpen */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>szRegion</name></decl>;</decl_stmt>              <comment type="block">/* Size of shared-memory regions */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRegion</name></decl>;</decl_stmt>               <comment type="block">/* Size of array apRegion */</comment>
  <struct>struct <name>ShmRegion</name> <block>{
    <decl_stmt><decl><type><name>HANDLE</name></type> <name>hMap</name></decl>;</decl_stmt>             <comment type="block">/* File handle from CreateFileMapping */</comment>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pMap</name></decl>;</decl_stmt>
  }</block> <decl><modifier>*</modifier><name>aRegion</name></decl>;</struct>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>lastErrno</name></decl>;</decl_stmt>           <comment type="block">/* The Windows errno from the last I/O error */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>nRef</name></decl>;</decl_stmt>                  <comment type="block">/* Number of winShm objects pointing to this */</comment>
  <decl_stmt><decl><type><name>winShm</name> <modifier>*</modifier></type><name>pFirst</name></decl>;</decl_stmt>            <comment type="block">/* All winShm objects pointing to this */</comment>
  <decl_stmt><decl><type><name>winShmNode</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>         <comment type="block">/* Next in list of all winShmNode objects */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_HAVE_OS_TRACE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>u8</name></type> <name>nextShmId</name></decl>;</decl_stmt>              <comment type="block">/* Next available winShm.id value */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<comment type="block">/*
** A global array of all winShmNode objects.
**
** The winShmMutexHeld() must be true while reading or writing this list.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>winShmNode</name> <modifier>*</modifier></type><name>winShmNodeList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Structure used internally by this VFS to record the state of an
** open shared memory connection.
**
** The following fields are initialized when this object is created and
** are read-only thereafter:
**
**    winShm.pShmNode
**    winShm.id
**
** All other fields are read/write.  The winShm.pShmNode-&gt;mutex must be held
** while accessing any read/write fields.
*/</comment>
<struct>struct <name>winShm</name> <block>{
  <decl_stmt><decl><type><name>winShmNode</name> <modifier>*</modifier></type><name>pShmNode</name></decl>;</decl_stmt>      <comment type="block">/* The underlying winShmNode object */</comment>
  <decl_stmt><decl><type><name>winShm</name> <modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>             <comment type="block">/* Next winShm with the same winShmNode */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>hasMutex</name></decl>;</decl_stmt>               <comment type="block">/* True if holding the winShmNode mutex */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>sharedMask</name></decl>;</decl_stmt>            <comment type="block">/* Mask of shared locks held */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>exclMask</name></decl>;</decl_stmt>              <comment type="block">/* Mask of exclusive locks held */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_HAVE_OS_TRACE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>u8</name></type> <name>id</name></decl>;</decl_stmt>                     <comment type="block">/* Id of this connection with its winShmNode */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<comment type="block">/*
** Constants used for locking
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN_SHM_BASE</name></cpp:macro>   <cpp:value>((22+SQLITE_SHM_NLOCK)*4)</cpp:value></cpp:define>        <comment type="block">/* first lock byte */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN_SHM_DMS</name></cpp:macro>    <cpp:value>(WIN_SHM_BASE+SQLITE_SHM_NLOCK)</cpp:value></cpp:define>  <comment type="block">/* deadman switch */</comment>

<comment type="block">/*
** Apply advisory locks for all n bytes beginning at ofst.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_SHM_UNLCK</name></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_SHM_RDLCK</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_SHM_WRLCK</name></cpp:macro>  <cpp:value>3</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winShmSystemLock</name><parameter_list>(
  <parameter><decl><type><name>winShmNode</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>,    <comment type="block">/* Apply locks to this open shared-memory segment */</comment>
  <parameter><decl><type><name>int</name></type> <name>lockType</name></decl></parameter>,         <comment type="block">/* _SHM_UNLCK, _SHM_RDLCK, or _SHM_WRLCK */</comment>
  <parameter><decl><type><name>int</name></type> <name>ofst</name></decl></parameter>,             <comment type="block">/* Offset to first byte to be locked/unlocked */</comment>
  <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>             <comment type="block">/* Number of bytes to lock or unlock */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* Result code form Lock/UnlockFileEx() */</comment>

  <comment type="block">/* Access to the winShmNode object is serialized by the caller */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>pFile</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SHM-LOCK file=%p, lock=%d, offset=%d, size=%d\n"</literal><operator>,</operator>
           <name><name>pFile</name><operator>-&gt;</operator><name>hFile</name><operator>.</operator><name>h</name></name><operator>,</operator> <name>lockType</name><operator>,</operator> <name>ofst</name><operator>,</operator> <name>nByte</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Release/Acquire the system-level lock */</comment>
  <if_stmt><if>if<condition>( <expr><name>lockType</name><operator>==</operator><name>_SHM_UNLCK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winUnlockFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFile</name><operator>-&gt;</operator><name>hFile</name><operator>.</operator><name>h</name></name></expr></argument>, <argument><expr><name>ofst</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Initialize the locking parameters */</comment>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>dwFlags</name> <init>= <expr><name>LOCKFILE_FAIL_IMMEDIATELY</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>lockType</name> <operator>==</operator> <name>_SHM_WRLCK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dwFlags</name> <operator>|=</operator> <name>LOCKFILE_EXCLUSIVE_LOCK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winLockFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pFile</name><operator>-&gt;</operator><name>hFile</name><operator>.</operator><name>h</name></name></expr></argument>, <argument><expr><name>dwFlags</name></expr></argument>, <argument><expr><name>ofst</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator>  <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SHM-LOCK file=%p, func=%s, errno=%lu, rc=%s\n"</literal><operator>,</operator>
           <name><name>pFile</name><operator>-&gt;</operator><name>hFile</name><operator>.</operator><name>h</name></name><operator>,</operator> <ternary><condition><expr><operator>(</operator><name>lockType</name> <operator>==</operator> <name>_SHM_UNLCK</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"winUnlockFile"</literal></expr> </then><else>:
           <expr><literal type="string">"winLockFile"</literal></expr></else></ternary><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name><operator>,</operator> <call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Forward references to VFS methods */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>winOpen</name><argument_list>(<argument><expr><name>sqlite3_vfs</name><operator>*</operator></expr></argument>,<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>,<argument><expr><name>sqlite3_file</name><operator>*</operator></expr></argument>,<argument><expr><name>int</name></expr></argument>,<argument><expr><name>int</name><operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>winDelete</name><argument_list>(<argument><expr><name>sqlite3_vfs</name> <operator>*</operator></expr></argument>,<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<comment type="block">/*
** Purge the winShmNodeList list of all entries with winShmNode.nRef==0.
**
** This is not a VFS shared-memory method; it is a utility function called
** by VFS shared-memory methods.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>winShmPurge</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deleteFlag</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>winShmNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>winShmNode</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>winShmMutexHeld</name><argument_list>()</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SHM-PURGE pid=%lu, deleteFlag=%d\n"</literal><operator>,</operator>
           <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>deleteFlag</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pp</name> <operator>=</operator> <operator>&amp;</operator><name>winShmNodeList</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>p</name> <operator>=</operator> <operator>*</operator><name>pp</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>mutex</name></name></expr> )</condition><block>{<block_content> <expr_stmt><expr><call><name>sqlite3_mutex_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nRegion</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>bRc</name> <init>= <expr><call><name>osUnmapViewOfFile</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aRegion</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pMap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SHM-PURGE-UNMAP pid=%lu, region=%d, rc=%s\n"</literal><operator>,</operator>
                 <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>i</name><operator>,</operator> <ternary><condition><expr><name>bRc</name></expr> ?</condition><then> <expr><literal type="string">"ok"</literal></expr> </then><else>: <expr><literal type="string">"failed"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UNUSED_VARIABLE_VALUE</name><argument_list>(<argument><expr><name>bRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bRc</name> <operator>=</operator> <call><name>osCloseHandle</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aRegion</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>hMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SHM-PURGE-CLOSE pid=%lu, region=%d, rc=%s\n"</literal><operator>,</operator>
                 <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>i</name><operator>,</operator> <ternary><condition><expr><name>bRc</name></expr> ?</condition><then> <expr><literal type="string">"ok"</literal></expr> </then><else>: <expr><literal type="string">"failed"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>UNUSED_VARIABLE_VALUE</name><argument_list>(<argument><expr><name>bRc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>hFile</name><operator>.</operator><name>h</name></name><operator>!=</operator><name>NULL</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>hFile</name><operator>.</operator><name>h</name></name><operator>!=</operator><name>INVALID_HANDLE_VALUE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>SimulateIOErrorBenign</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>winClose</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_file</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>hFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SimulateIOErrorBenign</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>deleteFlag</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>SimulateIOErrorBenign</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3BeginBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>winDelete</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3EndBenignMalloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SimulateIOErrorBenign</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aRegion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pp</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
** Open the shared-memory area associated with database file pDbFd.
**
** When opening a new shared-memory file, if no other instances of that
** file are currently open, in this process or in other processes, then
** the file must be truncated to zero length or have its header cleared.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winOpenSharedMemory</name><parameter_list>(<parameter><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pDbFd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>winShm</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>                  <comment type="block">/* The connection to be opened */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>winShmNode</name></name> <modifier>*</modifier></type><name>pShmNode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* The underlying mmapped file */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                            <comment type="block">/* Result code */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>winShmNode</name></name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>           <comment type="block">/* Newly allocated winShmNode */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>                         <comment type="block">/* Size of zName in bytes */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pDbFd</name><operator>-&gt;</operator><name>pShm</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* Not previously opened */</comment>

  <comment type="block">/* Allocate space for the new sqlite3_shm object.  Also speculatively
  ** allocate space for a new winShmNode and filename.
  */</comment>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3MallocZero</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nName</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pDbFd</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3MallocZero</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pShmNode</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nName</name> <operator>+</operator> <literal type="number">17</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zFilename</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nName</name><operator>+</operator><literal type="number">15</literal></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>, <argument><expr><literal type="string">"%s-shm"</literal></expr></argument>, <argument><expr><name><name>pDbFd</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3FileSuffix3</name><argument_list>(<argument><expr><name><name>pDbFd</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Look to see if there is an existing winShmNode that can be used.
  ** If no matching winShmNode currently exists, create a new one.
  */</comment>
  <expr_stmt><expr><call><name>winShmEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pShmNode</name> <operator>=</operator> <name>winShmNodeList</name></expr>;</init> <condition><expr><name>pShmNode</name></expr>;</condition> <incr><expr><name>pShmNode</name><operator>=</operator><name><name>pShmNode</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <comment type="block">/* TBD need to come up with better match here.  Perhaps
    ** use FILE_ID_BOTH_DIR_INFO Structure.
    */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrICmp</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>, <argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>pShmNode</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pShmNode</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>pShmNode</name><operator>-&gt;</operator><name>hFile</name></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>h</name> <operator>=</operator> <name>INVALID_HANDLE_VALUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>winShmNodeList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>winShmNodeList</name> <operator>=</operator> <name>pShmNode</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name> <operator>=</operator> <call><name>sqlite3_mutex_alloc</name><argument_list>(<argument><expr><name>SQLITE_MUTEX_FAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_NOMEM</name></expr>;</expr_stmt>
      <goto>goto <name>shm_open_err</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winOpen</name><argument_list>(<argument><expr><name><name>pDbFd</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>,
                 <argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>zFilename</name></name></expr></argument>,             <comment type="block">/* Name of the file (UTF-8) */</comment>
                 <argument><expr><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pShmNode</name><operator>-&gt;</operator><name>hFile</name></name></expr></argument>,  <comment type="block">/* File handle here */</comment>
                 <argument><expr><name>SQLITE_OPEN_WAL</name> <operator>|</operator> <name>SQLITE_OPEN_READWRITE</name> <operator>|</operator> <name>SQLITE_OPEN_CREATE</name></expr></argument>,
                 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><name>rc</name></expr> )</condition><block>{<block_content>
      <goto>goto <name>shm_open_err</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check to see if another process is holding the dead-man switch.
    ** If not, truncate the file to zero length.
    */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>winShmSystemLock</name><argument_list>(<argument><expr><name>pShmNode</name></expr></argument>, <argument><expr><name>_SHM_WRLCK</name></expr></argument>, <argument><expr><name>WIN_SHM_DMS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winTruncate</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_file</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pShmNode</name><operator>-&gt;</operator><name>hFile</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_SHMOPEN</name></expr></argument>, <argument><expr><call><name>osGetLastError</name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><literal type="string">"winOpenShm"</literal></expr></argument>, <argument><expr><name><name>pDbFd</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>winShmSystemLock</name><argument_list>(<argument><expr><name>pShmNode</name></expr></argument>, <argument><expr><name>_SHM_UNLCK</name></expr></argument>, <argument><expr><name>WIN_SHM_DMS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winShmSystemLock</name><argument_list>(<argument><expr><name>pShmNode</name></expr></argument>, <argument><expr><name>_SHM_RDLCK</name></expr></argument>, <argument><expr><name>WIN_SHM_DMS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>shm_open_err</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Make the new connection a child of the winShmNode */</comment>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pShmNode</name></name> <operator>=</operator> <name>pShmNode</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_DEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_HAVE_OS_TRACE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name><name>pShmNode</name><operator>-&gt;</operator><name>nextShmId</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDbFd</name><operator>-&gt;</operator><name>pShm</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>winShmLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The reference count on pShmNode has already been incremented under
  ** the cover of the winShmEnterMutex() mutex and the pointer from the
  ** new (struct winShm) object to the pShmNode has been set. All that is
  ** left to do is to link the new object into the linked list starting
  ** at pShmNode-&gt;pFirst. This must be done while holding the pShmNode-&gt;mutex
  ** mutex.
  */</comment>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pShmNode</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>pFirst</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>

  <comment type="block">/* Jump here on any error */</comment>
<label><name>shm_open_err</name>:</label>
  <expr_stmt><expr><call><name>winShmSystemLock</name><argument_list>(<argument><expr><name>pShmNode</name></expr></argument>, <argument><expr><name>_SHM_UNLCK</name></expr></argument>, <argument><expr><name>WIN_SHM_DMS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>winShmPurge</name><argument_list>(<argument><expr><name><name>pDbFd</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* This call frees pShmNode if required */</comment>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>winShmLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Close a connection to shared-memory.  Delete the underlying
** storage if deleteFlag is true.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winShmUnmap</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>,          <comment type="block">/* Database holding shared memory */</comment>
  <parameter><decl><type><name>int</name></type> <name>deleteFlag</name></decl></parameter>             <comment type="block">/* Delete after closing if true */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pDbFd</name></decl>;</decl_stmt>       <comment type="block">/* Database holding shared-memory */</comment>
  <decl_stmt><decl><type><name>winShm</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>            <comment type="block">/* The connection to be closed */</comment>
  <decl_stmt><decl><type><name>winShmNode</name> <modifier>*</modifier></type><name>pShmNode</name></decl>;</decl_stmt> <comment type="block">/* The underlying shared-memory file */</comment>
  <decl_stmt><decl><type><name>winShm</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>          <comment type="block">/* For looping over sibling connections */</comment>

  <expr_stmt><expr><name>pDbFd</name> <operator>=</operator> <operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>fd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pDbFd</name><operator>-&gt;</operator><name>pShm</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pShmNode</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pShmNode</name></name></expr>;</expr_stmt>

  <comment type="block">/* Remove connection p from the set of connections associated
  ** with pShmNode */</comment>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pp</name><operator>=</operator><operator>&amp;</operator><name><name>pShmNode</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</init> <condition><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>!=</operator><name>p</name></expr>;</condition> <incr><expr><name>pp</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content/>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>

  <comment type="block">/* Free the connection p */</comment>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pDbFd</name><operator>-&gt;</operator><name>pShm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If pShmNode-&gt;nRef has reached 0, then close the underlying
  ** shared-memory file, too */</comment>
  <expr_stmt><expr><call><name>winShmEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>nRef</name></name><operator>--</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pShmNode</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>winShmPurge</name><argument_list>(<argument><expr><name><name>pDbFd</name><operator>-&gt;</operator><name>pVfs</name></name></expr></argument>, <argument><expr><name>deleteFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>winShmLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Change the lock state for a shared-memory segment.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winShmLock</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>,          <comment type="block">/* Database file holding the shared memory */</comment>
  <parameter><decl><type><name>int</name></type> <name>ofst</name></decl></parameter>,                  <comment type="block">/* First lock to acquire or release */</comment>
  <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,                     <comment type="block">/* Number of locks to acquire or release */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>                  <comment type="block">/* What to do with the lock */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pDbFd</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>fd</name></expr></init></decl>;</decl_stmt>        <comment type="block">/* Connection holding shared memory */</comment>
  <decl_stmt><decl><type><name>winShm</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pDbFd</name><operator>-&gt;</operator><name>pShm</name></name></expr></init></decl>;</decl_stmt>              <comment type="block">/* The shared memory being locked */</comment>
  <decl_stmt><decl><type><name>winShm</name> <modifier>*</modifier></type><name>pX</name></decl>;</decl_stmt>                           <comment type="block">/* For looping over all siblings */</comment>
  <decl_stmt><decl><type><name>winShmNode</name> <modifier>*</modifier></type><name>pShmNode</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pShmNode</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Result code */</comment>
  <decl_stmt><decl><type><name>u16</name></type> <name>mask</name></decl>;</decl_stmt>                             <comment type="block">/* Mask of locks to take or release */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>ofst</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ofst</name><operator>+</operator><name>n</name><operator>&lt;=</operator><name>SQLITE_SHM_NLOCK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;=</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>flags</name><operator>==</operator><operator>(</operator><name>SQLITE_SHM_LOCK</name> <operator>|</operator> <name>SQLITE_SHM_SHARED</name><operator>)</operator>
       <operator>||</operator> <name>flags</name><operator>==</operator><operator>(</operator><name>SQLITE_SHM_LOCK</name> <operator>|</operator> <name>SQLITE_SHM_EXCLUSIVE</name><operator>)</operator>
       <operator>||</operator> <name>flags</name><operator>==</operator><operator>(</operator><name>SQLITE_SHM_UNLOCK</name> <operator>|</operator> <name>SQLITE_SHM_SHARED</name><operator>)</operator>
       <operator>||</operator> <name>flags</name><operator>==</operator><operator>(</operator><name>SQLITE_SHM_UNLOCK</name> <operator>|</operator> <name>SQLITE_SHM_EXCLUSIVE</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_SHM_EXCLUSIVE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>mask</name> <operator>=</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>(</operator><operator>(</operator><literal type="number">1U</literal><operator>&lt;&lt;</operator><operator>(</operator><name>ofst</name><operator>+</operator><name>n</name><operator>)</operator><operator>)</operator> <operator>-</operator> <operator>(</operator><literal type="number">1U</literal><operator>&lt;&lt;</operator><name>ofst</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">1</literal> <operator>||</operator> <name>mask</name><operator>==</operator><operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>ofst</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_SHM_UNLOCK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u16</name></type> <name>allMask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Mask of locks held by siblings */</comment>

    <comment type="block">/* See if any siblings hold this same lock */</comment>
    <for>for<control>(<init><expr><name>pX</name><operator>=</operator><name><name>pShmNode</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</init> <condition><expr><name>pX</name></expr>;</condition> <incr><expr><name>pX</name><operator>=</operator><name><name>pX</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pX</name><operator>==</operator><name>p</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pX</name><operator>-&gt;</operator><name>exclMask</name></name> <operator>&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>exclMask</name></name><operator>|</operator><name><name>p</name><operator>-&gt;</operator><name>sharedMask</name></name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>allMask</name> <operator>|=</operator> <name><name>pX</name><operator>-&gt;</operator><name>sharedMask</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Unlock the system-level locks */</comment>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>mask</name> <operator>&amp;</operator> <name>allMask</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winShmSystemLock</name><argument_list>(<argument><expr><name>pShmNode</name></expr></argument>, <argument><expr><name>_SHM_UNLCK</name></expr></argument>, <argument><expr><name>ofst</name><operator>+</operator><name>WIN_SHM_BASE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Undo the local locks */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>exclMask</name></name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sharedMask</name></name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_SHM_SHARED</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u16</name></type> <name>allShared</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Union of locks held by connections other than "p" */</comment>

    <comment type="block">/* Find out which shared locks are already held by sibling connections.
    ** If any sibling already holds an exclusive lock, go ahead and return
    ** SQLITE_BUSY.
    */</comment>
    <for>for<control>(<init><expr><name>pX</name><operator>=</operator><name><name>pShmNode</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</init> <condition><expr><name>pX</name></expr>;</condition> <incr><expr><name>pX</name><operator>=</operator><name><name>pX</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pX</name><operator>-&gt;</operator><name>exclMask</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>allShared</name> <operator>|=</operator> <name><name>pX</name><operator>-&gt;</operator><name>sharedMask</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Get shared locks at the system level, if necessary */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name>allShared</name> <operator>&amp;</operator> <name>mask</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winShmSystemLock</name><argument_list>(<argument><expr><name>pShmNode</name></expr></argument>, <argument><expr><name>_SHM_RDLCK</name></expr></argument>, <argument><expr><name>ofst</name><operator>+</operator><name>WIN_SHM_BASE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Get the local shared locks */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sharedMask</name></name> <operator>|=</operator> <name>mask</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Make sure no sibling connections hold locks that will block this
    ** lock.  If any do, return SQLITE_BUSY right away.
    */</comment>
    <for>for<control>(<init><expr><name>pX</name><operator>=</operator><name><name>pShmNode</name><operator>-&gt;</operator><name>pFirst</name></name></expr>;</init> <condition><expr><name>pX</name></expr>;</condition> <incr><expr><name>pX</name><operator>=</operator><name><name>pX</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pX</name><operator>-&gt;</operator><name>exclMask</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pX</name><operator>-&gt;</operator><name>sharedMask</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_BUSY</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Get the exclusive locks at the system level.  Then if successful
    ** also mark the local connection as being locked.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winShmSystemLock</name><argument_list>(<argument><expr><name>pShmNode</name></expr></argument>, <argument><expr><name>_SHM_WRLCK</name></expr></argument>, <argument><expr><name>ofst</name><operator>+</operator><name>WIN_SHM_BASE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>sharedMask</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>exclMask</name></name> <operator>|=</operator> <name>mask</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SHM-LOCK pid=%lu, id=%d, sharedMask=%03x, exclMask=%03x, rc=%s\n"</literal><operator>,</operator>
           <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>id</name></name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>sharedMask</name></name><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>exclMask</name></name><operator>,</operator>
           <call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implement a memory barrier or memory fence on shared memory.
**
** All loads and stores begun before the barrier must complete before
** any load or store begun after the barrier.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>winShmBarrier</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>          <comment type="block">/* Database holding the shared memory */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3MemoryBarrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* compiler-defined memory barrier */</comment>
  <expr_stmt><expr><call><name>winShmEnterMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>       <comment type="block">/* Also mutex, for redundancy */</comment>
  <expr_stmt><expr><call><name>winShmLeaveMutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is called to obtain a pointer to region iRegion of the
** shared-memory associated with the database file fd. Shared-memory regions
** are numbered starting from zero. Each shared-memory region is szRegion
** bytes in size.
**
** If an error occurs, an error code is returned and *pp is set to NULL.
**
** Otherwise, if the isWrite parameter is 0 and the requested shared-memory
** region has not been allocated (by any client, including one running in a
** separate process), then *pp is set to NULL and SQLITE_OK returned. If
** isWrite is non-zero and the requested shared-memory region has not yet
** been allocated, it is allocated by this function.
**
** If the shared-memory region has already been allocated or is allocated by
** this call as described above, then it is mapped into this processes
** address space (if it is not already), *pp is set to point to the mapped
** memory and SQLITE_OK returned.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winShmMap</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>,               <comment type="block">/* Handle open on database file */</comment>
  <parameter><decl><type><name>int</name></type> <name>iRegion</name></decl></parameter>,                    <comment type="block">/* Region to retrieve */</comment>
  <parameter><decl><type><name>int</name></type> <name>szRegion</name></decl></parameter>,                   <comment type="block">/* Size of regions */</comment>
  <parameter><decl><type><name>int</name></type> <name>isWrite</name></decl></parameter>,                    <comment type="block">/* True to extend file if necessary */</comment>
  <parameter><decl><type><name>void</name> <specifier>volatile</specifier> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>              <comment type="block">/* OUT: Mapped memory */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pDbFd</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>fd</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>winShm</name> <modifier>*</modifier></type><name>pShm</name> <init>= <expr><name><name>pDbFd</name><operator>-&gt;</operator><name>pShm</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>winShmNode</name> <modifier>*</modifier></type><name>pShmNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pShm</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winOpenSharedMemory</name><argument_list>(<argument><expr><name>pDbFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pShm</name> <operator>=</operator> <name><name>pDbFd</name><operator>-&gt;</operator><name>pShm</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pShmNode</name> <operator>=</operator> <name><name>pShm</name><operator>-&gt;</operator><name>pShmNode</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>szRegion</name><operator>==</operator><name><name>pShmNode</name><operator>-&gt;</operator><name>szRegion</name></name> <operator>||</operator> <name><name>pShmNode</name><operator>-&gt;</operator><name>nRegion</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pShmNode</name><operator>-&gt;</operator><name>nRegion</name></name><operator>&lt;=</operator><name>iRegion</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>ShmRegion</name></name> <modifier>*</modifier></type><name>apNew</name></decl>;</decl_stmt>           <comment type="block">/* New aRegion[] array */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nByte</name> <init>= <expr><operator>(</operator><name>iRegion</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><name>szRegion</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Minimum required file size */</comment>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>sz</name></decl>;</decl_stmt>                  <comment type="block">/* Current size of wal-index file */</comment>

    <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>szRegion</name></name> <operator>=</operator> <name>szRegion</name></expr>;</expr_stmt>

    <comment type="block">/* The requested region is not mapped into this processes address space.
    ** Check to see if it has been allocated (i.e. if the wal-index file is
    ** large enough to contain the requested region).
    */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winFileSize</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_file</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pShmNode</name><operator>-&gt;</operator><name>hFile</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_SHMSIZE</name></expr></argument>, <argument><expr><call><name>osGetLastError</name><argument_list>()</argument_list></call></expr></argument>,
                       <argument><expr><literal type="string">"winShmMap1"</literal></expr></argument>, <argument><expr><name><name>pDbFd</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>shmpage_out</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>sz</name><operator>&lt;</operator><name>nByte</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* The requested memory region does not exist. If isWrite is set to
      ** zero, exit early. *pp will be set to NULL and SQLITE_OK returned.
      **
      ** Alternatively, if isWrite is non-zero, use ftruncate() to allocate
      ** the requested memory region.
      */</comment>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>isWrite</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>shmpage_out</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winTruncate</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_file</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pShmNode</name><operator>-&gt;</operator><name>hFile</name></name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_SHMSIZE</name></expr></argument>, <argument><expr><call><name>osGetLastError</name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><literal type="string">"winShmMap2"</literal></expr></argument>, <argument><expr><name><name>pDbFd</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>shmpage_out</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Map the requested memory region into this processes address space. */</comment>
    <expr_stmt><expr><name>apNew</name> <operator>=</operator> <operator>(</operator>struct <name>ShmRegion</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_realloc64</name><argument_list>(
        <argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>aRegion</name></name></expr></argument>, <argument><expr><operator>(</operator><name>iRegion</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>apNew</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>apNew</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_NOMEM</name></expr>;</expr_stmt>
      <goto>goto <name>shmpage_out</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>aRegion</name></name> <operator>=</operator> <name>apNew</name></expr>;</expr_stmt>

    <while>while<condition>( <expr><name><name>pShmNode</name><operator>-&gt;</operator><name>nRegion</name></name><operator>&lt;=</operator><name>iRegion</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>HANDLE</name></type> <name>hMap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>         <comment type="block">/* file-mapping handle */</comment>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pMap</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Mapped memory region */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINRT</name></expr></cpp:if>
      <expr_stmt><expr><name>hMap</name> <operator>=</operator> <call><name>osCreateFileMappingFromApp</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>hFile</name><operator>.</operator><name>h</name></name></expr></argument>,
          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PAGE_READWRITE</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_WIN32_HAS_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:elif>
      <expr_stmt><expr><name>hMap</name> <operator>=</operator> <call><name>osCreateFileMappingW</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>hFile</name><operator>.</operator><name>h</name></name></expr></argument>,
          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PAGE_READWRITE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_WIN32_HAS_ANSI</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_WIN32_CREATEFILEMAPPINGA</name></expr></cpp:elif>
      <expr_stmt><expr><name>hMap</name> <operator>=</operator> <call><name>osCreateFileMappingA</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>hFile</name><operator>.</operator><name>h</name></name></expr></argument>,
          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PAGE_READWRITE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SHM-MAP-CREATE pid=%lu, region=%d, size=%d, rc=%s\n"</literal><operator>,</operator>
               <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name><name>pShmNode</name><operator>-&gt;</operator><name>nRegion</name></name><operator>,</operator> <name>nByte</name><operator>,</operator>
               <ternary><condition><expr><name>hMap</name></expr> ?</condition><then> <expr><literal type="string">"ok"</literal></expr> </then><else>: <expr><literal type="string">"failed"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>hMap</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iOffset</name> <init>= <expr><name><name>pShmNode</name><operator>-&gt;</operator><name>nRegion</name></name><operator>*</operator><name>szRegion</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>iOffsetShift</name> <init>= <expr><name>iOffset</name> <operator>%</operator> <name><name>winSysInfo</name><operator>.</operator><name>dwAllocationGranularity</name></name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINRT</name></expr></cpp:if>
        <expr_stmt><expr><name>pMap</name> <operator>=</operator> <call><name>osMapViewOfFileFromApp</name><argument_list>(<argument><expr><name>hMap</name></expr></argument>, <argument><expr><name>FILE_MAP_WRITE</name> <operator>|</operator> <name>FILE_MAP_READ</name></expr></argument>,
            <argument><expr><name>iOffset</name> <operator>-</operator> <name>iOffsetShift</name></expr></argument>, <argument><expr><name>szRegion</name> <operator>+</operator> <name>iOffsetShift</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>pMap</name> <operator>=</operator> <call><name>osMapViewOfFile</name><argument_list>(<argument><expr><name>hMap</name></expr></argument>, <argument><expr><name>FILE_MAP_WRITE</name> <operator>|</operator> <name>FILE_MAP_READ</name></expr></argument>,
            <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iOffset</name> <operator>-</operator> <name>iOffsetShift</name></expr></argument>, <argument><expr><name>szRegion</name> <operator>+</operator> <name>iOffsetShift</name></expr></argument>
        )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"SHM-MAP-MAP pid=%lu, region=%d, offset=%d, size=%d, rc=%s\n"</literal><operator>,</operator>
                 <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name><name>pShmNode</name><operator>-&gt;</operator><name>nRegion</name></name><operator>,</operator> <name>iOffset</name><operator>,</operator>
                 <name>szRegion</name><operator>,</operator> <ternary><condition><expr><name>pMap</name></expr> ?</condition><then> <expr><literal type="string">"ok"</literal></expr> </then><else>: <expr><literal type="string">"failed"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pMap</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_SHMMAP</name></expr></argument>, <argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>,
                         <argument><expr><literal type="string">"winShmMap3"</literal></expr></argument>, <argument><expr><name><name>pDbFd</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>hMap</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>osCloseHandle</name><argument_list>(<argument><expr><name>hMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <goto>goto <name>shmpage_out</name>;</goto>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>aRegion</name><index>[<expr><name><name>pShmNode</name><operator>-&gt;</operator><name>nRegion</name></name></expr>]</index></name><operator>.</operator><name>pMap</name> <operator>=</operator> <name>pMap</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>aRegion</name><index>[<expr><name><name>pShmNode</name><operator>-&gt;</operator><name>nRegion</name></name></expr>]</index></name><operator>.</operator><name>hMap</name> <operator>=</operator> <name>hMap</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>nRegion</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>

<label><name>shmpage_out</name>:</label>
  <if_stmt><if>if<condition>( <expr><name><name>pShmNode</name><operator>-&gt;</operator><name>nRegion</name></name><operator>&gt;</operator><name>iRegion</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iOffset</name> <init>= <expr><name>iRegion</name><operator>*</operator><name>szRegion</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iOffsetShift</name> <init>= <expr><name>iOffset</name> <operator>%</operator> <name><name>winSysInfo</name><operator>.</operator><name>dwAllocationGranularity</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>pShmNode</name><operator>-&gt;</operator><name>aRegion</name><index>[<expr><name>iRegion</name></expr>]</index></name><operator>.</operator><name>pMap</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>p</name><index>[<expr><name>iOffsetShift</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>pShmNode</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>winShmMap</name></cpp:macro>     <cpp:value>0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>winShmLock</name></cpp:macro>    <cpp:value>0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>winShmBarrier</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>winShmUnmap</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* #ifndef SQLITE_OMIT_WAL */</comment>

<comment type="block">/*
** Cleans up the mapped region of the specified file, if any.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winUnmapfile</name><parameter_list>(<parameter><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"UNMAP-FILE pid=%lu, pFile=%p, hMap=%p, pMapRegion=%p, "</literal>
           <literal type="string">"mmapSize=%lld, mmapSizeActual=%lld, mmapSizeMax=%lld\n"</literal><operator>,</operator>
           <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>hMap</name></name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>pMapRegion</name></name><operator>,</operator>
           <name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>mmapSizeActual</name></name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>mmapSizeMax</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>pMapRegion</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>osUnmapViewOfFile</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>pMapRegion</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"UNMAP-FILE pid=%lu, pFile=%p, pMapRegion=%p, "</literal>
               <literal type="string">"rc=SQLITE_IOERR_MMAP\n"</literal><operator>,</operator> <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator>
               <name><name>pFile</name><operator>-&gt;</operator><name>pMapRegion</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_MMAP</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>,
                         <argument><expr><literal type="string">"winUnmapfile1"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>pMapRegion</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>mmapSizeActual</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pFile</name><operator>-&gt;</operator><name>hMap</name></name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>osCloseHandle</name><argument_list>(<argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>hMap</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"UNMAP-FILE pid=%lu, pFile=%p, hMap=%p, rc=SQLITE_IOERR_MMAP\n"</literal><operator>,</operator>
               <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>,</operator> <name><name>pFile</name><operator>-&gt;</operator><name>hMap</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_MMAP</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>,
                         <argument><expr><literal type="string">"winUnmapfile2"</literal></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>hMap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"UNMAP-FILE pid=%lu, pFile=%p, rc=SQLITE_OK\n"</literal><operator>,</operator>
           <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFile</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Memory map or remap the file opened by file-descriptor pFd (if the file
** is already mapped, the existing mapping is replaced by the new). Or, if
** there already exists a mapping for this file, and there are still
** outstanding xFetch() references to it, this function is a no-op.
**
** If parameter nByte is non-negative, then it is the requested size of
** the mapping to create. Otherwise, if nByte is less than zero, then the
** requested size is the size of the file on disk. The actual size of the
** created mapping is either the requested size or the value configured
** using SQLITE_FCNTL_MMAP_SIZE, whichever is smaller.
**
** SQLITE_OK is returned if no error occurs (even if the mapping is not
** recreated as a result of outstanding references) or an SQLite error
** code otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winMapfile</name><parameter_list>(<parameter><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFd</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>nMap</name> <init>= <expr><name>nByte</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nMap</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pFd</name><operator>-&gt;</operator><name>nFetchOut</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"MAP-FILE pid=%lu, pFile=%p, size=%lld\n"</literal><operator>,</operator>
           <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFd</name><operator>,</operator> <name>nByte</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pFd</name><operator>-&gt;</operator><name>nFetchOut</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>nMap</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winFileSize</name><argument_list>(<argument><expr><operator>(</operator><name>sqlite3_file</name><operator>*</operator><operator>)</operator><name>pFd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"MAP-FILE pid=%lu, pFile=%p, rc=SQLITE_IOERR_FSTAT\n"</literal><operator>,</operator>
               <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFd</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_IOERR_FSTAT</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nMap</name><operator>&gt;</operator><name><name>pFd</name><operator>-&gt;</operator><name>mmapSizeMax</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nMap</name> <operator>=</operator> <name><name>pFd</name><operator>-&gt;</operator><name>mmapSizeMax</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nMap</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><operator>(</operator><name><name>winSysInfo</name><operator>.</operator><name>dwPageSize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>nMap</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pFd</name><operator>-&gt;</operator><name>mmapSize</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>winUnmapfile</name><argument_list>(<argument><expr><name>pFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nMap</name><operator>!=</operator><name><name>pFd</name><operator>-&gt;</operator><name>mmapSize</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pNew</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>protect</name> <init>= <expr><name>PAGE_READONLY</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>flags</name> <init>= <expr><name>FILE_MAP_READ</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>winUnmapfile</name><argument_list>(<argument><expr><name>pFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_MMAP_READWRITE</name></cpp:ifdef>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pFd</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>&amp;</operator> <name>WINFILE_RDONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>protect</name> <operator>=</operator> <name>PAGE_READWRITE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>FILE_MAP_WRITE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINRT</name></expr></cpp:if>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>hMap</name></name> <operator>=</operator> <call><name>osCreateFileMappingFromApp</name><argument_list>(<argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>protect</name></expr></argument>, <argument><expr><name>nMap</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_WIN32_HAS_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>hMap</name></name> <operator>=</operator> <call><name>osCreateFileMappingW</name><argument_list>(<argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>protect</name></expr></argument>,
                                <argument><expr><operator>(</operator><name>DWORD</name><operator>)</operator><operator>(</operator><operator>(</operator><name>nMap</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffffffff</literal><operator>)</operator></expr></argument>,
                                <argument><expr><operator>(</operator><name>DWORD</name><operator>)</operator><operator>(</operator><name>nMap</name> <operator>&amp;</operator> <literal type="number">0xffffffff</literal><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_WIN32_HAS_ANSI</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SQLITE_WIN32_CREATEFILEMAPPINGA</name></expr></cpp:elif>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>hMap</name></name> <operator>=</operator> <call><name>osCreateFileMappingA</name><argument_list>(<argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>protect</name></expr></argument>,
                                <argument><expr><operator>(</operator><name>DWORD</name><operator>)</operator><operator>(</operator><operator>(</operator><name>nMap</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffffffff</literal><operator>)</operator></expr></argument>,
                                <argument><expr><operator>(</operator><name>DWORD</name><operator>)</operator><operator>(</operator><name>nMap</name> <operator>&amp;</operator> <literal type="number">0xffffffff</literal><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name><name>pFd</name><operator>-&gt;</operator><name>hMap</name></name><operator>==</operator><name>NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_MMAP</name></expr></argument>, <argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>,
                       <argument><expr><literal type="string">"winMapfile1"</literal></expr></argument>, <argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Log the error, but continue normal operation using xRead/xWrite */</comment>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"MAP-FILE-CREATE pid=%lu, pFile=%p, rc=%s\n"</literal><operator>,</operator>
               <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFd</name><operator>,</operator> <call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>nMap</name> <operator>%</operator> <name><name>winSysInfo</name><operator>.</operator><name>dwPageSize</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SIZE_T</name></expr></argument>)</argument_list></sizeof><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_int64</name></expr></argument>)</argument_list></sizeof> <operator>||</operator> <name>nMap</name><operator>&lt;=</operator><literal type="number">0xffffffff</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINRT</name></expr></cpp:if>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>osMapViewOfFileFromApp</name><argument_list>(<argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>hMap</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>SIZE_T</name><operator>)</operator><name>nMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>osMapViewOfFile</name><argument_list>(<argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>hMap</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>SIZE_T</name><operator>)</operator><name>nMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><name>NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>osCloseHandle</name><argument_list>(<argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>hMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>hMap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_MMAP</name></expr></argument>, <argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>,
                       <argument><expr><literal type="string">"winMapfile2"</literal></expr></argument>, <argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>zPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Log the error, but continue normal operation using xRead/xWrite */</comment>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"MAP-FILE-MAP pid=%lu, pFile=%p, rc=%s\n"</literal><operator>,</operator>
               <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFd</name><operator>,</operator> <call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>pMapRegion</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>mmapSize</name></name> <operator>=</operator> <name>nMap</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>mmapSizeActual</name></name> <operator>=</operator> <name>nMap</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"MAP-FILE pid=%lu, pFile=%p, rc=SQLITE_OK\n"</literal><operator>,</operator>
           <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFd</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_MAX_MMAP_SIZE&gt;0 */</comment>

<comment type="block">/*
** If possible, return a pointer to a mapping of file fd starting at offset
** iOff. The mapping must be valid for at least nAmt bytes.
**
** If such a pointer can be obtained, store it in *pp and return SQLITE_OK.
** Or, if one cannot but no error occurs, set *pp to 0 and return SQLITE_OK.
** Finally, if an error does occur, return an SQLite error code. The final
** value of *pp is undefined in this case.
**
** If this function does return a pointer, the caller must eventually
** release the reference by calling winUnfetch().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winFetch</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iOff</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nAmt</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFd</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>fd</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* The underlying database file */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FETCH pid=%lu, pFile=%p, offset=%lld, amount=%d, pp=%p\n"</literal><operator>,</operator>
           <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>fd</name><operator>,</operator> <name>iOff</name><operator>,</operator> <name>nAmt</name><operator>,</operator> <name>pp</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name><name>pFd</name><operator>-&gt;</operator><name>mmapSizeMax</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pFd</name><operator>-&gt;</operator><name>pMapRegion</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>winMapfile</name><argument_list>(<argument><expr><name>pFd</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FETCH pid=%lu, pFile=%p, rc=%s\n"</literal><operator>,</operator>
                 <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFd</name><operator>,</operator> <call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pFd</name><operator>-&gt;</operator><name>mmapSize</name></name> <operator>&gt;=</operator> <name>iOff</name><operator>+</operator><name>nAmt</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name><name>pFd</name><operator>-&gt;</operator><name>pMapRegion</name></name><operator>)</operator><index>[<expr><name>iOff</name></expr>]</index></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>nFetchOut</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FETCH pid=%lu, pFile=%p, pp=%p, *pp=%p, rc=SQLITE_OK\n"</literal><operator>,</operator>
           <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>fd</name><operator>,</operator> <name>pp</name><operator>,</operator> <operator>*</operator><name>pp</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the third argument is non-NULL, then this function releases a
** reference obtained by an earlier call to winFetch(). The second
** argument passed to this function must be the same as the corresponding
** argument that was passed to the winFetch() invocation.
**
** Or, if the third argument is NULL, then this function is being called
** to inform the VFS layer that, according to POSIX, any existing mapping
** may now be invalid and should be unmapped.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winUnfetch</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>iOff</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFd</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>fd</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* The underlying database file */</comment>

  <comment type="block">/* If p==0 (unmap the entire file) then there must be no outstanding
  ** xFetch references. Or, if p!=0 (meaning it is an xFetch reference),
  ** then there must be at least one outstanding.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>p</name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>==</operator><operator>(</operator><name><name>pFd</name><operator>-&gt;</operator><name>nFetchOut</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If p!=0, it must match the iOff value. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>p</name><operator>==</operator><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>u8</name> <operator>*</operator><operator>)</operator><name><name>pFd</name><operator>-&gt;</operator><name>pMapRegion</name></name><operator>)</operator><index>[<expr><name>iOff</name></expr>]</index></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"UNFETCH pid=%lu, pFile=%p, offset=%lld, p=%p\n"</literal><operator>,</operator>
           <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>pFd</name><operator>,</operator> <name>iOff</name><operator>,</operator> <name>p</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFd</name><operator>-&gt;</operator><name>nFetchOut</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* FIXME:  If Windows truly always prevents truncating or deleting a
    ** file while a mapping is held, then the following winUnmapfile() call
    ** is unnecessary can be omitted - potentially improving
    ** performance.  */</comment>
    <expr_stmt><expr><call><name>winUnmapfile</name><argument_list>(<argument><expr><name>pFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pFd</name><operator>-&gt;</operator><name>nFetchOut</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"UNFETCH pid=%lu, pFile=%p, rc=SQLITE_OK\n"</literal><operator>,</operator>
           <call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call><operator>,</operator> <name>fd</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Here ends the implementation of all sqlite3_file methods.
**
********************** End sqlite3_file Methods *******************************
******************************************************************************/</comment>

<comment type="block">/*
** This vector defines all the methods that can operate on an
** sqlite3_file for win32.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_io_methods</name></type> <name>winIoMethod</name> <init>= <expr><block>{
  <expr><literal type="number">3</literal></expr>,                              <comment type="block">/* iVersion */</comment>
  <expr><name>winClose</name></expr>,                       <comment type="block">/* xClose */</comment>
  <expr><name>winRead</name></expr>,                        <comment type="block">/* xRead */</comment>
  <expr><name>winWrite</name></expr>,                       <comment type="block">/* xWrite */</comment>
  <expr><name>winTruncate</name></expr>,                    <comment type="block">/* xTruncate */</comment>
  <expr><name>winSync</name></expr>,                        <comment type="block">/* xSync */</comment>
  <expr><name>winFileSize</name></expr>,                    <comment type="block">/* xFileSize */</comment>
  <expr><name>winLock</name></expr>,                        <comment type="block">/* xLock */</comment>
  <expr><name>winUnlock</name></expr>,                      <comment type="block">/* xUnlock */</comment>
  <expr><name>winCheckReservedLock</name></expr>,           <comment type="block">/* xCheckReservedLock */</comment>
  <expr><name>winFileControl</name></expr>,                 <comment type="block">/* xFileControl */</comment>
  <expr><name>winSectorSize</name></expr>,                  <comment type="block">/* xSectorSize */</comment>
  <expr><name>winDeviceCharacteristics</name></expr>,       <comment type="block">/* xDeviceCharacteristics */</comment>
  <expr><name>winShmMap</name></expr>,                      <comment type="block">/* xShmMap */</comment>
  <expr><name>winShmLock</name></expr>,                     <comment type="block">/* xShmLock */</comment>
  <expr><name>winShmBarrier</name></expr>,                  <comment type="block">/* xShmBarrier */</comment>
  <expr><name>winShmUnmap</name></expr>,                    <comment type="block">/* xShmUnmap */</comment>
  <expr><name>winFetch</name></expr>,                       <comment type="block">/* xFetch */</comment>
  <expr><name>winUnfetch</name></expr>                      <comment type="block">/* xUnfetch */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block" format="doxygen">/****************************************************************************
**************************** sqlite3_vfs methods ****************************
**
** This division contains the implementation of methods on the
** sqlite3_vfs object.
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/*
** Convert a filename from whatever the underlying operating system
** supports for filenames into UTF-8.  Space to hold the result is
** obtained from malloc and must be freed by the calling function.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>winConvertToUtf8Filename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zConverted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>osIsNT</name><argument_list>()</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zConverted</name> <operator>=</operator> <call><name>winUnicodeToUtf8</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_WIN32_HAS_ANSI</name></cpp:ifdef>
  <else>else<block>{<block_content>
    <expr_stmt><expr><name>zConverted</name> <operator>=</operator> <call><name>sqlite3_win32_mbcs_to_utf8</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="block">/* caller will handle out of memory */</comment>
  <return>return <expr><name>zConverted</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Convert a UTF-8 filename into whatever form the underlying
** operating system wants filenames in.  Space to hold the result
** is obtained from malloc and must be freed by the calling
** function.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>winConvertFromUtf8Filename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>zConverted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>osIsNT</name><argument_list>()</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zConverted</name> <operator>=</operator> <call><name>winUtf8ToUnicode</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_WIN32_HAS_ANSI</name></cpp:ifdef>
  <else>else<block>{<block_content>
    <expr_stmt><expr><name>zConverted</name> <operator>=</operator> <call><name>sqlite3_win32_utf8_to_mbcs</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="block">/* caller will handle out of memory */</comment>
  <return>return <expr><name>zConverted</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function returns non-zero if the specified UTF-8 string buffer
** ends with a directory separator character or one was successfully
** added to it.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winMakeEndInDirSep</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nBuf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>zBuf</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nLen</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>nLen</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>winIsDirSep</name><argument_list>(<argument><expr><name><name>zBuf</name><index>[<expr><name>nLen</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>nLen</name><operator>+</operator><literal type="number">1</literal><operator>&lt;</operator><name>nBuf</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>nLen</name></expr>]</index></name> <operator>=</operator> <call><name>winGetDirSep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>nLen</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create a temporary file name and store the resulting pointer into pzBuf.
** The pointer returned in pzBuf must be freed via sqlite3_free().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winGetTempname</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>zChars</name><index>[]</index></name> <init>=
    <expr><literal type="string">"abcdefghijklmnopqrstuvwxyz"</literal>
    <literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</literal>
    <literal type="string">"0123456789"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nPre</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>SQLITE_TEMP_FILE_PREFIX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nMax</name></decl>, <decl><type ref="prev"/><name>nBuf</name></decl>, <decl><type ref="prev"/><name>nDir</name></decl>, <decl><type ref="prev"/><name>nLen</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl>;</decl_stmt>

  <comment type="block">/* It's odd to simulate an io-error here, but really this is just
  ** using the io-error infrastructure to test that SQLite handles this
  ** function failing.
  */</comment>
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>

  <comment type="block">/* Allocate a temporary buffer to store the fully qualified file
  ** name for the temporary file.  If this fails, we cannot continue.
  */</comment>
  <expr_stmt><expr><name>nMax</name> <operator>=</operator> <name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name></expr>;</expr_stmt> <expr_stmt><expr><name>nBuf</name> <operator>=</operator> <name>nMax</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <call><name>sqlite3MallocZero</name><argument_list>( <argument><expr><name>nBuf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zBuf</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Figure out the effective temporary directory.  First, check if one
  ** has been explicitly set by the application; otherwise, use the one
  ** configured by the operating system.
  */</comment>
  <expr_stmt><expr><name>nDir</name> <operator>=</operator> <name>nMax</name> <operator>-</operator> <operator>(</operator><name>nPre</name> <operator>+</operator> <literal type="number">15</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nDir</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>sqlite3_temp_directory</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nDirLen</name> <init>= <expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>sqlite3_temp_directory</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>nDirLen</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>winIsDirSep</name><argument_list>(<argument><expr><name><name>sqlite3_temp_directory</name><index>[<expr><name>nDirLen</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>nDirLen</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>nDirLen</name><operator>&gt;</operator><name>nDir</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEMP-FILENAME rc=SQLITE_ERROR\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_ERROR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"winGetTempname1"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nMax</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>sqlite3_temp_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>azDirs</name><index>[]</index></name> <init>= <expr><block>{
       <expr><literal type="number">0</literal></expr>, <comment type="block">/* getenv("SQLITE_TMPDIR") */</comment>
       <expr><literal type="number">0</literal></expr>, <comment type="block">/* getenv("TMPDIR") */</comment>
       <expr><literal type="number">0</literal></expr>, <comment type="block">/* getenv("TMP") */</comment>
       <expr><literal type="number">0</literal></expr>, <comment type="block">/* getenv("TEMP") */</comment>
       <expr><literal type="number">0</literal></expr>, <comment type="block">/* getenv("USERPROFILE") */</comment>
       <expr><literal type="string">"/var/tmp"</literal></expr>,
       <expr><literal type="string">"/usr/tmp"</literal></expr>,
       <expr><literal type="string">"/tmp"</literal></expr>,
       <expr><literal type="string">"."</literal></expr>,
       <expr><literal type="number">0</literal></expr>        <comment type="block">/* List terminator */</comment>
    }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDir</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>azDirs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>azDirs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"SQLITE_TMPDIR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>azDirs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>azDirs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TMPDIR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>azDirs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>azDirs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TMP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>azDirs</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>azDirs</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TEMP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>azDirs</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>azDirs</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"USERPROFILE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>azDirs</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>azDirs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>zDir</name><operator>=</operator><name><name>azDirs</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>zConverted</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zDir</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <comment type="block">/* If the path starts with a drive letter followed by the colon
      ** character, assume it is already a native Win32 path; otherwise,
      ** it must be converted to a native Win32 path via the Cygwin API
      ** prior to using it.
      */</comment>
      <if_stmt><if>if<condition>( <expr><call><name>winIsDriveLetterAndColon</name><argument_list>(<argument><expr><name>zDir</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zConverted</name> <operator>=</operator> <call><name>winConvertFromUtf8Filename</name><argument_list>(<argument><expr><name>zDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zConverted</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>winIsDir</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nMax</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>zConverted</name> <operator>=</operator> <call><name>sqlite3MallocZero</name><argument_list>( <argument><expr><name>nMax</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zConverted</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>cygwin_conv_path</name><argument_list>(
                <argument><expr><ternary><condition><expr><call><name>osIsNT</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>CCP_POSIX_TO_WIN_W</name></expr> </then><else>: <expr><name>CCP_POSIX_TO_WIN_A</name></expr></else></ternary></expr></argument>, <argument><expr><name>zDir</name></expr></argument>,
                <argument><expr><name>zConverted</name></expr></argument>, <argument><expr><name>nMax</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEMP-FILENAME rc=SQLITE_IOERR_CONVPATH\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_CONVPATH</name></expr></argument>, <argument><expr><operator>(</operator><name>DWORD</name><operator>)</operator><name>errno</name></expr></argument>,
                             <argument><expr><literal type="string">"winGetTempname2"</literal></expr></argument>, <argument><expr><name>zDir</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>winIsDir</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <comment type="block">/* At this point, we know the candidate directory exists and should
          ** be used.  However, we may need to convert the string containing
          ** its name into UTF-8 (i.e. if it is UTF-16 right now).
          */</comment>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zUtf8</name> <init>= <expr><call><name>winConvertToUtf8Filename</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zUtf8</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nMax</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zUtf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zUtf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><name>SQLITE_OS_WINRT</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
  <if_stmt><if type="elseif">else if<condition>( <expr><call><name>osIsNT</name><argument_list>()</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMulti</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LPWSTR</name></type> <name>zWidePath</name> <init>= <expr><call><name>sqlite3MallocZero</name><argument_list>( <argument><expr><name>nMax</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>WCHAR</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zWidePath</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>osGetTempPathW</name><argument_list>(<argument><expr><name>nMax</name></expr></argument>, <argument><expr><name>zWidePath</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zWidePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEMP-FILENAME rc=SQLITE_IOERR_GETTEMPPATH\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_GETTEMPPATH</name></expr></argument>, <argument><expr><call><name>osGetLastError</name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><literal type="string">"winGetTempname2"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zMulti</name> <operator>=</operator> <call><name>winUnicodeToUtf8</name><argument_list>(<argument><expr><name>zWidePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zMulti</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nMax</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zMulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zMulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zWidePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zWidePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_WIN32_HAS_ANSI</name></cpp:ifdef>
  <else>else<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zUtf8</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMbcsPath</name> <init>= <expr><call><name>sqlite3MallocZero</name><argument_list>( <argument><expr><name>nMax</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zMbcsPath</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>osGetTempPathA</name><argument_list>(<argument><expr><name>nMax</name></expr></argument>, <argument><expr><name>zMbcsPath</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEMP-FILENAME rc=SQLITE_IOERR_GETTEMPPATH\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_GETTEMPPATH</name></expr></argument>, <argument><expr><call><name>osGetLastError</name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><literal type="string">"winGetTempname3"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zUtf8</name> <operator>=</operator> <call><name>sqlite3_win32_mbcs_to_utf8</name><argument_list>(<argument><expr><name>zMbcsPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zUtf8</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nMax</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zUtf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zUtf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_WIN32_HAS_ANSI */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !SQLITE_OS_WINRT */</comment>

  <comment type="block">/*
  ** Check to make sure the temporary directory ends with an appropriate
  ** separator.  If it does not and there is not enough space left to add
  ** one, fail.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>winMakeEndInDirSep</name><argument_list>(<argument><expr><name>nDir</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEMP-FILENAME rc=SQLITE_ERROR\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_ERROR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"winGetTempname4"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/*
  ** Check that the output buffer is large enough for the temporary file
  ** name in the following format:
  **
  **   "&lt;temporary_directory&gt;/etilqs_XXXXXXXXXXXXXXX\0\0"
  **
  ** If not, return SQLITE_ERROR.  The number 17 is used here in order to
  ** account for the space used by the 15 character random suffix and the
  ** two trailing NUL characters.  The final directory separator character
  ** has already added if it was not already present.
  */</comment>
  <expr_stmt><expr><name>nLen</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>nLen</name> <operator>+</operator> <name>nPre</name> <operator>+</operator> <literal type="number">17</literal><operator>)</operator> <operator>&gt;</operator> <name>nBuf</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEMP-FILENAME rc=SQLITE_ERROR\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_ERROR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"winGetTempname5"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nBuf</name><operator>-</operator><literal type="number">16</literal><operator>-</operator><name>nLen</name></expr></argument>, <argument><expr><name>zBuf</name><operator>+</operator><name>nLen</name></expr></argument>, <argument><expr><name>SQLITE_TEMP_FILE_PREFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">15</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name><name>zChars</name><index>[ <expr><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>zBuf</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator><operator>%</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>zChars</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zBuf</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pzBuf</name> <operator>=</operator> <name>zBuf</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"TEMP-FILENAME name=%s, rc=SQLITE_OK\n"</literal><operator>,</operator> <name>zBuf</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if the named file is really a directory.  Return false if
** it is something other than a directory, or if there is any kind of memory
** allocation failure.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winIsDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>zConverted</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>attr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>lastErrno</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>osIsNT</name><argument_list>()</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WIN32_FILE_ATTRIBUTE_DATA</name></type> <name>sAttrData</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sAttrData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sAttrData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>!</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>osGetFileAttributesExW</name><argument_list>(<argument><expr><operator>(</operator><name>LPCWSTR</name><operator>)</operator><name>zConverted</name></expr></argument>,
                             <argument><expr><name>GetFileExInfoStandard</name></expr></argument>,
                             <argument><expr><operator>&amp;</operator><name>sAttrData</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>winRetryIoerr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastErrno</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content/>}</block></while>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>rc</name></expr> )</condition><block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* Invalid name? */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>attr</name> <operator>=</operator> <name><name>sAttrData</name><operator>.</operator><name>dwFileAttributes</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINCE</name><operator>==</operator><literal type="number">0</literal></expr></cpp:if>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>osGetFileAttributesA</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><operator>(</operator><name>attr</name><operator>!=</operator><name>INVALID_FILE_ATTRIBUTES</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>attr</name><operator>&amp;</operator><name>FILE_ATTRIBUTE_DIRECTORY</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Open a file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winOpen</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,        <comment type="block">/* Used to get maximum path name length */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,        <comment type="block">/* Name of the file (UTF-8) */</comment>
  <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>id</name></decl></parameter>,         <comment type="block">/* Write the SQLite file handle here */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,                <comment type="block">/* Open mode flags */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pOutFlags</name></decl></parameter>            <comment type="block">/* Status return flags */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>HANDLE</name></type> <name>h</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>lastErrno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>dwDesiredAccess</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>dwShareMode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>dwCreationDisposition</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>dwFlagsAndAttributes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINCE</name></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>isTemp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>winFile</name> <modifier>*</modifier></type><name>pFile</name> <init>= <expr><operator>(</operator><name>winFile</name><operator>*</operator><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>zConverted</name></decl>;</decl_stmt>              <comment type="block">/* Filename in OS encoding */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zUtf8Name</name> <init>= <expr><name>zName</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Filename in UTF-8 encoding */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If argument zPath is a NULL pointer, this function is required to open
  ** a temporary file. Use this buffer to store the file name in.
  */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTmpname</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* For temporary filename, if necessary. */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>            <comment type="block">/* Function Return Code */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>SQLITE_OS_WINCE</name></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>eType</name> <init>= <expr><name>flags</name><operator>&amp;</operator><literal type="number">0xFFFFFF00</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Type of file to open */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <decl_stmt><decl><type><name>int</name></type> <name>isExclusive</name>  <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_EXCLUSIVE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isDelete</name>     <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_DELETEONCLOSE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isCreate</name>     <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_CREATE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isReadonly</name>   <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_READONLY</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isReadWrite</name>  <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_READWRITE</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>isOpenJournal</name> <init>= <expr><operator>(</operator><name>isCreate</name> <operator>&amp;&amp;</operator> <operator>(</operator>
        <name>eType</name><operator>==</operator><name>SQLITE_OPEN_MASTER_JOURNAL</name>
     <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_OPEN_MAIN_JOURNAL</name>
     <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_OPEN_WAL</name>
  <operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"OPEN name=%s, pFile=%p, flags=%x, pOutFlags=%p\n"</literal><operator>,</operator>
           <name>zUtf8Name</name><operator>,</operator> <name>id</name><operator>,</operator> <name>flags</name><operator>,</operator> <name>pOutFlags</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the following statements are true:
  **
  **   (a) Exactly one of the READWRITE and READONLY flags must be set, and
  **   (b) if CREATE is set, then READWRITE must also be set, and
  **   (c) if EXCLUSIVE is set, then CREATE must also be set.
  **   (d) if DELETEONCLOSE is set, then CREATE must also be set.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>isReadonly</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isReadWrite</name><operator>==</operator><literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>isReadWrite</name> <operator>||</operator> <name>isReadonly</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>isCreate</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isReadWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>isExclusive</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isCreate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>isDelete</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>isCreate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The main DB, main journal, WAL file and master journal are never
  ** automatically deleted. Nor are they ever temporary files.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>!</operator><name>isDelete</name> <operator>&amp;&amp;</operator> <name>zName</name><operator>)</operator> <operator>||</operator> <name>eType</name><operator>!=</operator><name>SQLITE_OPEN_MAIN_DB</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>!</operator><name>isDelete</name> <operator>&amp;&amp;</operator> <name>zName</name><operator>)</operator> <operator>||</operator> <name>eType</name><operator>!=</operator><name>SQLITE_OPEN_MAIN_JOURNAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>!</operator><name>isDelete</name> <operator>&amp;&amp;</operator> <name>zName</name><operator>)</operator> <operator>||</operator> <name>eType</name><operator>!=</operator><name>SQLITE_OPEN_MASTER_JOURNAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>!</operator><name>isDelete</name> <operator>&amp;&amp;</operator> <name>zName</name><operator>)</operator> <operator>||</operator> <name>eType</name><operator>!=</operator><name>SQLITE_OPEN_WAL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Assert that the upper layer has set one of the "file-type" flags. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>eType</name><operator>==</operator><name>SQLITE_OPEN_MAIN_DB</name>      <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_OPEN_TEMP_DB</name>
       <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_OPEN_MAIN_JOURNAL</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_OPEN_TEMP_JOURNAL</name>
       <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_OPEN_SUBJOURNAL</name>   <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_OPEN_MASTER_JOURNAL</name>
       <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_OPEN_TRANSIENT_DB</name> <operator>||</operator> <name>eType</name><operator>==</operator><name>SQLITE_OPEN_WAL</name></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pFile</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>winFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name>INVALID_HANDLE_VALUE</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINRT</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zUtf8Name</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>sqlite3_temp_directory</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><name>SQLITE_ERROR</name></expr></argument>,
        <argument><expr><literal type="string">"sqlite3_temp_directory variable should be set for WinRT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If the second argument to this function is NULL, generate a
  ** temporary file name to use
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zUtf8Name</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isDelete</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isOpenJournal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winGetTempname</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zTmpname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"OPEN name=%s, rc=%s"</literal><operator>,</operator> <name>zUtf8Name</name><operator>,</operator> <call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zUtf8Name</name> <operator>=</operator> <name>zTmpname</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Database filenames are double-zero terminated if they are not
  ** URIs with parameters.  Hence, they can always be passed into
  ** sqlite3_uri_parameter().
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>eType</name><operator>!=</operator><name>SQLITE_OPEN_MAIN_DB</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_URI</name><operator>)</operator> <operator>||</operator>
       <name><name>zUtf8Name</name><index>[<expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zUtf8Name</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Convert the filename to the system encoding. */</comment>
  <expr_stmt><expr><name>zConverted</name> <operator>=</operator> <call><name>winConvertFromUtf8Filename</name><argument_list>(<argument><expr><name>zUtf8Name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zConverted</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTmpname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"OPEN name=%s, rc=SQLITE_IOERR_NOMEM"</literal><operator>,</operator> <name>zUtf8Name</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>winIsDir</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTmpname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"OPEN name=%s, rc=SQLITE_CANTOPEN_ISDIR"</literal><operator>,</operator> <name>zUtf8Name</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_CANTOPEN_ISDIR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>isReadWrite</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>dwDesiredAccess</name> <operator>=</operator> <name>GENERIC_READ</name> <operator>|</operator> <name>GENERIC_WRITE</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>dwDesiredAccess</name> <operator>=</operator> <name>GENERIC_READ</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* SQLITE_OPEN_EXCLUSIVE is used to make sure that a new file is
  ** created. SQLite doesn't use it to indicate "exclusive access"
  ** as it is usually understood.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>isExclusive</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Creates a new file, only if it does not already exist. */</comment>
    <comment type="block">/* If the file exists, it fails. */</comment>
    <expr_stmt><expr><name>dwCreationDisposition</name> <operator>=</operator> <name>CREATE_NEW</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>isCreate</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Open existing file, or create if it doesn't exist */</comment>
    <expr_stmt><expr><name>dwCreationDisposition</name> <operator>=</operator> <name>OPEN_ALWAYS</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Opens a file, only if it exists. */</comment>
    <expr_stmt><expr><name>dwCreationDisposition</name> <operator>=</operator> <name>OPEN_EXISTING</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>dwShareMode</name> <operator>=</operator> <name>FILE_SHARE_READ</name> <operator>|</operator> <name>FILE_SHARE_WRITE</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>isDelete</name></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINCE</name></expr></cpp:if>
    <expr_stmt><expr><name>dwFlagsAndAttributes</name> <operator>=</operator> <name>FILE_ATTRIBUTE_HIDDEN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>isTemp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>dwFlagsAndAttributes</name> <operator>=</operator> <name>FILE_ATTRIBUTE_TEMPORARY</name>
                               <operator>|</operator> <name>FILE_ATTRIBUTE_HIDDEN</name>
                               <operator>|</operator> <name>FILE_FLAG_DELETE_ON_CLOSE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>dwFlagsAndAttributes</name> <operator>=</operator> <name>FILE_ATTRIBUTE_NORMAL</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <comment type="block">/* Reports from the internet are that performance is always
  ** better if FILE_FLAG_RANDOM_ACCESS is used.  Ticket #2699. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINCE</name></expr></cpp:if>
  <expr_stmt><expr><name>dwFlagsAndAttributes</name> <operator>|=</operator> <name>FILE_FLAG_RANDOM_ACCESS</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if<condition>( <expr><call><name>osIsNT</name><argument_list>()</argument_list></call></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINRT</name></expr></cpp:if>
    <decl_stmt><decl><type><name>CREATEFILE2_EXTENDED_PARAMETERS</name></type> <name>extendedParameters</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>extendedParameters</name><operator>.</operator><name>dwSize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CREATEFILE2_EXTENDED_PARAMETERS</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>extendedParameters</name><operator>.</operator><name>dwFileAttributes</name></name> <operator>=</operator>
            <name>dwFlagsAndAttributes</name> <operator>&amp;</operator> <name>FILE_ATTRIBUTE_MASK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>extendedParameters</name><operator>.</operator><name>dwFileFlags</name></name> <operator>=</operator> <name>dwFlagsAndAttributes</name> <operator>&amp;</operator> <name>FILE_FLAG_MASK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>extendedParameters</name><operator>.</operator><name>dwSecurityQosFlags</name></name> <operator>=</operator> <name>SECURITY_ANONYMOUS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>extendedParameters</name><operator>.</operator><name>lpSecurityAttributes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>extendedParameters</name><operator>.</operator><name>hTemplateFile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>(</operator><name>h</name> <operator>=</operator> <call><name>osCreateFile2</name><argument_list>(<argument><expr><operator>(</operator><name>LPCWSTR</name><operator>)</operator><name>zConverted</name></expr></argument>,
                              <argument><expr><name>dwDesiredAccess</name></expr></argument>,
                              <argument><expr><name>dwShareMode</name></expr></argument>,
                              <argument><expr><name>dwCreationDisposition</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>extendedParameters</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>INVALID_HANDLE_VALUE</name> <operator>&amp;&amp;</operator>
                              <call><name>winRetryIoerr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastErrno</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
               <comment type="block">/* Noop */</comment>
    </block_content>}</block></while>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <while>while<condition>( <expr><operator>(</operator><name>h</name> <operator>=</operator> <call><name>osCreateFileW</name><argument_list>(<argument><expr><operator>(</operator><name>LPCWSTR</name><operator>)</operator><name>zConverted</name></expr></argument>,
                              <argument><expr><name>dwDesiredAccess</name></expr></argument>,
                              <argument><expr><name>dwShareMode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><name>dwCreationDisposition</name></expr></argument>,
                              <argument><expr><name>dwFlagsAndAttributes</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>INVALID_HANDLE_VALUE</name> <operator>&amp;&amp;</operator>
                              <call><name>winRetryIoerr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastErrno</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
               <comment type="block">/* Noop */</comment>
    </block_content>}</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_WIN32_HAS_ANSI</name></cpp:ifdef>
  <else>else<block>{<block_content>
    <while>while<condition>( <expr><operator>(</operator><name>h</name> <operator>=</operator> <call><name>osCreateFileA</name><argument_list>(<argument><expr><operator>(</operator><name>LPCSTR</name><operator>)</operator><name>zConverted</name></expr></argument>,
                              <argument><expr><name>dwDesiredAccess</name></expr></argument>,
                              <argument><expr><name>dwShareMode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><name>dwCreationDisposition</name></expr></argument>,
                              <argument><expr><name>dwFlagsAndAttributes</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>INVALID_HANDLE_VALUE</name> <operator>&amp;&amp;</operator>
                              <call><name>winRetryIoerr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastErrno</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
               <comment type="block">/* Noop */</comment>
    </block_content>}</block></while>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>winLogIoerr</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"OPEN file=%p, name=%s, access=%lx, rc=%s\n"</literal><operator>,</operator> <name>h</name><operator>,</operator> <name>zUtf8Name</name><operator>,</operator>
           <name>dwDesiredAccess</name><operator>,</operator> <ternary><condition><expr><operator>(</operator><name>h</name><operator>==</operator><name>INVALID_HANDLE_VALUE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"failed"</literal></expr> </then><else>: <expr><literal type="string">"ok"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>h</name><operator>==</operator><name>INVALID_HANDLE_VALUE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>lastErrno</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN</name></expr></argument>, <argument><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name></expr></argument>, <argument><expr><literal type="string">"winOpen"</literal></expr></argument>, <argument><expr><name>zUtf8Name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTmpname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>isReadWrite</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isExclusive</name></expr> )</condition><block>{<block_content>
      <return>return <expr><call><name>winOpen</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>id</name></expr></argument>,
         <argument><expr><operator>(</operator><operator>(</operator><name>flags</name><operator>|</operator><name>SQLITE_OPEN_READONLY</name><operator>)</operator> <operator>&amp;</operator>
                     <operator>~</operator><operator>(</operator><name>SQLITE_OPEN_CREATE</name><operator>|</operator><name>SQLITE_OPEN_READWRITE</name><operator>)</operator><operator>)</operator></expr></argument>,
         <argument><expr><name>pOutFlags</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <return>return <expr><name>SQLITE_CANTOPEN_BKPT</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>pOutFlags</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>isReadWrite</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pOutFlags</name> <operator>=</operator> <name>SQLITE_OPEN_READWRITE</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pOutFlags</name> <operator>=</operator> <name>SQLITE_OPEN_READONLY</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"OPEN file=%p, name=%s, access=%lx, pOutFlags=%p, *pOutFlags=%d, "</literal>
           <literal type="string">"rc=%s\n"</literal><operator>,</operator> <name>h</name><operator>,</operator> <name>zUtf8Name</name><operator>,</operator> <name>dwDesiredAccess</name><operator>,</operator> <name>pOutFlags</name><operator>,</operator> <ternary><condition><expr><name>pOutFlags</name></expr> ?</condition><then>
           <expr><operator>*</operator><name>pOutFlags</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator> <ternary><condition><expr><operator>(</operator><name>h</name><operator>==</operator><name>INVALID_HANDLE_VALUE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"failed"</literal></expr> </then><else>: <expr><literal type="string">"ok"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINCE</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>isReadWrite</name> <operator>&amp;&amp;</operator> <name>eType</name><operator>==</operator><name>SQLITE_OPEN_MAIN_DB</name>
       <operator>&amp;&amp;</operator> <operator>(</operator><name>rc</name> <operator>=</operator> <call><name>winceCreateLock</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><name>pFile</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><name>SQLITE_OK</name></expr>
  )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>osCloseHandle</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTmpname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"OPEN-CE-LOCK name=%s, rc=%s\n"</literal><operator>,</operator> <name>zName</name><operator>,</operator> <call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>isTemp</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>zDeleteOnClose</name></name> <operator>=</operator> <name>zConverted</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTmpname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>pMethod</name></name> <operator>=</operator> <operator>&amp;</operator><name>winIoMethod</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>pVfs</name></name> <operator>=</operator> <name>pVfs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>isReadonly</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>|=</operator> <name>WINFILE_RDONLY</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_uri_boolean</name><argument_list>(<argument><expr><name>zName</name></expr></argument>, <argument><expr><literal type="string">"psow"</literal></expr></argument>, <argument><expr><name>SQLITE_POWERSAFE_OVERWRITE</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>ctrlFlags</name></name> <operator>|=</operator> <name>WINFILE_PSOW</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>lastErrno</name></name> <operator>=</operator> <name>NO_ERROR</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>zPath</name></name> <operator>=</operator> <name>zName</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_MAX_MMAP_SIZE</name><operator>&gt;</operator><literal type="number">0</literal></expr></cpp:if>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>hMap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>pMapRegion</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>mmapSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>mmapSizeActual</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pFile</name><operator>-&gt;</operator><name>mmapSizeMax</name></name> <operator>=</operator> <name><name>sqlite3GlobalConfig</name><operator>.</operator><name>szMmap</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>OpenCounter</name><argument_list>(<argument><expr><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Delete the named file.
**
** Note that Windows does not allow a file to be deleted if some other
** process has it open.  Sometimes a virus scanner or indexing program
** will open a journal file shortly after it is created in order to do
** whatever it does.  While this other process is holding the
** file open, we will be unable to delete it.  To work around this
** problem, we delay 100 milliseconds and try to delete again.  Up
** to MX_DELETION_ATTEMPTs deletion attempts are run before giving
** up and returning an error.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winDelete</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,          <comment type="block">/* Not used on win32 */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>,      <comment type="block">/* Name of file to delete */</comment>
  <parameter><decl><type><name>int</name></type> <name>syncDir</name></decl></parameter>                 <comment type="block">/* Not used on win32 */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>attr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>lastErrno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>zConverted</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>syncDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <macro><name>SimulateIOError</name><argument_list>(<argument>return SQLITE_IOERR_DELETE</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"DELETE name=%s, syncDir=%d\n"</literal><operator>,</operator> <name>zFilename</name><operator>,</operator> <name>syncDir</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>zConverted</name> <operator>=</operator> <call><name>winConvertFromUtf8Filename</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zConverted</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"DELETE name=%s, rc=SQLITE_IOERR_NOMEM\n"</literal><operator>,</operator> <name>zFilename</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>osIsNT</name><argument_list>()</argument_list></call></expr> )</condition><block>{<block_content>
    <do>do <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINRT</name></expr></cpp:if>
      <decl_stmt><decl><type><name>WIN32_FILE_ATTRIBUTE_DATA</name></type> <name>sAttrData</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sAttrData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sAttrData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>( <expr><call><name>osGetFileAttributesExW</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>, <argument><expr><name>GetFileExInfoStandard</name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>sAttrData</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>attr</name> <operator>=</operator> <name><name>sAttrData</name><operator>.</operator><name>dwFileAttributes</name></name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>lastErrno</name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>lastErrno</name><operator>==</operator><name>ERROR_FILE_NOT_FOUND</name>
         <operator>||</operator> <name>lastErrno</name><operator>==</operator><name>ERROR_PATH_NOT_FOUND</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_DELETE_NOENT</name></expr>;</expr_stmt> <comment type="block">/* Already gone? */</comment>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>osGetFileAttributesW</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if_stmt><if>if <condition>( <expr><name>attr</name><operator>==</operator><name>INVALID_FILE_ATTRIBUTES</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>lastErrno</name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>lastErrno</name><operator>==</operator><name>ERROR_FILE_NOT_FOUND</name>
         <operator>||</operator> <name>lastErrno</name><operator>==</operator><name>ERROR_PATH_NOT_FOUND</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_DELETE_NOENT</name></expr>;</expr_stmt> <comment type="block">/* Already gone? */</comment>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>( <expr><name>attr</name><operator>&amp;</operator><name>FILE_ATTRIBUTE_DIRECTORY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt> <comment type="block">/* Files only. */</comment>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>( <expr><call><name>osDeleteFileW</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt> <comment type="block">/* Deleted OK. */</comment>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>( <expr><operator>!</operator><call><name>winRetryIoerr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastErrno</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt> <comment type="block">/* No more retries. */</comment>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block> while<condition>(<expr><literal type="number">1</literal></expr>)</condition>;</do>
  </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_WIN32_HAS_ANSI</name></cpp:ifdef>
  <else>else<block>{<block_content>
    <do>do <block>{<block_content>
      <expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>osGetFileAttributesA</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>( <expr><name>attr</name><operator>==</operator><name>INVALID_FILE_ATTRIBUTES</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>lastErrno</name> <operator>=</operator> <call><name>osGetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>lastErrno</name><operator>==</operator><name>ERROR_FILE_NOT_FOUND</name>
         <operator>||</operator> <name>lastErrno</name><operator>==</operator><name>ERROR_PATH_NOT_FOUND</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_DELETE_NOENT</name></expr>;</expr_stmt> <comment type="block">/* Already gone? */</comment>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>( <expr><name>attr</name><operator>&amp;</operator><name>FILE_ATTRIBUTE_DIRECTORY</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt> <comment type="block">/* Files only. */</comment>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>( <expr><call><name>osDeleteFileA</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt> <comment type="block">/* Deleted OK. */</comment>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>( <expr><operator>!</operator><call><name>winRetryIoerr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastErrno</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt> <comment type="block">/* No more retries. */</comment>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block> while<condition>(<expr><literal type="number">1</literal></expr>)</condition>;</do>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>rc</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_IOERR_DELETE_NOENT</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_DELETE</name></expr></argument>, <argument><expr><name>lastErrno</name></expr></argument>, <argument><expr><literal type="string">"winDelete"</literal></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>winLogIoerr</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"DELETE name=%s, rc=%s\n"</literal><operator>,</operator> <name>zFilename</name><operator>,</operator> <call><name>sqlite3ErrName</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check the existence and status of a file.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winAccess</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,         <comment type="block">/* Not used on win32 */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>,     <comment type="block">/* Name of file to check */</comment>
  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,                 <comment type="block">/* Type of test to make on this file */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pResOut</name></decl></parameter>               <comment type="block">/* OUT: Result */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>attr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>lastErrno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>zConverted</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_IOERR_ACCESS;</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"ACCESS name=%s, flags=%x, pResOut=%p\n"</literal><operator>,</operator>
           <name>zFilename</name><operator>,</operator> <name>flags</name><operator>,</operator> <name>pResOut</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>zConverted</name> <operator>=</operator> <call><name>winConvertFromUtf8Filename</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zConverted</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"ACCESS name=%s, rc=SQLITE_IOERR_NOMEM\n"</literal><operator>,</operator> <name>zFilename</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>osIsNT</name><argument_list>()</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WIN32_FILE_ATTRIBUTE_DATA</name></type> <name>sAttrData</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sAttrData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sAttrData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>!</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>osGetFileAttributesExW</name><argument_list>(<argument><expr><operator>(</operator><name>LPCWSTR</name><operator>)</operator><name>zConverted</name></expr></argument>,
                             <argument><expr><name>GetFileExInfoStandard</name></expr></argument>,
                             <argument><expr><operator>&amp;</operator><name>sAttrData</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>winRetryIoerr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lastErrno</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content/>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* For an SQLITE_ACCESS_EXISTS query, treat a zero-length file
      ** as if it does not exist.
      */</comment>
      <if_stmt><if>if<condition>(    <expr><name>flags</name><operator>==</operator><name>SQLITE_ACCESS_EXISTS</name>
          <operator>&amp;&amp;</operator> <name><name>sAttrData</name><operator>.</operator><name>nFileSizeHigh</name></name><operator>==</operator><literal type="number">0</literal>
          <operator>&amp;&amp;</operator> <name><name>sAttrData</name><operator>.</operator><name>nFileSizeLow</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>attr</name> <operator>=</operator> <name>INVALID_FILE_ATTRIBUTES</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>attr</name> <operator>=</operator> <name><name>sAttrData</name><operator>.</operator><name>dwFileAttributes</name></name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>winLogIoerr</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>lastErrno</name><operator>!=</operator><name>ERROR_FILE_NOT_FOUND</name> <operator>&amp;&amp;</operator> <name>lastErrno</name><operator>!=</operator><name>ERROR_PATH_NOT_FOUND</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_IOERR_ACCESS</name></expr></argument>, <argument><expr><name>lastErrno</name></expr></argument>, <argument><expr><literal type="string">"winAccess"</literal></expr></argument>,
                           <argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr>;</return>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>attr</name> <operator>=</operator> <name>INVALID_FILE_ATTRIBUTES</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_WIN32_HAS_ANSI</name></cpp:ifdef>
  <else>else<block>{<block_content>
    <expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>osGetFileAttributesA</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>flags</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_ACCESS_READ</name></expr>:</case>
    <case>case <expr><name>SQLITE_ACCESS_EXISTS</name></expr>:</case>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>attr</name><operator>!=</operator><name>INVALID_FILE_ATTRIBUTES</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>SQLITE_ACCESS_READWRITE</name></expr>:</case>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>attr</name><operator>!=</operator><name>INVALID_FILE_ATTRIBUTES</name> <operator>&amp;&amp;</operator>
             <operator>(</operator><name>attr</name> <operator>&amp;</operator> <name>FILE_ATTRIBUTE_READONLY</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><literal type="string">"Invalid flags argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></switch>
  <expr_stmt><expr><operator>*</operator><name>pResOut</name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"ACCESS name=%s, pResOut=%p, *pResOut=%d, rc=SQLITE_OK\n"</literal><operator>,</operator>
           <name>zFilename</name><operator>,</operator> <name>pResOut</name><operator>,</operator> <operator>*</operator><name>pResOut</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Returns non-zero if the specified path name starts with a drive letter
** followed by a colon character.
*/</comment>
<function><type><specifier>static</specifier> <name>BOOL</name></type> <name>winIsDriveLetterAndColon</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPathname</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator> <call><name>sqlite3Isalpha</name><argument_list>(<argument><expr><name><name>zPathname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>zPathname</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">':'</literal> <operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Returns non-zero if the specified path name should be used verbatim.  If
** non-zero is returned from this function, the calling function must simply
** use the provided path name verbatim -OR- resolve it into a full path name
** using the GetFullPathName Win32 API function (if available).
*/</comment>
<function><type><specifier>static</specifier> <name>BOOL</name></type> <name>winIsVerbatimPathname</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPathname</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <comment type="block">/*
  ** If the path name starts with a forward slash or a backslash, it is either
  ** a legal UNC name, a volume relative path, or an absolute path name in the
  ** "Unix" format on Windows.  There is no easy way to differentiate between
  ** the final two cases; therefore, we return the safer return value of TRUE
  ** so that callers of this function will simply use it verbatim.
  */</comment>
  <if_stmt><if>if <condition>( <expr><call><name>winIsDirSep</name><argument_list>(<argument><expr><name><name>zPathname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/*
  ** If the path name starts with a letter and a colon it is either a volume
  ** relative path or an absolute path.  Callers of this function must not
  ** attempt to treat it as a relative path name (i.e. they should simply use
  ** it verbatim).
  */</comment>
  <if_stmt><if>if <condition>( <expr><call><name>winIsDriveLetterAndColon</name><argument_list>(<argument><expr><name>zPathname</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/*
  ** If we get to this point, the path name should almost certainly be a purely
  ** relative one (i.e. not a UNC name, not absolute, and not volume relative).
  */</comment>
  <return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Turn a relative pathname into a full pathname.  Write the full
** pathname into zOut[].  zOut[] will be at least pVfs-&gt;mxPathname
** bytes in size.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winFullPathname</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>,            <comment type="block">/* Pointer to vfs object */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRelative</name></decl></parameter>,        <comment type="block">/* Possibly relative input path */</comment>
  <parameter><decl><type><name>int</name></type> <name>nFull</name></decl></parameter>,                    <comment type="block">/* Size of output buffer in bytes */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zFull</name></decl></parameter>                   <comment type="block">/* Output buffer */</comment>
)</parameter_list><block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_ERROR</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>nFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nFull</name><operator>&gt;=</operator><name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>( <expr><name>sqlite3_data_directory</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>winIsVerbatimPathname</name><argument_list>(<argument><expr><name>zRelative</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/*
    ** NOTE: We are dealing with a relative path name and the data
    **       directory has been set.  Therefore, use it as the basis
    **       for converting the relative path name to an absolute
    **       one by prepending the data directory and a slash.
    */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name> <init>= <expr><call><name>sqlite3MallocZero</name><argument_list>( <argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zOut</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>cygwin_conv_path</name><argument_list>(
            <argument><expr><operator>(</operator><ternary><condition><expr><call><name>osIsNT</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>CCP_POSIX_TO_WIN_W</name></expr> </then><else>: <expr><name>CCP_POSIX_TO_WIN_A</name></expr></else></ternary><operator>)</operator> <operator>|</operator>
            <name>CCP_RELATIVE</name></expr></argument>, <argument><expr><name>zRelative</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN_CONVPATH</name></expr></argument>, <argument><expr><operator>(</operator><name>DWORD</name><operator>)</operator><name>errno</name></expr></argument>,
                         <argument><expr><literal type="string">"winFullPathname1"</literal></expr></argument>, <argument><expr><name>zRelative</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zUtf8</name> <init>= <expr><call><name>winConvertToUtf8Filename</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zUtf8</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>nFull</name></expr></argument>, <argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zFull</name></expr></argument>, <argument><expr><literal type="string">"%s%c%s"</literal></expr></argument>,
                       <argument><expr><name>sqlite3_data_directory</name></expr></argument>, <argument><expr><call><name>winGetDirSep</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>zUtf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zUtf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name> <init>= <expr><call><name>sqlite3MallocZero</name><argument_list>( <argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zOut</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>cygwin_conv_path</name><argument_list>(
            <argument><expr><operator>(</operator><ternary><condition><expr><call><name>osIsNT</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>CCP_POSIX_TO_WIN_W</name></expr> </then><else>: <expr><name>CCP_POSIX_TO_WIN_A</name></expr></else></ternary><operator>)</operator></expr></argument>,
            <argument><expr><name>zRelative</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN_CONVPATH</name></expr></argument>, <argument><expr><operator>(</operator><name>DWORD</name><operator>)</operator><name>errno</name></expr></argument>,
                         <argument><expr><literal type="string">"winFullPathname2"</literal></expr></argument>, <argument><expr><name>zRelative</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zUtf8</name> <init>= <expr><call><name>winConvertToUtf8Filename</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zUtf8</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>nFull</name></expr></argument>, <argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zFull</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zUtf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zUtf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>SQLITE_OS_WINCE</name> <operator>||</operator> <name>SQLITE_OS_WINRT</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_ERROR</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  <comment type="block">/* WinCE has no concept of a relative pathname, or so I am told. */</comment>
  <comment type="block">/* WinRT has no way to convert a relative path to an absolute one. */</comment>
  <if_stmt><if>if <condition>( <expr><name>sqlite3_data_directory</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>winIsVerbatimPathname</name><argument_list>(<argument><expr><name>zRelative</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/*
    ** NOTE: We are dealing with a relative path name and the data
    **       directory has been set.  Therefore, use it as the basis
    **       for converting the relative path name to an absolute
    **       one by prepending the data directory and a backslash.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>nFull</name></expr></argument>, <argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zFull</name></expr></argument>, <argument><expr><literal type="string">"%s%c%s"</literal></expr></argument>,
                     <argument><expr><name>sqlite3_data_directory</name></expr></argument>, <argument><expr><call><name>winGetDirSep</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>zRelative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>nFull</name></expr></argument>, <argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zFull</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zRelative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_OS_WINCE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>SQLITE_OS_WINRT</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>nByte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>zConverted</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl>;</decl_stmt>

  <comment type="block">/* If this path name begins with "/X:", where "X" is any alphabetic
  ** character, discard the initial "/" from the pathname.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>zRelative</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <call><name>winIsDriveLetterAndColon</name><argument_list>(<argument><expr><name>zRelative</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zRelative</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* It's odd to simulate an io-error here, but really this is just
  ** using the io-error infrastructure to test that SQLite handles this
  ** function failing. This function could fail if, for example, the
  ** current working directory has been unlinked.
  */</comment>
  <macro><name>SimulateIOError</name><argument_list>( <argument>return SQLITE_ERROR</argument> )</argument_list></macro><empty_stmt>;</empty_stmt>
  <if_stmt><if>if <condition>( <expr><name>sqlite3_data_directory</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>winIsVerbatimPathname</name><argument_list>(<argument><expr><name>zRelative</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/*
    ** NOTE: We are dealing with a relative path name and the data
    **       directory has been set.  Therefore, use it as the basis
    **       for converting the relative path name to an absolute
    **       one by prepending the data directory and a backslash.
    */</comment>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>nFull</name></expr></argument>, <argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zFull</name></expr></argument>, <argument><expr><literal type="string">"%s%c%s"</literal></expr></argument>,
                     <argument><expr><name>sqlite3_data_directory</name></expr></argument>, <argument><expr><call><name>winGetDirSep</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>zRelative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zConverted</name> <operator>=</operator> <call><name>winConvertFromUtf8Filename</name><argument_list>(<argument><expr><name>zRelative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zConverted</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>osIsNT</name><argument_list>()</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LPWSTR</name></type> <name>zTemp</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>osGetFullPathNameW</name><argument_list>(<argument><expr><operator>(</operator><name>LPCWSTR</name><operator>)</operator><name>zConverted</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN_FULLPATH</name></expr></argument>, <argument><expr><call><name>osGetLastError</name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><literal type="string">"winFullPathname1"</literal></expr></argument>, <argument><expr><name>zRelative</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zTemp</name> <operator>=</operator> <call><name>sqlite3MallocZero</name><argument_list>( <argument><expr><name>nByte</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>zTemp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zTemp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>osGetFullPathNameW</name><argument_list>(<argument><expr><operator>(</operator><name>LPCWSTR</name><operator>)</operator><name>zConverted</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>zTemp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN_FULLPATH</name></expr></argument>, <argument><expr><call><name>osGetLastError</name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><literal type="string">"winFullPathname2"</literal></expr></argument>, <argument><expr><name>zRelative</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zOut</name> <operator>=</operator> <call><name>winUnicodeToUtf8</name><argument_list>(<argument><expr><name>zTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_WIN32_HAS_ANSI</name></cpp:ifdef>
  <else>else<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zTemp</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>osGetFullPathNameA</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zConverted</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN_FULLPATH</name></expr></argument>, <argument><expr><call><name>osGetLastError</name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><literal type="string">"winFullPathname3"</literal></expr></argument>, <argument><expr><name>zRelative</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zTemp</name> <operator>=</operator> <call><name>sqlite3MallocZero</name><argument_list>( <argument><expr><name>nByte</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>zTemp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zTemp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nByte</name> <operator>=</operator> <call><name>osGetFullPathNameA</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zConverted</name></expr></argument>, <argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>zTemp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>winLogError</name><argument_list>(<argument><expr><name>SQLITE_CANTOPEN_FULLPATH</name></expr></argument>, <argument><expr><call><name>osGetLastError</name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><literal type="string">"winFullPathname4"</literal></expr></argument>, <argument><expr><name>zRelative</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zOut</name> <operator>=</operator> <call><name>sqlite3_win32_mbcs_to_utf8</name><argument_list>(<argument><expr><name>zTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zTemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>zOut</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>nFull</name></expr></argument>, <argument><expr><name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>zFull</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><name>SQLITE_IOERR_NOMEM</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOAD_EXTENSION</name></cpp:ifndef>
<comment type="block">/*
** Interfaces for opening a shared library, finding entry points
** within the shared library, and closing the shared library.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>winDlOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFilename</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>HANDLE</name></type> <name>h</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>nFull</name> <init>= <expr><name><name>pVfs</name><operator>-&gt;</operator><name>mxPathname</name></name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zFull</name> <init>= <expr><call><name>sqlite3MallocZero</name><argument_list>( <argument><expr><name>nFull</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>zConverted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zFull</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"DLOPEN name=%s, handle=%p\n"</literal><operator>,</operator> <name>zFilename</name><operator>,</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>winFullPathname</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><name>zFilename</name></expr></argument>, <argument><expr><name>nFull</name></expr></argument>, <argument><expr><name>zFull</name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"DLOPEN name=%s, handle=%p\n"</literal><operator>,</operator> <name>zFilename</name><operator>,</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zConverted</name> <operator>=</operator> <call><name>winConvertFromUtf8Filename</name><argument_list>(<argument><expr><name>zFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zFull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>zConverted</name> <init>= <expr><call><name>winConvertFromUtf8Filename</name><argument_list>(<argument><expr><name>zFilename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>zConverted</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"DLOPEN name=%s, handle=%p\n"</literal><operator>,</operator> <name>zFilename</name><operator>,</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>osIsNT</name><argument_list>()</argument_list></call></expr> )</condition><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINRT</name></expr></cpp:if>
    <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>osLoadPackagedLibrary</name><argument_list>(<argument><expr><operator>(</operator><name>LPCWSTR</name><operator>)</operator><name>zConverted</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>osLoadLibraryW</name><argument_list>(<argument><expr><operator>(</operator><name>LPCWSTR</name><operator>)</operator><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_WIN32_HAS_ANSI</name></cpp:ifdef>
  <else>else<block>{<block_content>
    <expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>osLoadLibraryA</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"DLOPEN name=%s, handle=%p\n"</literal><operator>,</operator> <name>zFilename</name><operator>,</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>h</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zConverted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>h</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>winDlError</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nBuf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBufOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>winGetLastErrorMsg</name><argument_list>(<argument><expr><call><name>osGetLastError</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>, <argument><expr><name>zBufOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><specifier>static</specifier> <macro><name>void</name> <argument_list>(<argument>*winDlSym(sqlite3_vfs *pVfs,void *pH,const char *zSym)</argument>)</argument_list></macro><operator>(</operator><name>void</name><operator>)</operator><block>{
  <expr><name>FARPROC</name> <name>proc</name></expr>;
  <call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
  <expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>osGetProcAddressA</name><argument_list>(<argument><expr><operator>(</operator><name>HANDLE</name><operator>)</operator><name>pH</name></expr></argument>, <argument><expr><name>zSym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"DLSYM handle=%p, symbol=%s, address=%p\n"</literal><operator>,</operator>
           <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pH</name><operator>,</operator> <name>zSym</name><operator>,</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>proc</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call><operator>)</operator><name>proc</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>winDlClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pHandle</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>osFreeLibrary</name><argument_list>(<argument><expr><operator>(</operator><name>HANDLE</name><operator>)</operator><name>pHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OSTRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"DLCLOSE handle=%p\n"</literal><operator>,</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pHandle</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* if SQLITE_OMIT_LOAD_EXTENSION is defined: */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>winDlOpen</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>winDlError</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>winDlSym</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>winDlClose</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Write up to nBuf bytes of randomness into zBuf.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winRandomness</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nBuf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_TEST</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_OMIT_RANDOMNESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name>nBuf</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if<condition>( <expr><sizeof>sizeof<argument_list>(<argument><expr><name>SYSTEMTIME</name></expr></argument>)</argument_list></sizeof><operator>&lt;=</operator><name>nBuf</name><operator>-</operator><name>n</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>SYSTEMTIME</name></type> <name>x</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>osGetSystemTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><sizeof>sizeof<argument_list>(<argument><expr><name>DWORD</name></expr></argument>)</argument_list></sizeof><operator>&lt;=</operator><name>nBuf</name><operator>-</operator><name>n</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>pid</name> <init>= <expr><call><name>osGetCurrentProcessId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINRT</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><sizeof>sizeof<argument_list>(<argument><expr><name>ULONGLONG</name></expr></argument>)</argument_list></sizeof><operator>&lt;=</operator><name>nBuf</name><operator>-</operator><name>n</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>ULONGLONG</name></type> <name>cnt</name> <init>= <expr><call><name>osGetTickCount64</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if<condition>( <expr><sizeof>sizeof<argument_list>(<argument><expr><name>DWORD</name></expr></argument>)</argument_list></sizeof><operator>&lt;=</operator><name>nBuf</name><operator>-</operator><name>n</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>cnt</name> <init>= <expr><call><name>osGetTickCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><sizeof>sizeof<argument_list>(<argument><expr><name>LARGE_INTEGER</name></expr></argument>)</argument_list></sizeof><operator>&lt;=</operator><name>nBuf</name><operator>-</operator><name>n</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LARGE_INTEGER</name></type> <name>i</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>osQueryPerformanceCounter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_OS_WINCE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>SQLITE_OS_WINRT</name> <operator>&amp;&amp;</operator> <name>SQLITE_WIN32_USE_UUID</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><sizeof>sizeof<argument_list>(<argument><expr><name>UUID</name></expr></argument>)</argument_list></sizeof><operator>&lt;=</operator><name>nBuf</name><operator>-</operator><name>n</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>UUID</name></type> <name>id</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UUID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>osUuidCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UUID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UUID</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><sizeof>sizeof<argument_list>(<argument><expr><name>UUID</name></expr></argument>)</argument_list></sizeof><operator>&lt;=</operator><name>nBuf</name><operator>-</operator><name>n</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>UUID</name></type> <name>id</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UUID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>osUuidCreateSequential</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UUID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UUID</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(SQLITE_TEST) || defined(SQLITE_ZERO_PRNG_SEED) */</comment>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Sleep for a little while.  Return the amount of time slept.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winSleep</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>microsec</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_win32_sleep</name><argument_list>(<argument><expr><operator>(</operator><name>microsec</name><operator>+</operator><literal type="number">999</literal><operator>)</operator><operator>/</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><operator>(</operator><name>microsec</name><operator>+</operator><literal type="number">999</literal><operator>)</operator><operator>/</operator><literal type="number">1000</literal><operator>)</operator><operator>*</operator><literal type="number">1000</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The following variable, if set to a non-zero value, is interpreted as
** the number of seconds since 1970 and is used to set the result of
** sqlite3OsCurrentTime() during testing.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_current_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Fake system time in seconds since 1970. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Find the current time (in Universal Coordinated Time).  Write into *piNow
** the current time and date as a Julian Day number times 86_400_000.  In
** other words, write into *piNow the number of milliseconds since the Julian
** epoch of noon in Greenwich on November 24, 4714 B.C according to the
** proleptic Gregorian calendar.
**
** On success, return SQLITE_OK.  Return SQLITE_ERROR if the time and date
** cannot be found.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winCurrentTimeInt64</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piNow</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* FILETIME structure is a 64-bit value representing the number of
     100-nanosecond intervals since January 1, 1601 (= JD 2305813.5).
  */</comment>
  <decl_stmt><decl><type><name>FILETIME</name></type> <name>ft</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_int64</name></type> <name>winFiletimeEpoch</name> <init>= <expr><literal type="number">23058135</literal><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><literal type="number">8640000</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_int64</name></type> <name>unixEpoch</name> <init>= <expr><literal type="number">24405875</literal><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><literal type="number">8640000</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="block">/* 2^32 - to avoid use of LL and warnings in gcc */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_int64</name></type> <name>max32BitValue</name> <init>=
      <expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><literal type="number">2000000000</literal> <operator>+</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><literal type="number">2000000000</literal> <operator>+</operator>
      <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><literal type="number">294967296</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINCE</name></expr></cpp:if>
  <decl_stmt><decl><type><name>SYSTEMTIME</name></type> <name>time</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>osGetSystemTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* if SystemTimeToFileTime() fails, it returns zero. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>osSystemTimeToFileTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>time</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ft</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>osGetSystemTimeAsFileTime</name><argument_list>( <argument><expr><operator>&amp;</operator><name>ft</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><operator>*</operator><name>piNow</name> <operator>=</operator> <name>winFiletimeEpoch</name> <operator>+</operator>
            <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>ft</name><operator>.</operator><name>dwHighDateTime</name></name><operator>)</operator><operator>*</operator><name>max32BitValue</name><operator>)</operator> <operator>+</operator>
               <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>ft</name><operator>.</operator><name>dwLowDateTime</name></name><operator>)</operator><operator>/</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><literal type="number">10000</literal></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><name>sqlite3_current_time</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>piNow</name> <operator>=</operator> <literal type="number">1000</literal><operator>*</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>sqlite3_current_time</name> <operator>+</operator> <name>unixEpoch</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Find the current time (in Universal Coordinated Time).  Write the
** current time and date as a Julian Day number into *prNow and
** return 0.  Return 1 if the time and date cannot be found.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winCurrentTime</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>prNow</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>winCurrentTimeInt64</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>prNow</name> <operator>=</operator> <name>i</name><operator>/</operator><literal type="number">86400000.0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The idea is that this function works like a combination of
** GetLastError() and FormatMessage() on Windows (or errno and
** strerror_r() on Unix). After an error is returned by an OS
** function, SQLite calls this function with zBuf pointing to
** a buffer of nBuf bytes. The OS layer should populate the
** buffer with a nul-terminated UTF-8 encoded error message
** describing the last IO error to have occurred within the calling
** thread.
**
** If the error message is too large for the supplied buffer,
** it should be truncated. The return value of xGetLastError
** is zero if the error message fits in the buffer, or non-zero
** otherwise (if the message was truncated). If non-zero is returned,
** then it is not necessary to include the nul-terminator character
** in the output buffer.
**
** Not supplying an error message will have no adverse effect
** on SQLite. It is fine to have an implementation that never
** returns an error message:
**
**   int xGetLastError(sqlite3_vfs *pVfs, int nBuf, char *zBuf){
**     assert(zBuf[0]=='\0');
**     return 0;
**   }
**
** However if an error message is supplied, it will be incorporated
** by sqlite into the error message available to the user using
** sqlite3_errmsg(), possibly making IO errors easier to debug.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winGetLastError</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>pVfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nBuf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>pVfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>winGetLastErrorMsg</name><argument_list>(<argument><expr><call><name>osGetLastError</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nBuf</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Initialize and deinitialize the operating system interface.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_os_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_vfs</name></type> <name>winVfs</name> <init>= <expr><block>{
    <expr><literal type="number">3</literal></expr>,                   <comment type="block">/* iVersion */</comment>
    <expr><sizeof>sizeof<argument_list>(<argument><expr><name>winFile</name></expr></argument>)</argument_list></sizeof></expr>,     <comment type="block">/* szOsFile */</comment>
    <expr><name>SQLITE_WIN32_MAX_PATH_BYTES</name></expr>, <comment type="block">/* mxPathname */</comment>
    <expr><literal type="number">0</literal></expr>,                   <comment type="block">/* pNext */</comment>
    <expr><literal type="string">"win32"</literal></expr>,             <comment type="block">/* zName */</comment>
    <expr><literal type="number">0</literal></expr>,                   <comment type="block">/* pAppData */</comment>
    <expr><name>winOpen</name></expr>,             <comment type="block">/* xOpen */</comment>
    <expr><name>winDelete</name></expr>,           <comment type="block">/* xDelete */</comment>
    <expr><name>winAccess</name></expr>,           <comment type="block">/* xAccess */</comment>
    <expr><name>winFullPathname</name></expr>,     <comment type="block">/* xFullPathname */</comment>
    <expr><name>winDlOpen</name></expr>,           <comment type="block">/* xDlOpen */</comment>
    <expr><name>winDlError</name></expr>,          <comment type="block">/* xDlError */</comment>
    <expr><name>winDlSym</name></expr>,            <comment type="block">/* xDlSym */</comment>
    <expr><name>winDlClose</name></expr>,          <comment type="block">/* xDlClose */</comment>
    <expr><name>winRandomness</name></expr>,       <comment type="block">/* xRandomness */</comment>
    <expr><name>winSleep</name></expr>,            <comment type="block">/* xSleep */</comment>
    <expr><name>winCurrentTime</name></expr>,      <comment type="block">/* xCurrentTime */</comment>
    <expr><name>winGetLastError</name></expr>,     <comment type="block">/* xGetLastError */</comment>
    <expr><name>winCurrentTimeInt64</name></expr>, <comment type="block">/* xCurrentTimeInt64 */</comment>
    <expr><name>winSetSystemCall</name></expr>,    <comment type="block">/* xSetSystemCall */</comment>
    <expr><name>winGetSystemCall</name></expr>,    <comment type="block">/* xGetSystemCall */</comment>
    <expr><name>winNextSystemCall</name></expr>,   <comment type="block">/* xNextSystemCall */</comment>
  }</block></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_WIN32_HAS_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_vfs</name></type> <name>winLongPathVfs</name> <init>= <expr><block>{
    <expr><literal type="number">3</literal></expr>,                   <comment type="block">/* iVersion */</comment>
    <expr><sizeof>sizeof<argument_list>(<argument><expr><name>winFile</name></expr></argument>)</argument_list></sizeof></expr>,     <comment type="block">/* szOsFile */</comment>
    <expr><name>SQLITE_WINNT_MAX_PATH_BYTES</name></expr>, <comment type="block">/* mxPathname */</comment>
    <expr><literal type="number">0</literal></expr>,                   <comment type="block">/* pNext */</comment>
    <expr><literal type="string">"win32-longpath"</literal></expr>,    <comment type="block">/* zName */</comment>
    <expr><literal type="number">0</literal></expr>,                   <comment type="block">/* pAppData */</comment>
    <expr><name>winOpen</name></expr>,             <comment type="block">/* xOpen */</comment>
    <expr><name>winDelete</name></expr>,           <comment type="block">/* xDelete */</comment>
    <expr><name>winAccess</name></expr>,           <comment type="block">/* xAccess */</comment>
    <expr><name>winFullPathname</name></expr>,     <comment type="block">/* xFullPathname */</comment>
    <expr><name>winDlOpen</name></expr>,           <comment type="block">/* xDlOpen */</comment>
    <expr><name>winDlError</name></expr>,          <comment type="block">/* xDlError */</comment>
    <expr><name>winDlSym</name></expr>,            <comment type="block">/* xDlSym */</comment>
    <expr><name>winDlClose</name></expr>,          <comment type="block">/* xDlClose */</comment>
    <expr><name>winRandomness</name></expr>,       <comment type="block">/* xRandomness */</comment>
    <expr><name>winSleep</name></expr>,            <comment type="block">/* xSleep */</comment>
    <expr><name>winCurrentTime</name></expr>,      <comment type="block">/* xCurrentTime */</comment>
    <expr><name>winGetLastError</name></expr>,     <comment type="block">/* xGetLastError */</comment>
    <expr><name>winCurrentTimeInt64</name></expr>, <comment type="block">/* xCurrentTimeInt64 */</comment>
    <expr><name>winSetSystemCall</name></expr>,    <comment type="block">/* xSetSystemCall */</comment>
    <expr><name>winGetSystemCall</name></expr>,    <comment type="block">/* xGetSystemCall */</comment>
    <expr><name>winNextSystemCall</name></expr>,   <comment type="block">/* xNextSystemCall */</comment>
  }</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Double-check that the aSyscall[] array has been constructed
  ** correctly.  See ticket [bb3a86e890c8e96ab] */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>ArraySize</name><argument_list>(<argument><expr><name>aSyscall</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">80</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* get memory map allocation granularity */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>winSysInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SYSTEM_INFO</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINRT</name></expr></cpp:if>
  <expr_stmt><expr><call><name>osGetNativeSystemInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>winSysInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>osGetSystemInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>winSysInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>winSysInfo</name><operator>.</operator><name>dwAllocationGranularity</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>winSysInfo</name><operator>.</operator><name>dwPageSize</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3_vfs_register</name><argument_list>(<argument><expr><operator>&amp;</operator><name>winVfs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_WIN32_HAS_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><call><name>sqlite3_vfs_register</name><argument_list>(<argument><expr><operator>&amp;</operator><name>winLongPathVfs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>sqlite3_os_end</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_OS_WINRT</name></expr></cpp:if>
  <if_stmt><if>if<condition>( <expr><name>sleepObj</name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>osCloseHandle</name><argument_list>(<argument><expr><name>sleepObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sleepObj</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function></block_content></block></function></block_content></block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OS_WIN */</comment>
</unit>
