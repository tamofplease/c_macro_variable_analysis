<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/src/vtab.c"><comment type="block">/*
** 2006 June 10
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code used to help implement virtual tables.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Before a virtual table xCreate() or xConnect() method is invoked, the
** sqlite3.pVtabCtx member variable is set to point to an instance of
** this struct allocated on the stack. It is used by the implementation of 
** the sqlite3_declare_vtab() and sqlite3_vtab_config() APIs, both of which
** are invoked only from within xCreate and xConnect methods.
*/</comment>
<struct>struct <name>VtabCtx</name> <block>{
  <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier></type><name>pVTable</name></decl>;</decl_stmt>    <comment type="block">/* The virtual table being constructed */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>        <comment type="block">/* The Table object to which the virtual table belongs */</comment>
  <decl_stmt><decl><type><name>VtabCtx</name> <modifier>*</modifier></type><name>pPrior</name></decl>;</decl_stmt>    <comment type="block">/* Parent context (if any) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bDeclared</name></decl>;</decl_stmt>      <comment type="block">/* True after sqlite3_declare_vtab() is called */</comment>
}</block>;</struct>

<comment type="block">/*
** The actual function that does the work of creating a new module.
** This function implements the sqlite3_create_module() and
** sqlite3_create_module_v2() interfaces.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>createModule</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database in which module is registered */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,              <comment type="block">/* Name assigned to this module */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name></decl></parameter>,  <comment type="block">/* The definition of the module */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,                     <comment type="block">/* Context pointer for xCreate/xConnect */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDestroy</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>        <comment type="block">/* Module destructor function */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nName</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aModule</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>pMod</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pMod</name> <operator>=</operator> <operator>(</operator><name>Module</name> <operator>*</operator><operator>)</operator><call><name>sqlite3DbMallocRawNN</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Module</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nName</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pMod</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>pDel</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCopy</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>pMod</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zCopy</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMod</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <name>zCopy</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMod</name><operator>-&gt;</operator><name>pModule</name></name> <operator>=</operator> <name>pModule</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMod</name><operator>-&gt;</operator><name>pAux</name></name> <operator>=</operator> <name>pAux</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMod</name><operator>-&gt;</operator><name>xDestroy</name></name> <operator>=</operator> <name>xDestroy</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pMod</name><operator>-&gt;</operator><name>pEpoTab</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>pDel</name> <operator>=</operator> <operator>(</operator><name>Module</name> <operator>*</operator><operator>)</operator><call><name>sqlite3HashInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aModule</name></name></expr></argument>,<argument><expr><name>zCopy</name></expr></argument>,<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>pMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pDel</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>pDel</name><operator>==</operator><name>pMod</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pDel</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pDel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>xDestroy</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>xDestroy</name><argument_list>(<argument><expr><name>pAux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** External API function used to create a new virtual-table module.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_create_module</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database in which module is registered */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,              <comment type="block">/* Name assigned to this module */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name></decl></parameter>,  <comment type="block">/* The definition of the module */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>                      <comment type="block">/* Context pointer for xCreate/xConnect */</comment>
)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><call><name>createModule</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>pModule</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** External API function used to create a new virtual-table module.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_create_module_v2</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,                    <comment type="block">/* Database in which module is registered */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,              <comment type="block">/* Name assigned to this module */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name></decl></parameter>,  <comment type="block">/* The definition of the module */</comment>
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,                     <comment type="block">/* Context pointer for xCreate/xConnect */</comment>
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xDestroy</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>        <comment type="block">/* Module destructor function */</comment>
)</parameter_list><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>zName</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><call><name>createModule</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>pModule</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>, <argument><expr><name>xDestroy</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Lock the virtual table so that it cannot be disconnected.
** Locks nest.  Every lock should have a corresponding unlock.
** If an unlock is omitted, resources leaks will occur.  
**
** If a disconnect is attempted while a virtual table is locked,
** the disconnect is deferred until all locks have been removed.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabLock</name><parameter_list>(<parameter><decl><type><name>VTable</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pVTab</name><operator>-&gt;</operator><name>nRef</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** pTab is a pointer to a Table structure representing a virtual-table.
** Return a pointer to the VTable object used by connection db to access 
** this virtual-table, if one has been created, or NULL otherwise.
*/</comment>
<function><type><name>VTable</name> <modifier>*</modifier></type><name>sqlite3GetVTable</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>pVtab</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pVTable</name></name></expr>;</init> <condition><expr><name>pVtab</name> <operator>&amp;&amp;</operator> <name><name>pVtab</name><operator>-&gt;</operator><name>db</name></name><operator>!=</operator><name>db</name></expr>;</condition> <incr><expr><name>pVtab</name><operator>=</operator><name><name>pVtab</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <return>return <expr><name>pVtab</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Decrement the ref-count on a virtual table object. When the ref-count
** reaches zero, call the xDisconnect() method to delete the object.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabUnlock</name><parameter_list>(<parameter><decl><type><name>VTable</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pVTab</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pVTab</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>magic</name></name><operator>==</operator><name>SQLITE_MAGIC_OPEN</name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>magic</name></name><operator>==</operator><name>SQLITE_MAGIC_ZOMBIE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pVTab</name><operator>-&gt;</operator><name>nRef</name></name><operator>--</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pVTab</name><operator>-&gt;</operator><name>nRef</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pVTab</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name><name>p</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xDisconnect</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pVTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Table p is a virtual table. This function moves all elements in the
** p-&gt;pVTable list to the sqlite3.pDisconnect lists of their associated
** database connections to be disconnected at the next opportunity. 
** Except, if argument db is not NULL, then the entry associated with
** connection db is left in the p-&gt;pVTable list.
*/</comment>
<function><type><specifier>static</specifier> <name>VTable</name> <modifier>*</modifier></type><name>vtabDisconnectAll</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier></type><name>pRet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier></type><name>pVTable</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pVTable</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pVTable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Assert that the mutex (if any) associated with the BtShared database 
  ** that contains table p is held by the caller. See header comments 
  ** above function sqlite3VtabUnlockList() for an explanation of why
  ** this makes it safe to access the sqlite3.pDisconnect list of any
  ** database connection that may have an entry in the p-&gt;pVTable list.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><name>pVTable</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db2</name> <init>= <expr><name><name>pVTable</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><name><name>pVTable</name><operator>-&gt;</operator><name>pNext</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>db2</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>db2</name><operator>==</operator><name>db</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pRet</name> <operator>=</operator> <name>pVTable</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pVTable</name></name> <operator>=</operator> <name>pRet</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pRet</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pVTable</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>db2</name><operator>-&gt;</operator><name>pDisconnect</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db2</name><operator>-&gt;</operator><name>pDisconnect</name></name> <operator>=</operator> <name>pVTable</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>pVTable</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name>db</name> <operator>||</operator> <name>pRet</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pRet</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Table *p is a virtual table. This function removes the VTable object
** for table *p associated with database connection db from the linked
** list in p-&gt;pVTab. It also decrements the VTable ref count. This is
** used when closing database connection db to free all of its VTable
** objects without disturbing the rest of the Schema object (which may
** be being used by other shared-cache connections).
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVTab</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsAllMutexes</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>ppVTab</name><operator>=</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pVTable</name></name></expr>;</init> <condition><expr><operator>*</operator><name>ppVTab</name></expr>;</condition> <incr><expr><name>ppVTab</name><operator>=</operator><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>ppVTab</name><operator>)</operator><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><operator>(</operator><operator>*</operator><name>ppVTab</name><operator>)</operator><operator>-&gt;</operator><name>db</name></name><operator>==</operator><name>db</name></expr>  )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier></type><name>pVTab</name> <init>= <expr><operator>*</operator><name>ppVTab</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><name>ppVTab</name> <operator>=</operator> <name><name>pVTab</name><operator>-&gt;</operator><name>pNext</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VtabUnlock</name><argument_list>(<argument><expr><name>pVTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
** Disconnect all the virtual table objects in the sqlite3.pDisconnect list.
**
** This function may only be called when the mutexes associated with all
** shared b-tree databases opened using connection db are held by the 
** caller. This is done to protect the sqlite3.pDisconnect list. The
** sqlite3.pDisconnect list is accessed only as follows:
**
**   1) By this function. In this case, all BtShared mutexes and the mutex
**      associated with the database handle itself must be held.
**
**   2) By function vtabDisconnectAll(), when it adds a VTable entry to
**      the sqlite3.pDisconnect list. In this case either the BtShared mutex
**      associated with the database the virtual table is stored in is held
**      or, if the virtual table is stored in a non-sharable database, then
**      the database handle mutex is held.
**
** As a result, a sqlite3.pDisconnect cannot be accessed simultaneously 
** by multiple threads. It is thread-safe.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabUnlockList</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pDisconnect</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pDisconnect</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3BtreeHoldsAllMutexes</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_mutex_held</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ExpirePreparedStatements</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <do>do <block>{<block_content>
      <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier></type><name>pNext</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3VtabUnlock</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>p</name></expr> )</condition>;</do>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Clear any and all virtual-table information from the Table record.
** This routine is called, for example, just before deleting the Table
** record.
**
** Since it is a virtual-table, the Table structure contains a pointer
** to the head of a linked list of VTable structures. Each VTable 
** structure is associated with a single sqlite3* user of the schema.
** The reference count of the VTable structure associated with database 
** connection db is decremented immediately (which may lead to the 
** structure being xDisconnected and free). Any other VTable structures
** in the list are moved to the sqlite3.pDisconnect list of the associated 
** database connection.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabClear</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>db</name> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>pnBytesFreed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>vtabDisconnectAll</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>azModuleArg</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nModuleArg</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>azModuleArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>azModuleArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Add a new module argument to pTable-&gt;azModuleArg[].
** The string is not copied - the pointer is stored.  The
** string will be freed automatically when the table is
** deleted.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>addModuleArgument</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTable</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zArg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nBytes</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><literal type="number">2</literal><operator>+</operator><name><name>pTable</name><operator>-&gt;</operator><name>nModuleArg</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azModuleArg</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>azModuleArg</name> <operator>=</operator> <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>azModuleArg</name></name></expr></argument>, <argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>azModuleArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>pTable</name><operator>-&gt;</operator><name>nModuleArg</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>azModuleArg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>zArg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>azModuleArg</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pTable</name><operator>-&gt;</operator><name>azModuleArg</name></name> <operator>=</operator> <name>azModuleArg</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The parser calls this routine when it first sees a CREATE VIRTUAL TABLE
** statement.  The module name has been parsed, but the optional list
** of parameters that follow the module name are still pending.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabBeginParse</name><parameter_list>(
  <parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Parsing context */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName1</name></decl></parameter>,        <comment type="block">/* Name of new table, or database name */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pName2</name></decl></parameter>,        <comment type="block">/* Name of new table or NULL */</comment>
  <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pModuleName</name></decl></parameter>,   <comment type="block">/* Name of the module for the virtual table */</comment>
  <parameter><decl><type><name>int</name></type> <name>ifNotExists</name></decl></parameter>       <comment type="block">/* No error if the table already exists */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>              <comment type="block">/* The database the table is being created in */</comment>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTable</name></decl>;</decl_stmt>        <comment type="block">/* The new virtual table */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>          <comment type="block">/* Database connection */</comment>

  <expr_stmt><expr><call><name>sqlite3StartTable</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>pName1</name></expr></argument>, <argument><expr><name>pName2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ifNotExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTable</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTable</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal><operator>==</operator><name><name>pTable</name><operator>-&gt;</operator><name>pIndex</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>db</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDb</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pTable</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_Virtual</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTable</name><operator>-&gt;</operator><name>nModuleArg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>addModuleArgument</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>, <argument><expr><call><name>sqlite3NameFromToken</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pModuleName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>addModuleArgument</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>addModuleArgument</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTable</name></expr></argument>, <argument><expr><call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>sNameToken</name><operator>.</operator><name>z</name></name><operator>==</operator><name><name>pName2</name><operator>-&gt;</operator><name>z</name></name> <operator>&amp;&amp;</operator> <name><name>pName2</name><operator>-&gt;</operator><name>z</name></name><operator>!=</operator><literal type="number">0</literal><operator>)</operator>
       <operator>||</operator> <operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>sNameToken</name><operator>.</operator><name>z</name></name><operator>==</operator><name><name>pName1</name><operator>-&gt;</operator><name>z</name></name> <operator>&amp;&amp;</operator> <name><name>pName2</name><operator>-&gt;</operator><name>z</name></name><operator>==</operator><literal type="number">0</literal><operator>)</operator></expr></argument>
  )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>sNameToken</name><operator>.</operator><name>n</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator>
      <operator>&amp;</operator><name><name>pModuleName</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>pModuleName</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name> <operator>-</operator> <name><name>pParse</name><operator>-&gt;</operator><name>sNameToken</name><operator>.</operator><name>z</name></name>
  <operator>)</operator></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_AUTHORIZATION</name></cpp:ifndef>
  <comment type="block">/* Creating a virtual table invokes the authorization callback twice.
  ** The first invocation, to obtain permission to INSERT a row into the
  ** sqlite_master table, has already been made by sqlite3StartTable().
  ** The second call, to obtain permission to create the table, is made now.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pTable</name><operator>-&gt;</operator><name>azModuleArg</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3AuthCheck</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>SQLITE_CREATE_VTABLE</name></expr></argument>, <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, 
            <argument><expr><name><name>pTable</name><operator>-&gt;</operator><name>azModuleArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
** This routine takes the module argument that has been accumulating
** in pParse-&gt;zArg[] and appends it to the list of arguments on the
** virtual table currently under construction in pParse-&gt;pTable.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>addArgumentToVtab</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>sArg</name><operator>.</operator><name>z</name></name> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>pParse</name><operator>-&gt;</operator><name>sArg</name><operator>.</operator><name>z</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>sArg</name><operator>.</operator><name>n</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>addModuleArgument</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name></expr></argument>, <argument><expr><call><name>sqlite3DbStrNDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The parser calls this routine after the CREATE VIRTUAL TABLE statement
** has been completely parsed.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabFinishParse</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>pEnd</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* The table being constructed */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>         <comment type="block">/* The database connection */</comment>

  <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>addArgumentToVtab</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>sArg</name><operator>.</operator><name>z</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pTab</name><operator>-&gt;</operator><name>nModuleArg</name></name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  
  <comment type="block">/* If the CREATE VIRTUAL TABLE statement is being entered for the
  ** first time (in other words if the virtual table is actually being
  ** created now instead of just being read out of sqlite_master) then
  ** do additional initialization work and store the statement text
  ** in the sqlite_master table.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>init</name><operator>.</operator><name>busy</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zStmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zWhere</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iReg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

    <comment type="block">/* Compute the complete text of the CREATE VIRTUAL TABLE statement */</comment>
    <if_stmt><if>if<condition>( <expr><name>pEnd</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>sNameToken</name><operator>.</operator><name>n</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>pEnd</name><operator>-&gt;</operator><name>z</name></name> <operator>-</operator> <name><name>pParse</name><operator>-&gt;</operator><name>sNameToken</name><operator>.</operator><name>z</name></name><operator>)</operator> <operator>+</operator> <name><name>pEnd</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zStmt</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE VIRTUAL TABLE %T"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>sNameToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* A slot for the record has already been allocated in the 
    ** SQLITE_MASTER table.  We just need to update that slot with all
    ** the information we've collected.  
    **
    ** The VM register number pParse-&gt;regRowid holds the rowid of an
    ** entry in the sqlite_master table tht was created for this vtab
    ** by sqlite3StartTable().
    */</comment>
    <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3NestedParse</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>,
      <argument><expr><literal type="string">"UPDATE %Q.%s "</literal>
         <literal type="string">"SET type='table', name=%Q, tbl_name=%Q, rootpage=0, sql=%Q "</literal>
       <literal type="string">"WHERE rowid=#%d"</literal></expr></argument>,
      <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><call><name>SCHEMA_TABLE</name><argument_list>(<argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr></argument>,
      <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
      <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
      <argument><expr><name>zStmt</name></expr></argument>,
      <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>regRowid</name></name></expr></argument>
    )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3GetVdbe</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ChangeCookie</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_Expire</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zWhere</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"name='%q' AND type='table'"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddParseSchemaOp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>zWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>iReg</name> <operator>=</operator> <operator>++</operator><name><name>pParse</name><operator>-&gt;</operator><name>nMem</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeLoadString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeAddOp2</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>OP_VCreate</name></expr></argument>, <argument><expr><name>iDb</name></expr></argument>, <argument><expr><name>iReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>

  <comment type="block">/* If we are rereading the sqlite_master table create the in-memory
  ** record of the table. The xConnect() method is not called until
  ** the first time the virtual table is used in an SQL statement. This
  ** allows a schema that contains virtual tables to be loaded before
  ** the required virtual table implementations are registered.  */</comment>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pOld</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Schema</name> <modifier>*</modifier></type><name>pSchema</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3SchemaMutexHeld</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pSchema</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pOld</name> <operator>=</operator> <call><name>sqlite3HashInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pSchema</name><operator>-&gt;</operator><name>tblHash</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pOld</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name><operator>==</operator><name>pOld</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Malloc must have failed inside HashInsert() */</comment>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The parser calls this routine when it sees the first token
** of an argument to the module name in a CREATE VIRTUAL TABLE statement.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabArgInit</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>addArgumentToVtab</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>sArg</name><operator>.</operator><name>z</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>sArg</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The parser calls this routine for each token after the first token
** in an argument to the module name in a CREATE VIRTUAL TABLE statement.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabArgExtend</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Token</name> <modifier>*</modifier></type><name>pArg</name> <init>= <expr><operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>sArg</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pArg</name><operator>-&gt;</operator><name>z</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pArg</name><operator>-&gt;</operator><name>z</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pArg</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pArg</name><operator>-&gt;</operator><name>z</name></name> <operator>&lt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pArg</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name> <operator>-</operator> <name><name>pArg</name><operator>-&gt;</operator><name>z</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Invoke a virtual table constructor (either xCreate or xConnect). The
** pointer to the function to invoke is passed as the fourth parameter
** to this procedure.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vtabCallConstructor</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>,
  <parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>pMod</name></decl></parameter>,
  <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xConstruct</name>)<parameter_list>(<parameter><decl><type><name>sqlite3</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>sqlite3_vtab</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VtabCtx</name></type> <name>sCtx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier></type><name>pVTable</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>azArg</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><specifier>const</specifier><operator>*</operator><operator>)</operator><name><name>pTab</name><operator>-&gt;</operator><name>azModuleArg</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nArg</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>nModuleArg</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zModuleName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iDb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VtabCtx</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>

  <comment type="block">/* Check that the virtual-table is not already being initialized */</comment>
  <for>for<control>(<init><expr><name>pCtx</name><operator>=</operator><name><name>db</name><operator>-&gt;</operator><name>pVtabCtx</name></name></expr>;</init> <condition><expr><name>pCtx</name></expr>;</condition> <incr><expr><name>pCtx</name><operator>=</operator><name><name>pCtx</name><operator>-&gt;</operator><name>pPrior</name></name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pCtx</name><operator>-&gt;</operator><name>pTab</name></name><operator>==</operator><name>pTab</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, 
          <argument><expr><literal type="string">"vtable constructor called recursively: %s"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>
      )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_LOCKED</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name>zModuleName</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zModuleName</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>pVTable</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VTable</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pVTable</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zModuleName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pVTable</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pVTable</name><operator>-&gt;</operator><name>pMod</name></name> <operator>=</operator> <name>pMod</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>iDb</name> <operator>=</operator> <call><name>sqlite3SchemaToIndex</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>azModuleArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zName</name></expr>;</expr_stmt>

  <comment type="block">/* Invoke the virtual table constructor */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>pVtabCtx</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>xConstruct</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>pTab</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>pVTable</name></name> <operator>=</operator> <name>pVTable</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>pPrior</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pVtabCtx</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sCtx</name><operator>.</operator><name>bDeclared</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pVtabCtx</name></name> <operator>=</operator> <operator>&amp;</operator><name>sCtx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xConstruct</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pMod</name><operator>-&gt;</operator><name>pAux</name></name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>azArg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pVTable</name><operator>-&gt;</operator><name>pVtab</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>pVtabCtx</name></name> <operator>=</operator> <name><name>sCtx</name><operator>.</operator><name>pPrior</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>sCtx</name><operator>.</operator><name>pTab</name></name><operator>==</operator><name>pTab</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>!=</operator><name>rc</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>zErr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"vtable constructor failed: %s"</literal></expr></argument>, <argument><expr><name>zModuleName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pVTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name><name>pVTable</name><operator>-&gt;</operator><name>pVtab</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* Justification of ALWAYS():  A correct vtab constructor must allocate
    ** the sqlite3_vtab object if successful.  */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>pVTable</name><operator>-&gt;</operator><name>pVtab</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pVTable</name><operator>-&gt;</operator><name>pVtab</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pVTable</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name> <operator>=</operator> <name><name>pMod</name><operator>-&gt;</operator><name>pModule</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pVTable</name><operator>-&gt;</operator><name>nRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>sCtx</name><operator>.</operator><name>bDeclared</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name> <init>= <expr><literal type="string">"vtable constructor did not declare schema: %s"</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VtabUnlock</name><argument_list>(<argument><expr><name>pVTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u8</name></type> <name>oooHidden</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <comment type="block">/* If everything went according to plan, link the new VTable structure
      ** into the linked list headed by pTab-&gt;pVTable. Then loop through the 
      ** columns of the table to see if any of them contain the token "hidden".
      ** If so, set the Column COLFLAG_HIDDEN flag and remove the token from
      ** the type string.  */</comment>
      <expr_stmt><expr><name><name>pVTable</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pVTable</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pVTable</name></name> <operator>=</operator> <name>pVTable</name></expr>;</expr_stmt>

      <for>for<control>(<init><expr><name>iCol</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iCol</name><operator>&lt;</operator><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</condition> <incr><expr><name>iCol</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zType</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>zType</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nType</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zType</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>oooHidden</name></expr>;</expr_stmt>
          <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>nType</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><literal type="string">"hidden"</literal></expr></argument>, <argument><expr><name>zType</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call><operator>||</operator><operator>(</operator><name><name>zType</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>zType</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>!=</operator><literal type="char">' '</literal><operator>)</operator></expr> )</condition><block>{<block_content>
          <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nType</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><operator>(</operator><literal type="number">0</literal><operator>==</operator><call><name>sqlite3StrNICmp</name><argument_list>(<argument><expr><literal type="string">" hidden"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zType</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call><operator>)</operator>
             <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zType</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">7</literal></expr>]</index></name><operator>==</operator><literal type="char">'\0'</literal> <operator>||</operator> <name><name>zType</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">7</literal></expr>]</index></name><operator>==</operator><literal type="char">' '</literal><operator>)</operator></expr>
            )</condition><block>{<block_content>
              <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
              <break>break;</break>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name>nType</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>nDel</name> <init>= <expr><literal type="number">6</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>zType</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">6</literal></expr>]</index></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>i</name></expr>;</init> <condition><expr><operator>(</operator><name>j</name><operator>+</operator><name>nDel</name><operator>)</operator><operator>&lt;=</operator><name>nType</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><name><name>zType</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>zType</name><index>[<expr><name>j</name><operator>+</operator><name>nDel</name></expr>]</index></name></expr>;</expr_stmt>
          </block_content>}</block></for>
          <if_stmt><if>if<condition>( <expr><name><name>zType</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>zType</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>zType</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name><index>[<expr><name>iCol</name></expr>]</index></name><operator>.</operator><name>colFlags</name> <operator>|=</operator> <name>COLFLAG_HIDDEN</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>oooHidden</name> <operator>=</operator> <name>TF_OOOHidden</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>oooHidden</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zModuleName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is invoked by the parser to call the xConnect() method
** of the virtual table pTab. If an error occurs, an error code is returned 
** and an error left in pParse.
**
** This call is a no-op if table pTab is not a virtual table.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VtabCallConnect</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMod</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>pMod</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Virtual</name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>sqlite3GetVTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Locate the required virtual table module */</comment>
  <expr_stmt><expr><name>zMod</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>azModuleArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMod</name> <operator>=</operator> <operator>(</operator><name>Module</name><operator>*</operator><operator>)</operator><call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aModule</name></name></expr></argument>, <argument><expr><name>zMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pMod</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zModule</name> <init>= <expr><name><name>pTab</name><operator>-&gt;</operator><name>azModuleArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"no such module: %s"</literal></expr></argument>, <argument><expr><name>zModule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vtabCallConstructor</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pMod</name></expr></argument>, <argument><expr><name><name>pMod</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xConnect</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
** Grow the db-&gt;aVTrans[] array so that there is room for at least one
** more v-table. Return SQLITE_NOMEM if a malloc fails, or SQLITE_OK otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>growVTrans</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ARRAY_INCR</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Grow the sqlite3.aVTrans array if required */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>nVTrans</name></name><operator>%</operator><name>ARRAY_INCR</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier><modifier>*</modifier></type><name>aVTrans</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nBytes</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_vtab</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>db</name><operator>-&gt;</operator><name>nVTrans</name></name> <operator>+</operator> <name>ARRAY_INCR</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>aVTrans</name> <operator>=</operator> <call><name>sqlite3DbRealloc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>db</name><operator>-&gt;</operator><name>aVTrans</name></name></expr></argument>, <argument><expr><name>nBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>aVTrans</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aVTrans</name><index>[<expr><name><name>db</name><operator>-&gt;</operator><name>nVTrans</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_vtab</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>ARRAY_INCR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aVTrans</name></name> <operator>=</operator> <name>aVTrans</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add the virtual table pVTab to the array sqlite3.aVTrans[]. Space should
** have already been reserved using growVTrans().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>addToVTrans</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>VTable</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* Add pVtab to the end of sqlite3.aVTrans */</comment>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aVTrans</name><index>[<expr><name><name>db</name><operator>-&gt;</operator><name>nVTrans</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pVTab</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3VtabLock</name><argument_list>(<argument><expr><name>pVTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This function is invoked by the vdbe to call the xCreate method
** of the virtual table named zTab in database iDb. 
**
** If an error occurs, *pzErr is set to point an an English language
** description of the error and an SQLITE_XXX error code is returned.
** In this case the caller must call sqlite3DbFree(db, ) on *pzErr.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VtabCallCreate</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>pMod</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zMod</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTab</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Virtual</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pTab</name><operator>-&gt;</operator><name>pVTable</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Locate the required virtual table module */</comment>
  <expr_stmt><expr><name>zMod</name> <operator>=</operator> <name><name>pTab</name><operator>-&gt;</operator><name>azModuleArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMod</name> <operator>=</operator> <operator>(</operator><name>Module</name><operator>*</operator><operator>)</operator><call><name>sqlite3HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>aModule</name></name></expr></argument>, <argument><expr><name>zMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the module has been registered and includes a Create method, 
  ** invoke it now. If the module has not been registered, return an 
  ** error. Otherwise, do nothing.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>pMod</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pMod</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xCreate</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>pMod</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xDestroy</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3MPrintf</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"no such module: %s"</literal></expr></argument>, <argument><expr><name>zMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vtabCallConstructor</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pMod</name></expr></argument>, <argument><expr><name><name>pMod</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xCreate</name></name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Justification of ALWAYS():  The xConstructor method is required to
  ** create a valid sqlite3_vtab if it returns SQLITE_OK. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <call><name>ALWAYS</name><argument_list>(<argument><expr><call><name>sqlite3GetVTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>growVTrans</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>addToVTrans</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>sqlite3GetVTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is used to set the schema of a virtual table.  It is only
** valid to call this function from within the xCreate() or xConnect() of a
** virtual table module.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_declare_vtab</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zCreateTable</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VtabCtx</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>zCreateTable</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCtx</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>pVtabCtx</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pCtx</name> <operator>||</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>bDeclared</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_MISUSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pCtx</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Virtual</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pParse</name> <operator>=</operator> <call><name>sqlite3StackAllocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pParse</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pParse</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>declareVtab</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nQueryLoop</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  
    <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><call><name>sqlite3RunParser</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zCreateTable</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>)</argument_list></call> 
     <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name>
     <operator>&amp;&amp;</operator> <operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>mallocFailed</name></name>
     <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name><operator>-&gt;</operator><name>pSelect</name></name>
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Virtual</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>
    )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>aCol</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name><operator>-&gt;</operator><name>aCol</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name><operator>-&gt;</operator><name>nCol</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name><operator>-&gt;</operator><name>nCol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name><operator>-&gt;</operator><name>aCol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pCtx</name><operator>-&gt;</operator><name>bDeclared</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3ErrorWithMsg</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_ERROR</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>zErr</name></expr> ?</condition><then> <expr><literal type="string">"%s"</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>declareVtab</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeFinalize</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pVdbe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3DeleteTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>pNewTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3ParserReset</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3StackFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>rc</name><operator>&amp;</operator><literal type="number">0xff</literal><operator>)</operator><operator>==</operator><name>rc</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3ApiExit</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function is invoked by the vdbe to call the xDestroy method
** of the virtual table named zTab in database iDb. This occurs
** when a DROP TABLE is mentioned.
**
** This call is a no-op if zTab is not a virtual table.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VtabCallDestroy</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iDb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3FindTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zTab</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><name>iDb</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pTab</name><operator>-&gt;</operator><name>pVTable</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xDestroy</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
    <for>for<control>(<init><expr><name>p</name><operator>=</operator><name><name>pTab</name><operator>-&gt;</operator><name>pVTable</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>pNext</name></name></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVtab</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>nRef</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><name>SQLITE_LOCKED</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vtabDisconnectAll</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>xDestroy</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pMod</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xDestroy</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>xDestroy</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Checked before the virtual table is created */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xDestroy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pVtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Remove the sqlite3_vtab* from the aVTrans[] array, if applicable */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>pVTable</name></name><operator>==</operator><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>pNext</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pVtab</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pVTable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VtabUnlock</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This function invokes either the xRollback or xCommit method
** of each of the virtual tables in the sqlite3.aVTrans array. The method
** called is identified by the second argument, "offset", which is
** the offset of the method to call in the sqlite3_module structure.
**
** The array is cleared after invoking the callbacks. 
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>callFinaliser</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>aVTrans</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier><modifier>*</modifier></type><name>aVTrans</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aVTrans</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aVTrans</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nVTrans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier></type><name>pVTab</name> <init>= <expr><name><name>aVTrans</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pVTab</name><operator>-&gt;</operator><name>pVtab</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
        <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>x</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
        <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>*</operator><operator>(</operator><call><call><name>int</name> <argument_list>(<argument><expr><operator>*</operator><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>sqlite3_vtab</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>pModule</name></name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>x</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>x</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>pVTab</name><operator>-&gt;</operator><name>iSavepoint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VtabUnlock</name><argument_list>(<argument><expr><name>pVTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>aVTrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>nVTrans</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Invoke the xSync method of all virtual tables in the sqlite3.aVTrans
** array. Return the error code for the first error that occurs, or
** SQLITE_OK if all xSync operations are successful.
**
** If an error message is available, leave it in p-&gt;zErrMsg.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VtabSync</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Vdbe</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier><modifier>*</modifier></type><name>aVTrans</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aVTrans</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aVTrans</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nVTrans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>x</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name> <init>= <expr><name><name>aVTrans</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>pVtab</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>x</name> <operator>=</operator> <name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xSync</name></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>x</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3VtabImportErrmsg</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>aVTrans</name></name> <operator>=</operator> <name>aVTrans</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Invoke the xRollback method of all virtual tables in the 
** sqlite3.aVTrans array. Then clear the array itself.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VtabRollback</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>callFinaliser</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>sqlite3_module</name></expr></argument>,<argument><expr><name>xRollback</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Invoke the xCommit method of all virtual tables in the 
** sqlite3.aVTrans array. Then clear the array itself.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VtabCommit</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>callFinaliser</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>sqlite3_module</name></expr></argument>,<argument><expr><name>xCommit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the virtual table pVtab supports the transaction interface
** (xBegin/xRollback/xCommit and optionally xSync) and a transaction is
** not currently open, invoke the xBegin method now.
**
** If the xBegin call is successful, place the sqlite3_vtab pointer
** in the sqlite3.aVTrans array.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VtabBegin</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>VTable</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name></decl>;</decl_stmt>

  <comment type="block">/* Special case: If db-&gt;aVTrans is NULL and db-&gt;nVTrans is greater
  ** than zero, then this function is being called from within a
  ** virtual module xSync() callback. It is illegal to write to 
  ** virtual module tables in this case, so return SQLITE_LOCKED.
  */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3VtabInSync</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_LOCKED</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pVTab</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt> 
  <expr_stmt><expr><name>pModule</name> <operator>=</operator> <name><name>pVTab</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pModule</name><operator>-&gt;</operator><name>xBegin</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* If pVtab is already in the aVTrans array, return early */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nVTrans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>aVTrans</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>pVTab</name></expr> )</condition><block>{<block_content>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Invoke the xBegin method. If successful, add the vtab to the 
    ** sqlite3.aVTrans[] array. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>growVTrans</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xBegin</name></name><argument_list>(<argument><expr><name><name>pVTab</name><operator>-&gt;</operator><name>pVtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iSvpt</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>nStatement</name></name> <operator>+</operator> <name><name>db</name><operator>-&gt;</operator><name>nSavepoint</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>addToVTrans</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pVTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iSvpt</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3VtabSavepoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SAVEPOINT_BEGIN</name></expr></argument>, <argument><expr><name>iSvpt</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Invoke either the xSavepoint, xRollbackTo or xRelease method of all
** virtual tables that currently have an open transaction. Pass iSavepoint
** as the second argument to the virtual table method invoked.
**
** If op is SAVEPOINT_BEGIN, the xSavepoint method is invoked. If it is
** SAVEPOINT_ROLLBACK, the xRollbackTo method. Otherwise, if op is 
** SAVEPOINT_RELEASE, then the xRelease method of each virtual table with
** an open transaction is invoked.
**
** If any virtual table method returns an error code other than SQLITE_OK, 
** processing is abandoned and the error returned to the caller of this
** function immediately. If all calls to virtual table methods are successful,
** SQLITE_OK is returned.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VtabSavepoint</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iSavepoint</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>op</name><operator>==</operator><name>SAVEPOINT_RELEASE</name><operator>||</operator><name>op</name><operator>==</operator><name>SAVEPOINT_ROLLBACK</name><operator>||</operator><name>op</name><operator>==</operator><name>SAVEPOINT_BEGIN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iSavepoint</name><operator>&gt;=</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>db</name><operator>-&gt;</operator><name>aVTrans</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>db</name><operator>-&gt;</operator><name>nVTrans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>VTable</name> <modifier>*</modifier></type><name>pVTab</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>aVTrans</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_module</name> <modifier>*</modifier></type><name>pMod</name> <init>= <expr><name><name>pVTab</name><operator>-&gt;</operator><name>pMod</name><operator>-&gt;</operator><name>pModule</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pVTab</name><operator>-&gt;</operator><name>pVtab</name></name> <operator>&amp;&amp;</operator> <name><name>pMod</name><operator>-&gt;</operator><name>iVersion</name></name><operator>&gt;=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
        <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>xMethod</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
        <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
          <case>case <expr><name>SAVEPOINT_BEGIN</name></expr>:</case>
            <expr_stmt><expr><name>xMethod</name> <operator>=</operator> <name><name>pMod</name><operator>-&gt;</operator><name>xSavepoint</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pVTab</name><operator>-&gt;</operator><name>iSavepoint</name></name> <operator>=</operator> <name>iSavepoint</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <break>break;</break>
          <case>case <expr><name>SAVEPOINT_ROLLBACK</name></expr>:</case>
            <expr_stmt><expr><name>xMethod</name> <operator>=</operator> <name><name>pMod</name><operator>-&gt;</operator><name>xRollbackTo</name></name></expr>;</expr_stmt>
            <break>break;</break>
          <default>default:</default>
            <expr_stmt><expr><name>xMethod</name> <operator>=</operator> <name><name>pMod</name><operator>-&gt;</operator><name>xRelease</name></name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></switch>
        <if_stmt><if>if<condition>( <expr><name>xMethod</name> <operator>&amp;&amp;</operator> <name><name>pVTab</name><operator>-&gt;</operator><name>iSavepoint</name></name><operator>&gt;</operator><name>iSavepoint</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>xMethod</name><argument_list>(<argument><expr><name><name>pVTab</name><operator>-&gt;</operator><name>pVtab</name></name></expr></argument>, <argument><expr><name>iSavepoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The first parameter (pDef) is a function implementation.  The
** second parameter (pExpr) is the first argument to this function.
** If pExpr is a column in a virtual table, then let the virtual
** table implementation have an opportunity to overload the function.
**
** This routine is used to allow virtual table implementations to
** overload MATCH, LIKE, GLOB, and REGEXP operators.
**
** Return either the pDef argument (indicating no change) or a 
** new FuncDef structure that is marked as ephemeral using the
** SQLITE_FUNC_EPHEM flag.
*/</comment>
<function><type><name>FuncDef</name> <modifier>*</modifier></type><name>sqlite3VtabOverloadFunction</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,    <comment type="block">/* Database connection for reporting malloc problems */</comment>
  <parameter><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pDef</name></decl></parameter>,  <comment type="block">/* Function to possibly overload */</comment>
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,       <comment type="block">/* Number of arguments to the function */</comment>
  <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>     <comment type="block">/* First argument to the function */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_module</name> <modifier>*</modifier></type><name>pMod</name></decl>;</decl_stmt>
  <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xSFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pArg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zLowerName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>


  <comment type="block">/* Check to see the left operand is a column in a virtual table */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pExpr</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>pDef</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_COLUMN</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>pDef</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>pTab</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>pDef</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Virtual</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>pDef</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pVtab</name> <operator>=</operator> <call><name>sqlite3GetVTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pVtab</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pVtab</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMod</name> <operator>=</operator> <operator>(</operator><name>sqlite3_module</name> <operator>*</operator><operator>)</operator><name><name>pVtab</name><operator>-&gt;</operator><name>pModule</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMod</name><operator>-&gt;</operator><name>xFindFunction</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>pDef</name></expr>;</return></block_content></block></if></if_stmt>
 
  <comment type="block">/* Call the xFindFunction method on the virtual table implementation
  ** to see if the implementation wants to overload this function 
  */</comment>
  <expr_stmt><expr><name>zLowerName</name> <operator>=</operator> <call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zLowerName</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>z</name><operator>=</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>zLowerName</name></expr>;</init> <condition><expr><operator>*</operator><name>z</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>z</name> <operator>=</operator> <name><name>sqlite3UpperToLower</name><index>[<expr><operator>*</operator><name>z</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pMod</name><operator>-&gt;</operator><name>xFindFunction</name></name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>, <argument><expr><name>nArg</name></expr></argument>, <argument><expr><name>zLowerName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xSFunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zLowerName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>pDef</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Create a new ephemeral function definition for the overloaded
  ** function */</comment>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof>
                             <operator>+</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>pDef</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pNew</name> <operator>=</operator> <operator>*</operator><name>pDef</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pNew</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pNew</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>xSFunc</name></name> <operator>=</operator> <name>xSFunc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>pUserData</name></name> <operator>=</operator> <name>pArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNew</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>|=</operator> <name>SQLITE_FUNC_EPHEM</name></expr>;</expr_stmt>
  <return>return <expr><name>pNew</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Make sure virtual table pTab is contained in the pParse-&gt;apVirtualLock[]
** array so that an OP_VBegin will get generated for it.  Add pTab to the
** array if it is missing.  If pTab is already in the array, this routine
** is a no-op.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabMakeWritable</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pToplevel</name> <init>= <expr><call><name>sqlite3ParseToplevel</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier><modifier>*</modifier></type><name>apVtabLock</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>IsVirtual</name><argument_list>(<argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pToplevel</name><operator>-&gt;</operator><name>nVtabLock</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><name><name>pToplevel</name><operator>-&gt;</operator><name>apVtabLock</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name><name>pToplevel</name><operator>-&gt;</operator><name>nVtabLock</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>apVtabLock</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name>apVtabLock</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>apVtabLock</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>apVtabLock</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>apVtabLock</name></name> <operator>=</operator> <name>apVtabLock</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>apVtabLock</name><index>[<expr><name><name>pToplevel</name><operator>-&gt;</operator><name>nVtabLock</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name><name>pToplevel</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Check to see if virtual tale module pMod can be have an eponymous
** virtual table instance.  If it can, create one if one does not already
** exist. Return non-zero if the eponymous virtual table instance exists
** when this routine returns, and return zero if it does not exist.
**
** An eponymous virtual table instance is one that is named after its
** module, and more importantly, does not require a CREATE VIRTUAL TABLE
** statement in order to come into existance.  Eponymous virtual table
** instances always exist.  They cannot be DROP-ed.
**
** Any virtual table module for which xConnect and xCreate are the same
** method can have an eponymous virtual table instance.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3VtabEponymousTableInit</name><parameter_list>(<parameter><decl><type><name>Parse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>pMod</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name> <init>= <expr><name><name>pMod</name><operator>-&gt;</operator><name>pModule</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nName</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name><name>pParse</name><operator>-&gt;</operator><name>db</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pMod</name><operator>-&gt;</operator><name>pEpoTab</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pModule</name><operator>-&gt;</operator><name>xCreate</name></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pModule</name><operator>-&gt;</operator><name>xCreate</name></name><operator>!=</operator><name><name>pModule</name><operator>-&gt;</operator><name>xConnect</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nName</name> <operator>=</operator> <call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pMod</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTab</name> <operator>=</operator> <call><name>sqlite3DbMallocZero</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Table</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pMod</name><operator>-&gt;</operator><name>pEpoTab</name></name> <operator>=</operator> <name>pTab</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>pTab</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>pMod</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nRef</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>pSchema</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aDb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pSchema</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>|=</operator> <name>TF_Virtual</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>nModuleArg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pTab</name><operator>-&gt;</operator><name>iPKey</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>addModuleArgument</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>addModuleArgument</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>addModuleArgument</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><call><name>sqlite3DbStrDup</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pTab</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vtabCallConstructor</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>, <argument><expr><name>pMod</name></expr></argument>, <argument><expr><name><name>pModule</name><operator>-&gt;</operator><name>xConnect</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3ErrorMsg</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VtabEponymousTableClear</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Erase the eponymous virtual table instance associated with
** virtual table module pMod, if it exists.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3VtabEponymousTableClear</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>pMod</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>pTab</name> <init>= <expr><name><name>pMod</name><operator>-&gt;</operator><name>pEpoTab</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>pTab</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3DeleteColumnNames</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VtabClear</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3DbFree</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pMod</name><operator>-&gt;</operator><name>pEpoTab</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the ON CONFLICT resolution mode in effect for the virtual
** table update operation currently in progress.
**
** The results of this routine are undefined unless it is called from
** within an xUpdate method.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_vtab_on_conflict</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>aMap</name><index>[]</index></name> <init>= <expr><block>{ 
    <expr><name>SQLITE_ROLLBACK</name></expr>, <expr><name>SQLITE_ABORT</name></expr>, <expr><name>SQLITE_FAIL</name></expr>, <expr><name>SQLITE_IGNORE</name></expr>, <expr><name>SQLITE_REPLACE</name></expr> 
  }</block></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OE_Rollback</name><operator>==</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>OE_Abort</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>OE_Fail</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>OE_Ignore</name><operator>==</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>OE_Replace</name><operator>==</operator><literal type="number">5</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>db</name><operator>-&gt;</operator><name>vtabOnConflict</name></name><operator>&gt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>db</name><operator>-&gt;</operator><name>vtabOnConflict</name></name><operator>&lt;=</operator><literal type="number">5</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>aMap</name><index>[<expr><name><name>db</name><operator>-&gt;</operator><name>vtabOnConflict</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Call from within the xCreate() or xConnect() methods to provide 
** the SQLite core with additional information about the behavior
** of the virtual table being implemented.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_vtab_config</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_API_ARMOR</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>sqlite3SafetyCheckOk</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_MISUSE_BKPT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>sqlite3_mutex_enter</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>op</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_VTAB_CONSTRAINT_SUPPORT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>VtabCtx</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>db</name><operator>-&gt;</operator><name>pVtabCtx</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>p</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pTab</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pTab</name><operator>-&gt;</operator><name>tabFlags</name></name> <operator>&amp;</operator> <name>TF_Virtual</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pVTable</name><operator>-&gt;</operator><name>bConstraint</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_MISUSE_BKPT</name></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3Error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_mutex_leave</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>
</unit>
