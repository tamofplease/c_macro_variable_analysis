<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/src/func.c"><comment type="block">/*
** 2002 February 23
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains the C-language implementations for many of the SQL
** functions of SQLite.  (Some function, and in particular the date and
** time functions, are implemented separately.)
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqliteInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vdbeInt.h"</cpp:file></cpp:include>

<comment type="block">/*
** Return the collating function associated with a function.
*/</comment>
<function><type><specifier>static</specifier> <name>CollSeq</name> <modifier>*</modifier></type><name>sqlite3GetFuncCollSeq</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>VdbeOp</name> <modifier>*</modifier></type><name>pOp</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>context</name><operator>-&gt;</operator><name>pVdbe</name></name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pOp</name> <operator>=</operator> <operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>pVdbe</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name><name>context</name><operator>-&gt;</operator><name>iOp</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>opcode</name></name><operator>==</operator><name>OP_CollSeq</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOp</name><operator>-&gt;</operator><name>p4type</name></name><operator>==</operator><name>P4_COLLSEQ</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pOp</name><operator>-&gt;</operator><name>p4</name><operator>.</operator><name>pColl</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Indicate that the accumulator load should be skipped on this
** iteration of the aggregate loop.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sqlite3SkipAccumulatorLoad</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>skipFlag</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the non-aggregate min() and max() functions
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>minmaxFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mask</name></decl>;</decl_stmt>    <comment type="block">/* 0 for min() or 0xffffffff for max() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iBest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>&gt;</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mask</name> <operator>=</operator> <ternary><condition><expr><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name>pColl</name> <operator>=</operator> <call><name>sqlite3GetFuncCollSeq</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pColl</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>mask</name><operator>==</operator><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>mask</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iBest</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><call><name>sqlite3MemCompare</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>iBest</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>)</argument_list></call><operator>^</operator><name>mask</name><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>mask</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iBest</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>iBest</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return the type of the argument.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>typeofFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>NotUsed</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case> <expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="string">"integer"</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>SQLITE_TEXT</name></expr>:</case>    <expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="string">"text"</literal></expr>;</expr_stmt>    <break>break;</break>
    <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case>   <expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="string">"real"</literal></expr>;</expr_stmt>    <break>break;</break>
    <case>case <expr><name>SQLITE_BLOB</name></expr>:</case>    <expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="string">"blob"</literal></expr>;</expr_stmt>    <break>break;</break>
    <default>default:</default>             <expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="string">"null"</literal></expr>;</expr_stmt>    <break>break;</break>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Implementation of the length() function
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lengthFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_BLOB</name></expr>:</case>
    <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case>
    <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_TEXT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <while>while<condition>( <expr><operator>*</operator><name>z</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SQLITE_SKIP_UTF8</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_null</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the abs() function.
**
** IMP: R-23979-26855 The abs(X) function returns the absolute value of
** the numeric argument X. 
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>absFunc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>iVal</name> <init>= <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>==</operator><name>SMALLEST_INT64</name></expr> )</condition><block>{<block_content>
          <comment type="block">/* IMP: R-31676-45509 If X is the integer -9223372036854775808
          ** then abs(X) throws an integer overflow error since there is no
          ** equivalent positive 64-bit two complement value. */</comment>
          <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"integer overflow"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>iVal</name> <operator>=</operator> <operator>-</operator><name>iVal</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt> 
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_NULL</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* IMP: R-37434-19929 Abs(X) returns NULL if X is NULL. */</comment>
      <expr_stmt><expr><call><name>sqlite3_result_null</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <comment type="block">/* Because sqlite3_value_double() returns 0.0 if the argument is not
      ** something that can be converted into a number, we have:
      ** IMP: R-01992-00519 Abs(X) returns 0.0 if X is a string or blob
      ** that cannot be converted to a numeric value.
      */</comment>
      <decl_stmt><decl><type><name>double</name></type> <name>rVal</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rVal</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rVal</name> <operator>=</operator> <operator>-</operator><name>rVal</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>rVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the instr() function.
**
** instr(haystack,needle) finds the first occurrence of needle
** in haystack and returns the number of previous characters plus 1,
** or 0 if needle does not occur within haystack.
**
** If both haystack and needle are BLOBs, then the result is one more than
** the number of bytes in haystack prior to the first occurrence of needle,
** or 0 if needle never occurs in haystack.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>instrFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zHaystack</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zNeedle</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nHaystack</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nNeedle</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>typeHaystack</name></decl>, <decl><type ref="prev"/><name>typeNeedle</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>N</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isText</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>typeHaystack</name> <operator>=</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>typeNeedle</name> <operator>=</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>typeHaystack</name><operator>==</operator><name>SQLITE_NULL</name> <operator>||</operator> <name>typeNeedle</name><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nHaystack</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nNeedle</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>typeHaystack</name><operator>==</operator><name>SQLITE_BLOB</name> <operator>&amp;&amp;</operator> <name>typeNeedle</name><operator>==</operator><name>SQLITE_BLOB</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zHaystack</name> <operator>=</operator> <call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zNeedle</name> <operator>=</operator> <call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>isText</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zHaystack</name> <operator>=</operator> <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zNeedle</name> <operator>=</operator> <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>isText</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <while>while<condition>( <expr><name>nNeedle</name><operator>&lt;=</operator><name>nHaystack</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>zHaystack</name></expr></argument>, <argument><expr><name>zNeedle</name></expr></argument>, <argument><expr><name>nNeedle</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>N</name><operator>++</operator></expr>;</expr_stmt>
    <do>do<block>{<block_content>
      <expr_stmt><expr><name>nHaystack</name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>zHaystack</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>while<condition>( <expr><name>isText</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zHaystack</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal></expr> )</condition>;</do>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>nNeedle</name><operator>&gt;</operator><name>nHaystack</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>N</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the printf() function.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>printfFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PrintfArguments</name></type> <name>x</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StrAccum</name></type> <name>str</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&gt;=</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>zFormat</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>nArg</name></name> <operator>=</operator> <name>argc</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>nUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>apArg</name></name> <operator>=</operator> <name>argv</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3StrAccumInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>str</name><operator>.</operator><name>printfFlags</name></name> <operator>=</operator> <name>SQLITE_PRINTF_SQLFUNC</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3XPrintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>str</name><operator>.</operator><name>nChar</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>,
                        <argument><expr><name>SQLITE_DYNAMIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the substr() function.
**
** substr(x,p1,p2)  returns p2 characters of x[] beginning with p1.
** p1 is 1-indexed.  So substr(x,1,1) returns the first character
** of x.  If x is text, then we actually count UTF-8 characters.
** If x is a blob, then we count bytes.
**
** If p1 is negative, then we begin abs(p1) from the end of x[].
**
** If p2 is negative, return the p2 characters preceding p1.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>substrFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>p0type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>i64</name></type> <name>p1</name></decl>, <decl><type ref="prev"/><name>p2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>negP2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">3</literal> <operator>||</operator> <name>argc</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name>
   <operator>||</operator> <operator>(</operator><name>argc</name><operator>==</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name><operator>)</operator></expr>
  )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p0type</name> <operator>=</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p1</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p0type</name><operator>==</operator><name>SQLITE_BLOB</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>len</name><operator>==</operator><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p1</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>z2</name><operator>=</operator><name>z</name></expr>;</init> <condition><expr><operator>*</operator><name>z2</name></expr>;</condition> <incr><expr><name>len</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>SQLITE_SKIP_UTF8</name><argument_list>(<argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SUBSTR_COMPATIBILITY</name></cpp:ifdef>
  <comment type="block">/* If SUBSTR_COMPATIBILITY is defined then substr(X,0,N) work the same as
  ** as substr(X,1,N) - it returns the first N characters of X.  This
  ** is essentially a back-out of the bug-fix in check-in [5fc125d362df4b8]
  ** from 2009-02-02 for compatibility of applications that exploited the
  ** old buggy behavior. */</comment>
  <if_stmt><if>if<condition>( <expr><name>p1</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p1</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* &lt;rdar://problem/6778339&gt; */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p2</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p2</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>p2</name> <operator>=</operator> <operator>-</operator><name>p2</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>negP2</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>p2</name> <operator>=</operator> <call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>p1</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p1</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p1</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>p2</name> <operator>+=</operator> <name>p1</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>p2</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>p1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>p1</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p1</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>p2</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p2</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>negP2</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>p1</name> <operator>-=</operator> <name>p2</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p1</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>p2</name> <operator>+=</operator> <name>p1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>p1</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p2</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p0type</name><operator>!=</operator><name>SQLITE_BLOB</name></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><operator>*</operator><name>z</name> <operator>&amp;&amp;</operator> <name>p1</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>SQLITE_SKIP_UTF8</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p1</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <for>for<control>(<init><expr><name>z2</name><operator>=</operator><name>z</name></expr>;</init> <condition><expr><operator>*</operator><name>z2</name> <operator>&amp;&amp;</operator> <name>p2</name></expr>;</condition> <incr><expr><name>p2</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>SQLITE_SKIP_UTF8</name><argument_list>(<argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>sqlite3_result_text64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>z</name></expr></argument>, <argument><expr><name>z2</name><operator>-</operator><name>z</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>,
                          <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>p1</name><operator>+</operator><name>p2</name><operator>&gt;</operator><name>len</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>p2</name> <operator>=</operator> <name>len</name><operator>-</operator><name>p1</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>p2</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_blob64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>z</name><index>[<expr><name>p1</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>u64</name><operator>)</operator><name>p2</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the round() function
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>roundFunc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>argc</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>SQLITE_NULL</name><operator>==</operator><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">30</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">30</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* If Y==0 and X will fit in a 64-bit int,
  ** handle the rounding directly,
  ** otherwise use printf.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>r</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>r</name><operator>&lt;</operator><name>LARGEST_INT64</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><operator>(</operator><name>sqlite_int64</name><operator>)</operator><operator>(</operator><name>r</name><operator>+</operator><literal type="number">0.5</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>r</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>-</operator><name>r</name><operator>)</operator><operator>&lt;</operator><name>LARGEST_INT64</name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><operator>(</operator><name>sqlite_int64</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>-</operator><name>r</name><operator>)</operator><operator>+</operator><literal type="number">0.5</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zBuf</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%.*f"</literal></expr></argument>,<argument><expr><name>n</name></expr></argument>,<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zBuf</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3AtoF</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Allocate nByte bytes of space using sqlite3Malloc(). If the
** allocation fails, call sqlite3_result_error_nomem() to notify
** the database handle that malloc() has failed and return NULL.
** If nByte is larger than the maximum string or blob length, then
** raise an SQLITE_TOOBIG exception and return NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>contextMalloc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>i64</name></type> <name>nByte</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nByte</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nByte</name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nByte</name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nByte</name><operator>&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_toobig</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>sqlite3Malloc</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>z</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the upper() and lower() SQL functions.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>upperFunc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z2</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Verify that the call to _bytes() does not invalidate the _text() pointer */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>z2</name><operator>==</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>z2</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z1</name> <operator>=</operator> <call><name>contextMalloc</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name>n</name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z1</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>z1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>sqlite3Toupper</name><argument_list>(<argument><expr><name><name>z2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>z1</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lowerFunc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>z2</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Verify that the call to _bytes() does not invalidate the _text() pointer */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>z2</name><operator>==</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>z2</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z1</name> <operator>=</operator> <call><name>contextMalloc</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name>n</name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z1</name></expr> )</condition><block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>z1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3Tolower</name><argument_list>(<argument><expr><name><name>z2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>z1</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Some functions like COALESCE() and IFNULL() and UNLIKELY() are implemented
** as VDBE code so that unused argument values do not have to be computed.
** However, we still need some kind of function implementation for this
** routines in the function table.  The noopFunc macro provides this.
** noopFunc will never be called so it doesn't matter what the implementation
** is.  We might as well use the "version()" function as a substitute.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>noopFunc</name></cpp:macro> <cpp:value>versionFunc</cpp:value></cpp:define>   <comment type="block">/* Substitute function - never called */</comment>

<comment type="block">/*
** Implementation of random().  Return a random integer.  
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>randomFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>NotUsed</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>NotUsed2</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>r</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>, <argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>r</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* We need to prevent a random number of 0x8000000000000000 
    ** (or -9223372036854775808) since when you do abs() of that
    ** number of you get the same value back again.  To do this
    ** in a way that is testable, mask the sign bit off of negative
    ** values, resulting in a positive value.  Then take the 
    ** 2s complement of that positive value.  The end result can
    ** therefore be no less than -9223372036854775807.
    */</comment>
    <expr_stmt><expr><name>r</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>r</name> <operator>&amp;</operator> <name>LARGEST_INT64</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of randomblob(N).  Return a random blob
** that is N bytes long.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>randomBlob</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>contextMalloc</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the last_insert_rowid() SQL function.  The return
** value is the same as the sqlite3_last_insert_rowid() API function.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>last_insert_rowid</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>NotUsed</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>NotUsed2</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>, <argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* IMP: R-51513-12026 The last_insert_rowid() SQL function is a
  ** wrapper around the sqlite3_last_insert_rowid() C/C++ interface
  ** function. */</comment>
  <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sqlite3_last_insert_rowid</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the changes() SQL function.
**
** IMP: R-62073-11209 The changes() SQL function is a wrapper
** around the sqlite3_changes() C/C++ function and hence follows the same
** rules for counting changes.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>changes</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>NotUsed</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>NotUsed2</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>, <argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sqlite3_changes</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the total_changes() SQL function.  The return value is
** the same as the sqlite3_total_changes() API function.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>total_changes</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>NotUsed</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>NotUsed2</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>, <argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* IMP: R-52756-41993 This function is a wrapper around the
  ** sqlite3_total_changes() C/C++ interface. */</comment>
  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sqlite3_total_changes</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** A structure defining how to do GLOB-style comparisons.
*/</comment>
<struct>struct <name>compareInfo</name> <block>{
  <decl_stmt><decl><type><name>u8</name></type> <name>matchAll</name></decl>;</decl_stmt>          <comment type="block">/* "*" or "%" */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>matchOne</name></decl>;</decl_stmt>          <comment type="block">/* "?" or "_" */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>matchSet</name></decl>;</decl_stmt>          <comment type="block">/* "[" or 0 */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>noCase</name></decl>;</decl_stmt>            <comment type="block">/* true to ignore case differences */</comment>
}</block>;</struct>

<comment type="block">/*
** For LIKE and GLOB matching on EBCDIC machines, assume that every
** character is exactly one byte in size.  Also, provde the Utf8Read()
** macro for fast reading of the next character in the common case where
** the next character is ASCII.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_EBCDIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>sqlite3Utf8Read</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro>        <cpp:value>(*((*A)++))</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>Utf8Read</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro>               <cpp:value>(*(A++))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>Utf8Read</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro>               <cpp:value>(A[0]&lt;0x80?*(A++):sqlite3Utf8Read(&amp;A))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>compareInfo</name></name></type> <name>globInfo</name> <init>= <expr><block>{ <expr><literal type="char">'*'</literal></expr>, <expr><literal type="char">'?'</literal></expr>, <expr><literal type="char">'['</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<comment type="block">/* The correct SQL-92 behavior is for the LIKE operator to ignore
** case.  Thus  'a' LIKE 'A' would be true. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>compareInfo</name></name></type> <name>likeInfoNorm</name> <init>= <expr><block>{ <expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'_'</literal></expr>,   <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<comment type="block">/* If SQLITE_CASE_SENSITIVE_LIKE is defined, then the LIKE operator
** is case sensitive causing 'a' LIKE 'A' to be false */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>compareInfo</name></name></type> <name>likeInfoAlt</name> <init>= <expr><block>{ <expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'_'</literal></expr>,   <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Compare two UTF-8 strings for equality where the first string can
** potentially be a "glob" or "like" expression.  Return true (1) if they
** are the same and false (0) if they are different.
**
** Globbing rules:
**
**      '*'       Matches any sequence of zero or more characters.
**
**      '?'       Matches exactly one character.
**
**     [...]      Matches one character from the enclosed list of
**                characters.
**
**     [^...]     Matches one character not in the enclosed list.
**
** With the [...] and [^...] matching, a ']' character can be included
** in the list by making it the first character after '[' or '^'.  A
** range of characters can be specified using '-'.  Example:
** "[a-z]" matches any single lower-case letter.  To match a '-', make
** it the last character in the list.
**
** Like matching rules:
** 
**      '%'       Matches any sequence of zero or more characters
**
***     '_'       Matches any one character
**
**      Ec        Where E is the "esc" character and c is any other
**                character, including '%', '_', and esc, match exactly c.
**
** The comments within this routine usually assume glob matching.
**
** This routine is usually quick, but can be N**2 in the worst case.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>patternCompare</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>zPattern</name></decl></parameter>,              <comment type="block">/* The glob pattern */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>zString</name></decl></parameter>,               <comment type="block">/* The string to compare against the glob */</comment>
  <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>compareInfo</name></name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>, <comment type="block">/* Information about how to do the compare */</comment>
  <parameter><decl><type><name>u32</name></type> <name>matchOther</name></decl></parameter>                   <comment type="block">/* The escape char (LIKE) or '[' (GLOB) */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>                       <comment type="block">/* Next pattern and input string chars */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>matchOne</name> <init>= <expr><name><name>pInfo</name><operator>-&gt;</operator><name>matchOne</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* "?" or "_" */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>matchAll</name> <init>= <expr><name><name>pInfo</name><operator>-&gt;</operator><name>matchAll</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* "*" or "%" */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>noCase</name> <init>= <expr><name><name>pInfo</name><operator>-&gt;</operator><name>noCase</name></name></expr></init></decl>;</decl_stmt>       <comment type="block">/* True if uppercase==lowercase */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>zEscaped</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* One past the last escaped input char */</comment>
  
  <while>while<condition>( <expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>Utf8Read</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>matchAll</name></expr> )</condition><block>{<block_content>  <comment type="block">/* Match "*" */</comment>
      <comment type="block">/* Skip over multiple "*" characters in the pattern.  If there
      ** are also "?" characters, skip those as well, but consume a
      ** single character of the input string for each "?" skipped */</comment>
      <while>while<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator><call><name>Utf8Read</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>matchAll</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>matchOne</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>matchOne</name> <operator>&amp;&amp;</operator> <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zString</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return>   <comment type="block">/* "*" at the end of the pattern matches */</comment>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><name>matchOther</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pInfo</name><operator>-&gt;</operator><name>matchSet</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zPattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <comment type="block">/* "[...]" immediately follows the "*".  We have to do a slow
          ** recursive search in this case, but it is an unusual case. */</comment>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>matchOther</name><operator>&lt;</operator><literal type="number">0x80</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* '[' is a single-byte character */</comment>
          <while>while<condition>( <expr><operator>*</operator><name>zString</name>
                 <operator>&amp;&amp;</operator> <call><name>patternCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zPattern</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>zString</name></expr></argument>,<argument><expr><name>pInfo</name></expr></argument>,<argument><expr><name>matchOther</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>SQLITE_SKIP_UTF8</name><argument_list>(<argument><expr><name>zString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></while>
          <return>return <expr><operator>*</operator><name>zString</name><operator>!=</operator><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* At this point variable c contains the first character of the
      ** pattern string past the "*".  Search in the input string for the
      ** first matching character and recursively contine the match from
      ** that point.
      **
      ** For a case-insensitive search, set variable cx to be the same as
      ** c but in the other case and search the input string for either
      ** c or cx.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>&lt;=</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>u32</name></type> <name>cx</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>noCase</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>cx</name> <operator>=</operator> <call><name>sqlite3Toupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>sqlite3Tolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>cx</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <while>while<condition>( <expr><operator>(</operator><name>c2</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>zString</name><operator>++</operator><operator>)</operator><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>c2</name><operator>!=</operator><name>c</name> <operator>&amp;&amp;</operator> <name>c2</name><operator>!=</operator><name>cx</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>patternCompare</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>,<argument><expr><name>zString</name></expr></argument>,<argument><expr><name>pInfo</name></expr></argument>,<argument><expr><name>matchOther</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></while>
      </block_content>}</block></if><else>else<block>{<block_content>
        <while>while<condition>( <expr><operator>(</operator><name>c2</name> <operator>=</operator> <call><name>Utf8Read</name><argument_list>(<argument><expr><name>zString</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>c2</name><operator>!=</operator><name>c</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>patternCompare</name><argument_list>(<argument><expr><name>zPattern</name></expr></argument>,<argument><expr><name>zString</name></expr></argument>,<argument><expr><name>pInfo</name></expr></argument>,<argument><expr><name>matchOther</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></while>
      </block_content>}</block></else></if_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>matchOther</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pInfo</name><operator>-&gt;</operator><name>matchSet</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zPattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>zEscaped</name> <operator>=</operator> <name>zPattern</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <decl_stmt><decl><type><name>u32</name></type> <name>prior_c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>seen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>invert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zPattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>c2</name><operator>==</operator><literal type="char">'^'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>invert</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zPattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>c2</name><operator>==</operator><literal type="char">']'</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">']'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>seen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zPattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <while>while<condition>( <expr><name>c2</name> <operator>&amp;&amp;</operator> <name>c2</name><operator>!=</operator><literal type="char">']'</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>c2</name><operator>==</operator><literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>zPattern</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">']'</literal> <operator>&amp;&amp;</operator> <name><name>zPattern</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>prior_c</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zPattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><name>prior_c</name> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><name>c2</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>seen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>prior_c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>c2</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><name>seen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>prior_c</name> <operator>=</operator> <name>c2</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zPattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><name>c2</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>seen</name> <operator>^</operator> <name>invert</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <continue>continue;</continue>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>Utf8Read</name><argument_list>(<argument><expr><name>zString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>c2</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>noCase</name> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;</operator><literal type="number">0x80</literal> <operator>&amp;&amp;</operator> <name>c2</name><operator>&lt;</operator><literal type="number">0x80</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3Tolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>sqlite3Tolower</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>matchOne</name> <operator>&amp;&amp;</operator> <name>zPattern</name><operator>!=</operator><name>zEscaped</name> <operator>&amp;&amp;</operator> <name>c2</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></while>
  <return>return <expr><operator>*</operator><name>zString</name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The sqlite3_strglob() interface.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_strglob</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zGlobPattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zString</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>patternCompare</name><argument_list>(<argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>zGlobPattern</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>zString</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>globInfo</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** The sqlite3_strlike() interface.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3_strlike</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>esc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>patternCompare</name><argument_list>(<argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>zPattern</name></expr></argument>, <argument><expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>zStr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>likeInfoNorm</name></expr></argument>, <argument><expr><name>esc</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Count the number of times that the LIKE operator (or GLOB which is
** just a variation of LIKE) gets called.  This is used for testing
** only.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>sqlite3_like_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Implementation of the like() SQL function.  This function implements
** the build-in LIKE operator.  The first argument to the function is the
** pattern and the second argument is the string.  So, the SQL statements:
**
**       A LIKE B
**
** is implemented as like(B,A).
**
** This same function (with a different compareInfo structure) computes
** the GLOB operator.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>likeFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zA</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zB</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>escape</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nPat</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>compareInfo</name></name> <modifier>*</modifier></type><name>pInfo</name> <init>= <expr><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_LIKE_DOESNT_MATCH_BLOBS</name></cpp:ifdef>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_BLOB</name>
   <operator>||</operator> <call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_BLOB</name></expr>
  )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
    <expr_stmt><expr><name>sqlite3_like_count</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>zB</name> <operator>=</operator> <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zA</name> <operator>=</operator> <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Limit the length of the LIKE or GLOB pattern to avoid problems
  ** of deep recursion and N*N behavior in patternCompare().
  */</comment>
  <expr_stmt><expr><name>nPat</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nPat</name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LIKE_PATTERN_LENGTH</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nPat</name><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LIKE_PATTERN_LENGTH</name></expr>]</index></name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nPat</name> <operator>&gt;</operator> <name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LIKE_PATTERN_LENGTH</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"LIKE or GLOB pattern too complex"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zB</name><operator>==</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Encoding did not change */</comment>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* The escape character string must consist of a single UTF-8 character.
    ** Otherwise, return an error.
    */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zEsc</name> <init>= <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>zEsc</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3Utf8CharLen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zEsc</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, 
          <argument><expr><literal type="string">"ESCAPE expression must be a single character"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>escape</name> <operator>=</operator> <call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zEsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>escape</name> <operator>=</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>matchSet</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zA</name> <operator>&amp;&amp;</operator> <name>zB</name></expr> )</condition><block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
    <expr_stmt><expr><name>sqlite3_like_count</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>patternCompare</name><argument_list>(<argument><expr><name>zB</name></expr></argument>, <argument><expr><name>zA</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>, <argument><expr><name>escape</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the NULLIF(x,y) function.  The result is the first
** argument if the arguments are different.  The result is NULL if the
** arguments are equal to each other.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>nullifFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>NotUsed</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name> <init>= <expr><call><name>sqlite3GetFuncCollSeq</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3MemCompare</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the sqlite_version() function.  The result is the version
** of the SQLite library that is running.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>versionFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>NotUsed</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>NotUsed2</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>, <argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* IMP: R-48699-48617 This function is an SQL wrapper around the
  ** sqlite3_libversion() C-interface. */</comment>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sqlite3_libversion</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the sqlite_source_id() function. The result is a string
** that identifies the particular version of the source code used to build
** SQLite.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sourceidFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>NotUsed</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>NotUsed2</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER2</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>, <argument><expr><name>NotUsed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* IMP: R-24470-31136 This function is an SQL wrapper around the
  ** sqlite3_sourceid() C interface. */</comment>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sqlite3_sourceid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the sqlite_log() function.  This is a wrapper around
** sqlite3_log().  The return value is NULL.  The function exists purely for
** its side-effects.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>errlogFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_log</name><argument_list>(<argument><expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the sqlite_compileoption_used() function.
** The result is an integer that identifies if the compiler option
** was used to build SQLite.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_COMPILEOPTION_DIAGS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>compileoptionusedFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zOptName</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* IMP: R-39564-36305 The sqlite_compileoption_used() SQL
  ** function is a wrapper around the sqlite3_compileoption_used() C/C++
  ** function.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>zOptName</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sqlite3_compileoption_used</name><argument_list>(<argument><expr><name>zOptName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_COMPILEOPTION_DIAGS */</comment>

<comment type="block">/*
** Implementation of the sqlite_compileoption_get() function. 
** The result is a string that identifies the compiler options 
** used to build SQLite.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_COMPILEOPTION_DIAGS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>compileoptiongetFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* IMP: R-04922-24076 The sqlite_compileoption_get() SQL function
  ** is a wrapper around the sqlite3_compileoption_get() C/C++ function.
  */</comment>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sqlite3_compileoption_get</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_COMPILEOPTION_DIAGS */</comment>

<comment type="block">/* Array for converting from half-bytes (nybbles) into ASCII hex
** digits. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>hexdigits</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="char">'0'</literal></expr>, <expr><literal type="char">'1'</literal></expr>, <expr><literal type="char">'2'</literal></expr>, <expr><literal type="char">'3'</literal></expr>, <expr><literal type="char">'4'</literal></expr>, <expr><literal type="char">'5'</literal></expr>, <expr><literal type="char">'6'</literal></expr>, <expr><literal type="char">'7'</literal></expr>,
  <expr><literal type="char">'8'</literal></expr>, <expr><literal type="char">'9'</literal></expr>, <expr><literal type="char">'A'</literal></expr>, <expr><literal type="char">'B'</literal></expr>, <expr><literal type="char">'C'</literal></expr>, <expr><literal type="char">'D'</literal></expr>, <expr><literal type="char">'E'</literal></expr>, <expr><literal type="char">'F'</literal></expr> 
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** Implementation of the QUOTE() function.  This function takes a single
** argument.  If the argument is numeric, the return value is the same as
** the argument.  If the argument is NULL, the return value is the string
** "NULL".  Otherwise, the argument is enclosed in single quotes with
** single-quote escapes.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>quoteFunc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>double</name></type> <name>r1</name></decl>, <decl><type ref="prev"/><name>r2</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
      <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="string">"%!.15g"</literal></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3AtoF</name><argument_list>(<argument><expr><name>zBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r2</name></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>r1</name><operator>!=</operator><name>r2</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><literal type="string">"%!.20e"</literal></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_BLOB</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zText</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zBlob</name> <init>= <expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nBlob</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zBlob</name><operator>==</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt> <comment type="block">/* No encoding change */</comment>
      <expr_stmt><expr><name>zText</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>contextMalloc</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">2</literal><operator>*</operator><operator>(</operator><name>i64</name><operator>)</operator><name>nBlob</name><operator>)</operator><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <if_stmt><if>if<condition>( <expr><name>zText</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nBlob</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name><name>zText</name><index>[<expr><operator>(</operator><name>i</name><operator>*</operator><literal type="number">2</literal><operator>)</operator><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>hexdigits</name><index>[<expr><operator>(</operator><name><name>zBlob</name><index>[<expr><name>i</name></expr>]</index></name><operator>&gt;&gt;</operator><literal type="number">4</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x0F</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>zText</name><index>[<expr><operator>(</operator><name>i</name><operator>*</operator><literal type="number">2</literal><operator>)</operator><operator>+</operator><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>hexdigits</name><index>[<expr><operator>(</operator><name><name>zBlob</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>&amp;</operator><literal type="number">0x0F</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>zText</name><index>[<expr><operator>(</operator><name>nBlob</name><operator>*</operator><literal type="number">2</literal><operator>)</operator><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zText</name><index>[<expr><operator>(</operator><name>nBlob</name><operator>*</operator><literal type="number">2</literal><operator>)</operator><operator>+</operator><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zText</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'X'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>zText</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zText</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_TEXT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u64</name></type> <name>n</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zArg</name> <init>= <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>

      <if_stmt><if>if<condition>( <expr><name>zArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content> <if_stmt><if>if<condition>( <expr><name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt> </block_content>}</block></for>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>contextMalloc</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name>i</name><operator>)</operator><operator>+</operator><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name>n</name><operator>)</operator><operator>+</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>z</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>zArg</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'\''</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** The unicode() function.  Return the integer unicode code-point value
** for the first character of the input string. 
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unicodeFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argc</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sqlite3Utf8Read</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The char() function takes zero or more arguments, each of which is
** an integer.  It constructs a string where each character of the string
** is the unicode character for the corresponding integer argument.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>charFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zOut</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>zOut</name> <operator>=</operator> <name>z</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>argc</name><operator>*</operator><literal type="number">4</literal><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>c</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>x</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal> <operator>||</operator> <name>x</name></expr></argument>&gt;</argument_list></name><literal type="number">0x10ffff</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>x</name> <operator>=</operator> <literal type="number">0xfffd</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x1fffff</literal><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>&lt;</operator><literal type="number">0x00080</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>zOut</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&lt;</operator><literal type="number">0x00800</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>zOut</name><operator>++</operator> <operator>=</operator> <literal type="number">0xC0</literal> <operator>+</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>c</name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x1F</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>zOut</name><operator>++</operator> <operator>=</operator> <literal type="number">0x80</literal> <operator>+</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&lt;</operator><literal type="number">0x10000</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>zOut</name><operator>++</operator> <operator>=</operator> <literal type="number">0xE0</literal> <operator>+</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>c</name><operator>&gt;&gt;</operator><literal type="number">12</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x0F</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>zOut</name><operator>++</operator> <operator>=</operator> <literal type="number">0x80</literal> <operator>+</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>c</name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>zOut</name><operator>++</operator> <operator>=</operator> <literal type="number">0x80</literal> <operator>+</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>zOut</name><operator>++</operator> <operator>=</operator> <literal type="number">0xF0</literal> <operator>+</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>c</name><operator>&gt;&gt;</operator><literal type="number">18</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x07</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>zOut</name><operator>++</operator> <operator>=</operator> <literal type="number">0x80</literal> <operator>+</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>c</name><operator>&gt;&gt;</operator><literal type="number">12</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>zOut</name><operator>++</operator> <operator>=</operator> <literal type="number">0x80</literal> <operator>+</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><operator>(</operator><name>c</name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>zOut</name><operator>++</operator> <operator>=</operator> <literal type="number">0x80</literal> <operator>+</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3F</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>                                                    \
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_result_text64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>z</name></expr></argument>, <argument><expr><name>zOut</name><operator>-</operator><name>z</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The hex() function.  Interpret the argument as a blob.  Return
** a hexadecimal rendering as text.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>hexFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pBlob</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zHex</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pBlob</name> <operator>=</operator> <call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pBlob</name><operator>==</operator><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* No encoding change */</comment>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <name>zHex</name> <operator>=</operator> <call><name>contextMalloc</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name>n</name><operator>)</operator><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zHex</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pBlob</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>pBlob</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>hexdigits</name><index>[<expr><operator>(</operator><name>c</name><operator>&gt;&gt;</operator><literal type="number">4</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xf</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>hexdigits</name><index>[<expr><name>c</name><operator>&amp;</operator><literal type="number">0xf</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><operator>*</operator><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zHex</name></expr></argument>, <argument><expr><name>n</name><operator>*</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The zeroblob(N) function returns a zero-filled blob of size N bytes.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zeroblobFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>i64</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_result_zeroblob64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* IMP: R-00293-64994 */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_code</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The replace() function.  Three arguments are all strings: call
** them A, B, and C. The result is also a string which is derived
** from A by replacing every occurrence of B with C.  The match
** must be exact.  Collating sequences are not used.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>replaceFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zStr</name></decl>;</decl_stmt>        <comment type="block">/* The input string A */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zPattern</name></decl>;</decl_stmt>    <comment type="block">/* The pattern string B */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zRep</name></decl>;</decl_stmt>        <comment type="block">/* The replacement string C */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zOut</name></decl>;</decl_stmt>              <comment type="block">/* The output */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nStr</name></decl>;</decl_stmt>                <comment type="block">/* Size of zStr */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPattern</name></decl>;</decl_stmt>            <comment type="block">/* Size of zPattern */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nRep</name></decl>;</decl_stmt>                <comment type="block">/* Size of zRep */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>nOut</name></decl>;</decl_stmt>                <comment type="block">/* Maximum size of zOut */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>loopLimit</name></decl>;</decl_stmt>           <comment type="block">/* Last zStr[] that might match zPattern[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>                <comment type="block">/* Loop counters */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zStr</name> <operator>=</operator> <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zStr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nStr</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zStr</name><operator>==</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* No encoding change */</comment>
  <expr_stmt><expr><name>zPattern</name> <operator>=</operator> <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zPattern</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name>
            <operator>||</operator> <call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>mallocFailed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zPattern</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nPattern</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zPattern</name><operator>==</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* No encoding change */</comment>
  <expr_stmt><expr><name>zRep</name> <operator>=</operator> <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zRep</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nRep</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zRep</name><operator>==</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nOut</name> <operator>=</operator> <name>nStr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nOut</name><operator>&lt;</operator><name>SQLITE_MAX_LENGTH</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zOut</name> <operator>=</operator> <call><name>contextMalloc</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>i64</name><operator>)</operator><name>nOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>loopLimit</name> <operator>=</operator> <name>nStr</name> <operator>-</operator> <name>nPattern</name></expr>;</expr_stmt>  
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>loopLimit</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>zStr</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name><name>zPattern</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zStr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, <argument><expr><name>nPattern</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>zStr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>u8</name> <modifier>*</modifier></type><name>zOld</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>nOut</name> <operator>+=</operator> <name>nRep</name> <operator>-</operator> <name>nPattern</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nOut</name><operator>-</operator><literal type="number">1</literal><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>testcase</name><argument_list>( <argument><expr><name>nOut</name><operator>-</operator><literal type="number">2</literal><operator>==</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>nOut</name><operator>-</operator><literal type="number">1</literal><operator>&gt;</operator><name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_error_toobig</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>zOld</name> <operator>=</operator> <name>zOut</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zOut</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name>zOut</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>nOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>zRep</name></expr></argument>, <argument><expr><name>nRep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name> <operator>+=</operator> <name>nRep</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name> <operator>+=</operator> <name>nPattern</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>+</operator><name>nStr</name><operator>-</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>==</operator><name>nOut</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zOut</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zStr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>nStr</name><operator>-</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>j</name> <operator>+=</operator> <name>nStr</name> <operator>-</operator> <name>i</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>j</name><operator>&lt;=</operator><name>nOut</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zOut</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the TRIM(), LTRIM(), and RTRIM() functions.
** The userdata is 0x1 for left trim, 0x2 for right trim, 0x3 for both.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>trimFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>         <comment type="block">/* Input string */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zCharSet</name></decl>;</decl_stmt>    <comment type="block">/* Set of characters to trim */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nIn</name></decl>;</decl_stmt>                          <comment type="block">/* Number of bytes in input */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>                        <comment type="block">/* 1: trimleft  2: trimright  3: trim */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                            <comment type="block">/* Loop counter */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>aLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>          <comment type="block">/* Length of each character in zCharSet */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azChar</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* Individual characters in zCharSet */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nChar</name></decl>;</decl_stmt>                        <comment type="block">/* Number of characters in zCharSet */</comment>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zIn</name> <operator>=</operator> <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zIn</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nIn</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zIn</name><operator>==</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>lenOne</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">1</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>azOne</name><index>[]</index></name> <init>= <expr><block>{ <expr><operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><literal type="string">" "</literal></expr> }</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>nChar</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>aLen</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><name>lenOne</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>azChar</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>azOne</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCharSet</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>zCharSet</name> <operator>=</operator> <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>z</name><operator>=</operator><name>zCharSet</name></expr><operator>,</operator> <expr><name>nChar</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>z</name></expr>;</condition> <incr><expr><name>nChar</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>SQLITE_SKIP_UTF8</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>nChar</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>azChar</name> <operator>=</operator> <call><name>contextMalloc</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>i64</name><operator>)</operator><name>nChar</name><operator>)</operator><operator>*</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>azChar</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>aLen</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>azChar</name><index>[<expr><name>nChar</name></expr>]</index></name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>z</name><operator>=</operator><name>zCharSet</name></expr><operator>,</operator> <expr><name>nChar</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>z</name></expr>;</condition> <incr><expr><name>nChar</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>azChar</name><index>[<expr><name>nChar</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>z</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SQLITE_SKIP_UTF8</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>aLen</name><index>[<expr><name>nChar</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>z</name> <operator>-</operator> <name><name>azChar</name><index>[<expr><name>nChar</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nChar</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>SQLITE_PTR_TO_INT</name><argument_list>(<argument><expr><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <while>while<condition>( <expr><name>nIn</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nChar</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>aLen</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>len</name><operator>&lt;=</operator><name>nIn</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><name><name>azChar</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name>nChar</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>zIn</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nIn</name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>flags</name> <operator>&amp;</operator> <literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <while>while<condition>( <expr><name>nIn</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nChar</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>aLen</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>len</name><operator>&lt;=</operator><name>nIn</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zIn</name><index>[<expr><name>nIn</name><operator>-</operator><name>len</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>azChar</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name>nChar</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>nIn</name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>zCharSet</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>azChar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>zIn</name></expr></argument>, <argument><expr><name>nIn</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* IMP: R-25361-16150 This function is omitted from SQLite by default. It
** is only available if the SQLITE_SOUNDEX compile-time option is used
** when SQLite is built.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SOUNDEX</name></cpp:ifdef>
<comment type="block">/*
** Compute the soundex encoding of a word.
**
** IMP: R-59782-00072 The soundex(X) function returns a string that is the
** soundex encoding of the string X. 
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>soundexFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zResult</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>u8</name> <modifier>*</modifier></type><name>zIn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>iCode</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">0</literal></expr>,
    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  }</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zIn</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zIn</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zIn</name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>*</operator><operator>)</operator><literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sqlite3Isalpha</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>u8</name></type> <name>prevcode</name> <init>= <expr><name><name>iCode</name><index>[<expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7f</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>zResult</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3Toupper</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>code</name> <init>= <expr><name><name>iCode</name><index>[<expr><name><name>zIn</name><index>[<expr><name>i</name></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7f</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>code</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>code</name><operator>!=</operator><name>prevcode</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>prevcode</name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>zResult</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>code</name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>prevcode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <while>while<condition>( <expr><name>j</name><operator>&lt;</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>zResult</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>zResult</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zResult</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* IMP: R-64894-50321 The string "?000" is returned if the argument
    ** is NULL or contains no ASCII alphabetic characters. */</comment>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="string">"?000"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_SOUNDEX */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOAD_EXTENSION</name></cpp:ifndef>
<comment type="block">/*
** A function that loads a shared-library extension then returns NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>loadExt</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFile</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zProc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zErrMsg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zProc</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zProc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>zFile</name> <operator>&amp;&amp;</operator> <call><name>sqlite3_load_extension</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zFile</name></expr></argument>, <argument><expr><name>zProc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErrMsg</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zErrMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** An instance of the following structure holds the context of a
** sum() or avg() aggregate computation.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>SumCtx</name></name></type> <name>SumCtx</name>;</typedef>
<struct>struct <name>SumCtx</name> <block>{
  <decl_stmt><decl><type><name>double</name></type> <name>rSum</name></decl>;</decl_stmt>      <comment type="block">/* Floating point sum */</comment>
  <decl_stmt><decl><type><name>i64</name></type> <name>iSum</name></decl>;</decl_stmt>         <comment type="block">/* Integer sum */</comment>   
  <decl_stmt><decl><type><name>i64</name></type> <name>cnt</name></decl>;</decl_stmt>          <comment type="block">/* Number of elements summed */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>overflow</name></decl>;</decl_stmt>      <comment type="block">/* True if integer overflow seen */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>approx</name></decl>;</decl_stmt>        <comment type="block">/* True if non-integer value was input to the sum */</comment>
}</block>;</struct>

<comment type="block">/*
** Routines used to compute the sum, average, and total.
**
** The SUM() function follows the (broken) SQL standard which means
** that it returns NULL if it sums over no inputs.  TOTAL returns
** 0.0 in that case.  In addition, TOTAL always returns a float where
** SUM might return an integer if it never encounters a floating point
** value.  TOTAL never fails, but SUM might through an exception if
** it overflows an integer.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sumStep</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SumCtx</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>sqlite3_value_numeric_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name>type</name><operator>!=</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cnt</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>type</name><operator>==</operator><name>SQLITE_INTEGER</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>i64</name></type> <name>v</name> <init>= <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rSum</name></name> <operator>+=</operator> <name>v</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>approx</name></name><operator>|</operator><name><name>p</name><operator>-&gt;</operator><name>overflow</name></name><operator>)</operator><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sqlite3AddInt64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>iSum</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>overflow</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>rSum</name></name> <operator>+=</operator> <call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>approx</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sumFinalize</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SumCtx</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>cnt</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>overflow</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>,<argument><expr><literal type="string">"integer overflow"</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>approx</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rSum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iSum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>avgFinalize</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SumCtx</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>cnt</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>rSum</name></name><operator>/</operator><operator>(</operator><name>double</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>cnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>totalFinalize</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>SumCtx</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */</comment>
  <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>rSum</name></name></expr> </then><else>: <expr><operator>(</operator><name>double</name><operator>)</operator><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The following structure keeps track of state information for the
** count() aggregate function.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>CountCtx</name></name></type> <name>CountCtx</name>;</typedef>
<struct>struct <name>CountCtx</name> <block>{
  <decl_stmt><decl><type><name>i64</name></type> <name>n</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** Routines to implement the count() aggregate function.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>countStep</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CountCtx</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>argc</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>SQLITE_NULL</name><operator>!=</operator><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <name>p</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_DEPRECATED</name></cpp:ifndef>
  <comment type="block">/* The sqlite3_aggregate_count() function is deprecated.  But just to make
  ** sure it still operates correctly, verify that its count agrees with our 
  ** internal count when using count(*) and when the total count can be
  ** expressed as a 32-bit integer. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>p</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>&gt;</operator><literal type="number">0x7fffffff</literal>
          <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>n</name></name><operator>==</operator><call><name>sqlite3_aggregate_count</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>   
<function><type><specifier>static</specifier> <name>void</name></type> <name>countFinalize</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>CountCtx</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Routines to implement min() and max() aggregate functions.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>minmaxStep</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>NotUsed</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pArg</name>  <init>= <expr><operator>(</operator><name>Mem</name> <operator>*</operator><operator>)</operator><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mem</name> <modifier>*</modifier></type><name>pBest</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAMETER</name><argument_list>(<argument><expr><name>NotUsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pBest</name> <operator>=</operator> <operator>(</operator><name>Mem</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pBest</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pBest</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pBest</name><operator>-&gt;</operator><name>flags</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3SkipAccumulatorLoad</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pBest</name><operator>-&gt;</operator><name>flags</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>max</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CollSeq</name> <modifier>*</modifier></type><name>pColl</name> <init>= <expr><call><name>sqlite3GetFuncCollSeq</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* This step function is used for both the min() and max() aggregates,
    ** the only difference between the two being that the sense of the
    ** comparison is inverted. For the max() aggregate, the
    ** sqlite3_user_data() function returns (void *)-1. For min() it
    ** returns (void *)db, where db is the sqlite3* database pointer.
    ** Therefore the next statement sets variable 'max' to 1 for the max()
    ** aggregate, or 0 for min().
    */</comment>
    <expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>sqlite3MemCompare</name><argument_list>(<argument><expr><name>pBest</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>, <argument><expr><name>pColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>max</name> <operator>&amp;&amp;</operator> <name>cmp</name><operator>&lt;</operator><literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><name>max</name> <operator>&amp;&amp;</operator> <name>cmp</name><operator>&gt;</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3VdbeMemCopy</name><argument_list>(<argument><expr><name>pBest</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3SkipAccumulatorLoad</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pBest</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemCopy</name><argument_list>(<argument><expr><name>pBest</name></expr></argument>, <argument><expr><name>pArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>minMaxFinalize</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pRes</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pRes</name> <operator>=</operator> <operator>(</operator><name>sqlite3_value</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRes</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pRes</name><operator>-&gt;</operator><name>flags</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>sqlite3VdbeMemRelease</name><argument_list>(<argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** group_concat(EXPR, ?SEPARATOR?)
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>groupConcatStep</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zVal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StrAccum</name> <modifier>*</modifier></type><name>pAccum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nVal</name></decl>, <decl><type ref="prev"/><name>nSep</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal> <operator>||</operator> <name>argc</name><operator>==</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pAccum</name> <operator>=</operator> <operator>(</operator><name>StrAccum</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pAccum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>pAccum</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>firstTerm</name> <init>= <expr><name><name>pAccum</name><operator>-&gt;</operator><name>mxAlloc</name></name><operator>==</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pAccum</name><operator>-&gt;</operator><name>mxAlloc</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>aLimit</name><index>[<expr><name>SQLITE_LIMIT_LENGTH</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>firstTerm</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zSep</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nSep</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>nSep</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>nSep</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>nSep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zVal</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nVal</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zVal</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3StrAccumAppend</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>, <argument><expr><name>zVal</name></expr></argument>, <argument><expr><name>nVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>groupConcatFinalize</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>StrAccum</name> <modifier>*</modifier></type><name>pAccum</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pAccum</name> <operator>=</operator> <call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pAccum</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pAccum</name><operator>-&gt;</operator><name>accError</name></name><operator>==</operator><name>STRACCUM_TOOBIG</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_toobig</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pAccum</name><operator>-&gt;</operator><name>accError</name></name><operator>==</operator><name>STRACCUM_NOMEM</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>    
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sqlite3StrAccumFinish</name><argument_list>(<argument><expr><name>pAccum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, 
                          <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This routine does per-connection function registration.  Most
** of the built-in functions above are part of the global function set.
** This routine only deals with those that are not global.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RegisterBuiltinFunctions</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_overload_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"MATCH"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name> <operator>||</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3OomFault</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Set the LIKEOPT flag on the 2-argument function with the given name.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setLikeOptFlag</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, <parameter><decl><type><name>u8</name></type> <name>flagVal</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pDef</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pDef</name> <operator>=</operator> <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>ALWAYS</name><argument_list>(<argument><expr><name>pDef</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>|=</operator> <name>flagVal</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Register the built-in LIKE and GLOB functions.  The caseSensitive
** parameter determines whether or not the LIKE operator is case
** sensitive.  GLOB is always case sensitive.
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RegisterLikeFunctions</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>caseSensitive</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>compareInfo</name></name> <modifier>*</modifier></type><name>pInfo</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>caseSensitive</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pInfo</name> <operator>=</operator> <operator>(</operator>struct <name>compareInfo</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>likeInfoAlt</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pInfo</name> <operator>=</operator> <operator>(</operator>struct <name>compareInfo</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>likeInfoNorm</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"like"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>, <argument><expr><name>likeFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"like"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>, <argument><expr><name>likeFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3CreateFunc</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"glob"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, 
      <argument><expr><operator>(</operator>struct <name>compareInfo</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>globInfo</name></expr></argument>, <argument><expr><name>likeFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setLikeOptFlag</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"glob"</literal></expr></argument>, <argument><expr><name>SQLITE_FUNC_LIKE</name> <operator>|</operator> <name>SQLITE_FUNC_CASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setLikeOptFlag</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"like"</literal></expr></argument>, 
      <argument><expr><ternary><condition><expr><name>caseSensitive</name></expr> ?</condition><then> <expr><operator>(</operator><name>SQLITE_FUNC_LIKE</name> <operator>|</operator> <name>SQLITE_FUNC_CASE</name><operator>)</operator></expr> </then><else>: <expr><name>SQLITE_FUNC_LIKE</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** pExpr points to an expression which implements a function.  If
** it is appropriate to apply the LIKE optimization to that function
** then set aWc[0] through aWc[2] to the wildcard characters and
** return TRUE.  If the function is not a LIKE-style function then
** return FALSE.
**
** *pIsNocase is set to true if uppercase and lowercase are equivalent for
** the function (default for LIKE).  If the function makes the distinction
** between uppercase and lowercase (as does GLOB) then *pIsNocase is set to
** false.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3IsLikeFunction</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>pExpr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pIsNocase</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>aWc</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>pDef</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pExpr</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>TK_FUNCTION</name> 
   <operator>||</operator> <operator>!</operator><name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name></name> 
   <operator>||</operator> <name><name>pExpr</name><operator>-&gt;</operator><name>x</name><operator>.</operator><name>pList</name><operator>-&gt;</operator><name>nExpr</name></name><operator>!=</operator><literal type="number">2</literal></expr>
  )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>ExprHasProperty</name><argument_list>(<argument><expr><name>pExpr</name></expr></argument>, <argument><expr><name>EP_xIsSelect</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pDef</name> <operator>=</operator> <call><name>sqlite3FindFunction</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>, 
                             <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name><name>pExpr</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zToken</name></name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>NEVER</name><argument_list>(<argument><expr><name>pDef</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_LIKE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The memcpy() statement assumes that the wildcard characters are
  ** the first three statements in the compareInfo structure.  The
  ** asserts() that follow verify that assumption
  */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aWc</name></expr></argument>, <argument><expr><name><name>pDef</name><operator>-&gt;</operator><name>pUserData</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>likeInfoAlt</name> <operator>==</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>likeInfoAlt</name><operator>.</operator><name>matchAll</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>likeInfoAlt</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>==</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>likeInfoAlt</name><operator>.</operator><name>matchOne</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>likeInfoAlt</name><operator>)</operator><index>[<expr><literal type="number">2</literal></expr>]</index> <operator>==</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>likeInfoAlt</name><operator>.</operator><name>matchSet</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pIsNocase</name> <operator>=</operator> <operator>(</operator><name><name>pDef</name><operator>-&gt;</operator><name>funcFlags</name></name> <operator>&amp;</operator> <name>SQLITE_FUNC_CASE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** All of the FuncDef structures in the aBuiltinFunc[] array above
** to the global function hash table.  This occurs at start-time (as
** a consequence of calling sqlite3_initialize()).
**
** After this routine runs
*/</comment>
<function><type><name>void</name></type> <name>sqlite3RegisterGlobalFunctions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/*
  ** The following array holds FuncDef structures for all of the functions
  ** defined in this file.
  **
  ** The array cannot be constant since changes are made to the
  ** FuncDef.pHash elements at start-time.  The elements of this array
  ** are read-only after initialization is complete.
  */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>SQLITE_WSD</name> <name>FuncDef</name></type> <name><name>aBuiltinFunc</name><index>[]</index></name> <init>= <expr><block>{
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>ltrim</name></expr></argument>,              <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>trimFunc</name></expr></argument>         )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>ltrim</name></expr></argument>,              <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>trimFunc</name></expr></argument>         )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>rtrim</name></expr></argument>,              <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>trimFunc</name></expr></argument>         )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>rtrim</name></expr></argument>,              <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>trimFunc</name></expr></argument>         )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>trim</name></expr></argument>,               <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>trimFunc</name></expr></argument>         )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>trim</name></expr></argument>,               <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>trimFunc</name></expr></argument>         )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>min</name></expr></argument>,               <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>minmaxFunc</name></expr></argument>       )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>min</name></expr></argument>,                <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>                )</argument_list></call></expr>,
    <expr><call><name>AGGREGATE2</name><argument_list>(<argument><expr><name>min</name></expr></argument>,              <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>minmaxStep</name></expr></argument>,      <argument><expr><name>minMaxFinalize</name></expr></argument>,
                                          <argument><expr><name>SQLITE_FUNC_MINMAX</name></expr></argument> )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>max</name></expr></argument>,               <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>minmaxFunc</name></expr></argument>       )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>max</name></expr></argument>,                <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>                )</argument_list></call></expr>,
    <expr><call><name>AGGREGATE2</name><argument_list>(<argument><expr><name>max</name></expr></argument>,              <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>minmaxStep</name></expr></argument>,      <argument><expr><name>minMaxFinalize</name></expr></argument>,
                                          <argument><expr><name>SQLITE_FUNC_MINMAX</name></expr></argument> )</argument_list></call></expr>,
    <expr><call><name>FUNCTION2</name><argument_list>(<argument><expr><name>typeof</name></expr></argument>,            <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>typeofFunc</name></expr></argument>,  <argument><expr><name>SQLITE_FUNC_TYPEOF</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>FUNCTION2</name><argument_list>(<argument><expr><name>length</name></expr></argument>,            <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lengthFunc</name></expr></argument>,  <argument><expr><name>SQLITE_FUNC_LENGTH</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>instr</name></expr></argument>,              <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>instrFunc</name></expr></argument>        )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>substr</name></expr></argument>,             <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>substrFunc</name></expr></argument>       )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>substr</name></expr></argument>,             <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>substrFunc</name></expr></argument>       )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>printf</name></expr></argument>,            <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>printfFunc</name></expr></argument>       )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>,            <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>unicodeFunc</name></expr></argument>      )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>char</name></expr></argument>,              <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>charFunc</name></expr></argument>         )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>abs</name></expr></argument>,                <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>absFunc</name></expr></argument>          )</argument_list></call></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_FLOATING_POINT</name></cpp:ifndef>
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>round</name></expr></argument>,              <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>roundFunc</name></expr></argument>        )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>round</name></expr></argument>,              <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>roundFunc</name></expr></argument>        )</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>upper</name></expr></argument>,              <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>upperFunc</name></expr></argument>        )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>lower</name></expr></argument>,              <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lowerFunc</name></expr></argument>        )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>coalesce</name></expr></argument>,           <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>                )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>coalesce</name></expr></argument>,           <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>                )</argument_list></call></expr>,
    <expr><call><name>FUNCTION2</name><argument_list>(<argument><expr><name>coalesce</name></expr></argument>,         <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>noopFunc</name></expr></argument>,  <argument><expr><name>SQLITE_FUNC_COALESCE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>hex</name></expr></argument>,                <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>hexFunc</name></expr></argument>          )</argument_list></call></expr>,
    <expr><call><name>FUNCTION2</name><argument_list>(<argument><expr><name>ifnull</name></expr></argument>,            <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>noopFunc</name></expr></argument>,  <argument><expr><name>SQLITE_FUNC_COALESCE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>FUNCTION2</name><argument_list>(<argument><expr><name>unlikely</name></expr></argument>,          <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>noopFunc</name></expr></argument>,  <argument><expr><name>SQLITE_FUNC_UNLIKELY</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>FUNCTION2</name><argument_list>(<argument><expr><name>likelihood</name></expr></argument>,        <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>noopFunc</name></expr></argument>,  <argument><expr><name>SQLITE_FUNC_UNLIKELY</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>FUNCTION2</name><argument_list>(<argument><expr><name>likely</name></expr></argument>,            <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>noopFunc</name></expr></argument>,  <argument><expr><name>SQLITE_FUNC_UNLIKELY</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>VFUNCTION</name><argument_list>(<argument><expr><name>random</name></expr></argument>,            <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>randomFunc</name></expr></argument>       )</argument_list></call></expr>,
    <expr><call><name>VFUNCTION</name><argument_list>(<argument><expr><name>randomblob</name></expr></argument>,        <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>randomBlob</name></expr></argument>       )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>nullif</name></expr></argument>,             <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nullifFunc</name></expr></argument>       )</argument_list></call></expr>,
    <expr><call><name>DFUNCTION</name><argument_list>(<argument><expr><name>sqlite_version</name></expr></argument>,    <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>versionFunc</name></expr></argument>      )</argument_list></call></expr>,
    <expr><call><name>DFUNCTION</name><argument_list>(<argument><expr><name>sqlite_source_id</name></expr></argument>,  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sourceidFunc</name></expr></argument>     )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>sqlite_log</name></expr></argument>,         <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>errlogFunc</name></expr></argument>       )</argument_list></call></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_USER_AUTHENTICATION</name></expr></cpp:if>
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>sqlite_crypt</name></expr></argument>,       <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sqlite3CryptFunc</name></expr></argument> )</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_COMPILEOPTION_DIAGS</name></cpp:ifndef>
    <expr><call><name>DFUNCTION</name><argument_list>(<argument><expr><name>sqlite_compileoption_used</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>compileoptionusedFunc</name></expr></argument>  )</argument_list></call></expr>,
    <expr><call><name>DFUNCTION</name><argument_list>(<argument><expr><name>sqlite_compileoption_get</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>compileoptiongetFunc</name></expr></argument>  )</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_COMPILEOPTION_DIAGS */</comment>
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>quote</name></expr></argument>,              <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>quoteFunc</name></expr></argument>        )</argument_list></call></expr>,
    <expr><call><name>VFUNCTION</name><argument_list>(<argument><expr><name>last_insert_rowid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>last_insert_rowid</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>VFUNCTION</name><argument_list>(<argument><expr><name>changes</name></expr></argument>,           <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>changes</name></expr></argument>          )</argument_list></call></expr>,
    <expr><call><name>VFUNCTION</name><argument_list>(<argument><expr><name>total_changes</name></expr></argument>,     <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>total_changes</name></expr></argument>    )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>replace</name></expr></argument>,            <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>replaceFunc</name></expr></argument>      )</argument_list></call></expr>,
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>zeroblob</name></expr></argument>,           <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zeroblobFunc</name></expr></argument>     )</argument_list></call></expr>,
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_SOUNDEX</name></cpp:ifdef>
    <expr><call><name>FUNCTION</name><argument_list>(<argument><expr><name>soundex</name></expr></argument>,            <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>soundexFunc</name></expr></argument>      )</argument_list></call></expr>,
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_LOAD_EXTENSION</name></cpp:ifndef>
    <expr><call><name>VFUNCTION</name><argument_list>(<argument><expr><name>load_extension</name></expr></argument>,    <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>loadExt</name></expr></argument>          )</argument_list></call></expr>,
    <expr><call><name>VFUNCTION</name><argument_list>(<argument><expr><name>load_extension</name></expr></argument>,    <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>loadExt</name></expr></argument>          )</argument_list></call></expr>,
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><call><name>AGGREGATE</name><argument_list>(<argument><expr><name>sum</name></expr></argument>,               <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sumStep</name></expr></argument>,         <argument><expr><name>sumFinalize</name></expr></argument>    )</argument_list></call></expr>,
    <expr><call><name>AGGREGATE</name><argument_list>(<argument><expr><name>total</name></expr></argument>,             <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sumStep</name></expr></argument>,         <argument><expr><name>totalFinalize</name></expr></argument>    )</argument_list></call></expr>,
    <expr><call><name>AGGREGATE</name><argument_list>(<argument><expr><name>avg</name></expr></argument>,               <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sumStep</name></expr></argument>,         <argument><expr><name>avgFinalize</name></expr></argument>    )</argument_list></call></expr>,
    <expr><call><name>AGGREGATE2</name><argument_list>(<argument><expr><name>count</name></expr></argument>,            <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>countStep</name></expr></argument>,       <argument><expr><name>countFinalize</name></expr></argument>,
               <argument><expr><name>SQLITE_FUNC_COUNT</name></expr></argument>  )</argument_list></call></expr>,
    <expr><call><name>AGGREGATE</name><argument_list>(<argument><expr><name>count</name></expr></argument>,             <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>countStep</name></expr></argument>,       <argument><expr><name>countFinalize</name></expr></argument>  )</argument_list></call></expr>,
    <expr><call><name>AGGREGATE</name><argument_list>(<argument><expr><name>group_concat</name></expr></argument>,      <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>groupConcatStep</name></expr></argument>, <argument><expr><name>groupConcatFinalize</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>AGGREGATE</name><argument_list>(<argument><expr><name>group_concat</name></expr></argument>,      <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>groupConcatStep</name></expr></argument>, <argument><expr><name>groupConcatFinalize</name></expr></argument>)</argument_list></call></expr>,
  
    <expr><call><name>LIKEFUNC</name><argument_list>(<argument><expr><name>glob</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>globInfo</name></expr></argument>, <argument><expr><name>SQLITE_FUNC_LIKE</name><operator>|</operator><name>SQLITE_FUNC_CASE</name></expr></argument>)</argument_list></call></expr>,
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_CASE_SENSITIVE_LIKE</name></cpp:ifdef>
    <expr><call><name>LIKEFUNC</name><argument_list>(<argument><expr><name>like</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>likeInfoAlt</name></expr></argument>, <argument><expr><name>SQLITE_FUNC_LIKE</name><operator>|</operator><name>SQLITE_FUNC_CASE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>LIKEFUNC</name><argument_list>(<argument><expr><name>like</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>likeInfoAlt</name></expr></argument>, <argument><expr><name>SQLITE_FUNC_LIKE</name><operator>|</operator><name>SQLITE_FUNC_CASE</name></expr></argument>)</argument_list></call></expr>,
  <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr><call><name>LIKEFUNC</name><argument_list>(<argument><expr><name>like</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>likeInfoNorm</name></expr></argument>, <argument><expr><name>SQLITE_FUNC_LIKE</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>LIKEFUNC</name><argument_list>(<argument><expr><name>like</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>likeInfoNorm</name></expr></argument>, <argument><expr><name>SQLITE_FUNC_LIKE</name></expr></argument>)</argument_list></call></expr>,
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncDefHash</name> <modifier>*</modifier></type><name>pHash</name> <init>= <expr><operator>&amp;</operator><call><name>GLOBAL</name><argument_list>(<argument><expr><name>FuncDefHash</name></expr></argument>, <argument><expr><name>sqlite3GlobalFunctions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncDef</name> <modifier>*</modifier></type><name>aFunc</name> <init>= <expr><operator>(</operator><name>FuncDef</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><call><name>GLOBAL</name><argument_list>(<argument><expr><name>FuncDef</name></expr></argument>, <argument><expr><name>aBuiltinFunc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>ArraySize</name><argument_list>(<argument><expr><name>aBuiltinFunc</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3FuncDefInsert</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3RegisterDateTimeFunctions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_ALTERTABLE</name></cpp:ifndef>
  <expr_stmt><expr><call><name>sqlite3AlterFunctions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_STAT3</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_STAT4</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><call><name>sqlite3AnalyzeFunctions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
</unit>
