<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/ext/misc/regexp.c"><comment type="block">/*
** 2012-11-13
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** The code in this file implements a compact but reasonably
** efficient regular-expression matcher for posix extended regular
** expressions against UTF8 text.
**
** This file is an SQLite extension.  It registers a single function
** named "regexp(A,B)" where A is the regular expression and B is the
** string to be matched.  By registering this function, SQLite will also
** then implement the "B regexp A" operator.  Note that with the function
** the regular expression comes first, but with the operator it comes
** second.
**
**  The following regular expression syntax is supported:
**
**     X*      zero or more occurrences of X
**     X+      one or more occurrences of X
**     X?      zero or one occurrences of X
**     X{p,q}  between p and q occurrences of X
**     (X)     match X
**     X|Y     X or Y
**     ^X      X occurring at the beginning of the string
**     X$      X occurring at the end of the string
**     .       Match any single character
**     \c      Character c where c is one of \{}()[]|*+?.
**     \c      C-language escapes for c in afnrtv.  ex: \t or \n
**     \uXXXX  Where XXXX is exactly 4 hex digits, unicode value XXXX
**     \xXX    Where XX is exactly 2 hex digits, unicode value XX
**     [abc]   Any single character from the set abc
**     [^abc]  Any single character not in the set abc
**     [a-z]   Any single character in the range a-z
**     [^a-z]  Any single character not in the range a-z
**     \b      Word boundary
**     \w      Word character.  [A-Za-z0-9_]
**     \W      Non-word character
**     \d      Digit
**     \D      Non-digit
**     \s      Whitespace character
**     \S      Non-whitespace character
**
** A nondeterministic finite automaton (NFA) is used for matching, so the
** performance is bounded by O(N*M) where N is the size of the regular
** expression and M is the size of the input string.  The matcher never
** exhibits exponential behavior.  Note that the X{p,q} operator expands
** to p copies of X following by q-p copies of X? and that the size of the
** regular expression in the O(N*M) performance bound is computed after
** this expansion.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3ext.h"</cpp:file></cpp:include>
<macro><name>SQLITE_EXTENSION_INIT1</name></macro>

<comment type="block">/*
** The following #defines change the names of some functions implemented in
** this file to prevent name collisions with C-library functions of the
** same name.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>re_match</name></cpp:macro>   <cpp:value>sqlite3re_match</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>re_compile</name></cpp:macro> <cpp:value>sqlite3re_compile</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>re_free</name></cpp:macro>    <cpp:value>sqlite3re_free</cpp:value></cpp:define>

<comment type="block">/* The end-of-input character */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_EOF</name></cpp:macro>            <cpp:value>0</cpp:value></cpp:define>    <comment type="block">/* End of input */</comment>

<comment type="block">/* The NFA is implemented as sequence of opcodes taken from the following
** set.  Each opcode has a single integer argument.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_MATCH</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>    <comment type="block">/* Match the one character in the argument */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_ANY</name></cpp:macro>         <cpp:value>2</cpp:value></cpp:define>    <comment type="block">/* Match any one character.  (Implements ".") */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_ANYSTAR</name></cpp:macro>     <cpp:value>3</cpp:value></cpp:define>    <comment type="block">/* Special optimized version of .* */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_FORK</name></cpp:macro>        <cpp:value>4</cpp:value></cpp:define>    <comment type="block">/* Continue to both next and opcode at iArg */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_GOTO</name></cpp:macro>        <cpp:value>5</cpp:value></cpp:define>    <comment type="block">/* Jump to opcode at iArg */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_ACCEPT</name></cpp:macro>      <cpp:value>6</cpp:value></cpp:define>    <comment type="block">/* Halt and indicate a successful match */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_CC_INC</name></cpp:macro>      <cpp:value>7</cpp:value></cpp:define>    <comment type="block">/* Beginning of a [...] character class */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_CC_EXC</name></cpp:macro>      <cpp:value>8</cpp:value></cpp:define>    <comment type="block">/* Beginning of a [^...] character class */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_CC_VALUE</name></cpp:macro>    <cpp:value>9</cpp:value></cpp:define>    <comment type="block">/* Single value in a character class */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_CC_RANGE</name></cpp:macro>   <cpp:value>10</cpp:value></cpp:define>    <comment type="block">/* Range of values in a character class */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_WORD</name></cpp:macro>       <cpp:value>11</cpp:value></cpp:define>    <comment type="block">/* Perl word character [A-Za-z0-9_] */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_NOTWORD</name></cpp:macro>    <cpp:value>12</cpp:value></cpp:define>    <comment type="block">/* Not a perl word character */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_DIGIT</name></cpp:macro>      <cpp:value>13</cpp:value></cpp:define>    <comment type="block">/* digit:  [0-9] */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_NOTDIGIT</name></cpp:macro>   <cpp:value>14</cpp:value></cpp:define>    <comment type="block">/* Not a digit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_SPACE</name></cpp:macro>      <cpp:value>15</cpp:value></cpp:define>    <comment type="block">/* space:  [ \t\n\r\v\f] */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_NOTSPACE</name></cpp:macro>   <cpp:value>16</cpp:value></cpp:define>    <comment type="block">/* Not a digit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_OP_BOUNDARY</name></cpp:macro>   <cpp:value>17</cpp:value></cpp:define>    <comment type="block">/* Boundary between word and non-word */</comment>

<comment type="block">/* Each opcode is a "state" in the NFA */</comment>
<typedef>typedef <type><name>unsigned</name> <name>short</name></type> <name>ReStateNumber</name>;</typedef>

<comment type="block">/* Because this is an NFA and not a DFA, multiple states can be active at
** once.  An instance of the following object records all active states in
** the NFA.  The implementation is optimized for the common case where the
** number of actives states is small.
*/</comment>
<typedef>typedef <type><struct>struct <name>ReStateSet</name> <block>{
  <decl_stmt><decl><type><name>unsigned</name></type> <name>nState</name></decl>;</decl_stmt>            <comment type="block">/* Number of current states */</comment>
  <decl_stmt><decl><type><name>ReStateNumber</name> <modifier>*</modifier></type><name>aState</name></decl>;</decl_stmt>      <comment type="block">/* Current states */</comment>
}</block></struct></type> <name>ReStateSet</name>;</typedef>

<comment type="block">/* An input string read one character at a time.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ReInput</name></name></type> <name>ReInput</name>;</typedef>
<struct>struct <name>ReInput</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>  <comment type="block">/* All text */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>                   <comment type="block">/* Next byte to read */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mx</name></decl>;</decl_stmt>                  <comment type="block">/* EOF when i&gt;=mx */</comment>
}</block>;</struct>

<comment type="block">/* A compiled NFA (or an NFA that is in the process of being compiled) is
** an instance of the following object.
*/</comment>
<typedef>typedef <type><name><name>struct</name> <name>ReCompiled</name></name></type> <name>ReCompiled</name>;</typedef>
<struct>struct <name>ReCompiled</name> <block>{
  <decl_stmt><decl><type><name>ReInput</name></type> <name>sIn</name></decl>;</decl_stmt>                <comment type="block">/* Regular expression text */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>           <comment type="block">/* Error message to return */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aOp</name></decl>;</decl_stmt>                  <comment type="block">/* Operators for the virtual machine */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aArg</name></decl>;</decl_stmt>                  <comment type="block">/* Arguments to each operator */</comment>
  <function_decl><type><name>unsigned</name></type> (<modifier>*</modifier><name>xNextChar</name>)<parameter_list>(<parameter><decl><type><name>ReInput</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>  <comment type="block">/* Next character function */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zInit</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* Initial text to match */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nInit</name></decl>;</decl_stmt>                  <comment type="block">/* Number of characters in zInit */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>nState</name></decl>;</decl_stmt>            <comment type="block">/* Number of entries in aOp[] and aArg[] */</comment>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>nAlloc</name></decl>;</decl_stmt>            <comment type="block">/* Slots allocated for aOp[] and aArg[] */</comment>
}</block>;</struct>

<comment type="block">/* Add a state to the given state set if it is not already there */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>re_add_state</name><parameter_list>(<parameter><decl><type><name>ReStateSet</name> <modifier>*</modifier></type><name>pSet</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newState</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSet</name><operator>-&gt;</operator><name>nState</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <if_stmt><if>if<condition>( <expr><name><name>pSet</name><operator>-&gt;</operator><name>aState</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>newState</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt></block_content></block></for>
  <expr_stmt><expr><name><name>pSet</name><operator>-&gt;</operator><name>aState</name><index>[<expr><name><name>pSet</name><operator>-&gt;</operator><name>nState</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>newState</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Extract the next unicode character from *pzIn and return it.  Advance
** *pzIn to the first byte past the end of the character returned.  To
** be clear:  this routine converts utf8 to unicode.  This routine is 
** optimized for the common case where the next character is a single byte.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>re_next_char</name><parameter_list>(<parameter><decl><type><name>ReInput</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>c</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>mx</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0xe0</literal><operator>)</operator><operator>==</operator><literal type="number">0xc0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>mx</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0x1f</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">6</literal> <operator>|</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>++</operator></expr>]</index></name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>&lt;</operator><literal type="number">0x80</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0xfffd</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0xf0</literal><operator>)</operator><operator>==</operator><literal type="number">0xe0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">1</literal><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>mx</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal>
           <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0x0f</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">12</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">6</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>&lt;=</operator><literal type="number">0x3ff</literal> <operator>||</operator> <operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="number">0xd800</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="number">0xdfff</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0xfffd</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0xf8</literal><operator>)</operator><operator>==</operator><literal type="number">0xf0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">3</literal><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>mx</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal>
           <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0xc0</literal><operator>)</operator><operator>==</operator><literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0x07</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">18</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">12</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">6</literal><operator>)</operator>
                       <operator>|</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>&lt;=</operator><literal type="number">0xffff</literal> <operator>||</operator> <name>c</name><operator>&gt;</operator><literal type="number">0x10ffff</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0xfffd</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0xfffd</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>re_next_char_nocase</name><parameter_list>(<parameter><decl><type><name>ReInput</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>c</name> <init>= <expr><call><name>re_next_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'Z'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>+=</operator> <literal type="char">'a'</literal> <operator>-</operator> <literal type="char">'A'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return true if c is a perl "word" character:  [A-Za-z0-9_] */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>re_word_char</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'z'</literal><operator>)</operator>
      <operator>||</operator> <operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'Z'</literal><operator>)</operator> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'_'</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return true if c is a "digit" character:  [0-9] */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>re_digit_char</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return true if c is a perl "space" character:  [ \t\r\n\v\f] */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>re_space_char</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>c</name><operator>==</operator><literal type="char">' '</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\t'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\n'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\r'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\v'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\f'</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Run a compiled regular expression on the zero-terminated input
** string zIn[].  Return true on a match and false if there is no match.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>re_match</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>pRe</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ReStateSet</name></type> <name><name>aStateSet</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pThis</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ReStateNumber</name></type> <name><name>aSpace</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ReStateNumber</name> <modifier>*</modifier></type><name>pToFree</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>iSwap</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name>RE_EOF</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>cPrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ReInput</name></type> <name>in</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>in</name><operator>.</operator><name>z</name></name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>in</name><operator>.</operator><name>i</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>in</name><operator>.</operator><name>mx</name></name> <operator>=</operator> <ternary><condition><expr><name>nIn</name><operator>&gt;=</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>nIn</name></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <specifier>const</specifier><operator>*</operator><operator>)</operator><name>zIn</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

  <comment type="block">/* Look for the initial prefix match, if there is one. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>nInit</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>x</name> <init>= <expr><name><name>pRe</name><operator>-&gt;</operator><name>zInit</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><name><name>in</name><operator>.</operator><name>i</name></name><operator>+</operator><name><name>pRe</name><operator>-&gt;</operator><name>nInit</name></name><operator>&lt;=</operator><name><name>in</name><operator>.</operator><name>mx</name></name> 
     <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zIn</name><index>[<expr><name><name>in</name><operator>.</operator><name>i</name></name></expr>]</index></name><operator>!=</operator><name>x</name> <operator>||</operator>
         <call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>zIn</name><operator>+</operator><name><name>in</name><operator>.</operator><name>i</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>pRe</name><operator>-&gt;</operator><name>zInit</name></name></expr></argument>, <argument><expr><name><name>pRe</name><operator>-&gt;</operator><name>nInit</name></name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>in</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name><name>in</name><operator>.</operator><name>i</name></name><operator>+</operator><name><name>pRe</name><operator>-&gt;</operator><name>nInit</name></name><operator>&gt;</operator><name><name>in</name><operator>.</operator><name>mx</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>nState</name></name><operator>&lt;=</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aSpace</name></expr></argument>)</argument_list></sizeof><operator>/</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aSpace</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pToFree</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>aStateSet</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>aState</name> <operator>=</operator> <name>aSpace</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pToFree</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ReStateNumber</name></expr></argument>)</argument_list></sizeof><operator>*</operator><literal type="number">2</literal><operator>*</operator><name><name>pRe</name><operator>-&gt;</operator><name>nState</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pToFree</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>aStateSet</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>aState</name> <operator>=</operator> <name>pToFree</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>aStateSet</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>aState</name> <operator>=</operator> <operator>&amp;</operator><name><name>aStateSet</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>aState</name><index>[<expr><name><name>pRe</name><operator>-&gt;</operator><name>nState</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNext</name> <operator>=</operator> <operator>&amp;</operator><name><name>aStateSet</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pNext</name><operator>-&gt;</operator><name>nState</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>c</name><operator>!=</operator><name>RE_EOF</name> <operator>&amp;&amp;</operator> <name><name>pNext</name><operator>-&gt;</operator><name>nState</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>cPrev</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name><name>pRe</name><operator>-&gt;</operator><name>xNextChar</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pThis</name> <operator>=</operator> <name>pNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNext</name> <operator>=</operator> <operator>&amp;</operator><name><name>aStateSet</name><index>[<expr><name>iSwap</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iSwap</name> <operator>=</operator> <literal type="number">1</literal> <operator>-</operator> <name>iSwap</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pNext</name><operator>-&gt;</operator><name>nState</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pThis</name><operator>-&gt;</operator><name>nState</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name><name>pThis</name><operator>-&gt;</operator><name>aState</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <switch>switch<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>x</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <case>case <expr><name>RE_OP_MATCH</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>x</name></expr>]</index></name><operator>==</operator><name>c</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_ANY</name></expr>:</case> <block>{<block_content>
          <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_WORD</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>re_word_char</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_NOTWORD</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>re_word_char</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_DIGIT</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>re_digit_char</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_NOTDIGIT</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>re_digit_char</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_SPACE</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>re_space_char</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_NOTSPACE</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>re_space_char</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_BOUNDARY</name></expr>:</case> <block>{<block_content>
          <if_stmt><if>if<condition>( <expr><call><name>re_word_char</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>!=</operator><call><name>re_word_char</name><argument_list>(<argument><expr><name>cPrev</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pThis</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_ANYSTAR</name></expr>:</case> <block>{<block_content>
          <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pThis</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_FORK</name></expr>:</case> <block>{<block_content>
          <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pThis</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><name><name>pRe</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>x</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pThis</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_GOTO</name></expr>:</case> <block>{<block_content>
          <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pThis</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><name><name>pRe</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>x</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_ACCEPT</name></expr>:</case> <block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <goto>goto <name>re_match_end</name>;</goto>
        </block_content>}</block>
        <case>case <expr><name>RE_OP_CC_INC</name></expr>:</case>
        <case>case <expr><name>RE_OP_CC_EXC</name></expr>:</case> <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>pRe</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>x</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>hit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>j</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>x</name><operator>+</operator><name>j</name></expr>]</index></name><operator>==</operator><name>RE_OP_CC_VALUE</name></expr> )</condition><block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>x</name><operator>+</operator><name>j</name></expr>]</index></name><operator>==</operator><name>c</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>hit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>j</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>x</name><operator>+</operator><name>j</name></expr>]</index></name><operator>&lt;=</operator><name>c</name> <operator>&amp;&amp;</operator> <name><name>pRe</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>x</name><operator>+</operator><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>&gt;=</operator><name>c</name></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>hit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>j</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
              </block_content>}</block></if><else>else<block>{<block_content>
                <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></for>
          <if_stmt><if>if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>x</name></expr>]</index></name><operator>==</operator><name>RE_OP_CC_EXC</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hit</name> <operator>=</operator> <operator>!</operator><name>hit</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>hit</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_add_state</name><argument_list>(<argument><expr><name>pNext</name></expr></argument>, <argument><expr><name>x</name><operator>+</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>            
        </block_content>}</block>
      </block_content>}</block></switch>
    </block_content>}</block></for>
  </block_content>}</block></while>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pNext</name><operator>-&gt;</operator><name>nState</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name><name>pNext</name><operator>-&gt;</operator><name>aState</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>==</operator><name>RE_OP_ACCEPT</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
<label><name>re_match_end</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pToFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Resize the opcode and argument arrays for an RE under construction.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>re_resize</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aOp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>aArg</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>aOp</name> <operator>=</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name></expr></argument>, <argument><expr><name>N</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aOp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name></name> <operator>=</operator> <name>aOp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aArg</name> <operator>=</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aArg</name></name></expr></argument>, <argument><expr><name>N</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aArg</name></name> <operator>=</operator> <name>aArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name>N</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Insert a new opcode and argument into an RE under construction.  The
** insertion point is just prior to existing opcode iBefore.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>re_insert</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iBefore</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>&lt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nState</name></name> <operator>&amp;&amp;</operator> <call><name>re_resize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name><name>p</name><operator>-&gt;</operator><name>nState</name></name></expr>;</init> <condition><expr><name>i</name><operator>&gt;</operator><name>iBefore</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nState</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>iBefore</name></expr>]</index></name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>iBefore</name></expr>]</index></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
  <return>return <expr><name>iBefore</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Append a new opcode and argument to the end of the RE under construction.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>re_append</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>re_insert</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nState</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Make a copy of N opcodes starting at iStart onto the end of the RE
** under construction.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>re_copy</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iStart</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nState</name></name><operator>+</operator><name>N</name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>&amp;&amp;</operator> <call><name>re_resize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>*</operator><literal type="number">2</literal><operator>+</operator><name>N</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nState</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>iStart</name></expr>]</index></name></expr></argument>, <argument><expr><name>N</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nState</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>iStart</name></expr>]</index></name></expr></argument>, <argument><expr><name>N</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nState</name></name> <operator>+=</operator> <name>N</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Return true if c is a hexadecimal digit character:  [0-9a-fA-F]
** If c is a hex digit, also set *pV = (*pV)*16 + valueof(c).  If
** c is not a hex digit *pV is unchanged.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>re_hex</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pV</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>-=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'f'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>-=</operator> <literal type="char">'a'</literal> <operator>-</operator> <literal type="number">10</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'F'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>-=</operator> <literal type="char">'A'</literal> <operator>-</operator> <literal type="number">10</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pV</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>pV</name><operator>)</operator><operator>*</operator><literal type="number">16</literal> <operator>+</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* A backslash character has been seen, read the next character and
** return its interpretation.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>re_esc_char</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>zEsc</name><index>[]</index></name> <init>= <expr><literal type="string">"afnrtv\\()*.+?[$^{|}]"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>zTrans</name><index>[]</index></name> <init>= <expr><literal type="string">"\a\f\n\r\t\v"</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>mx</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'u'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>+</operator><literal type="number">4</literal><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>mx</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>z</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>re_hex</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <call><name>re_hex</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <call><name>re_hex</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <call><name>re_hex</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
      <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'x'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>+</operator><literal type="number">2</literal><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>mx</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zIn</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>z</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>re_hex</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call>
     <operator>&amp;&amp;</operator> <call><name>re_hex</name><argument_list>(<argument><expr><name><name>zIn</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zEsc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>zEsc</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name>c</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>zEsc</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">6</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zTrans</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zErr</name></name> <operator>=</operator> <literal type="string">"unknown \\ escape"</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Forward declaration */</comment>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>re_subcompile_string</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Peek at the next byte of input */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>rePeek</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>mx</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>z</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compile RE text into a sequence of opcodes.  Continue up to the
** first unmatched ")" character, then return.  If an error is found,
** return a pointer to the error message string.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>re_subcompile_re</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iStart</name></decl>, <decl><type ref="prev"/><name>iEnd</name></decl>, <decl><type ref="prev"/><name>iGoto</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>iStart</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nState</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>re_subcompile_string</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zErr</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>zErr</name></expr>;</return></block_content></block></if></if_stmt>
  <while>while<condition>( <expr><call><name>rePeek</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="char">'|'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iEnd</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nState</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>re_insert</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iStart</name></expr></argument>, <argument><expr><name>RE_OP_FORK</name></expr></argument>, <argument><expr><name>iEnd</name> <operator>+</operator> <literal type="number">2</literal> <operator>-</operator> <name>iStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iGoto</name> <operator>=</operator> <call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_GOTO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>re_subcompile_string</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zErr</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>zErr</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>iGoto</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nState</name></name> <operator>-</operator> <name>iGoto</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compile an element of regular expression text (anything that can be
** an operand to the "|" operator).  Return NULL on success or a pointer
** to the error message if there is a problem.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>re_subcompile_string</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iPrev</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iStart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name><name>p</name><operator>-&gt;</operator><name>xNextChar</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sIn</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iStart</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nState</name></name></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name>c</name></expr> )</condition><block>{<block_content>
      <case>case <expr><literal type="char">'|'</literal></expr>:</case>
      <case>case <expr><literal type="char">'$'</literal></expr>:</case> 
      <case>case <expr><literal type="char">')'</literal></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>--</operator></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block>
      <case>case <expr><literal type="char">'('</literal></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>re_subcompile_re</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zErr</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>zErr</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>rePeek</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="char">')'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"unmatched '('"</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'.'</literal></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>rePeek</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="char">'*'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_ANYSTAR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content> 
          <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_ANY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'*'</literal></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iPrev</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"'*' without operand"</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>re_insert</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iPrev</name></expr></argument>, <argument><expr><name>RE_OP_GOTO</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nState</name></name> <operator>-</operator> <name>iPrev</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_FORK</name></expr></argument>, <argument><expr><name>iPrev</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nState</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'+'</literal></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iPrev</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"'+' without operand"</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_FORK</name></expr></argument>, <argument><expr><name>iPrev</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>nState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'?'</literal></expr>:</case> <block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iPrev</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"'?' without operand"</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>re_insert</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iPrev</name></expr></argument>, <argument><expr><name>RE_OP_FORK</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nState</name></name> <operator>-</operator> <name>iPrev</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'{'</literal></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>m</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>iPrev</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"'{m,n}' without operand"</literal></expr>;</return></block_content></block></if></if_stmt>
        <while>while<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator><call><name>rePeek</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>m</name> <operator>=</operator> <name>m</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">','</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <while>while<condition>( <expr><operator>(</operator><name>c</name><operator>=</operator><call><name>rePeek</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <name>n</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name>c</name><operator>-</operator><literal type="char">'0'</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><literal type="char">'}'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"unmatched '{'"</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name><operator>&lt;</operator><name>m</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"n less than m in '{m,n}'"</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>sz</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nState</name></name> <operator>-</operator> <name>iPrev</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>m</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"both m and n are zero in '{m,n}'"</literal></expr>;</return></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>re_insert</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iPrev</name></expr></argument>, <argument><expr><name>RE_OP_FORK</name></expr></argument>, <argument><expr><name>sz</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>m</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>re_copy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iPrev</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></else></if_stmt>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>m</name></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_FORK</name></expr></argument>, <argument><expr><name>sz</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>re_copy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iPrev</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>m</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_FORK</name></expr></argument>, <argument><expr><operator>-</operator><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'['</literal></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>iFirst</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>nState</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><call><name>rePeek</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="char">'^'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_CC_EXC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_CC_INC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <while>while<condition>( <expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name><name>p</name><operator>-&gt;</operator><name>xNextChar</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sIn</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'['</literal> <operator>&amp;&amp;</operator> <call><name>rePeek</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="char">':'</literal></expr> )</condition><block>{<block_content>
            <return>return <expr><literal type="string">"POSIX character classes not supported"</literal></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\\'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>re_esc_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>rePeek</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_CC_RANGE</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name><name>p</name><operator>-&gt;</operator><name>xNextChar</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sIn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\\'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>re_esc_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_CC_RANGE</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_CC_VALUE</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>rePeek</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="char">']'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"unclosed '['"</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>iFirst</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nState</name></name> <operator>-</operator> <name>iFirst</name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'\\'</literal></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>specialOp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <switch>switch<condition>( <expr><call><name>rePeek</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <case>case <expr><literal type="char">'b'</literal></expr>:</case> <expr_stmt><expr><name>specialOp</name> <operator>=</operator> <name>RE_OP_BOUNDARY</name></expr>;</expr_stmt>   <break>break;</break>
          <case>case <expr><literal type="char">'d'</literal></expr>:</case> <expr_stmt><expr><name>specialOp</name> <operator>=</operator> <name>RE_OP_DIGIT</name></expr>;</expr_stmt>      <break>break;</break>
          <case>case <expr><literal type="char">'D'</literal></expr>:</case> <expr_stmt><expr><name>specialOp</name> <operator>=</operator> <name>RE_OP_NOTDIGIT</name></expr>;</expr_stmt>   <break>break;</break>
          <case>case <expr><literal type="char">'s'</literal></expr>:</case> <expr_stmt><expr><name>specialOp</name> <operator>=</operator> <name>RE_OP_SPACE</name></expr>;</expr_stmt>      <break>break;</break>
          <case>case <expr><literal type="char">'S'</literal></expr>:</case> <expr_stmt><expr><name>specialOp</name> <operator>=</operator> <name>RE_OP_NOTSPACE</name></expr>;</expr_stmt>   <break>break;</break>
          <case>case <expr><literal type="char">'w'</literal></expr>:</case> <expr_stmt><expr><name>specialOp</name> <operator>=</operator> <name>RE_OP_WORD</name></expr>;</expr_stmt>       <break>break;</break>
          <case>case <expr><literal type="char">'W'</literal></expr>:</case> <expr_stmt><expr><name>specialOp</name> <operator>=</operator> <name>RE_OP_NOTWORD</name></expr>;</expr_stmt>    <break>break;</break>
        </block_content>}</block></switch>
        <if_stmt><if>if<condition>( <expr><name>specialOp</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>specialOp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>re_esc_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_MATCH</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <block>{<block_content>
        <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>RE_OP_MATCH</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
    <expr_stmt><expr><name>iPrev</name> <operator>=</operator> <name>iStart</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Free and reclaim all the memory used by a previously compiled
** regular expression.  Applications should invoke this routine once
** for every call to re_compile() to avoid memory leaks.
*/</comment>
<function><type><name>void</name></type> <name>re_free</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>pRe</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name>pRe</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pRe</name><operator>-&gt;</operator><name>aOp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pRe</name><operator>-&gt;</operator><name>aArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Compile a textual regular expression in zIn[] into a compiled regular
** expression suitable for us by re_match() and return a pointer to the
** compiled regular expression in *ppRe.  Return NULL on success or an
** error message if something goes wrong.
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>re_compile</name><parameter_list>(<parameter><decl><type><name>ReCompiled</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppRe</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>noCase</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>pRe</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppRe</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pRe</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pRe</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRe</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="string">"out of memory"</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pRe</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>xNextChar</name></name> <operator>=</operator> <ternary><condition><expr><name>noCase</name></expr> ?</condition><then> <expr><name>re_next_char_nocase</name></expr> </then><else>: <expr><name>re_next_char</name></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>re_resize</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>, <argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>re_free</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="string">"out of memory"</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zIn</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'^'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zIn</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>, <argument><expr><name>RE_OP_ANYSTAR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>z</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>zIn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>mx</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>re_subcompile_re</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zErr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>re_free</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>zErr</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>rePeek</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="char">'$'</literal> <operator>&amp;&amp;</operator> <name><name>pRe</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>+</operator><literal type="number">1</literal><operator>&gt;=</operator><name><name>pRe</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>mx</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>, <argument><expr><name>RE_OP_MATCH</name></expr></argument>, <argument><expr><name>RE_EOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>, <argument><expr><name>RE_OP_ACCEPT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppRe</name> <operator>=</operator> <name>pRe</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>i</name></name><operator>&gt;=</operator><name><name>pRe</name><operator>-&gt;</operator><name>sIn</name><operator>.</operator><name>mx</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>re_append</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>, <argument><expr><name>RE_OP_ACCEPT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppRe</name> <operator>=</operator> <name>pRe</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>re_free</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="string">"unrecognized character"</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* The following is a performance optimization.  If the regex begins with
  ** ".*" (if the input regex lacks an initial "^") and afterwards there are
  ** one or more matching characters, enter those matching characters into
  ** zInit[].  The re_match() routine can then search ahead in the input 
  ** string looking for the initial match without having to run the whole
  ** regex engine over the string.  Do not worry able trying to match
  ** unicode characters beyond plane 0 - those are very rare and this is
  ** just an optimization. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pRe</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name>RE_OP_ANYSTAR</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>pRe</name><operator>-&gt;</operator><name>zInit</name></name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>pRe</name><operator>-&gt;</operator><name>aOp</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>RE_OP_MATCH</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>unsigned</name></type> <name>x</name> <init>= <expr><name><name>pRe</name><operator>-&gt;</operator><name>aArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;=</operator><literal type="number">127</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>zInit</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>x</name><operator>&lt;=</operator><literal type="number">0xfff</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>zInit</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0xc0</literal> <operator>|</operator> <operator>(</operator><name>x</name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>zInit</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>x</name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>x</name><operator>&lt;=</operator><literal type="number">0xffff</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>zInit</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0xd0</literal> <operator>|</operator> <operator>(</operator><name>x</name><operator>&gt;&gt;</operator><literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>zInit</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>zInit</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>x</name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <break>break;</break>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pRe</name><operator>-&gt;</operator><name>zInit</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pRe</name><operator>-&gt;</operator><name>nInit</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>pRe</name><operator>-&gt;</operator><name>zErr</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the regexp() SQL function.  This function implements
** the build-in REGEXP operator.  The first argument to the function is the
** pattern and the second argument is the string.  So, the SQL statements:
**
**       A REGEXP B
**
** is implemented as regexp(B,A).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>re_sql_func</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, 
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, 
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>ReCompiled</name> <modifier>*</modifier></type><name>pRe</name></decl>;</decl_stmt>          <comment type="block">/* Compiled regular expression */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPattern</name></decl>;</decl_stmt>     <comment type="block">/* The regular expression */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zStr</name></decl>;</decl_stmt><comment type="block">/* String being searched */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name></decl>;</decl_stmt>         <comment type="block">/* Compile error message */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>setAux</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>           <comment type="block">/* True to invoke sqlite3_set_auxdata() */</comment>

  <expr_stmt><expr><name>pRe</name> <operator>=</operator> <call><name>sqlite3_get_auxdata</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pRe</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zPattern</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zPattern</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zErr</name> <operator>=</operator> <call><name>re_compile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pRe</name></expr></argument>, <argument><expr><name>zPattern</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zErr</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>re_free</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>zErr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pRe</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>setAux</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zStr</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zStr</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>re_match</name><argument_list>(<argument><expr><name>pRe</name></expr></argument>, <argument><expr><name>zStr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>setAux</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_set_auxdata</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pRe</name></expr></argument>, <argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>re_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Invoke this routine to register the regexp() function with the
** SQLite database connection.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_regexp_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"regexp"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                 <argument><expr><name>re_sql_func</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
</unit>
