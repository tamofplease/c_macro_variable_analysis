<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/ext/misc/json1.c"><comment type="block">/*
** 2015-08-12
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This SQLite extension implements JSON functions.  The interface is
** modeled after MySQL JSON functions:
**
**     https://dev.mysql.com/doc/refman/5.7/en/json.html
**
** For the time being, all JSON is stored as pure text.  (We might add
** a JSONB type in the future which stores a binary encoding of JSON in
** a BLOB, but there is no support for JSONB in the current implementation.
** This implementation parses JSON text at 250 MB/s, so it is hard to see
** how JSONB might improve on that.)
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_CORE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_JSON1</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_SQLITEINT_H_</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3ext.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>SQLITE_EXTENSION_INIT1</name>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>

<comment type="block">/* Mark a function parameter as unused, to suppress nuisance compiler
** warnings. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UNUSED_PARAM</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>UNUSED_PARAM</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(void)(X)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LARGEST_INT64</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>LARGEST_INT64</name></cpp:macro>  <cpp:value>(0xffffffff|(((sqlite3_int64)0x7fffffff)&lt;&lt;32))</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SMALLEST_INT64</name></cpp:macro> <cpp:value>(((sqlite3_int64)-1) - LARGEST_INT64)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Versions of isspace(), isalnum() and isdigit() to which it is safe
** to pass signed char values.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>sqlite3Isdigit</name></cpp:ifdef>
   <comment type="block">/* Use the SQLite core versions if this routine is part of the
   ** SQLite amalgamation */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>safe_isdigit</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sqlite3Isdigit(x)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>safe_isalnum</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sqlite3Isalnum(x)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
   <comment type="block">/* Use the standard library for separate compilation */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>  <comment type="block">/* amalgamator: keep */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>safe_isdigit</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>isdigit((unsigned char)(x))</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>safe_isalnum</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>isalnum((unsigned char)(x))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Growing our own isspace() routine this way is twice as fast as
** the library isspace() function, resulting in a 7% overall performance
** increase for the parser.  (Ubuntu14.10 gcc 4.8.4 x64 with -Os).
*/</comment>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>jsonIsSpace</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,     <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>safe_isspace</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(jsonIsSpace[(unsigned char)x])</cpp:value></cpp:define>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_AMALGAMATION</name></cpp:ifndef>
  <comment type="block">/* Unsigned integer types.  These are already defined in the sqliteInt.h,
  ** but the definitions need to be repeated for separate compilation. */</comment>
  <typedef>typedef <type><name>sqlite3_uint64</name></type> <name>u64</name>;</typedef>
  <typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>u32</name>;</typedef>
  <typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>u8</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Objects */</comment>
<typedef>typedef <type><name><name>struct</name> <name>JsonString</name></name></type> <name>JsonString</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>JsonNode</name></name></type> <name>JsonNode</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>JsonParse</name></name></type> <name>JsonParse</name>;</typedef>

<comment type="block">/* An instance of this object represents a JSON string
** under construction.  Really, this is a generic string accumulator
** that can be and is used to create strings other than JSON.
*/</comment>
<struct>struct <name>JsonString</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl>;</decl_stmt>   <comment type="block">/* Function context - put error messages here */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zBuf</name></decl>;</decl_stmt>              <comment type="block">/* Append JSON content here */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>nAlloc</name></decl>;</decl_stmt>              <comment type="block">/* Bytes of storage available in zBuf[] */</comment>
  <decl_stmt><decl><type><name>u64</name></type> <name>nUsed</name></decl>;</decl_stmt>               <comment type="block">/* Bytes of zBuf[] currently used */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bStatic</name></decl>;</decl_stmt>              <comment type="block">/* True if zBuf is static space */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bErr</name></decl>;</decl_stmt>                 <comment type="block">/* True if an error has been encountered */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zSpace</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>        <comment type="block">/* Initial static space */</comment>
}</block>;</struct>

<comment type="block">/* JSON type values
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_NULL</name></cpp:macro>     <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_TRUE</name></cpp:macro>     <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_FALSE</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_INT</name></cpp:macro>      <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_REAL</name></cpp:macro>     <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_STRING</name></cpp:macro>   <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_ARRAY</name></cpp:macro>    <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_OBJECT</name></cpp:macro>   <cpp:value>7</cpp:value></cpp:define>

<comment type="block">/* The "subtype" set for JSON values */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_SUBTYPE</name></cpp:macro>  <cpp:value>74</cpp:value></cpp:define>    <comment type="block">/* Ascii for "J" */</comment>

<comment type="block">/*
** Names of the various JSON types:
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>jsonType</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="string">"null"</literal></expr>, <expr><literal type="string">"true"</literal></expr>, <expr><literal type="string">"false"</literal></expr>, <expr><literal type="string">"integer"</literal></expr>, <expr><literal type="string">"real"</literal></expr>, <expr><literal type="string">"text"</literal></expr>, <expr><literal type="string">"array"</literal></expr>, <expr><literal type="string">"object"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Bit values for the JsonNode.jnFlag field
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JNODE_RAW</name></cpp:macro>     <cpp:value>0x01</cpp:value></cpp:define>         <comment type="block">/* Content is raw, not JSON encoded */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JNODE_ESCAPE</name></cpp:macro>  <cpp:value>0x02</cpp:value></cpp:define>         <comment type="block">/* Content is text with \ escapes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JNODE_REMOVE</name></cpp:macro>  <cpp:value>0x04</cpp:value></cpp:define>         <comment type="block">/* Do not output */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JNODE_REPLACE</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define>         <comment type="block">/* Replace with JsonNode.iVal */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JNODE_APPEND</name></cpp:macro>  <cpp:value>0x10</cpp:value></cpp:define>         <comment type="block">/* More ARRAY/OBJECT entries at u.iAppend */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JNODE_LABEL</name></cpp:macro>   <cpp:value>0x20</cpp:value></cpp:define>         <comment type="block">/* Is a label of an object */</comment>


<comment type="block">/* A single node of parsed JSON
*/</comment>
<struct>struct <name>JsonNode</name> <block>{
  <decl_stmt><decl><type><name>u8</name></type> <name>eType</name></decl>;</decl_stmt>              <comment type="block">/* One of the JSON_ type values */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>jnFlags</name></decl>;</decl_stmt>            <comment type="block">/* JNODE flags */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>iVal</name></decl>;</decl_stmt>               <comment type="block">/* Replacement value when JNODE_REPLACE */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>n</name></decl>;</decl_stmt>                 <comment type="block">/* Bytes of content, or number of sub-nodes */</comment>
  <union>union <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zJContent</name></decl>;</decl_stmt> <comment type="block">/* Content for INT, REAL, and STRING */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>iAppend</name></decl>;</decl_stmt>           <comment type="block">/* More terms for ARRAY and OBJECT */</comment>
    <decl_stmt><decl><type><name>u32</name></type> <name>iKey</name></decl>;</decl_stmt>              <comment type="block">/* Key for ARRAY objects in json_tree() */</comment>
  }</block> <decl><name>u</name></decl>;</union>
}</block>;</struct>

<comment type="block">/* A completely parsed JSON string
*/</comment>
<struct>struct <name>JsonParse</name> <block>{
  <decl_stmt><decl><type><name>u32</name></type> <name>nNode</name></decl>;</decl_stmt>         <comment type="block">/* Number of slots of aNode[] used */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>nAlloc</name></decl>;</decl_stmt>        <comment type="block">/* Number of slots of aNode[] allocated */</comment>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>aNode</name></decl>;</decl_stmt>   <comment type="block">/* Array of nodes containing the parse */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zJson</name></decl>;</decl_stmt> <comment type="block">/* Original JSON string */</comment>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aUp</name></decl>;</decl_stmt>          <comment type="block">/* Index of parent of each node */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>oom</name></decl>;</decl_stmt>            <comment type="block">/* Set to true if out of memory */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>nErr</name></decl>;</decl_stmt>           <comment type="block">/* Number of errors seen */</comment>
}</block>;</struct>

<comment type="block" format="doxygen">/**************************************************************************
** Utility routines for dealing with JsonString objects
**************************************************************************/</comment>

<comment type="block">/* Set the JsonString object to an empty string
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonZero</name><parameter_list>(<parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>zSpace</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSpace</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bStatic</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Initialize the JsonString object
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonInit</name><parameter_list>(<parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pCtx</name></name> <operator>=</operator> <name>pCtx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bErr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonZero</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Free all allocated memory and reset the JsonString object back to its
** initial state.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonReset</name><parameter_list>(<parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>bStatic</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>jsonZero</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Report an out-of-memory (OOM) condition 
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonOom</name><parameter_list>(<parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bErr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Enlarge pJson-&gt;zBuf so that it can hold at least N more bytes.
** Return zero on success.  Return non-zero on an OOM error
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonGrow</name><parameter_list>(<parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u64</name></type> <name>nTotal</name> <init>= <expr><ternary><condition><expr><name>N</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> ?</condition><then> <expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>*</operator><literal type="number">2</literal></expr> </then><else>: <expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>+</operator><name>N</name><operator>+</operator><literal type="number">10</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zNew</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bStatic</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bErr</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zNew</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>nTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>jsonOom</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zNew</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name> <operator>=</operator> <name>zNew</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bStatic</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>zNew</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><name>nTotal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>jsonOom</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name> <operator>=</operator> <name>zNew</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name>nTotal</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Append N bytes from zIn onto the end of the JsonString string.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonAppendRaw</name><parameter_list>(<parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>N</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>jsonGrow</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>N</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name></expr></argument>, <argument><expr><name>zIn</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>+=</operator> <name>N</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Append formatted text (not to exceed N bytes) to the JsonString.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonPrintf</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>N</name></decl></parameter>, <parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>+</operator> <name>N</name> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>jsonGrow</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_vsnprintf</name><argument_list>(<argument><expr><name>N</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name></expr></argument>, <argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Append a single character
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonAppendChar</name><parameter_list>(<parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>&amp;&amp;</operator> <call><name>jsonGrow</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Append a comma separator to the output buffer, if the previous
** character is not '[' or '{'.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonAppendSeparator</name><parameter_list>(<parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><literal type="char">'['</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>!=</operator><literal type="char">'{'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Append the N-byte string in zIn to the end of the JsonString string
** under construction.  Enclose the string in "..." and escape
** any double-quotes or backslash characters contained within the
** string.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonAppendString</name><parameter_list>(<parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>N</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>N</name><operator>+</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>+</operator><literal type="number">2</literal> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>jsonGrow</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>N</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>N</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><operator>(</operator><operator>(</operator><name>unsigned</name> <specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>zIn</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'"'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\\'</literal></expr> )</condition><block>{<block_content>
      <label><name>json_simple_escape</name>:</label>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>+</operator><name>N</name><operator>+</operator><literal type="number">3</literal><operator>-</operator><name>i</name> <operator>&gt;</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>jsonGrow</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>N</name><operator>+</operator><literal type="number">3</literal><operator>-</operator><name>i</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&lt;=</operator><literal type="number">0x1f</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>aSpecial</name><index>[]</index></name> <init>= <expr><block>{
         <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="char">'b'</literal></expr>, <expr><literal type="char">'t'</literal></expr>, <expr><literal type="char">'n'</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="char">'f'</literal></expr>, <expr><literal type="char">'r'</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
         <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>
      }</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>aSpecial</name></expr></argument>)</argument_list></sizeof><operator>==</operator><literal type="number">32</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aSpecial</name><index>[<expr><literal type="char">'\b'</literal></expr>]</index></name><operator>==</operator><literal type="char">'b'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aSpecial</name><index>[<expr><literal type="char">'\f'</literal></expr>]</index></name><operator>==</operator><literal type="char">'f'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aSpecial</name><index>[<expr><literal type="char">'\n'</literal></expr>]</index></name><operator>==</operator><literal type="char">'n'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aSpecial</name><index>[<expr><literal type="char">'\r'</literal></expr>]</index></name><operator>==</operator><literal type="char">'r'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aSpecial</name><index>[<expr><literal type="char">'\t'</literal></expr>]</index></name><operator>==</operator><literal type="char">'t'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>aSpecial</name><index>[<expr><name>c</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>aSpecial</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt>
        <goto>goto <name>json_simple_escape</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>+</operator><name>N</name><operator>+</operator><literal type="number">7</literal><operator>+</operator><name>i</name> <operator>&gt;</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>jsonGrow</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>N</name><operator>+</operator><literal type="number">7</literal><operator>-</operator><name>i</name></expr></argument>)</argument_list></call><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'u'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal> <operator>+</operator> <operator>(</operator><name>c</name><operator>&gt;&gt;</operator><literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="string">"0123456789abcdef"</literal><index>[<expr><name>c</name><operator>&amp;</operator><literal type="number">0xf</literal></expr>]</index></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Append a function parameter value to the JSON string under 
** construction.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonAppendValue</name><parameter_list>(
  <parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,                 <comment type="block">/* Append to this JSON string */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pValue</name></decl></parameter>          <comment type="block">/* Value to append */</comment>
)</parameter_list><block>{<block_content>
  <switch>switch<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_NULL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case>
    <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>u32</name><operator>)</operator><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_TEXT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>u32</name><operator>)</operator><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_subtype</name><argument_list>(<argument><expr><name>pValue</name></expr></argument>)</argument_list></call><operator>==</operator><name>JSON_SUBTYPE</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>jsonAppendString</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bErr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><literal type="string">"JSON cannot hold BLOB values"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bErr</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jsonReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/* Make the JSON in p the result of the SQL function.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonResult</name><parameter_list>(<parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bErr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text64</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pCtx</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nUsed</name></name></expr></argument>, 
                          <argument><expr><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>bStatic</name></name></expr> ?</condition><then> <expr><name>SQLITE_TRANSIENT</name></expr> </then><else>: <expr><name>sqlite3_free</name></expr></else></ternary></expr></argument>,
                          <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonZero</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>p</name><operator>-&gt;</operator><name>bStatic</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**************************************************************************
** Utility routines for dealing with JsonNode and JsonParse objects
**************************************************************************/</comment>

<comment type="block">/*
** Return the number of consecutive JsonNode slots need to represent
** the parsed JSON at pNode.  The minimum answer is 1.  For ARRAY and
** OBJECT types, the number might be larger.
**
** Appended elements are not counted.  The value returned is the number
** by which the JsonNode counter should increment in order to go to the
** next peer value.
*/</comment>
<function><type><specifier>static</specifier> <name>u32</name></type> <name>jsonNodeSize</name><parameter_list>(<parameter><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name><operator>&gt;=</operator><name>JSON_ARRAY</name></expr> ?</condition><then> <expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Reclaim all memory allocated by a JsonParse object.  But do not
** delete the JsonParse object itself.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonParseReset</name><parameter_list>(<parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aUp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aUp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Convert the JsonNode pNode into a pure JSON string and
** append to pOut.  Subsubstructure is also included.  Return
** the number of JsonNode objects that are encoded.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonRenderNode</name><parameter_list>(
  <parameter><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>,               <comment type="block">/* The node to render */</comment>
  <parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>,              <comment type="block">/* Write JSON here */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>aReplace</name></decl></parameter>       <comment type="block">/* Replacement values */</comment>
)</parameter_list><block>{<block_content>
  <switch>switch<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name></expr> )</condition><block>{<block_content>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_TRUE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_FALSE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_STRING</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_RAW</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>jsonAppendString</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* Fall through into the next case */</comment>
    </block_content>}</block>
    <case>case <expr><name>JSON_REAL</name></expr>:</case>
    <case>case <expr><name>JSON_INT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_ARRAY</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
        <while>while<condition>( <expr><name>j</name><operator>&lt;=</operator><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>pNode</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <operator>(</operator><name>JNODE_REMOVE</name><operator>|</operator><name>JNODE_REPLACE</name><operator>)</operator></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pNode</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_REPLACE</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>jsonAppendSeparator</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>jsonAppendValue</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>aReplace</name><index>[<expr><name><name>pNode</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>iVal</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>jsonAppendSeparator</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonRenderNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>aReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name>j</name> <operator>+=</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_APPEND</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNode</name><index>[<expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iAppend</name></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_OBJECT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>j</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
        <while>while<condition>( <expr><name>j</name><operator>&lt;=</operator><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNode</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_REMOVE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>jsonAppendSeparator</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonRenderNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>aReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name><name>pNode</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_REPLACE</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>jsonAppendValue</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name><name>aReplace</name><index>[<expr><name><name>pNode</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iVal</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <expr_stmt><expr><call><name>jsonRenderNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>aReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>j</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_APPEND</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>&amp;</operator><name><name>pNode</name><index>[<expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iAppend</name></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Return a JsonNode and all its descendents as a JSON string.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonReturnJson</name><parameter_list>(
  <parameter><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>,            <comment type="block">/* Node to return */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,      <comment type="block">/* Return value for this function */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>aReplace</name></decl></parameter>    <comment type="block">/* Array of replacement values */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonString</name></type> <name>s</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>jsonInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonRenderNode</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>aReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonResult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_subtype</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>JSON_SUBTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Make the JsonNode the return value of the function.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonReturn</name><parameter_list>(
  <parameter><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>,            <comment type="block">/* Node to return */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,      <comment type="block">/* Return value for this function */</comment>
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>aReplace</name></decl></parameter>    <comment type="block">/* Array of replacement values */</comment>
)</parameter_list><block>{<block_content>
  <switch>switch<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name></expr> )</condition><block>{<block_content>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_null</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_TRUE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_FALSE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_INT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <while>while<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name></type> <name>v</name> <init>= <expr><operator>*</operator><operator>(</operator><name>z</name><operator>++</operator><operator>)</operator> <operator>-</operator> <literal type="char">'0'</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;=</operator><name>LARGEST_INT64</name><operator>/</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><name>LARGEST_INT64</name><operator>/</operator><literal type="number">10</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>int_as_real</name>;</goto></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>int_as_real</name>;</goto></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">9</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>int_as_real</name>;</goto></block_content></block></if></if_stmt>
          <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">8</literal></expr> )</condition><block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>SMALLEST_INT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <goto>goto <name>int_done</name>;</goto>
            </block_content>}</block></if><else>else<block>{<block_content>
              <goto>goto <name>int_as_real</name>;</goto>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <name>i</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name>v</name></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><name>i</name></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <label><name>int_done</name>:</label>
      <break>break;</break>
      <label><name>int_as_real</name>:</label> <comment type="block">/* fall through to real */</comment><empty_stmt>;</empty_stmt>
    </block_content>}</block>
    <case>case <expr><name>JSON_REAL</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_AMALGAMATION</name></cpp:ifdef>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3AtoF</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><call><name>sqlite3Strlen30</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_STRING</name></expr>:</case> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* Never happens because JNODE_RAW is only set by json_set(),
      ** json_insert() and json_replace() and those routines do not
      ** call jsonReturn() */</comment>
      if( pNode-&gt;jnFlags &amp; JNODE_RAW ){
        sqlite3_result_text(pCtx, pNode-&gt;u.zJContent, pNode-&gt;n,
                            SQLITE_TRANSIENT);
      }else 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_RAW</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_ESCAPE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* JSON formatted without any backslash-escapes */</comment>
        <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>,
                            <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* Translate JSON formatted string into raw text */</comment>
        <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u32</name></type> <name>n</name> <init>= <expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOut</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>u32</name></type> <name>j</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>zOut</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>zOut</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><literal type="char">'\\'</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'u'</literal></expr> )</condition><block>{<block_content>
              <decl_stmt><decl><type><name>u32</name></type> <name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
              <for>for<control>(<init><expr><name>k</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name><operator>&lt;</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name>n</name><operator>-</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>k</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
                <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v</name> <operator>=</operator> <name>v</name><operator>*</operator><literal type="number">16</literal> <operator>+</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'F'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v</name> <operator>=</operator> <name>v</name><operator>*</operator><literal type="number">16</literal> <operator>+</operator> <name>c</name> <operator>-</operator> <literal type="char">'A'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'f'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v</name> <operator>=</operator> <name>v</name><operator>*</operator><literal type="number">16</literal> <operator>+</operator> <name>c</name> <operator>-</operator> <literal type="char">'a'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt>
              </block_content>}</block></for>
              <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
              <if_stmt><if>if<condition>( <expr><name>v</name><operator>&lt;=</operator><literal type="number">0x7f</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>v</name></expr>;</expr_stmt>
              </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>v</name><operator>&lt;=</operator><literal type="number">0x7ff</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><literal type="number">0xc0</literal> <operator>|</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>v</name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
              </block_content>}</block></if><else>else<block>{<block_content>
                <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><literal type="number">0xe0</literal> <operator>|</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">12</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>v</name><operator>&amp;</operator><literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></if><else>else<block>{<block_content>
              <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'b'</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\b'</literal></expr>;</expr_stmt>
              </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'f'</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\f'</literal></expr>;</expr_stmt>
              </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'n'</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
              </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'r'</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt>
              </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'t'</literal></expr> )</condition><block>{<block_content>
                <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\t'</literal></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
              <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>zOut</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zOut</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_ARRAY</name></expr>:</case>
    <case>case <expr><name>JSON_OBJECT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>jsonReturnJson</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>aReplace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Forward reference */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>jsonParseAddNode</name><parameter_list>(<parameter><decl><type><name>JsonParse</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>u32</name></type></decl></parameter>,<parameter><decl><type><name>u32</name></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** A macro to hint to the compiler that a function should not be
** inlined.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_NOINLINE</name></cpp:macro>  <cpp:value>__attribute__((noinline))</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_MSC_VER</name><operator>&gt;=</operator><literal type="number">1310</literal></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_NOINLINE</name></cpp:macro>  <cpp:value>__declspec(noinline)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_NOINLINE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>static</specifier> <name>JSON_NOINLINE</name> <name>int</name></type> <name>jsonParseAddNodeExpand</name><parameter_list>(
  <parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Append the node to this object */</comment>
  <parameter><decl><type><name>u32</name></type> <name>eType</name></decl></parameter>,                <comment type="block">/* Node type */</comment>
  <parameter><decl><type><name>u32</name></type> <name>n</name></decl></parameter>,                    <comment type="block">/* Content size or sub-node count */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zContent</name></decl></parameter>      <comment type="block">/* Content */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>nNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name><operator>&gt;=</operator><name><name>pParse</name><operator>-&gt;</operator><name>nAlloc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nNew</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonNode</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>nNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name>nNew</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name></name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name><operator>&lt;</operator><name><name>pParse</name><operator>-&gt;</operator><name>nAlloc</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>zContent</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Create a new JsonNode instance based on the arguments and append that
** instance to the JsonParse.  Return the index in pParse-&gt;aNode[] of the
** new node, or -1 if a memory allocation fails.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonParseAddNode</name><parameter_list>(
  <parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,        <comment type="block">/* Append the node to this object */</comment>
  <parameter><decl><type><name>u32</name></type> <name>eType</name></decl></parameter>,                <comment type="block">/* Node type */</comment>
  <parameter><decl><type><name>u32</name></type> <name>n</name></decl></parameter>,                    <comment type="block">/* Content size or sub-node count */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zContent</name></decl></parameter>      <comment type="block">/* Content */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name><operator>&gt;=</operator><name><name>pParse</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>jsonParseAddNodeExpand</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>eType</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>zContent</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>eType</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iVal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name> <operator>=</operator> <name>zContent</name></expr>;</expr_stmt>
  <return>return <expr><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name><operator>++</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Parse a single JSON value which begins at pParse-&gt;zJson[i].  Return the
** index of the first character past the end of the value parsed.
**
** Return negative for a syntax error.  Special cases:  return -2 if the
** first non-whitespace character is '}' and return -3 if the first
** non-whitespace character is ']'.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonParseValue</name><parameter_list>(<parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iThis</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><call><name>safe_isspace</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>==</operator><literal type="char">'{'</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Parse object */</comment>
    <expr_stmt><expr><name>iThis</name> <operator>=</operator> <call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_OBJECT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iThis</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</init><condition>;</condition><incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <while>while<condition>( <expr><call><name>safe_isspace</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jsonParseValue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>x</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name><operator>==</operator><operator>(</operator><name>u32</name><operator>)</operator><name>iThis</name><operator>+</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name><operator>!=</operator><name>JSON_STRING</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>|=</operator> <name>JNODE_LABEL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
      <while>while<condition>( <expr><call><name>safe_isspace</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>j</name></expr>]</index></name><operator>!=</operator><literal type="char">':'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jsonParseValue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
      <while>while<condition>( <expr><call><name>safe_isspace</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">','</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><literal type="char">'}'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iThis</name></expr>]</index></name><operator>.</operator><name>n</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name> <operator>-</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>iThis</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'['</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Parse array */</comment>
    <expr_stmt><expr><name>iThis</name> <operator>=</operator> <call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_ARRAY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iThis</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</init><condition>;</condition><incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <while>while<condition>( <expr><call><name>safe_isspace</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
      <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>jsonParseValue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>x</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>x</name><operator>==</operator><operator>(</operator><operator>-</operator><literal type="number">3</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name><operator>==</operator><operator>(</operator><name>u32</name><operator>)</operator><name>iThis</name><operator>+</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
      <while>while<condition>( <expr><call><name>safe_isspace</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">','</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><literal type="char">']'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iThis</name></expr>]</index></name><operator>.</operator><name>n</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name> <operator>-</operator> <operator>(</operator><name>u32</name><operator>)</operator><name>iThis</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Parse string */</comment>
    <decl_stmt><decl><type><name>u8</name></type> <name>jnFlags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'\\'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><operator>++</operator><name>j</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>jnFlags</name> <operator>=</operator> <name>JNODE_ESCAPE</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_STRING</name></expr></argument>, <argument><expr><name>j</name><operator>+</operator><literal type="number">1</literal><operator>-</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>=</operator> <name>jnFlags</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'n'</literal>
         <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name></name><operator>+</operator><name>i</name></expr></argument>,<argument><expr><literal type="string">"null"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>!</operator><call><name>safe_isalnum</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>i</name><operator>+</operator><literal type="number">4</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'t'</literal>
         <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name></name><operator>+</operator><name>i</name></expr></argument>,<argument><expr><literal type="string">"true"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>!</operator><call><name>safe_isalnum</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_TRUE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>i</name><operator>+</operator><literal type="number">4</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'f'</literal>
         <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name></name><operator>+</operator><name>i</name></expr></argument>,<argument><expr><literal type="string">"false"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
         <operator>&amp;&amp;</operator> <operator>!</operator><call><name>safe_isalnum</name><argument_list>(<argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_FALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>i</name><operator>+</operator><literal type="number">5</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'-'</literal> <operator>||</operator> <operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <comment type="block">/* Parse number */</comment>
    <decl_stmt><decl><type><name>u8</name></type> <name>seenDP</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>u8</name></type> <name>seenE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <for>for<control>(<init>;</init><condition>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>seenDP</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>seenDP</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'e'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'E'</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>&lt;</operator><literal type="char">'0'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>seenE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>seenDP</name> <operator>=</operator> <name>seenE</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'+'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>c</name><argument_list type="generic">&lt;<argument><expr><literal type="char">'0'</literal> <operator>||</operator> <name>c</name></expr></argument>&gt;</argument_list></name><literal type="char">'9'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>&lt;</operator><literal type="char">'0'</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><ternary><condition><expr><name>seenDP</name></expr> ?</condition><then> <expr><name>JSON_REAL</name></expr> </then><else>: <expr><name>JSON_INT</name></expr></else></ternary></expr></argument>,
                        <argument><expr><name>j</name> <operator>-</operator> <name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>j</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">'}'</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>  <comment type="block">/* End of {...} */</comment>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="char">']'</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">3</literal></expr>;</return>  <comment type="block">/* End of [...] */</comment>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* End of file */</comment>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>  <comment type="block">/* Syntax error */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Parse a complete JSON string.  Return 0 on success or non-zero if there
** are any errors.  If an error occurs, free all memory associated with
** pParse.
**
** pParse is uninitialized when this routine is called.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonParse</name><parameter_list>(
  <parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,           <comment type="block">/* Initialize and fill this JsonParse object */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,       <comment type="block">/* Report errors here */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zJson</name></decl></parameter>            <comment type="block">/* Input JSON text to be parsed */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pParse</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zJson</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>zJson</name></name> <operator>=</operator> <name>zJson</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>jsonParseValue</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><call><name>safe_isspace</name><argument_list>(<argument><expr><name><name>zJson</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if<condition>( <expr><name><name>zJson</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>pCtx</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><literal type="string">"malformed JSON"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>jsonParseReset</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Mark node i of pParse as being a child of iParent.  Call recursively
** to fill in all the descendants of node i.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonParseFillInParentage</name><parameter_list>(<parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>iParent</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>j</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aUp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>iParent</name></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>JSON_ARRAY</name></expr>:</case> <block>{<block_content>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;=</operator><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>j</name> <operator>+=</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><name>pNode</name><operator>+</operator><name>j</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>jsonParseFillInParentage</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><name>j</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JSON_OBJECT</name></expr>:</case> <block>{<block_content>
      <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;=</operator><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>j</name> <operator>+=</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><name>pNode</name><operator>+</operator><name>j</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aUp</name><index>[<expr><name>i</name><operator>+</operator><name>j</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jsonParseFillInParentage</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><name>j</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Compute the parentage of all nodes in a completed parse.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonParseFindParents</name><parameter_list>(<parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name> <modifier>*</modifier></type><name>aUp</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>aUp</name></name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>aUp</name> <operator>=</operator> <name><name>pParse</name><operator>-&gt;</operator><name>aUp</name></name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>aUp</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>jsonParseFillInParentage</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compare the OBJECT label at pNode against zKey,nKey.  Return true on
** a match.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonLabelCompare</name><parameter_list>(<parameter><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>nKey</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_RAW</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name><operator>!=</operator><name>nKey</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name><operator>!=</operator><name>nKey</name><operator>+</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* forward declaration */</comment>
<function_decl><type><specifier>static</specifier> <name>JsonNode</name> <modifier>*</modifier></type><name>jsonLookupAppend</name><parameter_list>(<parameter><decl><type><name>JsonParse</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Search along zPath to find the node specified.  Return a pointer
** to that node, or NULL if zPath is malformed or if there is no such
** node.
**
** If pApnd!=0, then try to append new nodes to complete zPath if it is
** possible to do so and if no existing node corresponds to zPath.  If
** new nodes are appended *pApnd is set to 1.
*/</comment>
<function><type><specifier>static</specifier> <name>JsonNode</name> <modifier>*</modifier></type><name>jsonLookupStep</name><parameter_list>(
  <parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,      <comment type="block">/* The JSON to search */</comment>
  <parameter><decl><type><name>u32</name></type> <name>iRoot</name></decl></parameter>,              <comment type="block">/* Begin the search at this node */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,      <comment type="block">/* The path to search */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pApnd</name></decl></parameter>,             <comment type="block">/* Append nodes to complete path if not NULL */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>      <comment type="block">/* Make *pzErr point to any syntax error in zPath */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>nKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zKey</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pRoot</name> <init>= <expr><operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iRoot</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>pRoot</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pRoot</name><operator>-&gt;</operator><name>eType</name></name><operator>!=</operator><name>JSON_OBJECT</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zPath</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zKey</name> <operator>=</operator> <name>zPath</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name><name>zPath</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>zPath</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'"'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
      <expr_stmt><expr><name>nKey</name> <operator>=</operator> <name>i</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><name>i</name></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <name>zPath</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zKey</name> <operator>=</operator> <name>zPath</name></expr>;</expr_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>zPath</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>zPath</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name><name>zPath</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'['</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
      <expr_stmt><expr><name>nKey</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nKey</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <name>zPath</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
      <while>while<condition>( <expr><name>j</name><operator>&lt;=</operator><name><name>pRoot</name><operator>-&gt;</operator><name>n</name></name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>jsonLabelCompare</name><argument_list>(<argument><expr><name>pRoot</name><operator>+</operator><name>j</name></expr></argument>, <argument><expr><name>zKey</name></expr></argument>, <argument><expr><name>nKey</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <return>return <expr><call><name>jsonLookupStep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iRoot</name><operator>+</operator><name>j</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zPath</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pApnd</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> <operator>+=</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pRoot</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRoot</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_APPEND</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>iRoot</name> <operator>+=</operator> <name><name>pRoot</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iAppend</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iRoot</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>pApnd</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>iStart</name></decl>, <decl><type ref="prev"/><name>iLabel</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>iStart</name> <operator>=</operator> <call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_OBJECT</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iLabel</name> <operator>=</operator> <call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_STRING</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zPath</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookupAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pApnd</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pNode</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iRoot</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iAppend</name></name> <operator>=</operator> <name>iStart</name> <operator>-</operator> <name>iRoot</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>|=</operator> <name>JNODE_APPEND</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iLabel</name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>|=</operator> <name>JNODE_RAW</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>pNode</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'['</literal> <operator>&amp;&amp;</operator> <call><name>safe_isdigit</name><argument_list>(<argument><expr><name><name>zPath</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pRoot</name><operator>-&gt;</operator><name>eType</name></name><operator>!=</operator><name>JSON_ARRAY</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><call><name>safe_isdigit</name><argument_list>(<argument><expr><name><name>zPath</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>i</name> <operator>=</operator> <name>i</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name><name>zPath</name><index>[<expr><name>j</name></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><name>j</name></expr>]</index></name><operator>!=</operator><literal type="char">']'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <name>zPath</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>zPath</name> <operator>+=</operator> <name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control><block>{<block_content>
      <while>while<condition>( <expr><name>j</name><operator>&lt;=</operator><name><name>pRoot</name><operator>-&gt;</operator><name>n</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>i</name><operator>&gt;</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pRoot</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_REMOVE</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRoot</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_REMOVE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>j</name> <operator>+=</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pRoot</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pRoot</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_APPEND</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>iRoot</name> <operator>+=</operator> <name><name>pRoot</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iAppend</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iRoot</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>j</name><operator>&lt;=</operator><name><name>pRoot</name><operator>-&gt;</operator><name>n</name></name></expr> )</condition><block>{<block_content>
      <return>return <expr><call><name>jsonLookupStep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>iRoot</name><operator>+</operator><name>j</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pApnd</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pApnd</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>iStart</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>iStart</name> <operator>=</operator> <call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_ARRAY</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookupAppend</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pApnd</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>pNode</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>pRoot</name> <operator>=</operator> <operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name>iRoot</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iAppend</name></name> <operator>=</operator> <name>iStart</name> <operator>-</operator> <name>iRoot</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pRoot</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>|=</operator> <name>JNODE_APPEND</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>pNode</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <name>zPath</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Append content to pParse that will complete zPath.  Return a pointer
** to the inserted node, or return NULL if the append fails.
*/</comment>
<function><type><specifier>static</specifier> <name>JsonNode</name> <modifier>*</modifier></type><name>jsonLookupAppend</name><parameter_list>(
  <parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,     <comment type="block">/* Append content to the JSON parse */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,     <comment type="block">/* Description of content to append */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pApnd</name></decl></parameter>,            <comment type="block">/* Set this flag to 1 */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>     <comment type="block">/* Make this point to any syntax error */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>pApnd</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><ternary><condition><expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>&amp;</operator><name><name>pParse</name><operator>-&gt;</operator><name>aNode</name><index>[<expr><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></else></ternary></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_OBJECT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>zPath</name></expr></argument>,<argument><expr><literal type="string">"[0]"</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonParseAddNode</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name>JSON_ARRAY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pParse</name><operator>-&gt;</operator><name>oom</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>jsonLookupStep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><name><name>pParse</name><operator>-&gt;</operator><name>nNode</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pApnd</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return the text of a syntax error message on a JSON path.  Space is
** obtained from sqlite3_malloc().
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>jsonPathSyntaxError</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"JSON path error near '%q'"</literal></expr></argument>, <argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Do a node lookup using zPath.  Return a pointer to the node on success.
** Return NULL if not found or if there is an error.
**
** On an error, write an error message into pCtx and increment the
** pParse-&gt;nErr counter.
**
** If pApnd!=NULL then try to append missing nodes and set *pApnd = 1 if
** nodes are appended.
*/</comment>
<function><type><specifier>static</specifier> <name>JsonNode</name> <modifier>*</modifier></type><name>jsonLookup</name><parameter_list>(
  <parameter><decl><type><name>JsonParse</name> <modifier>*</modifier></type><name>pParse</name></decl></parameter>,      <comment type="block">/* The JSON to search */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl></parameter>,      <comment type="block">/* The path to search */</comment>
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pApnd</name></decl></parameter>,             <comment type="block">/* Append nodes to complete path if not NULL */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>   <comment type="block">/* Report errors here, if not NULL */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>zPath</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>zPath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'$'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zErr</name> <operator>=</operator> <name>zPath</name></expr>;</expr_stmt>
    <goto>goto <name>lookup_err</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zPath</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookupStep</name><argument_list>(<argument><expr><name>pParse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><name>pApnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zErr</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>pNode</name></expr>;</return></block_content></block></if></if_stmt>

<label><name>lookup_err</name>:</label>
  <expr_stmt><expr><name><name>pParse</name><operator>-&gt;</operator><name>nErr</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>zErr</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pCtx</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zMsg</name> <operator>=</operator> <call><name>jsonPathSyntaxError</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>zMsg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Report the wrong number of arguments for json_insert(), json_replace()
** or json_set().
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonWrongNumArgs</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pCtx</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFuncName</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zMsg</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"json_%s() needs an odd number of arguments"</literal></expr></argument>,
                               <argument><expr><name>zFuncName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pCtx</name></expr></argument>, <argument><expr><name>zMsg</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>     
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************************
** SQL functions used for testing and debugging
****************************************************************************/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** The json_parse(JSON) function returns a string which describes
** a parse of the JSON provided.  Or it returns NULL if JSON is not
** well-formed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonParseFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonString</name></type> <name>s</name></decl>;</decl_stmt>       <comment type="block">/* Output string - not real JSON */</comment>
  <decl_stmt><decl><type><name>JsonParse</name></type> <name>x</name></decl>;</decl_stmt>        <comment type="block">/* The parse */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>jsonParse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>jsonParseFindParents</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>x</name><operator>.</operator><name>nNode</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zType</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_LABEL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eType</name><operator>==</operator><name>JSON_STRING</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zType</name> <operator>=</operator> <literal type="string">"label"</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>zType</name> <operator>=</operator> <name><name>jsonType</name><index>[<expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eType</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>jsonPrintf</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>,<argument><expr><literal type="string">"node %3u: %7s n=%-4d up=%-4d"</literal></expr></argument>,
               <argument><expr><name>i</name></expr></argument>, <argument><expr><name>zType</name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n</name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>aUp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>zJContent</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>zJContent</name></name></expr></argument>, <argument><expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>jsonParseReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonResult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The json_test1(JSON) function return true (1) if the input is JSON
** text generated by another json function.  It returns (0) if the input
** is not known to be JSON.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonTest1Func</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>UNUSED_PARAM</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><call><name>sqlite3_value_subtype</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>JSON_SUBTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>

<comment type="block" format="doxygen">/****************************************************************************
** Scalar SQL function implementations
****************************************************************************/</comment>

<comment type="block">/*
** Implementation of the json_array(VALUE,...) function.  Return a JSON
** array that contains all values given in arguments.  Or if any argument
** is a BLOB, throw an error.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonArrayFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonString</name></type> <name>jx</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>jsonInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>jsonAppendSeparator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonAppendValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonResult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_subtype</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>JSON_SUBTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** json_array_length(JSON)
** json_array_length(JSON, PATH)
**
** Return the number of elements in the top-level JSON array.  
** Return 0 if the input is not a well-formed JSON array.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonArrayLengthFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonParse</name></type> <name>x</name></decl>;</decl_stmt>          <comment type="block">/* The parse */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>jsonParse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>x</name><operator>.</operator><name>nNode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>x</name><operator>.</operator><name>aNode</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNode</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>x</name><operator>.</operator><name>nErr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_ARRAY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_APPEND</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><name>i</name> <operator>+=</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pNode</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>nErr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>jsonParseReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** json_extract(JSON, PATH, ...)
**
** Return the element described by PATH.  Return NULL if there is no
** PATH element.  If there are multiple PATHs, then return a JSON array
** with the result from each path.  Throw an error if the JSON or any PATH
** is malformed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonExtractFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonParse</name></type> <name>x</name></decl>;</decl_stmt>          <comment type="block">/* The parse */</comment>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonString</name></type> <name>jx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>jsonParse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>jsonInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>zPath</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&gt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>jsonAppendSeparator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>pNode</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>jsonRenderNode</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pNode</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>jsonReturn</name><argument_list>(<argument><expr><name>pNode</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&gt;</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>==</operator><name>argc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonResult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_subtype</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>JSON_SUBTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>jsonReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonParseReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the json_object(NAME,VALUE,...) function.  Return a JSON
** object that contains all name/value given in arguments.  Or if any name
** is not a string or if any value is a BLOB, throw an error.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonObjectFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonString</name></type> <name>jx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>n</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&amp;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"json_object() requires an even number "</literal>
                                  <literal type="string">"of arguments"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>jsonInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_TEXT</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"json_object() labels must be TEXT"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>jsonReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>jsonAppendSeparator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonAppendString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonAppendValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonResult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>jx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_subtype</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>JSON_SUBTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** json_remove(JSON, PATH, ...)
**
** Remove the named elements from JSON and return the result.  malformed
** JSON or PATH arguments result in an error.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonRemoveFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonParse</name></type> <name>x</name></decl>;</decl_stmt>          <comment type="block">/* The parse */</comment>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>jsonParse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>x</name><operator>.</operator><name>nNode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>zPath</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zPath</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>remove_done</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>remove_done</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNode</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>|=</operator> <name>JNODE_REMOVE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_REMOVE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonReturnJson</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>aNode</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<label><name>remove_done</name>:</label>
  <expr_stmt><expr><call><name>jsonParseReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** json_replace(JSON, PATH, VALUE, ...)
**
** Replace the value at PATH with VALUE.  If PATH does not already exist,
** this routine is a no-op.  If JSON or PATH is malformed, throw an error.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonReplaceFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonParse</name></type> <name>x</name></decl>;</decl_stmt>          <comment type="block">/* The parse */</comment>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>argc</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>jsonWrongNumArgs</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"replace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>jsonParse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>x</name><operator>.</operator><name>nNode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>zPath</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>nErr</name></name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>replace_err</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNode</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>|=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>JNODE_REPLACE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>iVal</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_REPLACE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iVal</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>jsonReturnJson</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>aNode</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<label><name>replace_err</name>:</label>
  <expr_stmt><expr><call><name>jsonParseReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** json_set(JSON, PATH, VALUE, ...)
**
** Set the value at PATH to VALUE.  Create the PATH if it does not already
** exist.  Overwrite existing values that do exist.
** If JSON or PATH is malformed, throw an error.
**
** json_insert(JSON, PATH, VALUE, ...)
**
** Create PATH and initialize it to VALUE.  If PATH already exists, this
** routine is a no-op.  If JSON or PATH is malformed, throw an error.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonSetFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonParse</name></type> <name>x</name></decl>;</decl_stmt>          <comment type="block">/* The parse */</comment>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bApnd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bIsSet</name> <init>= <expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>sqlite3_user_data</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>argc</name><operator>&amp;</operator><literal type="number">1</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>jsonWrongNumArgs</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><ternary><condition><expr><name>bIsSet</name></expr> ?</condition><then> <expr><literal type="string">"set"</literal></expr> </then><else>: <expr><literal type="string">"insert"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>jsonParse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>x</name><operator>.</operator><name>nNode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>u32</name><operator>)</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>zPath</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bApnd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bApnd</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>oom</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>jsonSetDone</name>;</goto>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>x</name><operator>.</operator><name>nErr</name></name></expr> )</condition><block>{<block_content>
      <goto>goto <name>jsonSetDone</name>;</goto>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pNode</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>bApnd</name> <operator>||</operator> <name>bIsSet</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>|=</operator> <operator>(</operator><name>u8</name><operator>)</operator><name>JNODE_REPLACE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>iVal</name></name> <operator>=</operator> <operator>(</operator><name>u8</name><operator>)</operator><operator>(</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_REPLACE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name><name>x</name><operator>.</operator><name>aNode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iVal</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>jsonReturnJson</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>aNode</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<label><name>jsonSetDone</name>:</label>
  <expr_stmt><expr><call><name>jsonParseReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** json_type(JSON)
** json_type(JSON, PATH)
**
** Return the top-level "type" of a JSON string.  Throw an error if
** either the JSON or PATH inputs are not well-formed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonTypeFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonParse</name></type> <name>x</name></decl>;</decl_stmt>          <comment type="block">/* The parse */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zPath</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>jsonParse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>x</name><operator>.</operator><name>nNode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zPath</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>zPath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>x</name><operator>.</operator><name>aNode</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>pNode</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>jsonType</name><index>[<expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>jsonParseReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** json_valid(JSON)
**
** Return 1 if JSON is a well-formed JSON string according to RFC-7159.
** Return 0 otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonValidFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonParse</name></type> <name>x</name></decl>;</decl_stmt>          <comment type="block">/* The parse */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAM</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>jsonParse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>jsonParseReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_int</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************************
** Aggregate SQL function implementations
****************************************************************************/</comment>
<comment type="block">/*
** json_group_array(VALUE)
**
** Return a JSON array composed of all values in the aggregate.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonArrayStep</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>pStr</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAM</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pStr</name> <operator>=</operator> <operator>(</operator><name>JsonString</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pStr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pStr</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pStr</name><operator>-&gt;</operator><name>zBuf</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>jsonInit</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>pCtx</name></name> <operator>=</operator> <name>ctx</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>jsonAppendValue</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonArrayFinal</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>pStr</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pStr</name> <operator>=</operator> <operator>(</operator><name>JsonString</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pStr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>pCtx</name></name> <operator>=</operator> <name>ctx</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pStr</name><operator>-&gt;</operator><name>bErr</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pStr</name><operator>-&gt;</operator><name>bErr</name></name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>bStatic</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>nUsed</name></name></expr></argument>,
                          <argument><expr><ternary><condition><expr><name><name>pStr</name><operator>-&gt;</operator><name>bStatic</name></name></expr> ?</condition><then> <expr><name>SQLITE_TRANSIENT</name></expr> </then><else>: <expr><name>sqlite3_free</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>bStatic</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"[]"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_subtype</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>JSON_SUBTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** json_group_obj(NAME,VALUE)
**
** Return a JSON object composed of all names and values in the aggregate.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonObjectStep</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>pStr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>n</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAM</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pStr</name> <operator>=</operator> <operator>(</operator><name>JsonString</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pStr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pStr</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pStr</name><operator>-&gt;</operator><name>zBuf</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>jsonInit</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>pCtx</name></name> <operator>=</operator> <name>ctx</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>u32</name><operator>)</operator><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonAppendString</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonAppendValue</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonObjectFinal</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>pStr</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>pStr</name> <operator>=</operator> <operator>(</operator><name>JsonString</name><operator>*</operator><operator>)</operator><call><name>sqlite3_aggregate_context</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pStr</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pStr</name><operator>-&gt;</operator><name>bErr</name></name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pStr</name><operator>-&gt;</operator><name>bErr</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_result_error_nomem</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>bStatic</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>zBuf</name></name></expr></argument>, <argument><expr><name><name>pStr</name><operator>-&gt;</operator><name>nUsed</name></name></expr></argument>,
                          <argument><expr><ternary><condition><expr><name><name>pStr</name><operator>-&gt;</operator><name>bStatic</name></name></expr> ?</condition><then> <expr><name>SQLITE_TRANSIENT</name></expr> </then><else>: <expr><name>sqlite3_free</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pStr</name><operator>-&gt;</operator><name>bStatic</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="string">"{}"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_subtype</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>JSON_SUBTYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
<comment type="block" format="doxygen">/****************************************************************************
** The json_each virtual table
****************************************************************************/</comment>
<typedef>typedef <type><name><name>struct</name> <name>JsonEachCursor</name></name></type> <name>JsonEachCursor</name>;</typedef>
<struct>struct <name>JsonEachCursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>  <comment type="block">/* Base class - must be first */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iRowid</name></decl>;</decl_stmt>                <comment type="block">/* The rowid */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iBegin</name></decl>;</decl_stmt>                <comment type="block">/* The first node of the scan */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>i</name></decl>;</decl_stmt>                     <comment type="block">/* Index in sParse.aNode[] of current row */</comment>
  <decl_stmt><decl><type><name>u32</name></type> <name>iEnd</name></decl>;</decl_stmt>                  <comment type="block">/* EOF when i equals or exceeds this value */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>eType</name></decl>;</decl_stmt>                  <comment type="block">/* Type of top-level element */</comment>
  <decl_stmt><decl><type><name>u8</name></type> <name>bRecursive</name></decl>;</decl_stmt>             <comment type="block">/* True for json_tree().  False for json_each() */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zJson</name></decl>;</decl_stmt>               <comment type="block">/* Input JSON */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zRoot</name></decl>;</decl_stmt>               <comment type="block">/* Path by which to filter zJson */</comment>
  <decl_stmt><decl><type><name>JsonParse</name></type> <name>sParse</name></decl>;</decl_stmt>          <comment type="block">/* Parse of the input JSON */</comment>
}</block>;</struct>

<comment type="block">/* Constructor for the json_each virtual table */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVtab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

<comment type="block">/* Column numbers */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEACH_KEY</name></cpp:macro>     <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEACH_VALUE</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEACH_TYPE</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEACH_ATOM</name></cpp:macro>    <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEACH_ID</name></cpp:macro>      <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEACH_PARENT</name></cpp:macro>  <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEACH_FULLKEY</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEACH_PATH</name></cpp:macro>    <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEACH_JSON</name></cpp:macro>    <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEACH_ROOT</name></cpp:macro>    <cpp:value>9</cpp:value></cpp:define>

  <expr_stmt><expr><call><name>UNUSED_PARAM</name><argument_list>(<argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAM</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAM</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAM</name><argument_list>(<argument><expr><name>pAux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, 
     <argument><expr><literal type="string">"CREATE TABLE x(key,value,type,atom,id,parent,fullkey,path,"</literal>
                    <literal type="string">"json HIDDEN,root HIDDEN)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <operator>*</operator><name>ppVtab</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>pNew</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pNew</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pNew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* destructor for json_each virtual table */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* constructor for a JsonEachCursor object for json_each(). */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachOpenEach</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonEachCursor</name> <modifier>*</modifier></type><name>pCur</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAM</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pCur</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pCur</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pCur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pCur</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>&amp;</operator><name><name>pCur</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* constructor for a JsonEachCursor object for json_tree(). */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachOpenTree</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>jsonEachOpenEach</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ppCursor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>JsonEachCursor</name> <modifier>*</modifier></type><name>pCur</name> <init>= <expr><operator>(</operator><name>JsonEachCursor</name><operator>*</operator><operator>)</operator><operator>*</operator><name>ppCursor</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pCur</name><operator>-&gt;</operator><name>bRecursive</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Reset a JsonEachCursor back to its original state.  Free any memory
** held. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonEachCursorReset</name><parameter_list>(<parameter><decl><type><name>JsonEachCursor</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zJson</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zRoot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonParseReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iRowid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zJson</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zRoot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Destructor for a jsonEachCursor object */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonEachCursor</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>JsonEachCursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>jsonEachCursorReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return TRUE if the jsonEachCursor object has been advanced off the end
** of the JSON object */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonEachCursor</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>JsonEachCursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>iEnd</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Advance the cursor to the next element for json_tree() */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonEachCursor</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>JsonEachCursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bRecursive</name></name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_LABEL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iRowid</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>iEnd</name></name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>u32</name></type> <name>iUp</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aUp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pUp</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name>iUp</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <name><name>pUp</name><operator>-&gt;</operator><name>eType</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pUp</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_ARRAY</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>iUp</name><operator>==</operator><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>pUp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iKey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name><name>pUp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iKey</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <switch>switch<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>JSON_ARRAY</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name> <operator>+=</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iRowid</name></name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>JSON_OBJECT</name></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>jsonNodeSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iRowid</name></name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iEnd</name></name></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
    </block_content>}</block></switch>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Append the name of the path for element i to pStr
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jsonEachComputePath</name><parameter_list>(
  <parameter><decl><type><name>JsonEachCursor</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,       <comment type="block">/* The cursor */</comment>
  <parameter><decl><type><name>JsonString</name> <modifier>*</modifier></type><name>pStr</name></decl></parameter>,        <comment type="block">/* Write the path here */</comment>
  <parameter><decl><type><name>u32</name></type> <name>i</name></decl></parameter>                    <comment type="block">/* Path to this element */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pUp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>iUp</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>iUp</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aUp</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonEachComputePath</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pStr</name></expr></argument>, <argument><expr><name>iUp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pNode</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pUp</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name>iUp</name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pUp</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_ARRAY</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonPrintf</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>, <argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">"[%d]"</literal></expr></argument>, <argument><expr><name><name>pUp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pUp</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_OBJECT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_LABEL</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pNode</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_STRING</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_LABEL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>jsonPrintf</name><argument_list>(<argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pStr</name></expr></argument>, <argument><expr><literal type="string">".%.*s"</literal></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>n</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Return the value of a column */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachColumn</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>,   <comment type="block">/* The cursor */</comment>
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,       <comment type="block">/* First argument to sqlite3_result_...() */</comment>
  <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>                       <comment type="block">/* Which column to return */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonEachCursor</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>JsonEachCursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pThis</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><name>i</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>JEACH_KEY</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_OBJECT</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>jsonReturn</name><argument_list>(<argument><expr><name>pThis</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_ARRAY</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>u32</name></type> <name>iKey</name></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bRecursive</name></name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iRowid</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>iKey</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aUp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>iKey</name></name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>iKey</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iRowid</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>iKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JEACH_VALUE</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pThis</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_LABEL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pThis</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>jsonReturn</name><argument_list>(<argument><expr><name>pThis</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JEACH_TYPE</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pThis</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_LABEL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pThis</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>jsonType</name><index>[<expr><name><name>pThis</name><operator>-&gt;</operator><name>eType</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JEACH_ATOM</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pThis</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_LABEL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pThis</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pThis</name><operator>-&gt;</operator><name>eType</name></name><operator>&gt;=</operator><name>JSON_ARRAY</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>jsonReturn</name><argument_list>(<argument><expr><name>pThis</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JEACH_ID</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, 
         <argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>i</name></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>pThis</name><operator>-&gt;</operator><name>jnFlags</name></name> <operator>&amp;</operator> <name>JNODE_LABEL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JEACH_PARENT</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>&gt;</operator><name><name>p</name><operator>-&gt;</operator><name>iBegin</name></name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>bRecursive</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aUp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JEACH_FULLKEY</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>JsonString</name></type> <name>x</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>jsonInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bRecursive</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>jsonEachComputePath</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zRoot</name></name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>jsonAppendRaw</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zRoot</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zRoot</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>jsonAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>==</operator><name>JSON_ARRAY</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>jsonPrintf</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">"[%d]"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iRowid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>jsonPrintf</name><argument_list>(<argument><expr><name><name>pThis</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><literal type="string">".%.*s"</literal></expr></argument>, <argument><expr><name><name>pThis</name><operator>-&gt;</operator><name>n</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>pThis</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zJContent</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>jsonResult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JEACH_PATH</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bRecursive</name></name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>JsonString</name></type> <name>x</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>jsonInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jsonEachComputePath</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aUp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jsonResult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* For json_each() path and root are the same so fall through
      ** into the root case */</comment>
    </block_content>}</block>
    <case>case <expr><name>JEACH_ROOT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRoot</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>zRoot</name></name></expr></init></decl>;</decl_stmt>
       <if_stmt><if>if<condition>( <expr><name>zRoot</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zRoot</name> <operator>=</operator> <literal type="string">"$"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>zRoot</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>JEACH_JSON</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><name>JEACH_JSON</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>zJson</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the current rowid value */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonEachCursor</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>JsonEachCursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iRowid</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The query strategy is to look for an equality constraint on the json
** column.  Without such a constraint, the table cannot operate.  idxNum is
** 1 if the constraint is found, 3 if the constraint and zRoot are found,
** and 0 otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachBestIndex</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pIdxInfo</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>jsonIdx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rootIdx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pConstraint</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAM</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pConstraint</name> <operator>=</operator> <name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraint</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pIdxInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>pConstraint</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>usable</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>!=</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <switch>switch<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>JEACH_JSON</name></expr>:</case>   <expr_stmt><expr><name>jsonIdx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>    <break>break;</break>
      <case>case <expr><name>JEACH_ROOT</name></expr>:</case>   <expr_stmt><expr><name>rootIdx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>    <break>break;</break>
      <default>default:</default>           <comment type="block">/* no-op */</comment>     <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>jsonIdx</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">1e99</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>jsonIdx</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>jsonIdx</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rootIdx</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>rootIdx</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>rootIdx</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pIdxInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Start a search on a new JSON string */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jsonEachFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>JsonEachCursor</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>JsonEachCursor</name><operator>*</operator><operator>)</operator><name>cur</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zRoot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>n</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED_PARAM</name><argument_list>(<argument><expr><name>idxStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED_PARAM</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jsonEachCursorReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zJson</name></name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zJson</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zJson</name></name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>jsonParse</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zJson</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_NOMEM</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>oom</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"malformed JSON"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>jsonEachCursorReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bRecursive</name></name> <operator>&amp;&amp;</operator> <call><name>jsonParseFindParents</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>jsonEachCursorReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>JsonNode</name> <modifier>*</modifier></type><name>pNode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>idxNum</name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zErr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>zRoot</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>zRoot</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zRoot</name></name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zRoot</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zRoot</name></name></expr></argument>, <argument><expr><name>zRoot</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>zRoot</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'$'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zErr</name> <operator>=</operator> <name>zRoot</name></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name>pNode</name> <operator>=</operator> <call><name>jsonLookupStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zRoot</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if<condition>( <expr><name>zErr</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name> <operator>=</operator> <call><name>jsonPathSyntaxError</name><argument_list>(<argument><expr><name>zErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>jsonEachCursorReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><ternary><condition><expr><name><name>cur</name><operator>-&gt;</operator><name>pVtab</name><operator>-&gt;</operator><name>zErrMsg</name></name></expr> ?</condition><then> <expr><name>SQLITE_ERROR</name></expr> </then><else>: <expr><name>SQLITE_NOMEM</name></expr></else></ternary></expr>;</return>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>pNode</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pNode</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iBegin</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pNode</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <name><name>pNode</name><operator>-&gt;</operator><name>eType</name></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name><operator>&gt;=</operator><name>JSON_ARRAY</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pNode</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iKey</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iEnd</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>i</name></name> <operator>+</operator> <name><name>pNode</name><operator>-&gt;</operator><name>n</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>bRecursive</name></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>eType</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aUp</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>eType</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>sParse</name><operator>.</operator><name>aNode</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>jnFlags</name> <operator>&amp;</operator> <name>JNODE_LABEL</name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>iEnd</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>i</name></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The methods of the json_each virtual table */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>jsonEachModule</name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* iVersion */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xCreate */</comment>
  <expr><name>jsonEachConnect</name></expr>,           <comment type="block">/* xConnect */</comment>
  <expr><name>jsonEachBestIndex</name></expr>,         <comment type="block">/* xBestIndex */</comment>
  <expr><name>jsonEachDisconnect</name></expr>,        <comment type="block">/* xDisconnect */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xDestroy */</comment>
  <expr><name>jsonEachOpenEach</name></expr>,          <comment type="block">/* xOpen - open a cursor */</comment>
  <expr><name>jsonEachClose</name></expr>,             <comment type="block">/* xClose - close a cursor */</comment>
  <expr><name>jsonEachFilter</name></expr>,            <comment type="block">/* xFilter - configure scan constraints */</comment>
  <expr><name>jsonEachNext</name></expr>,              <comment type="block">/* xNext - advance a cursor */</comment>
  <expr><name>jsonEachEof</name></expr>,               <comment type="block">/* xEof - check for end of scan */</comment>
  <expr><name>jsonEachColumn</name></expr>,            <comment type="block">/* xColumn - read data */</comment>
  <expr><name>jsonEachRowid</name></expr>,             <comment type="block">/* xRowid - read data */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xUpdate */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xBegin */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSync */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xCommit */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRollback */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xFindMethod */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRename */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSavepoint */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRelease */</comment>
  <expr><literal type="number">0</literal></expr>                          <comment type="block">/* xRollbackTo */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* The methods of the json_tree virtual table. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>jsonTreeModule</name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* iVersion */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xCreate */</comment>
  <expr><name>jsonEachConnect</name></expr>,           <comment type="block">/* xConnect */</comment>
  <expr><name>jsonEachBestIndex</name></expr>,         <comment type="block">/* xBestIndex */</comment>
  <expr><name>jsonEachDisconnect</name></expr>,        <comment type="block">/* xDisconnect */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xDestroy */</comment>
  <expr><name>jsonEachOpenTree</name></expr>,          <comment type="block">/* xOpen - open a cursor */</comment>
  <expr><name>jsonEachClose</name></expr>,             <comment type="block">/* xClose - close a cursor */</comment>
  <expr><name>jsonEachFilter</name></expr>,            <comment type="block">/* xFilter - configure scan constraints */</comment>
  <expr><name>jsonEachNext</name></expr>,              <comment type="block">/* xNext - advance a cursor */</comment>
  <expr><name>jsonEachEof</name></expr>,               <comment type="block">/* xEof - check for end of scan */</comment>
  <expr><name>jsonEachColumn</name></expr>,            <comment type="block">/* xColumn - read data */</comment>
  <expr><name>jsonEachRowid</name></expr>,             <comment type="block">/* xRowid - read data */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xUpdate */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xBegin */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSync */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xCommit */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRollback */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xFindMethod */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRename */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xSavepoint */</comment>
  <expr><literal type="number">0</literal></expr>,                         <comment type="block">/* xRelease */</comment>
  <expr><literal type="number">0</literal></expr>                          <comment type="block">/* xRollbackTo */</comment>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_OMIT_VIRTUALTABLE */</comment>

<comment type="block" format="doxygen">/****************************************************************************
** The following routines are the only publically visible identifiers in this
** file.  Call the following routines in order to register the various SQL
** functions and the virtual table implemented by this file.
****************************************************************************/</comment>

<function><type><name>int</name></type> <name>sqlite3Json1Init</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
     <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>int</name></type> <name>nArg</name></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>int</name></type> <name>flag</name></decl>;</decl_stmt>
     <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  }</block> <decl><name><name>aFunc</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"json"</literal></expr>,                 <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><name>jsonRemoveFunc</name></expr>        }</block></expr>,
    <expr><block>{ <expr><literal type="string">"json_array"</literal></expr>,          <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><name>jsonArrayFunc</name></expr>         }</block></expr>,
    <expr><block>{ <expr><literal type="string">"json_array_length"</literal></expr>,    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><name>jsonArrayLengthFunc</name></expr>   }</block></expr>,
    <expr><block>{ <expr><literal type="string">"json_array_length"</literal></expr>,    <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><name>jsonArrayLengthFunc</name></expr>   }</block></expr>,
    <expr><block>{ <expr><literal type="string">"json_extract"</literal></expr>,        <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><name>jsonExtractFunc</name></expr>       }</block></expr>,
    <expr><block>{ <expr><literal type="string">"json_insert"</literal></expr>,         <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><name>jsonSetFunc</name></expr>           }</block></expr>,
    <expr><block>{ <expr><literal type="string">"json_object"</literal></expr>,         <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><name>jsonObjectFunc</name></expr>        }</block></expr>,
    <expr><block>{ <expr><literal type="string">"json_remove"</literal></expr>,         <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><name>jsonRemoveFunc</name></expr>        }</block></expr>,
    <expr><block>{ <expr><literal type="string">"json_replace"</literal></expr>,        <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><name>jsonReplaceFunc</name></expr>       }</block></expr>,
    <expr><block>{ <expr><literal type="string">"json_set"</literal></expr>,            <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,   <expr><name>jsonSetFunc</name></expr>           }</block></expr>,
    <expr><block>{ <expr><literal type="string">"json_type"</literal></expr>,            <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><name>jsonTypeFunc</name></expr>          }</block></expr>,
    <expr><block>{ <expr><literal type="string">"json_type"</literal></expr>,            <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><name>jsonTypeFunc</name></expr>          }</block></expr>,
    <expr><block>{ <expr><literal type="string">"json_valid"</literal></expr>,           <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><name>jsonValidFunc</name></expr>         }</block></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_DEBUG</name></expr></cpp:if>
    <comment type="block">/* DEBUG and TESTING functions */</comment>
    <expr><block>{ <expr><literal type="string">"json_parse"</literal></expr>,           <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><name>jsonParseFunc</name></expr>         }</block></expr>,
    <expr><block>{ <expr><literal type="string">"json_test1"</literal></expr>,           <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,   <expr><name>jsonTest1Func</name></expr>         }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></expr></init></decl>;</struct>
  <struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
     <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>int</name></type> <name>nArg</name></decl>;</decl_stmt>
     <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xStep</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
     <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>xFinal</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  }</block> <decl><name><name>aAgg</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"json_group_array"</literal></expr>,     <expr><literal type="number">1</literal></expr>,   <expr><name>jsonArrayStep</name></expr>,   <expr><name>jsonArrayFinal</name></expr>  }</block></expr>,
    <expr><block>{ <expr><literal type="string">"json_group_object"</literal></expr>,    <expr><literal type="number">2</literal></expr>,   <expr><name>jsonObjectStep</name></expr>,  <expr><name>jsonObjectFinal</name></expr> }</block></expr>,
  }</block></expr></init></decl>;</struct>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
     <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>sqlite3_module</name> <modifier>*</modifier></type><name>pModule</name></decl>;</decl_stmt>
  }</block> <decl><name><name>aMod</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"json_each"</literal></expr>,            <expr><operator>&amp;</operator><name>jsonEachModule</name></expr>               }</block></expr>,
    <expr><block>{ <expr><literal type="string">"json_tree"</literal></expr>,            <expr><operator>&amp;</operator><name>jsonTreeModule</name></expr>               }</block></expr>,
  }</block></expr></init></decl>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aFunc</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aFunc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nArg</name></expr></argument>,
                                 <argument><expr><name>SQLITE_UTF8</name> <operator>|</operator> <name>SQLITE_DETERMINISTIC</name></expr></argument>, 
                                 <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flag</name></expr></argument>,
                                 <argument><expr><name><name>aFunc</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aAgg</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aAgg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>aAgg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name><name>aAgg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nArg</name></expr></argument>,
                                 <argument><expr><name>SQLITE_UTF8</name> <operator>|</operator> <name>SQLITE_DETERMINISTIC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>aAgg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xStep</name></expr></argument>, <argument><expr><name><name>aAgg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>xFinal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_OMIT_VIRTUALTABLE</name></cpp:ifndef>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>aMod</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>aMod</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator> <name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>aMod</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zName</name></expr></argument>, <argument><expr><name><name>aMod</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pModule</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SQLITE_CORE</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_json_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>, 
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pzErrMsg</name></expr>;</expr_stmt>  <comment type="block">/* Unused parameter */</comment>
  <return>return <expr><call><name>sqlite3Json1Init</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_JSON1) */</comment>
</unit>
