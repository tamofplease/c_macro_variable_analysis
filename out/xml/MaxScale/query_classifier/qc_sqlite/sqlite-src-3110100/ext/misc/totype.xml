<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/ext/misc/totype.c"><comment type="block">/*
** 2013-10-14
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This SQLite extension implements functions tointeger(X) and toreal(X).
**
** If X is an integer, real, or string value that can be
** losslessly represented as an integer, then tointeger(X)
** returns the corresponding integer value.
** If X is an 8-byte BLOB then that blob is interpreted as
** a signed two-compliment little-endian encoding of an integer
** and tointeger(X) returns the corresponding integer value.
** Otherwise tointeger(X) return NULL.
**
** If X is an integer, real, or string value that can be
** convert into a real number, preserving at least 15 digits
** of precision, then toreal(X) returns the corresponding real value.
** If X is an 8-byte BLOB then that blob is interpreted as
** a 64-bit IEEE754 big-endian floating point value
** and toreal(X) returns the corresponding real value.
** Otherwise toreal(X) return NULL.
**
** Note that tointeger(X) of an 8-byte BLOB assumes a little-endian
** encoding whereas toreal(X) of an 8-byte BLOB assumes a big-endian
** encoding.
*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3ext.h"</cpp:file></cpp:include>
<decl_stmt><decl><type><name>SQLITE_EXTENSION_INIT1</name>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** Determine if this is running on a big-endian or little-endian
** processor
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>i386</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__i386__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_M_IX86</name></expr></argument>)</argument_list></call>\
                             <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>TOTYPE_BIGENDIAN</name></cpp:macro>    <cpp:value>0</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>TOTYPE_LITTLEENDIAN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <specifier>const</specifier> <name>int</name></type> <name>totype_one</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>TOTYPE_BIGENDIAN</name></cpp:macro>    <cpp:value>(*(char *)(&amp;totype_one)==0)</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>TOTYPE_LITTLEENDIAN</name></cpp:macro> <cpp:value>(*(char *)(&amp;totype_one)==1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Constants for the largest and smallest possible 64-bit signed integers.
** These macros are designed to work correctly on both 32-bit and 64-bit
** compilers.
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LARGEST_INT64</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>LARGEST_INT64</name></cpp:macro>   <cpp:value>(0xffffffff|(((sqlite3_int64)0x7fffffff)&lt;&lt;32))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SMALLEST_INT64</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SMALLEST_INT64</name></cpp:macro>  <cpp:value>(((sqlite3_int64)-1) - LARGEST_INT64)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Return TRUE if character c is a whitespace character
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>totypeIsspace</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>c</name><operator>==</operator><literal type="char">' '</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\t'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\n'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\v'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\f'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\r'</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if character c is a digit
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>totypeIsdigit</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Compare the 19-character string zNum against the text representation
** value 2^63:  9223372036854775808.  Return negative, zero, or positive
** if zNum is less than, equal to, or greater than the string.
** Note that zNum must contain exactly 19 characters.
**
** Unlike memcmp() this routine is guaranteed to return the difference
** in the values of the last digit if the only difference is in the
** last digit.  So, for example,
**
**      totypeCompare2pow63("9223372036854775800")
**
** will return -8.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>totypeCompare2pow63</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNum</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
                    <comment type="block">/* 012345678901234567 */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pow63</name> <init>= <expr><literal type="string">"922337203685477580"</literal></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><literal type="number">18</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name><name>zNum</name><index>[<expr><name>i</name></expr>]</index></name><operator>-</operator><name><name>pow63</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>*</operator><literal type="number">10</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>zNum</name><index>[<expr><literal type="number">18</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'8'</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert zNum to a 64-bit signed integer.
**
** If the zNum value is representable as a 64-bit twos-complement
** integer, then write that value into *pNum and return 0.
**
** If zNum is exactly 9223372036854665808, return 2.  This special
** case is broken out because while 9223372036854665808 cannot be a
** signed 64-bit integer, its negative -9223372036854665808 can be.
**
** If zNum is too big for a 64-bit integer and is not
** 9223372036854665808  or if zNum contains any non-numeric text,
** then return 1.
**
** The string is not necessarily zero-terminated.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>totypeAtoi64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zNum</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>pNum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_uint64</name></type> <name>u</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>neg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* assume positive */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nonNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStart</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><name>zNum</name> <operator>+</operator> <name>length</name></expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><name>zNum</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>totypeIsspace</name><argument_list>(<argument><expr><operator>*</operator><name>zNum</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zNum</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <if_stmt><if>if<condition>( <expr><name>zNum</name><operator>&lt;</operator><name>zEnd</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>zNum</name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>neg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>zNum</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>*</operator><name>zNum</name><operator>==</operator><literal type="char">'+'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zNum</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>zStart</name> <operator>=</operator> <name>zNum</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>zNum</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>zNum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>zNum</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while> <comment type="block">/* Skip leading zeros. */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><operator>&amp;</operator><name><name>zNum</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name><operator>=</operator><name><name>zNum</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>u</name> <operator>=</operator> <name>u</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>u</name><operator>&gt;</operator><name>LARGEST_INT64</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pNum</name> <operator>=</operator> <name>SMALLEST_INT64</name></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>neg</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pNum</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>u</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pNum</name> <operator>=</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>u</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>(</operator><name>c</name><operator>!=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>&amp;</operator><name><name>zNum</name><index>[<expr><name>i</name></expr>]</index></name><operator>&lt;</operator><name>zEnd</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>i</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>zStart</name><operator>==</operator><name>zNum</name><operator>)</operator> <operator>||</operator> <name>i</name><operator>&gt;</operator><literal type="number">19</literal> <operator>||</operator> <name>nonNum</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* zNum is empty or contains non-numeric text or is longer
    ** than 19 digits (thus guaranteeing that it is too large) */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>i</name><operator>&lt;</operator><literal type="number">19</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Less than 19 digits, so we know that it fits in 64 bits */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>u</name><operator>&lt;=</operator><name>LARGEST_INT64</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* zNum is a 19-digit numbers.  Compare it against 9223372036854775808. */</comment>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>totypeCompare2pow63</name><argument_list>(<argument><expr><name>zNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* zNum is less than 9223372036854775808 so it fits */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>u</name><operator>&lt;=</operator><name>LARGEST_INT64</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* zNum is greater than 9223372036854775808 so it overflows */</comment>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <comment type="block">/* zNum is exactly 9223372036854775808.  Fits if negative.  The
      ** special case 2 overflow if positive */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>u</name><operator>-</operator><literal type="number">1</literal><operator>==</operator><name>LARGEST_INT64</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>(</operator><operator>*</operator><name>pNum</name><operator>)</operator><operator>==</operator><name>SMALLEST_INT64</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The string z[] is an text representation of a real number.
** Convert this string to a double and write it into *pResult.
**
** The string is not necessarily zero-terminated.
**
** Return TRUE if the result is a valid real number (or integer) and FALSE
** if the string is empty or contains extraneous text.  Valid numbers
** are in one of these formats:
**
**    [+-]digits[E[+-]digits]
**    [+-]digits.[digits][E[+-]digits]
**    [+-].digits[E[+-]digits]
**
** Leading and trailing whitespace is ignored for the purpose of determining
** validity.
**
** If some prefix of the input string is a valid number, this routine
** returns FALSE but it still converts the prefix and writes the result
** into *pResult.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>totypeAtoF</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>pResult</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><name>z</name> <operator>+</operator> <name>length</name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* sign * significand * (10 ^ (esign * exponent)) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>sign</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* sign of significand */</comment>
  <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>s</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* significand */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* adjust exponent for shifting decimal point */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>esign</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* sign of exponent */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>       <comment type="block">/* exponent */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eValid</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* True exponent is either not used or is well-formed */</comment>
  <decl_stmt><decl><type><name>double</name></type> <name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDigits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nonNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>   <comment type="block">/* Default return value, in case of an error */</comment>

  <comment type="block">/* skip leading spaces */</comment>
  <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>totypeIsspace</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>&gt;=</operator><name>zEnd</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* get sign of significand */</comment>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'+'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* skip leading zeroes */</comment>
  <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'0'</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr><operator>,</operator> <expr><name>nDigits</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

  <comment type="block">/* copy max significant digits to significand */</comment>
  <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>totypeIsdigit</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>s</name><operator>&lt;</operator><operator>(</operator><operator>(</operator><name>LARGEST_INT64</name><operator>-</operator><literal type="number">9</literal><operator>)</operator><operator>/</operator><literal type="number">10</literal><operator>)</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name>s</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>z</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name><operator>++</operator></expr><operator>,</operator> <expr><name>nDigits</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* skip non-significant significand digits
  ** (increase exponent by d to shift decimal left) */</comment>
  <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>totypeIsdigit</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr><operator>,</operator> <expr><name>nDigits</name><operator>++</operator></expr><operator>,</operator> <expr><name>d</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>&gt;=</operator><name>zEnd</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>totype_atof_calc</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* if decimal point is present */</comment>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'.'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
    <comment type="block">/* copy digits from after decimal to significand
    ** (decrease exponent by d to shift decimal right) */</comment>
    <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>totypeIsdigit</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>s</name><operator>&lt;</operator><operator>(</operator><operator>(</operator><name>LARGEST_INT64</name><operator>-</operator><literal type="number">9</literal><operator>)</operator><operator>/</operator><literal type="number">10</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>s</name> <operator>=</operator> <name>s</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>z</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name><operator>++</operator></expr><operator>,</operator> <expr><name>nDigits</name><operator>++</operator></expr><operator>,</operator> <expr><name>d</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <comment type="block">/* skip non-significant digits */</comment>
    <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>totypeIsdigit</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr><operator>,</operator> <expr><name>nDigits</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>&gt;=</operator><name>zEnd</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>totype_atof_calc</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* if exponent is present */</comment>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'e'</literal> <operator>||</operator> <operator>*</operator><name>z</name><operator>==</operator><literal type="char">'E'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>eValid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>z</name><operator>&gt;=</operator><name>zEnd</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>totype_atof_calc</name>;</goto></block_content></block></if></if_stmt>
    <comment type="block">/* get sign of exponent */</comment>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>esign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><operator>*</operator><name>z</name><operator>==</operator><literal type="char">'+'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* copy digits to exponent */</comment>
    <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>totypeIsdigit</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>e</name> <operator>=</operator> <ternary><condition><expr><name>e</name><operator>&lt;</operator><literal type="number">10000</literal></expr> ?</condition><then> <expr><operator>(</operator><name>e</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>z</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator><operator>)</operator></expr> </then><else>: <expr><literal type="number">10000</literal></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>eValid</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* skip trailing spaces */</comment>
  <if_stmt><if>if<condition>( <expr><name>nDigits</name> <operator>&amp;&amp;</operator> <name>eValid</name></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><name>z</name><operator>&lt;</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <call><name>totypeIsspace</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>z</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  </block_content>}</block></if></if_stmt>

<label><name>totype_atof_calc</name>:</label>
  <comment type="block">/* adjust exponent by d, and update sign */</comment>
  <expr_stmt><expr><name>e</name> <operator>=</operator> <operator>(</operator><name>e</name><operator>*</operator><name>esign</name><operator>)</operator> <operator>+</operator> <name>d</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>e</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition> <block>{<block_content>
    <expr_stmt><expr><name>esign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>e</name> <operator>*=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>esign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* if 0 significand */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>s</name></expr> )</condition> <block>{<block_content>
    <comment type="block">/* In the IEEE 754 standard, zero is signed.
    ** Add the sign if we've seen at least one digit */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>sign</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nDigits</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><operator>(</operator><name>double</name><operator>)</operator><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>double</name><operator>)</operator><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* attempt to reduce exponent */</comment>
    <if_stmt><if>if<condition>( <expr><name>esign</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <while>while<condition>( <expr><name><name>s</name><argument_list type="generic">&lt;<argument><expr><operator>(</operator><name>LARGEST_INT64</name><operator>/</operator><literal type="number">10</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>e</name></expr></argument>&gt;</argument_list></name><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>e</name><operator>--</operator></expr><operator>,</operator><expr><name>s</name><operator>*=</operator><literal type="number">10</literal></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></if><else>else<block>{<block_content>
      <while>while<condition>( <expr><operator>!</operator><operator>(</operator><name>s</name><operator>%</operator><literal type="number">10</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>e</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>e</name><operator>--</operator></expr><operator>,</operator><expr><name>s</name><operator>/=</operator><literal type="number">10</literal></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* adjust the sign of significand */</comment>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <ternary><condition><expr><name>sign</name><operator>&lt;</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><name>s</name></expr> </then><else>: <expr><name>s</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* if exponent, scale significand as appropriate
    ** and store in result. */</comment>
    <if_stmt><if>if<condition>( <expr><name>e</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>double</name></type> <name>scale</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
      <comment type="block">/* attempt to handle extremely small/large numbers better */</comment>
      <if_stmt><if>if<condition>( <expr><name>e</name><operator>&gt;</operator><literal type="number">307</literal> <operator>&amp;&amp;</operator> <name>e</name><operator>&lt;</operator><literal type="number">342</literal></expr> )</condition><block>{<block_content>
        <while>while<condition>( <expr><name>e</name><operator>%</operator><literal type="number">308</literal></expr> )</condition> <block>{<block_content> <expr_stmt><expr><name>scale</name> <operator>*=</operator> <literal type="number">1.0e+1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>e</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt> </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><name>esign</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>s</name> <operator>/</operator> <name>scale</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>result</name> <operator>/=</operator> <literal type="number">1.0e+308</literal></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>s</name> <operator>*</operator> <name>scale</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>result</name> <operator>*=</operator> <literal type="number">1.0e+308</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>e</name><operator>&gt;=</operator><literal type="number">342</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>esign</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0.0</literal><operator>*</operator><name>s</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1e308</literal><operator>*</operator><literal type="number">1e308</literal><operator>*</operator><name>s</name></expr>;</expr_stmt>  <comment type="block">/* Infinity */</comment>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* 1.0e+22 is the largest power of 10 than can be
        ** represented exactly. */</comment>
        <while>while<condition>( <expr><name>e</name><operator>%</operator><literal type="number">22</literal></expr> )</condition> <block>{<block_content> <expr_stmt><expr><name>scale</name> <operator>*=</operator> <literal type="number">1.0e+1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>e</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt> </block_content>}</block></while>
        <while>while<condition>( <expr><name>e</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition> <block>{<block_content> <expr_stmt><expr><name>scale</name> <operator>*=</operator> <literal type="number">1.0e+22</literal></expr>;</expr_stmt> <expr_stmt><expr><name>e</name> <operator>-=</operator> <literal type="number">22</literal></expr>;</expr_stmt> </block_content>}</block></while>
        <if_stmt><if>if<condition>( <expr><name>esign</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>s</name> <operator>/</operator> <name>scale</name></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><name>result</name> <operator>=</operator> <name>s</name> <operator>*</operator> <name>scale</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name>s</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* store the result */</comment>
  <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

  <comment type="block">/* return true if number and no extra non-whitespace chracters after */</comment>
  <return>return <expr><name>z</name><operator>&gt;=</operator><name>zEnd</name> <operator>&amp;&amp;</operator> <name>nDigits</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>eValid</name> <operator>&amp;&amp;</operator> <name>nonNum</name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** tointeger(X):  If X is any value (integer, double, blob, or string) that
** can be losslessly converted into an integer, then make the conversion and
** return the result.  Otherwise, return NULL.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>tointegerFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argc</name></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>double</name></type> <name>rVal</name> <init>= <expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iVal</name> <init>= <expr><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>rVal</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>rVal</name><operator>==</operator><operator>(</operator><name>double</name><operator>)</operator><name>iVal</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_BLOB</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zBlob</name> <init>= <expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zBlob</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nBlob</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>nBlob</name><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_int64</name></expr></argument>)</argument_list></sizeof></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iVal</name></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>TOTYPE_BIGENDIAN</name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zBlobRev</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_int64</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
            <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_int64</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
              <expr_stmt><expr><name><name>zBlobRev</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>zBlob</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_int64</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iVal</name></expr></argument>, <argument><expr><name>zBlobRev</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_int64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iVal</name></expr></argument>, <argument><expr><name>zBlob</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_int64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_TEXT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zStr</name> <init>= <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zStr</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nStr</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>nStr</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>totypeIsspace</name><argument_list>(<argument><expr><name><name>zStr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iVal</name></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>totypeAtoi64</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>zStr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iVal</name></expr></argument>, <argument><expr><name>nStr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_result_int64</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>iVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** toreal(X): If X is any value (integer, double, blob, or string) that can
** be losslessly converted into a real number, then do so and return that
** real number.  Otherwise return NULL.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name> <name>4748</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>optimize</name><name>(</name><cpp:literal>""</cpp:literal><name>,</name> <name>off</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>void</name></type> <name>torealFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argc</name></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_FLOAT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>sqlite3_value_double</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>iVal</name> <init>= <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>double</name></type> <name>rVal</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator><name>iVal</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>iVal</name><operator>==</operator><operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>rVal</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>rVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_BLOB</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zBlob</name> <init>= <expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zBlob</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nBlob</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>nBlob</name><operator>==</operator><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>double</name></type> <name>rVal</name></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>TOTYPE_LITTLEENDIAN</name></expr> )</condition><block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zBlobRev</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
            <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
              <expr_stmt><expr><name><name>zBlobRev</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>zBlob</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rVal</name></expr></argument>, <argument><expr><name>zBlobRev</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rVal</name></expr></argument>, <argument><expr><name>zBlob</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>rVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>SQLITE_TEXT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zStr</name> <init>= <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>zStr</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nStr</name> <init>= <expr><call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if<condition>( <expr><name>nStr</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>totypeIsspace</name><argument_list>(<argument><expr><name><name>zStr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>totypeIsspace</name><argument_list>(<argument><expr><name><name>zStr</name><index>[<expr><name>nStr</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>double</name></type> <name>rVal</name></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><call><name>totypeAtoF</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>zStr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rVal</name></expr></argument>, <argument><expr><name>nStr</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>sqlite3_result_double</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>rVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>optimize</name><name>(</name><cpp:literal>""</cpp:literal><name>,</name> <name>on</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>default</name><name>:</name> <name>4748</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_totype_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument><expr><name>pApi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pzErrMsg</name></expr>;</expr_stmt>  <comment type="block">/* Unused parameter */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"tointeger"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                               <argument><expr><name>tointegerFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_create_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"toreal"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                 <argument><expr><name>torealFunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
</unit>
