<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/ext/fts2/fts2.c"><comment type="block">/* fts2 has a design flaw which can lead to database corruption (see
** below).  It is recommended not to use it any longer, instead use
** fts3 (or higher).  If you believe that your use of fts2 is safe,
** add -DSQLITE_ENABLE_BROKEN_FTS2=1 to your CFLAGS.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_CORE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_FTS2</name></expr></argument>)</argument_list></call><operator>)</operator> \
        <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_BROKEN_FTS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> fts2 has a design flaw and has been deprecated.</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* The flaw is that fts2 uses the content table's unaliased rowid as
** the unique docid.  fts2 embeds the rowid in the index it builds,
** and expects the rowid to not change.  The SQLite VACUUM operation
** will renumber such rowids, thereby breaking fts2.  If you are using
** fts2 in a system which has disabled VACUUM, then you can continue
** to use it safely.  Note that PRAGMA auto_vacuum does NOT disable
** VACUUM, though systems using auto_vacuum are unlikely to invoke
** VACUUM.
**
** Unlike fts1, which is safe across VACUUM if you never delete
** documents, fts2 has a second exposure to this flaw, in the segments
** table.  So fts2 should be considered unsafe across VACUUM in all
** cases.
*/</comment>

<comment type="block">/*
** 2006 Oct 10
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This is an SQLite module implementing full-text search.
*/</comment>

<comment type="block">/*
** The code in this file is only compiled if:
**
**     * The FTS2 module is being built as an extension
**       (in which case SQLITE_CORE is not defined), or
**
**     * The FTS2 module is being built into the core of
**       SQLite (in which case SQLITE_ENABLE_FTS2 is defined).
*/</comment>

<comment type="block">/* TODO(shess) Consider exporting this comment to an HTML file or the
** wiki.
*/</comment>
<comment type="block">/* The full-text index is stored in a series of b+tree (-like)
** structures called segments which map terms to doclists.  The
** structures are like b+trees in layout, but are constructed from the
** bottom up in optimal fashion and are not updatable.  Since trees
** are built from the bottom up, things will be described from the
** bottom up.
**
**
**** Varints ****
** The basic unit of encoding is a variable-length integer called a
** varint.  We encode variable-length integers in little-endian order
** using seven bits * per byte as follows:
**
** KEY:
**         A = 0xxxxxxx    7 bits of data and one flag bit
**         B = 1xxxxxxx    7 bits of data and one flag bit
**
**  7 bits - A
** 14 bits - BA
** 21 bits - BBA
** and so on.
**
** This is identical to how sqlite encodes varints (see util.c).
**
**
**** Document lists ****
** A doclist (document list) holds a docid-sorted list of hits for a
** given term.  Doclists hold docids, and can optionally associate
** token positions and offsets with docids.
**
** A DL_POSITIONS_OFFSETS doclist is stored like this:
**
** array {
**   varint docid;
**   array {                (position list for column 0)
**     varint position;     (delta from previous position plus POS_BASE)
**     varint startOffset;  (delta from previous startOffset)
**     varint endOffset;    (delta from startOffset)
**   }
**   array {
**     varint POS_COLUMN;   (marks start of position list for new column)
**     varint column;       (index of new column)
**     array {
**       varint position;   (delta from previous position plus POS_BASE)
**       varint startOffset;(delta from previous startOffset)
**       varint endOffset;  (delta from startOffset)
**     }
**   }
**   varint POS_END;        (marks end of positions for this document.
** }
**
** Here, array { X } means zero or more occurrences of X, adjacent in
** memory.  A "position" is an index of a token in the token stream
** generated by the tokenizer, while an "offset" is a byte offset,
** both based at 0.  Note that POS_END and POS_COLUMN occur in the
** same logical place as the position element, and act as sentinals
** ending a position list array.
**
** A DL_POSITIONS doclist omits the startOffset and endOffset
** information.  A DL_DOCIDS doclist omits both the position and
** offset information, becoming an array of varint-encoded docids.
**
** On-disk data is stored as type DL_DEFAULT, so we don't serialize
** the type.  Due to how deletion is implemented in the segmentation
** system, on-disk doclists MUST store at least positions.
**
**
**** Segment leaf nodes ****
** Segment leaf nodes store terms and doclists, ordered by term.  Leaf
** nodes are written using LeafWriter, and read using LeafReader (to
** iterate through a single leaf node's data) and LeavesReader (to
** iterate through a segment's entire leaf layer).  Leaf nodes have
** the format:
**
** varint iHeight;             (height from leaf level, always 0)
** varint nTerm;               (length of first term)
** char pTerm[nTerm];          (content of first term)
** varint nDoclist;            (length of term's associated doclist)
** char pDoclist[nDoclist];    (content of doclist)
** array {
**                             (further terms are delta-encoded)
**   varint nPrefix;           (length of prefix shared with previous term)
**   varint nSuffix;           (length of unshared suffix)
**   char pTermSuffix[nSuffix];(unshared suffix of next term)
**   varint nDoclist;          (length of term's associated doclist)
**   char pDoclist[nDoclist];  (content of doclist)
** }
**
** Here, array { X } means zero or more occurrences of X, adjacent in
** memory.
**
** Leaf nodes are broken into blocks which are stored contiguously in
** the %_segments table in sorted order.  This means that when the end
** of a node is reached, the next term is in the node with the next
** greater node id.
**
** New data is spilled to a new leaf node when the current node
** exceeds LEAF_MAX bytes (default 2048).  New data which itself is
** larger than STANDALONE_MIN (default 1024) is placed in a standalone
** node (a leaf node with a single term and doclist).  The goal of
** these settings is to pack together groups of small doclists while
** making it efficient to directly access large doclists.  The
** assumption is that large doclists represent terms which are more
** likely to be query targets.
**
** TODO(shess) It may be useful for blocking decisions to be more
** dynamic.  For instance, it may make more sense to have a 2.5k leaf
** node rather than splitting into 2k and .5k nodes.  My intuition is
** that this might extend through 2x or 4x the pagesize.
**
**
**** Segment interior nodes ****
** Segment interior nodes store blockids for subtree nodes and terms
** to describe what data is stored by the each subtree.  Interior
** nodes are written using InteriorWriter, and read using
** InteriorReader.  InteriorWriters are created as needed when
** SegmentWriter creates new leaf nodes, or when an interior node
** itself grows too big and must be split.  The format of interior
** nodes:
**
** varint iHeight;           (height from leaf level, always &gt;0)
** varint iBlockid;          (block id of node's leftmost subtree)
** optional {
**   varint nTerm;           (length of first term)
**   char pTerm[nTerm];      (content of first term)
**   array {
**                                (further terms are delta-encoded)
**     varint nPrefix;            (length of shared prefix with previous term)
**     varint nSuffix;            (length of unshared suffix)
**     char pTermSuffix[nSuffix]; (unshared suffix of next term)
**   }
** }
**
** Here, optional { X } means an optional element, while array { X }
** means zero or more occurrences of X, adjacent in memory.
**
** An interior node encodes n terms separating n+1 subtrees.  The
** subtree blocks are contiguous, so only the first subtree's blockid
** is encoded.  The subtree at iBlockid will contain all terms less
** than the first term encoded (or all terms if no term is encoded).
** Otherwise, for terms greater than or equal to pTerm[i] but less
** than pTerm[i+1], the subtree for that term will be rooted at
** iBlockid+i.  Interior nodes only store enough term data to
** distinguish adjacent children (if the rightmost term of the left
** child is "something", and the leftmost term of the right child is
** "wicked", only "w" is stored).
**
** New data is spilled to a new interior node at the same height when
** the current node exceeds INTERIOR_MAX bytes (default 2048).
** INTERIOR_MIN_TERMS (default 7) keeps large terms from monopolizing
** interior nodes and making the tree too skinny.  The interior nodes
** at a given height are naturally tracked by interior nodes at
** height+1, and so on.
**
**
**** Segment directory ****
** The segment directory in table %_segdir stores meta-information for
** merging and deleting segments, and also the root node of the
** segment's tree.
**
** The root node is the top node of the segment's tree after encoding
** the entire segment, restricted to ROOT_MAX bytes (default 1024).
** This could be either a leaf node or an interior node.  If the top
** node requires more than ROOT_MAX bytes, it is flushed to %_segments
** and a new root interior node is generated (which should always fit
** within ROOT_MAX because it only needs space for 2 varints, the
** height and the blockid of the previous root).
**
** The meta-information in the segment directory is:
**   level               - segment level (see below)
**   idx                 - index within level
**                       - (level,idx uniquely identify a segment)
**   start_block         - first leaf node
**   leaves_end_block    - last leaf node
**   end_block           - last block (including interior nodes)
**   root                - contents of root node
**
** If the root node is a leaf node, then start_block,
** leaves_end_block, and end_block are all 0.
**
**
**** Segment merging ****
** To amortize update costs, segments are groups into levels and
** merged in matches.  Each increase in level represents exponentially
** more documents.
**
** New documents (actually, document updates) are tokenized and
** written individually (using LeafWriter) to a level 0 segment, with
** incrementing idx.  When idx reaches MERGE_COUNT (default 16), all
** level 0 segments are merged into a single level 1 segment.  Level 1
** is populated like level 0, and eventually MERGE_COUNT level 1
** segments are merged to a single level 2 segment (representing
** MERGE_COUNT^2 updates), and so on.
**
** A segment merge traverses all segments at a given level in
** parallel, performing a straightforward sorted merge.  Since segment
** leaf nodes are written in to the %_segments table in order, this
** merge traverses the underlying sqlite disk structures efficiently.
** After the merge, all segment blocks from the merged level are
** deleted.
**
** MERGE_COUNT controls how often we merge segments.  16 seems to be
** somewhat of a sweet spot for insertion performance.  32 and 64 show
** very similar performance numbers to 16 on insertion, though they're
** a tiny bit slower (perhaps due to more overhead in merge-time
** sorting).  8 is about 20% slower than 16, 4 about 50% slower than
** 16, 2 about 66% slower than 16.
**
** At query time, high MERGE_COUNT increases the number of segments
** which need to be scanned and merged.  For instance, with 100k docs
** inserted:
**
**    MERGE_COUNT   segments
**       16           25
**        8           12
**        4           10
**        2            6
**
** This appears to have only a moderate impact on queries for very
** frequent terms (which are somewhat dominated by segment merge
** costs), and infrequent and non-existent terms still seem to be fast
** even with many segments.
**
** TODO(shess) That said, it would be nice to have a better query-side
** argument for MERGE_COUNT of 16.  Also, it is possible/likely that
** optimizations to things like doclist merging will swing the sweet
** spot around.
**
**
**
**** Handling of deletions and updates ****
** Since we're using a segmented structure, with no docid-oriented
** index into the term index, we clearly cannot simply update the term
** index when a document is deleted or updated.  For deletions, we
** write an empty doclist (varint(docid) varint(POS_END)), for updates
** we simply write the new doclist.  Segment merges overwrite older
** data for a particular docid with newer data, so deletes or updates
** will eventually overtake the earlier data and knock it out.  The
** query logic likewise merges doclists so that newer data knocks out
** older data.
**
** TODO(shess) Provide a VACUUM type operation to clear out all
** deletions and duplications.  This would basically be a forced merge
** into a single segment.
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_CORE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_FTS2</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_FTS2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_CORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_CORE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fts2.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fts2_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fts2_tokenizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3ext.h"</cpp:file></cpp:include>
<function><type><name>SQLITE_EXTENSION_INIT1</name>


<comment type="block">/* TODO(shess) MAN, this thing needs some refactoring.  At minimum, it
** would be nice to order the file better, perhaps something along the
** lines of:
**
**  - utility functions
**  - table setup functions
**  - table update functions
**  - table query functions
**
** Put the query functions last because they're likely to reference
** typedefs or functions from the table update section.
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>TRACE</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>printf A; fflush(stdout)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>TRACE</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* It is not safe to call isspace(), tolower(), or isalnum() on
** hi-bit-set characters.  This is the same solution used in the
** tokenizer.
*/</comment>
<comment type="block">/* TODO(shess) The snippet-generation code should be using the
** tokenizer-generated tokens rather than doing its own local
** tokenization.
*/</comment>
<comment type="block">/* TODO(shess) Is __isascii() a portable version of (c&amp;0x80)==0? */</comment>
<specifier>static</specifier> <name>int</name></type> <name>safe_isspace</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name>c</name><operator>==</operator><literal type="char">' '</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\t'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\n'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\r'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\v'</literal> <operator>||</operator> <name>c</name><operator>==</operator><literal type="char">'\f'</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>safe_tolower</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'Z'</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>c</name> <operator>-</operator> <literal type="char">'A'</literal> <operator>+</operator> <literal type="char">'a'</literal><operator>)</operator></expr> </then><else>: <expr><name>c</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>safe_isalnum</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'9'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'Z'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>c</name><operator>&gt;=</operator><literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name><operator>&lt;=</operator><literal type="char">'z'</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><enum>enum <name>DocListType</name> <block>{
  <decl><name>DL_DOCIDS</name></decl>,              <comment type="block">/* docids only */</comment>
  <decl><name>DL_POSITIONS</name></decl>,           <comment type="block">/* docids + positions */</comment>
  <decl><name>DL_POSITIONS_OFFSETS</name></decl>    <comment type="block">/* docids + positions + offsets */</comment>
}</block></enum></type> <name>DocListType</name>;</typedef>

<comment type="block">/*
** By default, only positions and not offsets are stored in the doclists.
** To change this so that offsets are stored too, compile with
**
**          -DDL_DEFAULT=DL_POSITIONS_OFFSETS
**
** If DL_DEFAULT is set to DL_DOCIDS, your table can only be inserted
** into (no deletes or updates).
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DL_DEFAULT</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>DL_DEFAULT</name></cpp:macro> <cpp:value>DL_POSITIONS</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<enum>enum <block>{
  <decl><name>POS_END</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,        <comment type="block">/* end of this position list */</comment>
  <decl><name>POS_COLUMN</name></decl>,         <comment type="block">/* followed by new column number */</comment>
  <decl><name>POS_BASE</name></decl>
}</block>;</enum>

<comment type="block">/* MERGE_COUNT controls how often we merge segments (see comment at
** top of file).
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MERGE_COUNT</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<comment type="block">/* utility functions */</comment>

<comment type="block">/* CLEAR() and SCRAMBLE() abstract memset() on a pointer to a single
** record to prevent errors of the form:
**
** my_function(SomeType *b){
**   memset(b, '\0', sizeof(b));  // sizeof(b)!=sizeof(*b)
** }
*/</comment>
<comment type="block">/* TODO(shess) Obvious candidates for a header file. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLEAR</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memset(b, '\0', sizeof(*(b)))</cpp:value></cpp:define>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SCRAMBLE</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memset(b, 0x55, sizeof(*(b)))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>SCRAMBLE</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* We may need up to VARINT_MAX bytes to store an encoded 64-bit integer. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARINT_MAX</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<comment type="block">/* Write a 64-bit variable-length integer to memory starting at p[0].
 * The length of data written will be between 1 and VARINT_MAX bytes.
 * The number of bytes written is returned. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>putVarint</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_uint64</name></type> <name>vu</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>vu</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>vu</name> <operator>&gt;&gt;=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>vu</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition>;</do>
  <expr_stmt><expr><name><name>q</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>  <comment type="block">/* turn off high bit in final byte */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>q</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>&lt;=</operator> <name>VARINT_MAX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>q</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Read a 64-bit variable-length integer from memory starting at p[0].
 * Return the number of bytes read, or 0 on error.
 * The value is stored in *v. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getVarint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_uint64</name></type> <name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>y</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><operator>(</operator><operator>*</operator><name>q</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>x</name> <operator>+=</operator> <name>y</name> <operator>*</operator> <operator>(</operator><operator>*</operator><name>q</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>y</name> <operator>&lt;&lt;=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>q</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>&gt;=</operator> <name>VARINT_MAX</name></expr> )</condition><block>{<block_content>  <comment type="block">/* bad data */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>x</name> <operator>+=</operator> <name>y</name> <operator>*</operator> <operator>(</operator><operator>*</operator><name>q</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>(</operator><name>sqlite_int64</name><operator>)</operator> <name>x</name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>q</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>getVarint32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pi</name></decl></parameter>)</parameter_list><block>{<block_content>
 <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>i</name></decl>;</decl_stmt>
 <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>getVarint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
 <expr_stmt><expr><operator>*</operator><name>pi</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>i</name></expr>;</expr_stmt>
 <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pi</name><operator>==</operator><name>i</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
 <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*******************************************************************/</comment>
<comment type="block">/* DataBuffer is used to collect data into a buffer in piecemeal
** fashion.  It implements the usual distinction between amount of
** data currently stored (nData) and buffer capacity (nCapacity).
**
** dataBufferInit - create a buffer with given initial capacity.
** dataBufferReset - forget buffer's data, retaining capacity.
** dataBufferDestroy - free buffer's data.
** dataBufferSwap - swap contents of two buffers.
** dataBufferExpand - expand capacity without adding data.
** dataBufferAppend - append data.
** dataBufferAppend2 - append two pieces of data at once.
** dataBufferReplace - replace buffer's data.
*/</comment>
<typedef>typedef <type><struct>struct <name>DataBuffer</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>          <comment type="block">/* Pointer to malloc'ed buffer. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nCapacity</name></decl>;</decl_stmt>        <comment type="block">/* Size of pData buffer. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>            <comment type="block">/* End of data loaded into pData. */</comment>
}</block></struct></type> <name>DataBuffer</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dataBufferInit</name><parameter_list>(<parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>pBuffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nCapacity</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nCapacity</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBuffer</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBuffer</name><operator>-&gt;</operator><name>nCapacity</name></name> <operator>=</operator> <name>nCapacity</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBuffer</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <ternary><condition><expr><name>nCapacity</name><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nCapacity</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dataBufferReset</name><parameter_list>(<parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>pBuffer</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pBuffer</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dataBufferDestroy</name><parameter_list>(<parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>pBuffer</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pBuffer</name><operator>-&gt;</operator><name>pData</name></name><operator>!=</operator><name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pBuffer</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>SCRAMBLE</name><argument_list>(<argument><expr><name>pBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dataBufferSwap</name><parameter_list>(<parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>pBuffer1</name></decl></parameter>, <parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>pBuffer2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DataBuffer</name></type> <name>tmp</name> <init>= <expr><operator>*</operator><name>pBuffer1</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>pBuffer1</name> <operator>=</operator> <operator>*</operator><name>pBuffer2</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pBuffer2</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dataBufferExpand</name><parameter_list>(<parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>pBuffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nAddCapacity</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nAddCapacity</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* TODO(shess) Consider expanding more aggressively.  Note that the
  ** underlying malloc implementation may take care of such things for
  ** us already.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pBuffer</name><operator>-&gt;</operator><name>nData</name></name><operator>+</operator><name>nAddCapacity</name><operator>&gt;</operator><name><name>pBuffer</name><operator>-&gt;</operator><name>nCapacity</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pBuffer</name><operator>-&gt;</operator><name>nCapacity</name></name> <operator>=</operator> <name><name>pBuffer</name><operator>-&gt;</operator><name>nData</name></name><operator>+</operator><name>nAddCapacity</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pBuffer</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name><name>pBuffer</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>pBuffer</name><operator>-&gt;</operator><name>nCapacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dataBufferAppend</name><parameter_list>(<parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>pBuffer</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pSource</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nSource</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nSource</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pSource</name><operator>!=</operator><name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dataBufferExpand</name><argument_list>(<argument><expr><name>pBuffer</name></expr></argument>, <argument><expr><name>nSource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pBuffer</name><operator>-&gt;</operator><name>pData</name></name><operator>+</operator><name><name>pBuffer</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>, <argument><expr><name>pSource</name></expr></argument>, <argument><expr><name>nSource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBuffer</name><operator>-&gt;</operator><name>nData</name></name> <operator>+=</operator> <name>nSource</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dataBufferAppend2</name><parameter_list>(<parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>pBuffer</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pSource1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nSource1</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pSource2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nSource2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nSource1</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pSource1</name><operator>!=</operator><name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nSource2</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pSource2</name><operator>!=</operator><name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dataBufferExpand</name><argument_list>(<argument><expr><name>pBuffer</name></expr></argument>, <argument><expr><name>nSource1</name><operator>+</operator><name>nSource2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pBuffer</name><operator>-&gt;</operator><name>pData</name></name><operator>+</operator><name><name>pBuffer</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>, <argument><expr><name>pSource1</name></expr></argument>, <argument><expr><name>nSource1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pBuffer</name><operator>-&gt;</operator><name>pData</name></name><operator>+</operator><name><name>pBuffer</name><operator>-&gt;</operator><name>nData</name></name><operator>+</operator><name>nSource1</name></expr></argument>, <argument><expr><name>pSource2</name></expr></argument>, <argument><expr><name>nSource2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pBuffer</name><operator>-&gt;</operator><name>nData</name></name> <operator>+=</operator> <name>nSource1</name><operator>+</operator><name>nSource2</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dataBufferReplace</name><parameter_list>(<parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>pBuffer</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pSource</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nSource</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>dataBufferReset</name><argument_list>(<argument><expr><name>pBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><name>pBuffer</name></expr></argument>, <argument><expr><name>pSource</name></expr></argument>, <argument><expr><name>nSource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* StringBuffer is a null-terminated version of DataBuffer. */</comment>
<typedef>typedef <type><struct>struct <name>StringBuffer</name> <block>{
  <decl_stmt><decl><type><name>DataBuffer</name></type> <name>b</name></decl>;</decl_stmt>            <comment type="block">/* Includes null terminator. */</comment>
}</block></struct></type> <name>StringBuffer</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>initStringBuffer</name><parameter_list>(<parameter><decl><type><name>StringBuffer</name> <modifier>*</modifier></type><name>sb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dataBufferReplace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>stringBufferLength</name><parameter_list>(<parameter><decl><type><name>StringBuffer</name> <modifier>*</modifier></type><name>sb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>sb</name><operator>-&gt;</operator><name>b</name><operator>.</operator><name>nData</name></name><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>stringBufferData</name><parameter_list>(<parameter><decl><type><name>StringBuffer</name> <modifier>*</modifier></type><name>sb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>sb</name><operator>-&gt;</operator><name>b</name><operator>.</operator><name>pData</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>stringBufferDestroy</name><parameter_list>(<parameter><decl><type><name>StringBuffer</name> <modifier>*</modifier></type><name>sb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>nappend</name><parameter_list>(<parameter><decl><type><name>StringBuffer</name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFrom</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nFrom</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>sb</name><operator>-&gt;</operator><name>b</name><operator>.</operator><name>nData</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nFrom</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>b</name><operator>.</operator><name>nData</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dataBufferAppend2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sb</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>zFrom</name></expr></argument>, <argument><expr><name>nFrom</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><name>StringBuffer</name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFrom</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>nappend</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>zFrom</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>zFrom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Append a list of strings separated by commas. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>appendList</name><parameter_list>(<parameter><decl><type><name>StringBuffer</name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nString</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azString</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nString</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name><name>azString</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>endsInWhiteSpace</name><parameter_list>(<parameter><decl><type><name>StringBuffer</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>stringBufferLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator>
    <call><name>safe_isspace</name><argument_list>(<argument><expr><call><name>stringBufferData</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><index>[<expr><call><name>stringBufferLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* If the StringBuffer ends in something other than white space, add a
** single space character to the end.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>appendWhiteSpace</name><parameter_list>(<parameter><decl><type><name>StringBuffer</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>stringBufferLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>endsInWhiteSpace</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Remove white space from the end of the StringBuffer */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>trimWhiteSpace</name><parameter_list>(<parameter><decl><type><name>StringBuffer</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><call><name>endsInWhiteSpace</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>b</name><operator>.</operator><name>pData</name><index>[<expr><operator>--</operator><name><name>p</name><operator>-&gt;</operator><name>b</name><operator>.</operator><name>nData</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*******************************************************************/</comment>
<comment type="block">/* DLReader is used to read document elements from a doclist.  The
** current docid is cached, so dlrDocid() is fast.  DLReader does not
** own the doclist buffer.
**
** dlrAtEnd - true if there's no more data to read.
** dlrDocid - docid of current document.
** dlrDocData - doclist data for current document (including docid).
** dlrDocDataBytes - length of same.
** dlrAllDataBytes - length of all remaining data.
** dlrPosData - position data for current document.
** dlrPosDataLen - length of pos data for current document (incl POS_END).
** dlrStep - step to current document.
** dlrInit - initial for doclist of given type against given data.
** dlrDestroy - clean up.
**
** Expected usage is something like:
**
**   DLReader reader;
**   dlrInit(&amp;reader, pData, nData);
**   while( !dlrAtEnd(&amp;reader) ){
**     // calls to dlrDocid() and kin.
**     dlrStep(&amp;reader);
**   }
**   dlrDestroy(&amp;reader);
*/</comment>
<typedef>typedef <type><struct>struct <name>DLReader</name> <block>{
  <decl_stmt><decl><type><name>DocListType</name></type> <name>iType</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nElement</name></decl>;</decl_stmt>
}</block></struct></type> <name>DLReader</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type> <name>dlrAtEnd</name><parameter_list>(<parameter><decl><type><name>DLReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>sqlite_int64</name></type> <name>dlrDocid</name><parameter_list>(<parameter><decl><type><name>DLReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>iDocid</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dlrDocData</name><parameter_list>(<parameter><decl><type><name>DLReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dlrDocDataBytes</name><parameter_list>(<parameter><decl><type><name>DLReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>nElement</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dlrAllDataBytes</name><parameter_list>(<parameter><decl><type><name>DLReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* TODO(shess) Consider adding a field to track iDocid varint length
** to make these two functions faster.  This might matter (a tiny bit)
** for queries.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dlrPosData</name><parameter_list>(<parameter><decl><type><name>DLReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iDummy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>getVarint</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name><operator>+</operator><name>n</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dlrPosDataLen</name><parameter_list>(<parameter><decl><type><name>DLReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iDummy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>getVarint</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>nElement</name></name><operator>-</operator><name>n</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dlrStep</name><parameter_list>(<parameter><decl><type><name>DLReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Skip past current doclist element. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>nElement</name></name><operator>&lt;=</operator><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name> <operator>+=</operator> <name><name>pReader</name><operator>-&gt;</operator><name>nElement</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name> <operator>-=</operator> <name><name>pReader</name><operator>-&gt;</operator><name>nElement</name></name></expr>;</expr_stmt>

  <comment type="block">/* If there is more data, read the next doclist element. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iDocidDelta</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iDummy</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name>getVarint</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDocidDelta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>+=</operator> <name>iDocidDelta</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pReader</name><operator>-&gt;</operator><name>iType</name></name><operator>&gt;=</operator><name>DL_POSITIONS</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;</operator><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;=</operator><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iDummy</name><operator>==</operator><name>POS_END</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>iDummy</name><operator>==</operator><name>POS_COLUMN</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;</operator><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>pReader</name><operator>-&gt;</operator><name>iType</name></name><operator>==</operator><name>DL_POSITIONS_OFFSETS</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;</operator><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nElement</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>nElement</name></name><operator>&lt;=</operator><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dlrInit</name><parameter_list>(<parameter><decl><type><name>DLReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>, <parameter><decl><type><name>DocListType</name></type> <name>iType</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pData</name><operator>!=</operator><name>NULL</name> <operator>&amp;&amp;</operator> <name>nData</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iType</name></name> <operator>=</operator> <name>iType</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <name>pData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <name>nData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nElement</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iDocid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Load the first element's data.  There must be a first element. */</comment>
  <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dlrDestroy</name><parameter_list>(<parameter><decl><type><name>DLReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>SCRAMBLE</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/* Verify that the doclist can be validly decoded.  Also returns the
** last docid found because it is convenient in other assertions for
** DLWriter.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListValidate</name><parameter_list>(<parameter><decl><type><name>DocListType</name></type> <name>iType</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>,
                            <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pLastDocid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iPrevDocid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nData</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pData</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pData</name><operator>+</operator><name>nData</name><operator>&gt;</operator><name>pData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>nData</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iDocidDelta</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>getVarint</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDocidDelta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>iPrevDocid</name> <operator>+=</operator> <name>iDocidDelta</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iType</name><operator>&gt;</operator><name>DL_DOCIDS</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iDummy</name></decl>;</decl_stmt>
      <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>pData</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>iDummy</name><operator>==</operator><name>POS_END</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>iDummy</name><operator>==</operator><name>POS_COLUMN</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>pData</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iType</name><operator>&gt;</operator><name>DL_POSITIONS</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>pData</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>pData</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;=</operator><name>nData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;=</operator><name>nData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pData</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nData</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>pLastDocid</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pLastDocid</name> <operator>=</operator> <name>iPrevDocid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_VALID_DOCLIST</name><parameter_list>(<parameter><type><name>i</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>docListValidate(i, p, n, o)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_VALID_DOCLIST</name><parameter_list>(<parameter><type><name>i</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>assert( 1 )</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*******************************************************************/</comment>
<comment type="block">/* DLWriter is used to write doclist data to a DataBuffer.  DLWriter
** always appends to the buffer and does not own it.
**
** dlwInit - initialize to write a given type doclistto a buffer.
** dlwDestroy - clear the writer's memory.  Does not free buffer.
** dlwAppend - append raw doclist data to buffer.
** dlwCopy - copy next doclist from reader to writer.
** dlwAdd - construct doclist element and append to buffer.
**    Only apply dlwAdd() to DL_DOCIDS doclists (else use PLWriter).
*/</comment>
<typedef>typedef <type><struct>struct <name>DLWriter</name> <block>{
  <decl_stmt><decl><type><name>DocListType</name></type> <name>iType</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iPrevDocid</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>has_iPrevDocid</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>DLWriter</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dlwInit</name><parameter_list>(<parameter><decl><type><name>DLWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>, <parameter><decl><type><name>DocListType</name></type> <name>iType</name></decl></parameter>, <parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iType</name></name> <operator>=</operator> <name>iType</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iPrevDocid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>has_iPrevDocid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dlwDestroy</name><parameter_list>(<parameter><decl><type><name>DLWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>SCRAMBLE</name><argument_list>(<argument><expr><name>pWriter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/* iFirstDocid is the first docid in the doclist in pData.  It is
** needed because pData may point within a larger doclist, in which
** case the first item would be delta-encoded.
**
** iLastDocid is the final docid in the doclist in pData.  It is
** needed to create the new iPrevDocid for future delta-encoding.  The
** code could decode the passed doclist to recreate iLastDocid, but
** the only current user (docListMerge) already has decoded this
** information.
*/</comment>
<comment type="block">/* TODO(shess) This has become just a helper for docListMerge.
** Consider a refactor to make this cleaner.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dlwAppend</name><parameter_list>(<parameter><decl><type><name>DLWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>,
                      <parameter><decl><type><name>sqlite_int64</name></type> <name>iFirstDocid</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iLastDocid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iDocid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><name>VARINT_MAX</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nFirstOld</name></decl>, <decl><type ref="prev"/><name>nFirstNew</name></decl>;</decl_stmt>     <comment type="block">/* Old and new varint len of first docid. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iLastDocidDelta</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Recode the initial docid as delta from iPrevDocid. */</comment>
  <expr_stmt><expr><name>nFirstOld</name> <operator>=</operator> <call><name>getVarint</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nFirstOld</name><operator>&lt;</operator><name>nData</name> <operator>||</operator> <operator>(</operator><name>nFirstOld</name><operator>==</operator><name>nData</name> <operator>&amp;&amp;</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>iType</name></name><operator>==</operator><name>DL_DOCIDS</name><operator>)</operator></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nFirstNew</name> <operator>=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>iFirstDocid</name><operator>-</operator><name><name>pWriter</name><operator>-&gt;</operator><name>iPrevDocid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Verify that the incoming doclist is valid AND that it ends with
  ** the expected docid.  This is essential because we'll trust this
  ** docid in future delta-encoding.
  */</comment>
  <expr_stmt><expr><call><name>ASSERT_VALID_DOCLIST</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iType</name></name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iLastDocidDelta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iLastDocid</name><operator>==</operator><name>iFirstDocid</name><operator>-</operator><name>iDocid</name><operator>+</operator><name>iLastDocidDelta</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Append recoded initial docid and everything else.  Rest of docids
  ** should have been delta-encoded from previous initial docid.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nFirstOld</name><operator>&lt;</operator><name>nData</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>dataBufferAppend2</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>nFirstNew</name></expr></argument>,
                      <argument><expr><name>pData</name><operator>+</operator><name>nFirstOld</name></expr></argument>, <argument><expr><name>nData</name><operator>-</operator><name>nFirstOld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>nFirstNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iPrevDocid</name></name> <operator>=</operator> <name>iLastDocid</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dlwCopy</name><parameter_list>(<parameter><decl><type><name>DLWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>, <parameter><decl><type><name>DLReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>dlwAppend</name><argument_list>(<argument><expr><name>pWriter</name></expr></argument>, <argument><expr><call><name>dlrDocData</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>dlrDocDataBytes</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>dlrDocid</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>dlrDocid</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dlwAdd</name><parameter_list>(<parameter><decl><type><name>DLWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><name>VARINT_MAX</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>putVarint</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>iDocid</name><operator>-</operator><name><name>pWriter</name><operator>-&gt;</operator><name>iPrevDocid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Docids must ascend. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pWriter</name><operator>-&gt;</operator><name>has_iPrevDocid</name></name> <operator>||</operator> <name>iDocid</name><operator>&gt;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>iPrevDocid</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iType</name></name><operator>==</operator><name>DL_DOCIDS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iPrevDocid</name></name> <operator>=</operator> <name>iDocid</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>has_iPrevDocid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*******************************************************************/</comment>
<comment type="block">/* PLReader is used to read data from a document's position list.  As
** the caller steps through the list, data is cached so that varints
** only need to be decoded once.
**
** plrInit, plrDestroy - create/destroy a reader.
** plrColumn, plrPosition, plrStartOffset, plrEndOffset - accessors
** plrAtEnd - at end of stream, only call plrDestroy once true.
** plrStep - step to the next element.
*/</comment>
<typedef>typedef <type><struct>struct <name>PLReader</name> <block>{
  <comment type="block">/* These refer to the next position's data.  nData will reach 0 when
  ** reading the last position, so plrStep() signals EOF by setting
  ** pData to NULL.
  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>DocListType</name></type> <name>iType</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iColumn</name></decl>;</decl_stmt>         <comment type="block">/* the last column read */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPosition</name></decl>;</decl_stmt>       <comment type="block">/* the last position read */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iStartOffset</name></decl>;</decl_stmt>    <comment type="block">/* the last start offset read */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iEndOffset</name></decl>;</decl_stmt>      <comment type="block">/* the last end offset read */</comment>
}</block></struct></type> <name>PLReader</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type> <name>plrAtEnd</name><parameter_list>(<parameter><decl><type><name>PLReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name><operator>==</operator><name>NULL</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>plrColumn</name><parameter_list>(<parameter><decl><type><name>PLReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>plrAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>plrPosition</name><parameter_list>(<parameter><decl><type><name>PLReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>plrAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>iPosition</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>plrStartOffset</name><parameter_list>(<parameter><decl><type><name>PLReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>plrAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>iStartOffset</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>plrEndOffset</name><parameter_list>(<parameter><decl><type><name>PLReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>plrAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>iEndOffset</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>plrStep</name><parameter_list>(<parameter><decl><type><name>PLReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>plrAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>POS_COLUMN</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>iColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iPosition</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iStartOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* Should never see adjacent column changes. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>!=</operator><name>POS_COLUMN</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>POS_END</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iPosition</name></name> <operator>+=</operator> <name>i</name><operator>-</operator><name>POS_BASE</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pReader</name><operator>-&gt;</operator><name>iType</name></name><operator>==</operator><name>DL_POSITIONS_OFFSETS</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iStartOffset</name></name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iEndOffset</name></name> <operator>=</operator> <name><name>pReader</name><operator>-&gt;</operator><name>iStartOffset</name></name><operator>+</operator><name>i</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;=</operator><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>plrInit</name><parameter_list>(<parameter><decl><type><name>PLReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>, <parameter><decl><type><name>DLReader</name> <modifier>*</modifier></type><name>pDLReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <call><name>dlrPosData</name><argument_list>(<argument><expr><name>pDLReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <call><name>dlrPosDataLen</name><argument_list>(<argument><expr><name>pDLReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iType</name></name> <operator>=</operator> <name><name>pDLReader</name><operator>-&gt;</operator><name>iType</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iPosition</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iStartOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iEndOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>plrStep</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>plrDestroy</name><parameter_list>(<parameter><decl><type><name>PLReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>SCRAMBLE</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*******************************************************************/</comment>
<comment type="block">/* PLWriter is used in constructing a document's position list.  As a
** convenience, if iType is DL_DOCIDS, PLWriter becomes a no-op.
** PLWriter writes to the associated DLWriter's buffer.
**
** plwInit - init for writing a document's poslist.
** plwDestroy - clear a writer.
** plwAdd - append position and offset information.
** plwCopy - copy next position's data from reader to writer.
** plwTerminate - add any necessary doclist terminator.
**
** Calling plwAdd() after plwTerminate() may result in a corrupt
** doclist.
*/</comment>
<comment type="block">/* TODO(shess) Until we've written the second item, we can cache the
** first item's information.  Then we'd have three states:
**
** - initialized with docid, no positions.
** - docid and one position.
** - docid and multiple positions.
**
** Only the last state needs to actually write to dlw-&gt;b, which would
** be an improvement in the DLCollector case.
*/</comment>
<typedef>typedef <type><struct>struct <name>PLWriter</name> <block>{
  <decl_stmt><decl><type><name>DLWriter</name> <modifier>*</modifier></type><name>dlw</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>iColumn</name></decl>;</decl_stmt>    <comment type="block">/* the last column written */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iPos</name></decl>;</decl_stmt>       <comment type="block">/* the last position written */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iOffset</name></decl>;</decl_stmt>    <comment type="block">/* the last start offset written */</comment>
}</block></struct></type> <name>PLWriter</name>;</typedef>

<comment type="block">/* TODO(shess) In the case where the parent is reading these values
** from a PLReader, we could optimize to a copy if that PLReader has
** the same type as pWriter.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>plwAdd</name><parameter_list>(<parameter><decl><type><name>PLWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iPos</name></decl></parameter>,
                   <parameter><decl><type><name>int</name></type> <name>iStartOffset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iEndOffset</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* Worst-case space for POS_COLUMN, iColumn, iPosDelta,
  ** iStartOffsetDelta, and iEndOffsetDelta.
  */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><literal type="number">5</literal><operator>*</operator><name>VARINT_MAX</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Ban plwAdd() after plwTerminate(). */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iPos</name></name><operator>!=</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pWriter</name><operator>-&gt;</operator><name>dlw</name><operator>-&gt;</operator><name>iType</name></name><operator>==</operator><name>DL_DOCIDS</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>!=</operator><name><name>pWriter</name><operator>-&gt;</operator><name>iColumn</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name>c</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>POS_COLUMN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name>c</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name>iColumn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iPos</name><operator>&gt;=</operator><name><name>pWriter</name><operator>-&gt;</operator><name>iPos</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name>c</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>POS_BASE</name><operator>+</operator><operator>(</operator><name>iPos</name><operator>-</operator><name><name>pWriter</name><operator>-&gt;</operator><name>iPos</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iPos</name></name> <operator>=</operator> <name>iPos</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pWriter</name><operator>-&gt;</operator><name>dlw</name><operator>-&gt;</operator><name>iType</name></name><operator>==</operator><name>DL_POSITIONS_OFFSETS</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iStartOffset</name><operator>&gt;=</operator><name><name>pWriter</name><operator>-&gt;</operator><name>iOffset</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name>c</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>iStartOffset</name><operator>-</operator><name><name>pWriter</name><operator>-&gt;</operator><name>iOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>=</operator> <name>iStartOffset</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iEndOffset</name><operator>&gt;=</operator><name>iStartOffset</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name>c</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>iEndOffset</name><operator>-</operator><name>iStartOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>dlw</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>plwCopy</name><parameter_list>(<parameter><decl><type><name>PLWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>, <parameter><decl><type><name>PLReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>plwAdd</name><argument_list>(<argument><expr><name>pWriter</name></expr></argument>, <argument><expr><call><name>plrColumn</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>plrPosition</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><call><name>plrStartOffset</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>plrEndOffset</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>plwInit</name><parameter_list>(<parameter><decl><type><name>PLWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>, <parameter><decl><type><name>DLWriter</name> <modifier>*</modifier></type><name>dlw</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><name>VARINT_MAX</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>dlw</name></name> <operator>=</operator> <name>dlw</name></expr>;</expr_stmt>

  <comment type="block">/* Docids must ascend. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pWriter</name><operator>-&gt;</operator><name>dlw</name><operator>-&gt;</operator><name>has_iPrevDocid</name></name> <operator>||</operator> <name>iDocid</name><operator>&gt;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>dlw</name><operator>-&gt;</operator><name>iPrevDocid</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>iDocid</name><operator>-</operator><name><name>pWriter</name><operator>-&gt;</operator><name>dlw</name><operator>-&gt;</operator><name>iPrevDocid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>dlw</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>dlw</name><operator>-&gt;</operator><name>iPrevDocid</name></name> <operator>=</operator> <name>iDocid</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>dlw</name><operator>-&gt;</operator><name>has_iPrevDocid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/* TODO(shess) Should plwDestroy() also terminate the doclist?  But
** then plwDestroy() would no longer be just a destructor, it would
** also be doing work, which isn't consistent with the overall idiom.
** Another option would be for plwAdd() to always append any necessary
** terminator, so that the output is always correct.  But that would
** add incremental work to the common case with the only benefit being
** API elegance.  Punt for now.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>plwTerminate</name><parameter_list>(<parameter><decl><type><name>PLWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pWriter</name><operator>-&gt;</operator><name>dlw</name><operator>-&gt;</operator><name>iType</name></name><operator>&gt;</operator><name>DL_DOCIDS</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><name>VARINT_MAX</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>putVarint</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POS_END</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>dlw</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <comment type="block">/* Mark as terminated for assert in plwAdd(). */</comment>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iPos</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>plwDestroy</name><parameter_list>(<parameter><decl><type><name>PLWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>SCRAMBLE</name><argument_list>(<argument><expr><name>pWriter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*******************************************************************/</comment>
<comment type="block">/* DLCollector wraps PLWriter and DLWriter to provide a
** dynamically-allocated doclist area to use during tokenization.
**
** dlcNew - malloc up and initialize a collector.
** dlcDelete - destroy a collector and all contained items.
** dlcAddPos - append position and offset information.
** dlcAddDoclist - add the collected doclist to the given buffer.
** dlcNext - terminate the current document and open another.
*/</comment>
<typedef>typedef <type><struct>struct <name>DLCollector</name> <block>{
  <decl_stmt><decl><type><name>DataBuffer</name></type> <name>b</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DLWriter</name></type> <name>dlw</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PLWriter</name></type> <name>plw</name></decl>;</decl_stmt>
}</block></struct></type> <name>DLCollector</name>;</typedef>

<comment type="block">/* TODO(shess) This could also be done by calling plwTerminate() and
** dataBufferAppend().  I tried that, expecting nominal performance
** differences, but it seemed to pretty reliably be worth 1% to code
** it this way.  I suspect it is the incremental malloc overhead (some
** percentage of the plwTerminate() calls will cause a realloc), so
** this might be worth revisiting if the DataBuffer implementation
** changes.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dlcAddDoclist</name><parameter_list>(<parameter><decl><type><name>DLCollector</name> <modifier>*</modifier></type><name>pCollector</name></decl></parameter>, <parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pCollector</name><operator>-&gt;</operator><name>dlw</name><operator>.</operator><name>iType</name></name><operator>&gt;</operator><name>DL_DOCIDS</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><name>VARINT_MAX</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>putVarint</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>POS_END</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>dataBufferAppend2</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>pCollector</name><operator>-&gt;</operator><name>b</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>pCollector</name><operator>-&gt;</operator><name>b</name><operator>.</operator><name>nData</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>pCollector</name><operator>-&gt;</operator><name>b</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>pCollector</name><operator>-&gt;</operator><name>b</name><operator>.</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dlcNext</name><parameter_list>(<parameter><decl><type><name>DLCollector</name> <modifier>*</modifier></type><name>pCollector</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>plwTerminate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCollector</name><operator>-&gt;</operator><name>plw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>plwDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCollector</name><operator>-&gt;</operator><name>plw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>plwInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCollector</name><operator>-&gt;</operator><name>plw</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCollector</name><operator>-&gt;</operator><name>dlw</name></name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dlcAddPos</name><parameter_list>(<parameter><decl><type><name>DLCollector</name> <modifier>*</modifier></type><name>pCollector</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iPos</name></decl></parameter>,
                      <parameter><decl><type><name>int</name></type> <name>iStartOffset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iEndOffset</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>plwAdd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCollector</name><operator>-&gt;</operator><name>plw</name></name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name>iPos</name></expr></argument>, <argument><expr><name>iStartOffset</name></expr></argument>, <argument><expr><name>iEndOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DLCollector</name> <modifier>*</modifier></type><name>dlcNew</name><parameter_list>(<parameter><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl></parameter>, <parameter><decl><type><name>DocListType</name></type> <name>iType</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DLCollector</name> <modifier>*</modifier></type><name>pCollector</name> <init>= <expr><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DLCollector</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCollector</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlwInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCollector</name><operator>-&gt;</operator><name>dlw</name></name></expr></argument>, <argument><expr><name>iType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCollector</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>plwInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCollector</name><operator>-&gt;</operator><name>plw</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCollector</name><operator>-&gt;</operator><name>dlw</name></name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>pCollector</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dlcDelete</name><parameter_list>(<parameter><decl><type><name>DLCollector</name> <modifier>*</modifier></type><name>pCollector</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>plwDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCollector</name><operator>-&gt;</operator><name>plw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlwDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCollector</name><operator>-&gt;</operator><name>dlw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCollector</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SCRAMBLE</name><argument_list>(<argument><expr><name>pCollector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pCollector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Copy the doclist data of iType in pData/nData into *out, trimming
** unnecessary data as we go.  Only columns matching iColumn are
** copied, all columns copied if iColumn is -1.  Elements with no
** matching columns are dropped.  The output is an iOutType doclist.
*/</comment>
<comment type="block">/* NOTE(shess) This code is only valid after all doclists are merged.
** If this is run before merges, then doclist items which represent
** deletion will be trimmed, and will thus not effect a deletion
** during the merge.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListTrim</name><parameter_list>(<parameter><decl><type><name>DocListType</name></type> <name>iType</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>,
                        <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>, <parameter><decl><type><name>DocListType</name></type> <name>iOutType</name></decl></parameter>, <parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DLReader</name></type> <name>dlReader</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DLWriter</name></type> <name>dlWriter</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iOutType</name><operator>&lt;=</operator><name>iType</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>dlrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dlReader</name></expr></argument>, <argument><expr><name>iType</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlwInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dlWriter</name></expr></argument>, <argument><expr><name>iOutType</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dlReader</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>PLReader</name></type> <name>plReader</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PLWriter</name></type> <name>plWriter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>match</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>plrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dlReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while<condition>( <expr><operator>!</operator><call><name>plrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>==</operator><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <call><name>plrColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>)</argument_list></call><operator>==</operator><name>iColumn</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><operator>!</operator><name>match</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>plwInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plWriter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dlWriter</name></expr></argument>, <argument><expr><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dlReader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>match</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>plwAdd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plWriter</name></expr></argument>, <argument><expr><call><name>plrColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>plrPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><call><name>plrStartOffset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>plrEndOffset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>plrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>match</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>plwTerminate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plWriter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>plwDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plWriter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>plrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dlReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>dlwDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dlWriter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dlReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Used by docListMerge() to keep doclists in the ascending order by
** docid, then ascending order by age (so the newest comes first).
*/</comment>
<typedef>typedef <type><struct>struct <name>OrderedDLReader</name> <block>{
  <decl_stmt><decl><type><name>DLReader</name> <modifier>*</modifier></type><name>pReader</name></decl>;</decl_stmt>

  <comment type="block">/* TODO(shess) If we assume that docListMerge pReaders is ordered by
  ** age (which we do), then we could use pReader comparisons to break
  ** ties.
  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
}</block></struct></type> <name>OrderedDLReader</name>;</typedef>

<comment type="block">/* Order eof to end, then by docid asc, idx desc. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>orderedDLReaderCmp</name><parameter_list>(<parameter><decl><type><name>OrderedDLReader</name> <modifier>*</modifier></type><name>r1</name></decl></parameter>, <parameter><decl><type><name>OrderedDLReader</name> <modifier>*</modifier></type><name>r2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>dlrAtEnd</name><argument_list>(<argument><expr><name><name>r1</name><operator>-&gt;</operator><name>pReader</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>dlrAtEnd</name><argument_list>(<argument><expr><name><name>r2</name><operator>-&gt;</operator><name>pReader</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Both atEnd(). */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>                              <comment type="block">/* Only r1 atEnd(). */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>dlrAtEnd</name><argument_list>(<argument><expr><name><name>r2</name><operator>-&gt;</operator><name>pReader</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* Only r2 atEnd(). */</comment>

  <if_stmt><if>if<condition>( <expr><call><name>dlrDocid</name><argument_list>(<argument><expr><name><name>r1</name><operator>-&gt;</operator><name>pReader</name></name></expr></argument>)</argument_list></call><operator>&lt;</operator><call><name>dlrDocid</name><argument_list>(<argument><expr><name><name>r2</name><operator>-&gt;</operator><name>pReader</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>dlrDocid</name><argument_list>(<argument><expr><name><name>r1</name><operator>-&gt;</operator><name>pReader</name></name></expr></argument>)</argument_list></call><operator>&gt;</operator><call><name>dlrDocid</name><argument_list>(<argument><expr><name><name>r2</name><operator>-&gt;</operator><name>pReader</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Descending on idx. */</comment>
  <return>return <expr><name><name>r2</name><operator>-&gt;</operator><name>idx</name></name><operator>-</operator><name><name>r1</name><operator>-&gt;</operator><name>idx</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Bubble p[0] to appropriate place in p[1..n-1].  Assumes that
** p[1..n-1] is already sorted.
*/</comment>
<comment type="block">/* TODO(shess) Is this frequent enough to warrant a binary search?
** Before implementing that, instrument the code to check.  In most
** current usage, I expect that p[0] will be less than p[1] a very
** high proportion of the time.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>orderedDLReaderReorder</name><parameter_list>(<parameter><decl><type><name>OrderedDLReader</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>orderedDLReaderCmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>OrderedDLReader</name></type> <name>tmp</name> <init>= <expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Given an array of doclist readers, merge their doclist elements
** into out in sorted order (by docid), dropping elements from older
** readers when there is a duplicate docid.  pReaders is assumed to be
** ordered by age, oldest first.
*/</comment>
<comment type="block">/* TODO(shess) nReaders must be &lt;= MERGE_COUNT.  This should probably
** be fixed.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListMerge</name><parameter_list>(<parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>out</name></decl></parameter>,
                         <parameter><decl><type><name>DLReader</name> <modifier>*</modifier></type><name>pReaders</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nReaders</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>OrderedDLReader</name></type> <name><name>readers</name><index>[<expr><name>MERGE_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DLWriter</name></type> <name>writer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iFirstDocid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>iLastDocid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nReaders</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nReaders</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>dlrDocData</name><argument_list>(<argument><expr><name>pReaders</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>dlrAllDataBytes</name><argument_list>(<argument><expr><name>pReaders</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nReaders</name><operator>&lt;=</operator><name>MERGE_COUNT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nReaders</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pReaders</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iType</name><operator>==</operator><name><name>pReaders</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iType</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>readers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pReader</name> <operator>=</operator> <name>pReaders</name><operator>+</operator><name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>readers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>dlrAllDataBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReaders</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <comment type="block">/* Conservatively size output to sum of inputs.  Output should end
  ** up strictly smaller than input.
  */</comment>
  <expr_stmt><expr><call><name>dataBufferExpand</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the readers into sorted order. */</comment>
  <while>while<condition>( <expr><name>i</name><operator>--</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>orderedDLReaderReorder</name><argument_list>(<argument><expr><name>readers</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>nReaders</name><operator>-</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>dlwInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><name><name>pReaders</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iType</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><name><name>readers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pReader</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iDocid</name> <init>= <expr><call><name>dlrDocid</name><argument_list>(<argument><expr><name><name>readers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pReader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If this is a continuation of the current buffer to copy, extend
    ** that buffer.  memcpy() seems to be more efficient if it has a
    ** lots of data to copy.
    */</comment>
    <if_stmt><if>if<condition>( <expr><call><name>dlrDocData</name><argument_list>(<argument><expr><name><name>readers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pReader</name></expr></argument>)</argument_list></call><operator>==</operator><name>pStart</name><operator>+</operator><name>nStart</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nStart</name> <operator>+=</operator> <call><name>dlrDocDataBytes</name><argument_list>(<argument><expr><name><name>readers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>pStart</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>dlwAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><name>pStart</name></expr></argument>, <argument><expr><name>nStart</name></expr></argument>, <argument><expr><name>iFirstDocid</name></expr></argument>, <argument><expr><name>iLastDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>pStart</name> <operator>=</operator> <call><name>dlrDocData</name><argument_list>(<argument><expr><name><name>readers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>nStart</name> <operator>=</operator> <call><name>dlrDocDataBytes</name><argument_list>(<argument><expr><name><name>readers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iFirstDocid</name> <operator>=</operator> <name>iDocid</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>iLastDocid</name> <operator>=</operator> <name>iDocid</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><name><name>readers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Drop all of the older elements with the same docid. */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nReaders</name> <operator>&amp;&amp;</operator>
             <operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><name><name>readers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pReader</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
             <call><name>dlrDocid</name><argument_list>(<argument><expr><name><name>readers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pReader</name></expr></argument>)</argument_list></call><operator>==</operator><name>iDocid</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><name><name>readers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Get the readers back into order. */</comment>
    <while>while<condition>( <expr><name>i</name><operator>--</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>orderedDLReaderReorder</name><argument_list>(<argument><expr><name>readers</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>nReaders</name><operator>-</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></while>

  <comment type="block">/* Copy over any remaining elements. */</comment>
  <if_stmt><if>if<condition>( <expr><name>nStart</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>dlwAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><name>pStart</name></expr></argument>, <argument><expr><name>nStart</name></expr></argument>, <argument><expr><name>iFirstDocid</name></expr></argument>, <argument><expr><name>iLastDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>dlwDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Helper function for posListUnion().  Compares the current position
** between left and right, returning as standard C idiom of &lt;0 if
** left&lt;right, &gt;0 if left&gt;right, and 0 if left==right.  "End" always
** compares greater.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>posListCmp</name><parameter_list>(<parameter><decl><type><name>PLReader</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>PLReader</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>iType</name></name><operator>==</operator><name><name>pRight</name><operator>-&gt;</operator><name>iType</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pLeft</name><operator>-&gt;</operator><name>iType</name></name><operator>==</operator><name>DL_DOCIDS</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>plrAtEnd</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><ternary><condition><expr><call><name>plrAtEnd</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>plrAtEnd</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>plrColumn</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call><operator>&lt;</operator><call><name>plrColumn</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>plrColumn</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call><operator>&gt;</operator><call><name>plrColumn</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>plrPosition</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call><operator>&lt;</operator><call><name>plrPosition</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>plrPosition</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call><operator>&gt;</operator><call><name>plrPosition</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pLeft</name><operator>-&gt;</operator><name>iType</name></name><operator>==</operator><name>DL_POSITIONS</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>plrStartOffset</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call><operator>&lt;</operator><call><name>plrStartOffset</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>plrStartOffset</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call><operator>&gt;</operator><call><name>plrStartOffset</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>plrEndOffset</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call><operator>&lt;</operator><call><name>plrEndOffset</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>plrEndOffset</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call><operator>&gt;</operator><call><name>plrEndOffset</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Write the union of position lists in pLeft and pRight to pOut.
** "Union" in this case meaning "All unique position tuples".  Should
** work with any doclist type, though both inputs and the output
** should be the same type.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>posListUnion</name><parameter_list>(<parameter><decl><type><name>DLReader</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>DLReader</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>DLWriter</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PLReader</name></type> <name>left</name></decl>, <decl><type ref="prev"/><name>right</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PLWriter</name></type> <name>writer</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>dlrDocid</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>dlrDocid</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>iType</name></name><operator>==</operator><name><name>pRight</name><operator>-&gt;</operator><name>iType</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pLeft</name><operator>-&gt;</operator><name>iType</name></name><operator>==</operator><name><name>pOut</name><operator>-&gt;</operator><name>iType</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>plrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>plrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>plwInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><call><name>dlrDocid</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><operator>!</operator><call><name>plrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>plrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>posListCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>plwCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>plrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>c</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>plwCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>plrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>plwCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>plrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>plrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>plwTerminate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>plwDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>plrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>plrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Write the union of doclists in pLeft and pRight to pOut.  For
** docids in common between the inputs, the union of the position
** lists is written.  Inputs and outputs are always type DL_DEFAULT.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListUnion</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLeft</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nRight</name></decl></parameter>,
  <parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>      <comment type="block">/* Write the combined doclist here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DLReader</name></type> <name>left</name></decl>, <decl><type ref="prev"/><name>right</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DLWriter</name></type> <name>writer</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>nLeft</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nRight</name><operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>nRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nRight</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>nLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>dlrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><name>DL_DEFAULT</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>nLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><name>DL_DEFAULT</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>nRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlwInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><name>DL_DEFAULT</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>dlrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>dlwCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>dlrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>dlwCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call><operator>&lt;</operator><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>dlwCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call><operator>&gt;</operator><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>dlwCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>posListUnion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>dlrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlwDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* pLeft and pRight are DLReaders positioned to the same docid.
**
** If there are no instances in pLeft or pRight where the position
** of pLeft is one less than the position of pRight, then this
** routine adds nothing to pOut.
**
** If there are one or more instances where positions from pLeft
** are exactly one less than positions from pRight, then add a new
** document record to pOut.  If pOut wants to hold positions, then
** include the positions from pRight that are one more than a
** position in pLeft.  In other words:  pRight.iPos==pLeft.iPos+1.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>posListPhraseMerge</name><parameter_list>(<parameter><decl><type><name>DLReader</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>DLReader</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>,
                               <parameter><decl><type><name>DLWriter</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>PLReader</name></type> <name>left</name></decl>, <decl><type ref="prev"/><name>right</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PLWriter</name></type> <name>writer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>match</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><call><name>dlrDocid</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call><operator>==</operator><call><name>dlrDocid</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>iType</name></name><operator>!=</operator><name>DL_POSITIONS_OFFSETS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>plrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>plrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><operator>!</operator><call><name>plrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>plrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>plrColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call><operator>&lt;</operator><call><name>plrColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>plrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>plrColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call><operator>&gt;</operator><call><name>plrColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>plrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>plrPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal><operator>&lt;</operator><call><name>plrPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>plrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>plrPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal><operator>&gt;</operator><call><name>plrPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>plrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>match</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>plwInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>, <argument><expr><call><name>dlrDocid</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>match</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>plwAdd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><call><name>plrColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>plrPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>plrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>plrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name>match</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>plwTerminate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>plwDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>plrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>plrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* We have two doclists with positions:  pLeft and pRight.
** Write the phrase intersection of these two doclists into pOut.
**
** A phrase intersection means that two documents only match
** if pLeft.iPos+1==pRight.iPos.
**
** iType controls the type of data written to pOut.  If iType is
** DL_POSITIONS, the positions are those from pRight.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListPhraseMerge</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLeft</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nRight</name></decl></parameter>,
  <parameter><decl><type><name>DocListType</name></type> <name>iType</name></decl></parameter>,
  <parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>      <comment type="block">/* Write the combined doclist here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DLReader</name></type> <name>left</name></decl>, <decl><type ref="prev"/><name>right</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DLWriter</name></type> <name>writer</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>nLeft</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>nRight</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iType</name><operator>!=</operator><name>DL_POSITIONS_OFFSETS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>dlrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><name>DL_POSITIONS</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>nLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><name>DL_POSITIONS</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>nRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlwInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><name>iType</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call><operator>&lt;</operator><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call><operator>&lt;</operator><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>posListPhraseMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>dlrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlwDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* We have two DL_DOCIDS doclists:  pLeft and pRight.
** Write the intersection of these two doclists into pOut as a
** DL_DOCIDS doclist.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListAndMerge</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLeft</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nRight</name></decl></parameter>,
  <parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>      <comment type="block">/* Write the combined doclist here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DLReader</name></type> <name>left</name></decl>, <decl><type ref="prev"/><name>right</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DLWriter</name></type> <name>writer</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>nLeft</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>nRight</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>dlrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><name>DL_DOCIDS</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>nLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><name>DL_DOCIDS</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>nRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlwInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><name>DL_DOCIDS</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call><operator>&lt;</operator><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call><operator>&lt;</operator><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>dlwAdd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>dlrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlwDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* We have two DL_DOCIDS doclists:  pLeft and pRight.
** Write the union of these two doclists into pOut as a
** DL_DOCIDS doclist.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListOrMerge</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLeft</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nRight</name></decl></parameter>,
  <parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>      <comment type="block">/* Write the combined doclist here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DLReader</name></type> <name>left</name></decl>, <decl><type ref="prev"/><name>right</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DLWriter</name></type> <name>writer</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>nLeft</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nRight</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>nRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nRight</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>nLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>dlrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><name>DL_DOCIDS</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>nLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><name>DL_DOCIDS</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>nRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlwInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><name>DL_DOCIDS</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>dlrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>dlwAdd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>dlrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>dlwAdd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call><operator>&lt;</operator><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>dlwAdd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call><operator>&lt;</operator><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>dlwAdd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>dlwAdd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>dlrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlwDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* We have two DL_DOCIDS doclists:  pLeft and pRight.
** Write into pOut as DL_DOCIDS doclist containing all documents that
** occur in pLeft but not in pRight.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListExceptMerge</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLeft</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nRight</name></decl></parameter>,
  <parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>      <comment type="block">/* Write the combined doclist here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DLReader</name></type> <name>left</name></decl>, <decl><type ref="prev"/><name>right</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DLWriter</name></type> <name>writer</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>nLeft</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nRight</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>nLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>dlrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><name>DL_DOCIDS</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>nLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><name>DL_DOCIDS</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>nRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlwInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><name>DL_DOCIDS</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call><operator>&lt;</operator><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><call><name>dlrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call><operator>&lt;</operator><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>dlwAdd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>, <argument><expr><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>dlrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlwDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>string_dup_n</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>str</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  <return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Duplicate a string; the caller must free() the returned string.
 * (We don't use strdup() since it is not part of the standard C library and
 * may not be available everywhere.) */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>string_dup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>string_dup_n</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Format a string, replacing each occurrence of the % character with
 * zDb.zName.  This may be more convenient than sqlite_mprintf()
 * when one string is used repeatedly in a format string.
 * The caller must free() the returned string. */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>string_format</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>nDb</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>nName</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>nFullTableName</name> <init>= <expr><name>nDb</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>nName</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

  <comment type="block">/* first compute length needed */</comment>
  <for>for<control>(<init><expr><name>p</name> <operator>=</operator> <name>zFormat</name></expr> ;</init> <condition><expr><operator>*</operator><name>p</name></expr> ;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><ternary><condition><expr><operator>*</operator><name>p</name><operator>==</operator><literal type="char">'%'</literal></expr> ?</condition><then> <expr><name>nFullTableName</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* for null terminator */</comment>

  <expr_stmt><expr><name>r</name> <operator>=</operator> <name>result</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>p</name> <operator>=</operator> <name>zFormat</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name><operator>==</operator><literal type="char">'%'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>nDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name> <operator>+=</operator> <name>nDb</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name> <operator>+=</operator> <name>nName</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>r</name> <operator>==</operator> <name>result</name> <operator>+</operator> <name>len</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sql_exec</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCommand</name> <init>= <expr><call><name>string_format</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS2 sql: %s\n"</literal><operator>,</operator> <name>zCommand</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zCommand</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sql_prepare</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,
                       <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCommand</name> <init>= <expr><call><name>string_format</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS2 prepare: %s\n"</literal><operator>,</operator> <name>zCommand</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zCommand</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>ppStmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* end utility functions */</comment>

<comment type="block">/* Forward reference */</comment>
<typedef>typedef <type><name><name>struct</name> <name>fulltext_vtab</name></name></type> <name>fulltext_vtab</name>;</typedef>

<comment type="block">/* A single term in a query is represented by an instances of
** the following structure.
*/</comment>
<typedef>typedef <type><struct>struct <name>QueryTerm</name> <block>{
  <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>nPhrase</name></decl>;</decl_stmt> <comment type="block">/* How many following terms are part of the same phrase */</comment>
  <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>iPhrase</name></decl>;</decl_stmt> <comment type="block">/* This is the i-th term of a phrase. */</comment>
  <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>iColumn</name></decl>;</decl_stmt> <comment type="block">/* Column of the index that must match this term */</comment>
  <decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name>isOr</name></decl>;</decl_stmt>  <comment type="block">/* this term is preceded by "OR" */</comment>
  <decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name>isNot</name></decl>;</decl_stmt> <comment type="block">/* this term is preceded by "-" */</comment>
  <decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name>isPrefix</name></decl>;</decl_stmt> <comment type="block">/* this term is followed by "*" */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>       <comment type="block">/* text of the term.  '\000' terminated.  malloced */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name></decl>;</decl_stmt>         <comment type="block">/* Number of bytes in pTerm[] */</comment>
}</block></struct></type> <name>QueryTerm</name>;</typedef>


<comment type="block">/* A query string is parsed into a Query structure.
 *
 * We could, in theory, allow query strings to be complicated
 * nested expressions with precedence determined by parentheses.
 * But none of the major search engines do this.  (Perhaps the
 * feeling is that an parenthesized expression is two complex of
 * an idea for the average user to grasp.)  Taking our lead from
 * the major search engines, we will allow queries to be a list
 * of terms (with an implied AND operator) or phrases in double-quotes,
 * with a single optional "-" before each non-phrase term to designate
 * negation and an optional OR connector.
 *
 * OR binds more tightly than the implied AND, which is what the
 * major search engines seem to do.  So, for example:
 * 
 *    [one two OR three]     ==&gt;    one AND (two OR three)
 *    [one OR two three]     ==&gt;    (one OR two) AND three
 *
 * A "-" before a term matches all entries that lack that term.
 * The "-" must occur immediately before the term with in intervening
 * space.  This is how the search engines do it.
 *
 * A NOT term cannot be the right-hand operand of an OR.  If this
 * occurs in the query string, the NOT is ignored:
 *
 *    [one OR -two]          ==&gt;    one OR two
 *
 */</comment>
<typedef>typedef <type><struct>struct <name>Query</name> <block>{
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>pFts</name></decl>;</decl_stmt>  <comment type="block">/* The full text index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerms</name></decl>;</decl_stmt>           <comment type="block">/* Number of terms in the query */</comment>
  <decl_stmt><decl><type><name>QueryTerm</name> <modifier>*</modifier></type><name>pTerms</name></decl>;</decl_stmt>    <comment type="block">/* Array of terms.  Space obtained from malloc() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nextIsOr</name></decl>;</decl_stmt>         <comment type="block">/* Set the isOr flag on the next inserted term */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nextColumn</name></decl>;</decl_stmt>       <comment type="block">/* Next word parsed must be in this column */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>dfltColumn</name></decl>;</decl_stmt>       <comment type="block">/* The default column */</comment>
}</block></struct></type> <name>Query</name>;</typedef>


<comment type="block">/*
** An instance of the following structure keeps track of generated
** matching-word offset information and snippets.
*/</comment>
<typedef>typedef <type><struct>struct <name>Snippet</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nMatch</name></decl>;</decl_stmt>     <comment type="block">/* Total number of matches */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name></decl>;</decl_stmt>     <comment type="block">/* Space allocated for aMatch[] */</comment>
  <struct>struct <name>snippetMatch</name> <block>{ <comment type="block">/* One entry for each matching term */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name>snStatus</name></decl>;</decl_stmt>       <comment type="block">/* Status flag for use while constructing snippets */</comment>
    <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>iCol</name></decl>;</decl_stmt>      <comment type="block">/* The column that contains the match */</comment>
    <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>iTerm</name></decl>;</decl_stmt>     <comment type="block">/* The index in Query.pTerms[] of the matching term */</comment>
    <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>nByte</name></decl>;</decl_stmt>     <comment type="block">/* Number of bytes in the term */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iStart</name></decl>;</decl_stmt>          <comment type="block">/* The offset to the first character of the term */</comment>
  }</block> <decl><modifier>*</modifier><name>aMatch</name></decl>;</struct>      <comment type="block">/* Points to space obtained from malloc */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOffset</name></decl>;</decl_stmt>  <comment type="block">/* Text rendering of aMatch[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOffset</name></decl>;</decl_stmt>    <comment type="block">/* strlen(zOffset) */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSnippet</name></decl>;</decl_stmt> <comment type="block">/* Snippet text */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSnippet</name></decl>;</decl_stmt>   <comment type="block">/* strlen(zSnippet) */</comment>
}</block></struct></type> <name>Snippet</name>;</typedef>


<typedef>typedef <type><enum>enum <name>QueryType</name> <block>{
  <decl><name>QUERY_GENERIC</name></decl>,   <comment type="block">/* table scan */</comment>
  <decl><name>QUERY_ROWID</name></decl>,     <comment type="block">/* lookup by rowid */</comment>
  <decl><name>QUERY_FULLTEXT</name></decl>   <comment type="block">/* QUERY_FULLTEXT + [i] is a full-text search for column i*/</comment>
}</block></enum></type> <name>QueryType</name>;</typedef>

<typedef>typedef <type><enum>enum <name>fulltext_statement</name> <block>{
  <decl><name>CONTENT_INSERT_STMT</name></decl>,
  <decl><name>CONTENT_SELECT_STMT</name></decl>,
  <decl><name>CONTENT_UPDATE_STMT</name></decl>,
  <decl><name>CONTENT_DELETE_STMT</name></decl>,
  <decl><name>CONTENT_EXISTS_STMT</name></decl>,

  <decl><name>BLOCK_INSERT_STMT</name></decl>,
  <decl><name>BLOCK_SELECT_STMT</name></decl>,
  <decl><name>BLOCK_DELETE_STMT</name></decl>,
  <decl><name>BLOCK_DELETE_ALL_STMT</name></decl>,

  <decl><name>SEGDIR_MAX_INDEX_STMT</name></decl>,
  <decl><name>SEGDIR_SET_STMT</name></decl>,
  <decl><name>SEGDIR_SELECT_LEVEL_STMT</name></decl>,
  <decl><name>SEGDIR_SPAN_STMT</name></decl>,
  <decl><name>SEGDIR_DELETE_STMT</name></decl>,
  <decl><name>SEGDIR_SELECT_SEGMENT_STMT</name></decl>,
  <decl><name>SEGDIR_SELECT_ALL_STMT</name></decl>,
  <decl><name>SEGDIR_DELETE_ALL_STMT</name></decl>,
  <decl><name>SEGDIR_COUNT_STMT</name></decl>,

  <decl><name>MAX_STMT</name></decl>                     <comment type="block">/* Always at end! */</comment>
}</block></enum></type> <name>fulltext_statement</name>;</typedef>

<comment type="block">/* These must exactly match the enum above. */</comment>
<comment type="block">/* TODO(shess): Is there some risk that a statement will be used in two
** cursors at once, e.g.  if a query joins a virtual table to itself?
** If so perhaps we should move some of these to the cursor object.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>fulltext_zStatement</name><index>[<expr><name>MAX_STMT</name></expr>]</index></name> <init>= <expr><block>{
  <comment type="block">/* CONTENT_INSERT */</comment> <expr><name>NULL</name></expr>,  <comment type="block">/* generated in contentInsertStatement() */</comment>
  <comment type="block">/* CONTENT_SELECT */</comment> <expr><literal type="string">"select * from %_content where rowid = ?"</literal></expr>,
  <comment type="block">/* CONTENT_UPDATE */</comment> <expr><name>NULL</name></expr>,  <comment type="block">/* generated in contentUpdateStatement() */</comment>
  <comment type="block">/* CONTENT_DELETE */</comment> <expr><literal type="string">"delete from %_content where rowid = ?"</literal></expr>,
  <comment type="block">/* CONTENT_EXISTS */</comment> <expr><literal type="string">"select rowid from %_content limit 1"</literal></expr>,

  <comment type="block">/* BLOCK_INSERT */</comment> <expr><literal type="string">"insert into %_segments values (?)"</literal></expr>,
  <comment type="block">/* BLOCK_SELECT */</comment> <expr><literal type="string">"select block from %_segments where rowid = ?"</literal></expr>,
  <comment type="block">/* BLOCK_DELETE */</comment> <expr><literal type="string">"delete from %_segments where rowid between ? and ?"</literal></expr>,
  <comment type="block">/* BLOCK_DELETE_ALL */</comment> <expr><literal type="string">"delete from %_segments"</literal></expr>,

  <comment type="block">/* SEGDIR_MAX_INDEX */</comment> <expr><literal type="string">"select max(idx) from %_segdir where level = ?"</literal></expr>,
  <comment type="block">/* SEGDIR_SET */</comment> <expr><literal type="string">"insert into %_segdir values (?, ?, ?, ?, ?, ?)"</literal></expr>,
  <comment type="block">/* SEGDIR_SELECT_LEVEL */</comment>
  <expr><literal type="string">"select start_block, leaves_end_block, root from %_segdir "</literal>
  <literal type="string">" where level = ? order by idx"</literal></expr>,
  <comment type="block">/* SEGDIR_SPAN */</comment>
  <expr><literal type="string">"select min(start_block), max(end_block) from %_segdir "</literal>
  <literal type="string">" where level = ? and start_block &lt;&gt; 0"</literal></expr>,
  <comment type="block">/* SEGDIR_DELETE */</comment> <expr><literal type="string">"delete from %_segdir where level = ?"</literal></expr>,

  <comment type="block">/* NOTE(shess): The first three results of the following two
  ** statements must match.
  */</comment>
  <comment type="block">/* SEGDIR_SELECT_SEGMENT */</comment>
  <expr><literal type="string">"select start_block, leaves_end_block, root from %_segdir "</literal>
  <literal type="string">" where level = ? and idx = ?"</literal></expr>,
  <comment type="block">/* SEGDIR_SELECT_ALL */</comment>
  <expr><literal type="string">"select start_block, leaves_end_block, root from %_segdir "</literal>
  <literal type="string">" order by level desc, idx asc"</literal></expr>,
  <comment type="block">/* SEGDIR_DELETE_ALL */</comment> <expr><literal type="string">"delete from %_segdir"</literal></expr>,
  <comment type="block">/* SEGDIR_COUNT */</comment> <expr><literal type="string">"select count(*), ifnull(max(level),0) from %_segdir"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** A connection to a fulltext index is an instance of the following
** structure.  The xCreate and xConnect methods create an instance
** of this structure and xDestroy and xDisconnect free that instance.
** All other methods receive a pointer to the structure as one of their
** arguments.
*/</comment>
<struct>struct <name>fulltext_vtab</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>               <comment type="block">/* Base class used by SQLite core */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                     <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>                 <comment type="block">/* logical database name */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>               <comment type="block">/* virtual table name */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nColumn</name></decl>;</decl_stmt>                     <comment type="block">/* number of columns in virtual table */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azColumn</name></decl>;</decl_stmt>                 <comment type="block">/* column names.  malloced */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azContentColumn</name></decl>;</decl_stmt>          <comment type="block">/* column names in content table; malloced */</comment>
  <decl_stmt><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name></decl>;</decl_stmt>   <comment type="block">/* tokenizer for inserts and queries */</comment>

  <comment type="block">/* Precompiled statements which we keep as long as the table is
  ** open.
  */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name><name>pFulltextStatements</name><index>[<expr><name>MAX_STMT</name></expr>]</index></name></decl>;</decl_stmt>

  <comment type="block">/* Precompiled statements used for segment merges.  We run a
  ** separate select across the leaf level of each tree being merged.
  */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name><name>pLeafSelectStmts</name><index>[<expr><name>MERGE_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
  <comment type="block">/* The statement used to prepare pLeafSelectStmts. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAF_SELECT</name></cpp:macro> \
  <cpp:value>"select block from %_segments where rowid between ? and ? order by rowid"</cpp:value></cpp:define>

  <comment type="block">/* These buffer pending index updates during transactions.
  ** nPendingData estimates the memory size of the pending data.  It
  ** doesn't include the hash-bucket overhead, nor any malloc
  ** overhead.  When nPendingData exceeds kPendingThreshold, the
  ** buffer is flushed even before the transaction closes.
  ** pendingTerms stores the data, and is only valid when nPendingData
  ** is &gt;=0 (nPendingData&lt;0 means pendingTerms has not been
  ** initialized).  iPrevDocid is the last docid written, used to make
  ** certain we're inserting in sorted order.
  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nPendingData</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kPendingThreshold</name></cpp:macro> <cpp:value>(1*1024*1024)</cpp:value></cpp:define>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iPrevDocid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fts2Hash</name></type> <name>pendingTerms</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** When the core wants to do a query, it create a cursor using a
** call to xOpen.  This structure is an instance of a cursor.  It
** is destroyed by xClose.
*/</comment>
<typedef>typedef <type><struct>struct <name>fulltext_cursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>        <comment type="block">/* Base class used by SQLite core */</comment>
  <decl_stmt><decl><type><name>QueryType</name></type> <name>iCursorType</name></decl>;</decl_stmt>           <comment type="block">/* Copy of sqlite3_index_info.idxNum */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>             <comment type="block">/* Prepared statement in use by the cursor */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eof</name></decl>;</decl_stmt>                         <comment type="block">/* True if at End Of Results */</comment>
  <decl_stmt><decl><type><name>Query</name></type> <name>q</name></decl>;</decl_stmt>                         <comment type="block">/* Parsed query string */</comment>
  <decl_stmt><decl><type><name>Snippet</name></type> <name>snippet</name></decl>;</decl_stmt>                 <comment type="block">/* Cached snippet for the current row */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iColumn</name></decl>;</decl_stmt>                     <comment type="block">/* Column being searched */</comment>
  <decl_stmt><decl><type><name>DataBuffer</name></type> <name>result</name></decl>;</decl_stmt>               <comment type="block">/* Doclist results from fulltextQuery */</comment>
  <decl_stmt><decl><type><name>DLReader</name></type> <name>reader</name></decl>;</decl_stmt>                 <comment type="block">/* Result reader if result not empty */</comment>
}</block></struct></type> <name>fulltext_cursor</name>;</typedef>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>fulltext_vtab</name></name> <modifier>*</modifier></type><name>cursor_vtab</name><parameter_list>(<parameter><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator> <name><name>c</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_module</name></type> <name>fts2Module</name></decl>;</decl_stmt>   <comment type="block">/* forward declaration */</comment>

<comment type="block">/* Return a dynamically generated statement of the form
 *   insert into %_content (rowid, ...) values (?, ...)
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>contentInsertStatement</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>StringBuffer</name></type> <name>sb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>initStringBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="string">"insert into %_content (rowid, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>appendList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>azContentColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="string">") values (?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="string">", ?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>stringBufferData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return a dynamically generated statement of the form
 *   update %_content set [col_0] = ?, [col_1] = ?, ...
 *                    where rowid = ?
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>contentUpdateStatement</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>StringBuffer</name></type> <name>sb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>initStringBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="string">"update %_content set "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>azContentColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="string">" = ?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="string">" where rowid = ?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>stringBufferData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Puts a freshly-prepared statement determined by iStmt in *ppStmt.
** If the indicated statement has never been prepared, it is prepared
** and cached, otherwise the cached version is reset.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sql_get_statement</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>fulltext_statement</name></type> <name>iStmt</name></decl></parameter>,
                             <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iStmt</name><operator>&lt;</operator><name>MAX_STMT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name><operator>==</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <switch>switch<condition>( <expr><name>iStmt</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>CONTENT_INSERT_STMT</name></expr>:</case>
        <expr_stmt><expr><name>zStmt</name> <operator>=</operator> <call><name>contentInsertStatement</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>CONTENT_UPDATE_STMT</name></expr>:</case>
        <expr_stmt><expr><name>zStmt</name> <operator>=</operator> <call><name>contentUpdateStatement</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name>zStmt</name> <operator>=</operator> <name><name>fulltext_zStatement</name><index>[<expr><name>iStmt</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></switch>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_prepare</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name></expr></argument>,
                         <argument><expr><name>zStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zStmt</name> <operator>!=</operator> <name><name>fulltext_zStatement</name><index>[<expr><name>iStmt</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>zStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppStmt</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like sqlite3_step(), but convert SQLITE_DONE to SQLITE_OK and
** SQLITE_ROW to SQLITE_ERROR.  Useful for statements like UPDATE,
** where we expect no results.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sql_single_step</name><parameter_list>(<parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name>rc</name><operator>==</operator><name>SQLITE_DONE</name><operator>)</operator></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like sql_get_statement(), but for special replicated LEAF_SELECT
** statements.  idx -1 is a special case for an uncached version of
** the statement (used in the optimize implementation).
*/</comment>
<comment type="block">/* TODO(shess) Write version for generic statements and then share
** that between the cached-statement functions.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sql_get_leaf_statement</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,
                                  <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idx</name><operator>&gt;=</operator><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>idx</name><operator>&lt;</operator><name>MERGE_COUNT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>idx</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>sql_prepare</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>ppStmt</name></expr></argument>, <argument><expr><name>LEAF_SELECT</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name><name>v</name><operator>-&gt;</operator><name>pLeafSelectStmts</name><index>[<expr><name>idx</name></expr>]</index></name><operator>==</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_prepare</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>pLeafSelectStmts</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>,
                         <argument><expr><name>LEAF_SELECT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>pLeafSelectStmts</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppStmt</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>pLeafSelectStmts</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* insert into %_content (rowid, ...) values ([rowid], [pValues]) */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>content_insert</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>rowid</name></decl></parameter>,
                          <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>pValues</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>CONTENT_INSERT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name><name>pValues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><call><name>sql_single_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* update %_content set col0 = pValues[0], col1 = pValues[1], ...
 *                  where rowid = [iRowid] */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>content_update</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>pValues</name></decl></parameter>,
                          <parameter><decl><type><name>sqlite_int64</name></type> <name>iRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>CONTENT_UPDATE_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name><name>pValues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>sql_single_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>freeStringArray</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nString</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pString</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nString</name></expr> ;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pString</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>pString</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>pString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* select * from %_content where rowid = [iRow]
 * The caller must delete the returned array and all strings in it.
 * null fields will be NULL in the returned array.
 *
 * TODO: Perhaps we should return pointer/length strings here for consistency
 * with other code which uses pointer/length. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>content_select</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iRow</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>pValues</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>pValues</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>CONTENT_SELECT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>string_dup</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* We expect only one row.  We must execute another sqlite3_step()
   * to complete the iteration; otherwise the table will remain locked. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pValues</name> <operator>=</operator> <name>values</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>freeStringArray</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* delete from %_content where rowid = [iRow ] */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>content_delete</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iRow</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>CONTENT_DELETE_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>sql_single_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns SQLITE_ROW if any rows exist in %_content, SQLITE_DONE if
** no rows exist, and any error in case of failure.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>content_exists</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>CONTENT_EXISTS_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* We expect only one row.  We must execute another sqlite3_step()
   * to complete the iteration; otherwise the table will remain locked. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ROW</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* insert into %_segments values ([pData])
**   returns assigned rowid in *piBlockid
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>block_insert</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>,
                        <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>piBlockid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>BLOCK_INSERT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_blob</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>piBlockid</name> <operator>=</operator> <call><name>sqlite3_last_insert_rowid</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* delete from %_segments
**   where rowid between [iStartBlockid] and [iEndBlockid]
**
** Deletes the range of blocks, inclusive, used to delete the blocks
** which form a segment.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>block_delete</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
                        <parameter><decl><type><name>sqlite_int64</name></type> <name>iStartBlockid</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iEndBlockid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>BLOCK_DELETE_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iStartBlockid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>iEndBlockid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>sql_single_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns SQLITE_ROW with *pidx set to the maximum segment idx found
** at iLevel.  Returns SQLITE_DONE if there are no segments at
** iLevel.  Otherwise returns an error.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>segdir_max_index</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pidx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SEGDIR_MAX_INDEX_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Should always get at least one row due to how max() works. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_DONE</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* NULL means that there were no inputs to max(). */</comment>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_NULL</name><operator>==</operator><call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pidx</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We expect only one row.  We must execute another sqlite3_step()
   * to complete the iteration; otherwise the table will remain locked. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>SQLITE_ROW</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* insert into %_segdir values (
**   [iLevel], [idx],
**   [iStartBlockid], [iLeavesEndBlockid], [iEndBlockid],
**   [pRootData]
** )
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>segdir_set</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,
                      <parameter><decl><type><name>sqlite_int64</name></type> <name>iStartBlockid</name></decl></parameter>,
                      <parameter><decl><type><name>sqlite_int64</name></type> <name>iLeavesEndBlockid</name></decl></parameter>,
                      <parameter><decl><type><name>sqlite_int64</name></type> <name>iEndBlockid</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pRootData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nRootData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SEGDIR_SET_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>iStartBlockid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>iLeavesEndBlockid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>iEndBlockid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_blob</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>pRootData</name></expr></argument>, <argument><expr><name>nRootData</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>sql_single_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Queries %_segdir for the block span of the segments in level
** iLevel.  Returns SQLITE_DONE if there are no blocks for iLevel,
** SQLITE_ROW if there are blocks, else an error.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>segdir_span</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>,
                       <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>piStartBlockid</name></decl></parameter>,
                       <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>piEndBlockid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SEGDIR_SPAN_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_DONE</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Should never happen */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* This happens if all segments at this level are entirely inline. */</comment>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_NULL</name><operator>==</operator><call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* We expect only one row.  We must execute another sqlite3_step()
     * to complete the iteration; otherwise the table will remain locked. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name> <init>= <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc2</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>rc2</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>piStartBlockid</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>piEndBlockid</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We expect only one row.  We must execute another sqlite3_step()
   * to complete the iteration; otherwise the table will remain locked. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>SQLITE_ROW</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Delete the segment blocks and segment directory records for all
** segments at iLevel.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>segdir_delete</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iStartBlockid</name></decl>, <decl><type ref="prev"/><name>iEndBlockid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>segdir_span</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iStartBlockid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iEndBlockid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>block_delete</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iStartBlockid</name></expr></argument>, <argument><expr><name>iEndBlockid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Delete the segment directory itself. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SEGDIR_DELETE_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>sql_single_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Delete entire fts index, SQLITE_OK on success, relevant error on
** failure.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>segdir_delete_all</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SEGDIR_DELETE_ALL_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_single_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>BLOCK_DELETE_ALL_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>sql_single_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns SQLITE_OK with *pnSegments set to the number of entries in
** %_segdir and *piMaxLevel set to the highest level which has a
** segment.  Otherwise returns the SQLite error which caused failure.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>segdir_count</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnSegments</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piMaxLevel</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SEGDIR_COUNT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* TODO(shess): This case should not be possible?  Should stronger
  ** measures be taken if it happens?
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pnSegments</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>piMaxLevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pnSegments</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>piMaxLevel</name> <operator>=</operator> <call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We expect only one row.  We must execute another sqlite3_step()
   * to complete the iteration; otherwise the table will remain locked. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* TODO(shess) clearPendingTerms() is far down the file because
** writeZeroSegment() is far down the file because LeafWriter is far
** down the file.  Consider refactoring the code to move the non-vtab
** code above the vtab code so that we don't need this forward
** reference.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>clearPendingTerms</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Free the memory used to contain a fulltext_vtab structure.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fulltext_vtab_destroy</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iStmt</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS2 Destroy %p\n"</literal><operator>,</operator> <name>v</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>( <init><expr><name>iStmt</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iStmt</name><operator>&lt;</operator><name>MAX_STMT</name></expr>;</condition> <incr><expr><name>iStmt</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <for>for<control>( <init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>MERGE_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>v</name><operator>-&gt;</operator><name>pLeafSelectStmts</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>pLeafSelectStmts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>pLeafSelectStmts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xDestroy</name></name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>clearPendingTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>azColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>azContentColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>azContentColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Token types for parsing the arguments to xConnect or xCreate.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOKEN_EOF</name></cpp:macro>         <cpp:value>0</cpp:value></cpp:define>    <comment type="block">/* End of file */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOKEN_SPACE</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>    <comment type="block">/* Any kind of whitespace */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOKEN_ID</name></cpp:macro>          <cpp:value>2</cpp:value></cpp:define>    <comment type="block">/* An identifier */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOKEN_STRING</name></cpp:macro>      <cpp:value>3</cpp:value></cpp:define>    <comment type="block">/* A string literal */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOKEN_PUNCT</name></cpp:macro>       <cpp:value>4</cpp:value></cpp:define>    <comment type="block">/* A single punctuation character */</comment>

<comment type="block">/*
** If X is a character that can be used in an identifier then
** IdChar(X) will be true.  Otherwise it is false.
**
** For ASCII, any character with the high-order bit set is
** allowed in an identifier.  For 7-bit characters, 
** sqlite3IsIdChar[X] must be 1.
**
** Ticket #1066.  the SQL standard does not allow '$' in the
** middle of identfiers.  But many SQL implementations do. 
** SQLite will allow '$' in identifiers for compatibility.
** But the feature is undocumented.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>isIdChar</name><index>[]</index></name> <init>= <expr><block>{
<comment type="block">/* x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF */</comment>
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,  <comment type="block">/* 2x */</comment>
    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,  <comment type="block">/* 3x */</comment>
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,  <comment type="block">/* 4x */</comment>
    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>,  <comment type="block">/* 5x */</comment>
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,  <comment type="block">/* 6x */</comment>
    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,  <comment type="block">/* 7x */</comment>
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IdChar</name><parameter_list>(<parameter><type><name>C</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(((c=C)&amp;0x80)!=0 || (c&gt;0x1f &amp;&amp; isIdChar[c-0x20]))</cpp:value></cpp:define>


<comment type="block">/*
** Return the length of the token that begins at z[0]. 
** Store the token type in *tokenType before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getToken</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tokenType</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><operator>*</operator><name>z</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="number">0</literal></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>tokenType</name> <operator>=</operator> <name>TOKEN_EOF</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><literal type="char">' '</literal></expr>:</case> <case>case <expr><literal type="char">'\t'</literal></expr>:</case> <case>case <expr><literal type="char">'\n'</literal></expr>:</case> <case>case <expr><literal type="char">'\f'</literal></expr>:</case> <case>case <expr><literal type="char">'\r'</literal></expr>:</case> <block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><call><name>safe_isspace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
      <expr_stmt><expr><operator>*</operator><name>tokenType</name> <operator>=</operator> <name>TOKEN_SPACE</name></expr>;</expr_stmt>
      <return>return <expr><name>i</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><literal type="char">'`'</literal></expr>:</case>
    <case>case <expr><literal type="char">'\''</literal></expr>:</case>
    <case>case <expr><literal type="char">'"'</literal></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>delim</name> <init>= <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><operator>(</operator><name>c</name><operator>=</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>delim</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><name>delim</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <break>break;</break>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><operator>*</operator><name>tokenType</name> <operator>=</operator> <name>TOKEN_STRING</name></expr>;</expr_stmt>
      <return>return <expr><name>i</name> <operator>+</operator> <operator>(</operator><name>c</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block>
    <case>case <expr><literal type="char">'['</literal></expr>:</case> <block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>c</name><operator>=</operator><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</init> <condition><expr><name>c</name><operator>!=</operator><literal type="char">']'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name><operator>=</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
      <expr_stmt><expr><operator>*</operator><name>tokenType</name> <operator>=</operator> <name>TOKEN_ID</name></expr>;</expr_stmt>
      <return>return <expr><name>i</name></expr>;</return>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IdChar</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><call><name>IdChar</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
      <expr_stmt><expr><operator>*</operator><name>tokenType</name> <operator>=</operator> <name>TOKEN_ID</name></expr>;</expr_stmt>
      <return>return <expr><name>i</name></expr>;</return>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><operator>*</operator><name>tokenType</name> <operator>=</operator> <name>TOKEN_PUNCT</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** A token extracted from a string is an instance of the following
** structure.
*/</comment>
<typedef>typedef <type><struct>struct <name>Token</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>       <comment type="block">/* Pointer to token text.  Not '\000' terminated */</comment>
  <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>n</name></decl>;</decl_stmt>         <comment type="block">/* Length of the token text in bytes. */</comment>
}</block></struct></type> <name>Token</name>;</typedef>

<comment type="block">/*
** Given a input string (which is really one of the argv[] parameters
** passed into xConnect or xCreate) split the string up into tokens.
** Return an array of pointers to '\000' terminated strings, one string
** for each non-whitespace token.
**
** The returned array is terminated by a single NULL pointer.
**
** Space to hold the returned array is obtained from a single
** malloc and should be freed by passing the return value to free().
** The individual strings within the token list are all a part of
** the single memory allocation and will all be freed at once.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>tokenizeString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnToken</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nToken</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Token</name> <modifier>*</modifier></type><name>aToken</name> <init>= <expr><call><name>sqlite3_malloc</name><argument_list>( <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>aToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>e</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>totalSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azToken</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCopy</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getToken</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>e</name><operator>!=</operator><name>TOKEN_SPACE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>aToken</name><index>[<expr><name>nToken</name></expr>]</index></name><operator>.</operator><name>z</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aToken</name><index>[<expr><name>nToken</name></expr>]</index></name><operator>.</operator><name>n</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nToken</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>totalSize</name> <operator>+=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>z</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>azToken</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>sqlite3_malloc</name><argument_list>( <argument><expr><name>nToken</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>totalSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zCopy</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>azToken</name><index>[<expr><name>nToken</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nToken</name><operator>--</operator></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nToken</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>azToken</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>zCopy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>aToken</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zCopy</name></expr></argument>, <argument><expr><name><name>aToken</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zCopy</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCopy</name> <operator>+=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>azToken</name><index>[<expr><name>nToken</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>aToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnToken</name> <operator>=</operator> <name>nToken</name></expr>;</expr_stmt>
  <return>return <expr><name>azToken</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert an SQL-style quoted string into a normal string by removing
** the quote characters.  The conversion is done in-place.  If the
** input does not begin with a quote character, then this routine
** is a no-op.
**
** Examples:
**
**     "abc"   becomes   abc
**     'xyz'   becomes   xyz
**     [pqr]   becomes   pqr
**     `mno`   becomes   mno
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dequoteString</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>quote</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>quote</name> <operator>=</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>quote</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="char">'\''</literal></expr>:</case>  <break>break;</break>
    <case>case <expr><literal type="char">'"'</literal></expr>:</case>   <break>break;</break>
    <case>case <expr><literal type="char">'`'</literal></expr>:</case>   <break>break;</break>                <comment type="block">/* For MySQL compatibility */</comment>
    <case>case <expr><literal type="char">'['</literal></expr>:</case>   <expr_stmt><expr><name>quote</name> <operator>=</operator> <literal type="char">']'</literal></expr>;</expr_stmt>  <break>break;</break>  <comment type="block">/* For MS SqlServer compatibility */</comment>
    <default>default:</default>    <return>return;</return>
  </block_content>}</block></switch>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>quote</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><name>quote</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>quote</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** The input azIn is a NULL-terminated list of tokens.  Remove the first
** token and all punctuation tokens.  Remove the quotes from
** around string literal tokens.
**
** Example:
**
**     input:      tokenize chinese ( 'simplifed' , 'mixed' )
**     output:     chinese simplifed mixed
**
** Another example:
**
**     input:      delimiters ( '[' , ']' , '...' )
**     output:     [ ] ...
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>tokenListToIdList</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>azIn</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name><name>azIn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>safe_isalnum</name><argument_list>(<argument><expr><name><name>azIn</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>azIn</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>dequoteString</name><argument_list>(<argument><expr><name><name>azIn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>azIn</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>azIn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>azIn</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Find the first alphanumeric token in the string zIn.  Null-terminate
** this token.  Remove any quotation marks.  And return a pointer to
** the result.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>firstToken</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzTail</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>ttype</name></decl>;</decl_stmt>
  <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getToken</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>ttype</name><operator>==</operator><name>TOKEN_SPACE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zIn</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>ttype</name><operator>==</operator><name>TOKEN_EOF</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzTail</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>zIn</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pzTail</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dequoteString</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>zIn</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <comment type="block">/*NOTREACHED*/</comment>
</block_content>}</block></function>

<comment type="block">/* Return true if...
**
**   *  s begins with the string t, ignoring case
**   *  s is longer than t
**   *  The first character of s beyond t is not a alphanumeric
** 
** Ignore leading space in *s.
**
** To put it another way, return true if the first token of
** s[] is t[].
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>startsWith</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><call><name>safe_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <while>while<condition>( <expr><operator>*</operator><name>t</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>safe_tolower</name><argument_list>(<argument><expr><operator>*</operator><name>s</name><operator>++</operator></expr></argument>)</argument_list></call><operator>!=</operator><call><name>safe_tolower</name><argument_list>(<argument><expr><operator>*</operator><name>t</name><operator>++</operator></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><operator>*</operator><name>s</name><operator>!=</operator><literal type="char">'_'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>safe_isalnum</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** An instance of this structure defines the "spec" of a
** full text index.  This structure is populated by parseSpec
** and use by fulltextConnect and fulltextCreate.
*/</comment>
<typedef>typedef <type><struct>struct <name>TableSpec</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>         <comment type="block">/* Logical database name */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>       <comment type="block">/* Name of the full-text index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nColumn</name></decl>;</decl_stmt>             <comment type="block">/* Number of columns to be indexed */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azColumn</name></decl>;</decl_stmt>         <comment type="block">/* Original names of columns to be indexed */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azContentColumn</name></decl>;</decl_stmt>  <comment type="block">/* Column names for %_content */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azTokenizer</name></decl>;</decl_stmt>      <comment type="block">/* Name of tokenizer and its arguments */</comment>
}</block></struct></type> <name>TableSpec</name>;</typedef>

<comment type="block">/*
** Reclaim all of the memory used by a TableSpec
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>clearTableSpec</name><parameter_list>(<parameter><decl><type><name>TableSpec</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>azColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>azContentColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>azTokenizer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse a CREATE VIRTUAL TABLE statement, which looks like this:
 *
 * CREATE VIRTUAL TABLE email
 *        USING fts2(subject, body, tokenize mytokenizer(myarg))
 *
 * We return parsed information in a TableSpec structure.
 * 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>parseSpec</name><parameter_list>(<parameter><decl><type><name>TableSpec</name> <modifier>*</modifier></type><name>pSpec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
                     <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zDummy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTokenizer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* argv[] entry describing the tokenizer */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>&gt;=</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Current interface:
  ** argv[0] - module name
  ** argv[1] - database name
  ** argv[2] - table name
  ** argv[3..] - columns, optionally followed by tokenizer specification
  **             and snippet delimiters specification.
  */</comment>

  <comment type="block">/* Make a copy of the complete argv[][] array in a single allocation.
  ** The argv[][] array is read-only and transient.  We can write to the
  ** copy in order to modify things and the copy is persistent.
  */</comment>
  <expr_stmt><expr><call><name>CLEAR</name><argument_list>(<argument><expr><name>pSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>azArg</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>argc</name> <operator>+</operator> <name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>azArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>azArg</name><index>[<expr><name>argc</name></expr>]</index></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Identify the column names and the tokenizer and delimiter arguments
  ** in the argv[][] array.
  */</comment>
  <expr_stmt><expr><name><name>pSpec</name><operator>-&gt;</operator><name>zDb</name></name> <operator>=</operator> <name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSpec</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSpec</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSpec</name><operator>-&gt;</operator><name>azColumn</name></name> <operator>=</operator> <name>azArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zTokenizer</name> <operator>=</operator> <literal type="string">"tokenize simple"</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">3</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>startsWith</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"tokenize"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zTokenizer</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><name><name>pSpec</name><operator>-&gt;</operator><name>nColumn</name></name></expr>]</index></name> <operator>=</operator> <call><name>firstToken</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSpec</name><operator>-&gt;</operator><name>nColumn</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>pSpec</name><operator>-&gt;</operator><name>nColumn</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"content"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSpec</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/*
  ** Construct the list of content column names.
  **
  ** Each content column name will be of the form cNNAAAA
  ** where NN is the column number and AAAA is the sanitized
  ** column name.  "sanitized" means that special characters are
  ** converted to "_".  The cNN prefix guarantees that all column
  ** names are unique.
  **
  ** The AAAA suffix is not strictly necessary.  It is included
  ** for the convenience of people who might examine the generated
  ** %_content table and wonder what the columns are used for.
  */</comment>
  <expr_stmt><expr><name><name>pSpec</name><operator>-&gt;</operator><name>azContentColumn</name></name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>( <argument><expr><name><name>pSpec</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSpec</name><operator>-&gt;</operator><name>azContentColumn</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>clearTableSpec</name><argument_list>(<argument><expr><name>pSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSpec</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pSpec</name><operator>-&gt;</operator><name>azContentColumn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"c%d%s"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>pSpec</name><operator>-&gt;</operator><name>azContentColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr> ;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>safe_isalnum</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <comment type="block">/*
  ** Parse the tokenizer specification string.
  */</comment>
  <expr_stmt><expr><name><name>pSpec</name><operator>-&gt;</operator><name>azTokenizer</name></name> <operator>=</operator> <call><name>tokenizeString</name><argument_list>(<argument><expr><name>zTokenizer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>tokenListToIdList</name><argument_list>(<argument><expr><name><name>pSpec</name><operator>-&gt;</operator><name>azTokenizer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate a CREATE TABLE statement that describes the schema of
** the virtual table.  Return a pointer to this schema string.
**
** Space is obtained from sqlite3_mprintf() and should be freed
** using sqlite3_free().
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>fulltextSchema</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nColumn</name></decl></parameter>,                  <comment type="block">/* Number of columns */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type> <name>azColumn</name></decl></parameter>,  <comment type="block">/* List of columns */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTableName</name></decl></parameter>        <comment type="block">/* Name of the table */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSchema</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zNext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="string">"("</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>zSchema</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"CREATE TABLE x"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nColumn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>zNext</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s%s%Q"</literal></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>azColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSchema</name> <operator>=</operator> <name>zNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>zNext</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s,%Q)"</literal></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>, <argument><expr><name>zTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>zNext</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Build a new sqlite3_vtab structure that will describe the
** fulltext index defined by spec.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>constructVtab</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,              <comment type="block">/* The SQLite database connection */</comment>
  <parameter><decl><type><name>fts2Hash</name> <modifier>*</modifier></type><name>pHash</name></decl></parameter>,          <comment type="block">/* Hash table containing tokenizers */</comment>
  <parameter><decl><type><name>TableSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>,          <comment type="block">/* Parsed spec information from parseSpec() */</comment>
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVTab</name></decl></parameter>,    <comment type="block">/* Write the resulting vtab structure here */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>              <comment type="block">/* Write any error message here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_tokenizer_module</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schema</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>zTok</name></decl>;</decl_stmt>         <comment type="block">/* Name of tokenizer to use for this fts table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTok</name></decl>;</decl_stmt>                 <comment type="block">/* Length of zTok, including nul terminator */</comment>

  <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fulltext_vtab</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>CLEAR</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* sqlite will initialize v-&gt;base */</comment>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>zDb</name></name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>zDb</name></name></expr>;</expr_stmt>       <comment type="block">/* Freed when azColumn is freed */</comment>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>   <comment type="block">/* Freed when azColumn is freed */</comment>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>azContentColumn</name></name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>azContentColumn</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>azContentColumn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>azColumn</name></name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>azColumn</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>azColumn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>spec</name><operator>-&gt;</operator><name>azTokenizer</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>zTok</name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>azTokenizer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt> 
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zTok</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>zTok</name> <operator>=</operator> <literal type="string">"simple"</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>nTok</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zTok</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>m</name> <operator>=</operator> <operator>(</operator><name>sqlite3_tokenizer_module</name> <operator>*</operator><operator>)</operator><call><name>sqlite3Fts2HashFind</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><name>zTok</name></expr></argument>, <argument><expr><name>nTok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>m</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"unknown tokenizer: %s"</literal></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>azTokenizer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>err</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <for>for<control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>spec</name><operator>-&gt;</operator><name>azTokenizer</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>n</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>m</name><operator>-&gt;</operator><name>xCreate</name></name><argument_list>(<argument><expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><specifier>const</specifier><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>spec</name><operator>-&gt;</operator><name>azTokenizer</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>m</name><operator>-&gt;</operator><name>xCreate</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name></name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>

  <comment type="block">/* TODO: verify the existence of backing tables foo_content, foo_term */</comment>

  <expr_stmt><expr><name>schema</name> <operator>=</operator> <call><name>fulltextSchema</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><specifier>const</specifier><operator>*</operator><operator>)</operator><name><name>v</name><operator>-&gt;</operator><name>azColumn</name></name></expr></argument>,
                          <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Indicate that the buffer is not live. */</comment>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nPendingData</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppVTab</name> <operator>=</operator> <operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS2 Connect %p\n"</literal><operator>,</operator> <name>v</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>

<label><name>err</name>:</label>
  <expr_stmt><expr><call><name>fulltext_vtab_destroy</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVTab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>TableSpec</name></type> <name>spec</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>parseSpec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spec</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>constructVtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>fts2Hash</name> <operator>*</operator><operator>)</operator><name>pAux</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>spec</name></expr></argument>, <argument><expr><name>ppVTab</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>clearTableSpec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The %_content table holds the text of each document, with
** the rowid used as the docid.
*/</comment>
<comment type="block">/* TODO(shess) This comment needs elaboration to match the updated
** code.  Work it into the top-of-file comment at that time.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextCreate</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
                          <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>argv</name></decl></parameter>,
                          <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVTab</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TableSpec</name></type> <name>spec</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StringBuffer</name></type> <name>schema</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS2 Create\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>parseSpec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spec</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>initStringBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE %_content("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>appendList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema</name></expr></argument>, <argument><expr><name><name>spec</name><operator>.</operator><name>nColumn</name></name></expr></argument>, <argument><expr><name><name>spec</name><operator>.</operator><name>azContentColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>spec</name><operator>.</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>spec</name><operator>.</operator><name>zName</name></name></expr></argument>, <argument><expr><call><name>stringBufferData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>stringBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>spec</name><operator>.</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>spec</name><operator>.</operator><name>zName</name></name></expr></argument>,
                <argument><expr><literal type="string">"create table %_segments(block blob);"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>spec</name><operator>.</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>spec</name><operator>.</operator><name>zName</name></name></expr></argument>,
                <argument><expr><literal type="string">"create table %_segdir("</literal>
                <literal type="string">"  level integer,"</literal>
                <literal type="string">"  idx integer,"</literal>
                <literal type="string">"  start_block integer,"</literal>
                <literal type="string">"  leaves_end_block integer,"</literal>
                <literal type="string">"  end_block integer,"</literal>
                <literal type="string">"  root blob,"</literal>
                <literal type="string">"  primary key(level, idx)"</literal>
                <literal type="string">");"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>constructVtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>(</operator><name>fts2Hash</name> <operator>*</operator><operator>)</operator><name>pAux</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>spec</name></expr></argument>, <argument><expr><name>ppVTab</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>out</name>:</label>
  <expr_stmt><expr><call><name>clearTableSpec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Decide how to handle an SQL query. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextBestIndex</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS2 BestIndex\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pConstraint</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pConstraint</name> <operator>=</operator> <operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>usable</name></name></expr> )</condition> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
          <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>QUERY_ROWID</name></expr>;</expr_stmt>      <comment type="block">/* lookup by rowid */</comment>
        <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS2 QUERY_ROWID\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator>
                 <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_MATCH</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* full-text search */</comment>
        <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>QUERY_FULLTEXT</name> <operator>+</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS2 QUERY_FULLTEXT %d\n"</literal><operator>,</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else<block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></else></if_stmt>

      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

      <comment type="block">/* An arbitrary value for now.
       * TODO: Perhaps rowid matches should be considered cheaper than
       * full-text searches. */</comment>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>   

      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>QUERY_GENERIC</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS2 Disconnect %p\n"</literal><operator>,</operator> <name>pVTab</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fulltext_vtab_destroy</name><argument_list>(<argument><expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator><name>pVTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextDestroy</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator><name>pVTab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS2 Destroy %p\n"</literal><operator>,</operator> <name>pVTab</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_exec</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
                <argument><expr><literal type="string">"drop table if exists %_content;"</literal>
                <literal type="string">"drop table if exists %_segments;"</literal>
                <literal type="string">"drop table if exists %_segdir;"</literal></expr></argument>
                )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>fulltext_vtab_destroy</name><argument_list>(<argument><expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator><name>pVTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fulltext_cursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fulltext_cursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* sqlite will initialize c-&gt;base */</comment>
    <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS2 Open %p: %p\n"</literal><operator>,</operator> <name>pVTab</name><operator>,</operator> <name>c</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* Free all of the dynamically allocated memory held by *q
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>queryClear</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>q</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>q</name><operator>-&gt;</operator><name>nTerms</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>pTerms</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>pTerms</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CLEAR</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Free all of the dynamically allocated memory held by the
** Snippet
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>snippetClear</name><parameter_list>(<parameter><decl><type><name>Snippet</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aMatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSnippet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CLEAR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
** Append a single entry to the p-&gt;aMatch[] log.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>snippetAppendMatch</name><parameter_list>(
  <parameter><decl><type><name>Snippet</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,               <comment type="block">/* Append the entry to this snippet */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTerm</name></decl></parameter>,      <comment type="block">/* The column and query term */</comment>
  <parameter><decl><type><name>int</name></type> <name>iStart</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>     <comment type="block">/* Offset and size of the match */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>snippetMatch</name></name> <modifier>*</modifier></type><name>pMatch</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nMatch</name></name><operator>+</operator><literal type="number">1</literal><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aMatch</name></name> <operator>=</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aMatch</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aMatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aMatch</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nMatch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nMatch</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMatch</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMatch</name><operator>-&gt;</operator><name>iCol</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMatch</name><operator>-&gt;</operator><name>iTerm</name></name> <operator>=</operator> <name>iTerm</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMatch</name><operator>-&gt;</operator><name>iStart</name></name> <operator>=</operator> <name>iStart</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMatch</name><operator>-&gt;</operator><name>nByte</name></name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Sizing information for the circular buffer used in snippetOffsetsOfColumn()
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTS2_ROTOR_SZ</name></cpp:macro>   <cpp:value>(32)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTS2_ROTOR_MASK</name></cpp:macro> <cpp:value>(FTS2_ROTOR_SZ-1)</cpp:value></cpp:define>

<comment type="block">/*
** Add entries to pSnippet-&gt;aMatch[] for every match that occurs against
** document zDoc[0..nDoc-1] which is stored in column iColumn.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>snippetOffsetsOfColumn</name><parameter_list>(
  <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>pQuery</name></decl></parameter>,
  <parameter><decl><type><name>Snippet</name> <modifier>*</modifier></type><name>pSnippet</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDoc</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nDoc</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_tokenizer_module</name> <modifier>*</modifier></type><name>pTModule</name></decl>;</decl_stmt>  <comment type="block">/* The tokenizer module */</comment>
  <decl_stmt><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name></decl>;</decl_stmt>             <comment type="block">/* The specific tokenizer */</comment>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pTCursor</name></decl>;</decl_stmt>        <comment type="block">/* Tokenizer cursor */</comment>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>                <comment type="block">/* The full text index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nColumn</name></decl>;</decl_stmt>                         <comment type="block">/* Number of columns in the index */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>QueryTerm</name> <modifier>*</modifier></type><name>aTerm</name></decl>;</decl_stmt>              <comment type="block">/* Query string terms */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name></decl>;</decl_stmt>                           <comment type="block">/* Number of query string terms */</comment>  
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>                            <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                              <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>match</name></decl>, <decl><type ref="prev"/><name>prevMatch</name></decl>;</decl_stmt>       <comment type="block">/* Phrase search bitmasks */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zToken</name></decl>;</decl_stmt>                  <comment type="block">/* Next token from the tokenizer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nToken</name></decl>;</decl_stmt>                          <comment type="block">/* Size of zToken */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iBegin</name></decl>, <decl><type ref="prev"/><name>iEnd</name></decl>, <decl><type ref="prev"/><name>iPos</name></decl>;</decl_stmt>              <comment type="block">/* Offsets of beginning and end */</comment>

  <comment type="block">/* The following variables keep a circular buffer of the last
  ** few tokens */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>iRotor</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Index of current token */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>iRotorBegin</name><index>[<expr><name>FTS2_ROTOR_SZ</name></expr>]</index></name></decl>;</decl_stmt>      <comment type="block">/* Beginning offset of token */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>iRotorLen</name><index>[<expr><name>FTS2_ROTOR_SZ</name></expr>]</index></name></decl>;</decl_stmt>        <comment type="block">/* Length of token */</comment>

  <expr_stmt><expr><name>pVtab</name> <operator>=</operator> <name><name>pQuery</name><operator>-&gt;</operator><name>pFts</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nColumn</name> <operator>=</operator> <name><name>pVtab</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTokenizer</name> <operator>=</operator> <name><name>pVtab</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTModule</name> <operator>=</operator> <name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pTModule</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pTokenizer</name></expr></argument>, <argument><expr><name>zDoc</name></expr></argument>, <argument><expr><name>nDoc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pTCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pTCursor</name><operator>-&gt;</operator><name>pTokenizer</name></name> <operator>=</operator> <name>pTokenizer</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aTerm</name> <operator>=</operator> <name><name>pQuery</name><operator>-&gt;</operator><name>pTerms</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nTerm</name> <operator>=</operator> <name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nTerm</name><operator>&gt;=</operator><name>FTS2_ROTOR_SZ</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nTerm</name> <operator>=</operator> <name>FTS2_ROTOR_SZ</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>prevMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pTModule</name><operator>-&gt;</operator><name>xNext</name></name><argument_list>(<argument><expr><name>pTCursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBegin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>iRotorBegin</name><index>[<expr><name>iRotor</name><operator>&amp;</operator><name>FTS2_ROTOR_MASK</name></expr>]</index></name> <operator>=</operator> <name>iBegin</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>iRotorLen</name><index>[<expr><name>iRotor</name><operator>&amp;</operator><name>FTS2_ROTOR_MASK</name></expr>]</index></name> <operator>=</operator> <name>iEnd</name><operator>-</operator><name>iBegin</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>match</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nTerm</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iColumn</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;</operator><name>nColumn</name> <operator>&amp;&amp;</operator> <name>iCol</name><operator>!=</operator><name>iColumn</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nTerm</name><operator>&gt;</operator><name>nToken</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isPrefix</name> <operator>&amp;&amp;</operator> <name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nTerm</name><operator>&lt;</operator><name>nToken</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nTerm</name><operator>&lt;=</operator><name>nToken</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pTerm</name></expr></argument>, <argument><expr><name>zToken</name></expr></argument>, <argument><expr><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nTerm</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iPhrase</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>prevMatch</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>i</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>match</name> <operator>|=</operator> <literal type="number">1</literal><operator>&lt;&lt;</operator><name>i</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>nTerm</name><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name><name>aTerm</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iPhrase</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iPhrase</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>k</name> <init>= <expr><operator>(</operator><name>iRotor</name><operator>-</operator><name>j</name><operator>)</operator> <operator>&amp;</operator> <name>FTS2_ROTOR_MASK</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>snippetAppendMatch</name><argument_list>(<argument><expr><name>pSnippet</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name>i</name><operator>-</operator><name>j</name></expr></argument>,
                <argument><expr><name><name>iRotorBegin</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>iRotorLen</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>prevMatch</name> <operator>=</operator> <name>match</name><operator>&lt;&lt;</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>iRotor</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name><name>pTModule</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pTCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
</block_content>}</block></function>


<comment type="block">/*
** Compute all offsets for the current row of the query.  
** If the offsets have already been computed, this routine is a no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>snippetAllOffsets</name><parameter_list>(<parameter><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nColumn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iColumn</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iFirst</name></decl>, <decl><type ref="prev"/><name>iLast</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>pFts</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>nMatch</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>q</name><operator>.</operator><name>nTerms</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pFts</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>q</name><operator>.</operator><name>pFts</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nColumn</name> <operator>=</operator> <name><name>pFts</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iColumn</name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>iCursorType</name></name> <operator>-</operator> <name>QUERY_FULLTEXT</name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>iColumn</name><operator>&gt;=</operator><name>nColumn</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iFirst</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>iLast</name> <operator>=</operator> <name>nColumn</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iFirst</name> <operator>=</operator> <name>iColumn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iLast</name> <operator>=</operator> <name>iColumn</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>iFirst</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>iLast</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDoc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nDoc</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>zDoc</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nDoc</name> <operator>=</operator> <call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>snippetOffsetsOfColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>q</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>snippet</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>zDoc</name></expr></argument>, <argument><expr><name>nDoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Convert the information in the aMatch[] array of the snippet
** into the string zOffset[0..nOffset-1].
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>snippetOffsetText</name><parameter_list>(<parameter><decl><type><name>Snippet</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StringBuffer</name></type> <name>sb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">200</literal></expr>]</index></name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zOffset</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>initStringBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nMatch</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>snippetMatch</name></name> <modifier>*</modifier></type><name>pMatch</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>zBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>cnt</name><operator>&gt;</operator><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%d %d %d %d"</literal></expr></argument>,
        <argument><expr><name><name>pMatch</name><operator>-&gt;</operator><name>iCol</name></name></expr></argument>, <argument><expr><name><name>pMatch</name><operator>-&gt;</operator><name>iTerm</name></name></expr></argument>, <argument><expr><name><name>pMatch</name><operator>-&gt;</operator><name>iStart</name></name></expr></argument>, <argument><expr><name><name>pMatch</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zOffset</name></name> <operator>=</operator> <call><name>stringBufferData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nOffset</name></name> <operator>=</operator> <call><name>stringBufferLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** zDoc[0..nDoc-1] is phrase of text.  aMatch[0..nMatch-1] are a set
** of matching words some of which might be in zDoc.  zDoc is column
** number iCol.
**
** iBreak is suggested spot in zDoc where we could begin or end an
** excerpt.  Return a value similar to iBreak but possibly adjusted
** to be a little left or right so that the break point is better.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>wordBoundary</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>iBreak</name></decl></parameter>,                   <comment type="block">/* The suggested break point */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDoc</name></decl></parameter>,             <comment type="block">/* Document text */</comment>
  <parameter><decl><type><name>int</name></type> <name>nDoc</name></decl></parameter>,                     <comment type="block">/* Number of bytes in zDoc[] */</comment>
  <parameter><decl><type><name><name>struct</name> <name>snippetMatch</name></name> <modifier>*</modifier></type><name>aMatch</name></decl></parameter>,  <comment type="block">/* Matching words */</comment>
  <parameter><decl><type><name>int</name></type> <name>nMatch</name></decl></parameter>,                   <comment type="block">/* Number of entries in aMatch[] */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>                      <comment type="block">/* The column number for zDoc[] */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iBreak</name><operator>&lt;=</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iBreak</name><operator>&gt;=</operator><name>nDoc</name><operator>-</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>nDoc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nMatch</name> <operator>&amp;&amp;</operator> <name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCol</name><operator>&lt;</operator><name>iCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <while>while<condition>( <expr><name>i</name><operator>&lt;</operator><name>nMatch</name> <operator>&amp;&amp;</operator> <name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iStart</name><operator>+</operator><name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nByte</name><operator>&lt;</operator><name>iBreak</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name>nMatch</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iStart</name><operator>&lt;</operator><name>iBreak</name><operator>+</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iStart</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>aMatch</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iStart</name><operator>+</operator><name><name>aMatch</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>nByte</name><operator>&gt;=</operator><name>iBreak</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name><name>aMatch</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iStart</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><literal type="number">10</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>safe_isspace</name><argument_list>(<argument><expr><name><name>zDoc</name><index>[<expr><name>iBreak</name><operator>-</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><name>iBreak</name> <operator>-</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>safe_isspace</name><argument_list>(<argument><expr><name><name>zDoc</name><index>[<expr><name>iBreak</name><operator>+</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><name>iBreak</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>iBreak</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
** Allowed values for Snippet.aMatch[].snStatus
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SNIPPET_IGNORE</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>   <comment type="block">/* It is ok to omit this match from the snippet */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SNIPPET_DESIRED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>   <comment type="block">/* We want to include this match in the snippet */</comment>

<comment type="block">/*
** Generate the text of a snippet.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>snippetText</name><parameter_list>(
  <parameter><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>,   <comment type="block">/* The cursor we need the snippet for */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStartMark</name></decl></parameter>,     <comment type="block">/* Markup to appear before each match */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEndMark</name></decl></parameter>,       <comment type="block">/* Markup to appear after each match */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEllipsis</name></decl></parameter>       <comment type="block">/* Ellipsis mark */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>snippetMatch</name></name> <modifier>*</modifier></type><name>aMatch</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nMatch</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDesired</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StringBuffer</name></type> <name>sb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tailCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tailOffset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDoc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDoc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iStart</name></decl>, <decl><type ref="prev"/><name>iEnd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tailEllipsis</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iMatch</name></decl>;</decl_stmt>
  

  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>zSnippet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>zSnippet</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>aMatch</name> <operator>=</operator> <name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>aMatch</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nMatch</name> <operator>=</operator> <name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>nMatch</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>initStringBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nMatch</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>snStatus</name> <operator>=</operator> <name>SNIPPET_IGNORE</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>nDesired</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCursor</name><operator>-&gt;</operator><name>q</name><operator>.</operator><name>nTerms</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nMatch</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aMatch</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>iTerm</name><operator>==</operator><name>i</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>aMatch</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>snStatus</name> <operator>=</operator> <name>SNIPPET_DESIRED</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nDesired</name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <expr_stmt><expr><name>iMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>tailCol</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>tailOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>i</name><argument_list type="generic">&lt;<argument><expr><name>nMatch</name> <operator>&amp;&amp;</operator> <name>nDesired</name></expr></argument>&gt;</argument_list></name><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>snStatus</name><operator>!=</operator><name>SNIPPET_DESIRED</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nDesired</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCol</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zDoc</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name><name>pCursor</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>iCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nDoc</name> <operator>=</operator> <call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name><name>pCursor</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>iCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iStart</name> <operator>=</operator> <name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iStart</name> <operator>-</operator> <literal type="number">40</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>iStart</name> <operator>=</operator> <call><name>wordBoundary</name><argument_list>(<argument><expr><name>iStart</name></expr></argument>, <argument><expr><name>zDoc</name></expr></argument>, <argument><expr><name>nDoc</name></expr></argument>, <argument><expr><name>aMatch</name></expr></argument>, <argument><expr><name>nMatch</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iStart</name><operator>&lt;=</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iStart</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>==</operator><name>tailCol</name> <operator>&amp;&amp;</operator> <name>iStart</name><operator>&lt;=</operator><name>tailOffset</name><operator>+</operator><literal type="number">20</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iStart</name> <operator>=</operator> <name>tailOffset</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iCol</name><operator>!=</operator><name>tailCol</name> <operator>&amp;&amp;</operator> <name>tailCol</name><operator>&gt;=</operator><literal type="number">0</literal><operator>)</operator> <operator>||</operator> <name>iStart</name><operator>!=</operator><name>tailOffset</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>trimWhiteSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>appendWhiteSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>zEllipsis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>appendWhiteSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iEnd</name> <operator>=</operator> <name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iStart</name> <operator>+</operator> <name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nByte</name> <operator>+</operator> <literal type="number">40</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>iEnd</name> <operator>=</operator> <call><name>wordBoundary</name><argument_list>(<argument><expr><name>iEnd</name></expr></argument>, <argument><expr><name>zDoc</name></expr></argument>, <argument><expr><name>nDoc</name></expr></argument>, <argument><expr><name>aMatch</name></expr></argument>, <argument><expr><name>nMatch</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iEnd</name><operator>&gt;=</operator><name>nDoc</name><operator>-</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iEnd</name> <operator>=</operator> <name>nDoc</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>tailEllipsis</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>tailEllipsis</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <while>while<condition>( <expr><name>iMatch</name><operator>&lt;</operator><name>nMatch</name> <operator>&amp;&amp;</operator> <name><name>aMatch</name><index>[<expr><name>iMatch</name></expr>]</index></name><operator>.</operator><name>iCol</name><operator>&lt;</operator><name>iCol</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>iMatch</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
    <while>while<condition>( <expr><name>iStart</name><operator>&lt;</operator><name>iEnd</name></expr> )</condition><block>{<block_content>
      <while>while<condition>( <expr><name>iMatch</name><operator>&lt;</operator><name>nMatch</name> <operator>&amp;&amp;</operator> <name><name>aMatch</name><index>[<expr><name>iMatch</name></expr>]</index></name><operator>.</operator><name>iStart</name><operator>&lt;</operator><name>iStart</name>
             <operator>&amp;&amp;</operator> <name><name>aMatch</name><index>[<expr><name>iMatch</name></expr>]</index></name><operator>.</operator><name>iCol</name><operator>&lt;=</operator><name>iCol</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iMatch</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name>iMatch</name><operator>&lt;</operator><name>nMatch</name> <operator>&amp;&amp;</operator> <name><name>aMatch</name><index>[<expr><name>iMatch</name></expr>]</index></name><operator>.</operator><name>iStart</name><operator>&lt;</operator><name>iEnd</name>
             <operator>&amp;&amp;</operator> <name><name>aMatch</name><index>[<expr><name>iMatch</name></expr>]</index></name><operator>.</operator><name>iCol</name><operator>==</operator><name>iCol</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>nappend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zDoc</name><index>[<expr><name>iStart</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>aMatch</name><index>[<expr><name>iMatch</name></expr>]</index></name><operator>.</operator><name>iStart</name> <operator>-</operator> <name>iStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iStart</name> <operator>=</operator> <name><name>aMatch</name><index>[<expr><name>iMatch</name></expr>]</index></name><operator>.</operator><name>iStart</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>zStartMark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>nappend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zDoc</name><index>[<expr><name>iStart</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>aMatch</name><index>[<expr><name>iMatch</name></expr>]</index></name><operator>.</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>zEndMark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iStart</name> <operator>+=</operator> <name><name>aMatch</name><index>[<expr><name>iMatch</name></expr>]</index></name><operator>.</operator><name>nByte</name></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>iMatch</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nMatch</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>aMatch</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>iTerm</name><operator>==</operator><name><name>aMatch</name><index>[<expr><name>iMatch</name></expr>]</index></name><operator>.</operator><name>iTerm</name>
              <operator>&amp;&amp;</operator> <name><name>aMatch</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>snStatus</name><operator>==</operator><name>SNIPPET_DESIRED</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>nDesired</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>aMatch</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>snStatus</name> <operator>=</operator> <name>SNIPPET_IGNORE</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>nappend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zDoc</name><index>[<expr><name>iStart</name></expr>]</index></name></expr></argument>, <argument><expr><name>iEnd</name> <operator>-</operator> <name>iStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iStart</name> <operator>=</operator> <name>iEnd</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>tailCol</name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tailOffset</name> <operator>=</operator> <name>iEnd</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>trimWhiteSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>tailEllipsis</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>appendWhiteSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>zEllipsis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>zSnippet</name></name> <operator>=</operator> <call><name>stringBufferData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>nSnippet</name></name> <operator>=</operator> <call><name>stringBufferLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Close the cursor.  For additional information see the documentation
** on the xClose method of the virtual table interface.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS2 Close %p\n"</literal><operator>,</operator> <name>c</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>queryClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>q</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>snippetClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>snippet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>c</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>nData</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>dlrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS2 Next %p\n"</literal><operator>,</operator> <name>pCursor</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>snippetClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>snippet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>c</name><operator>-&gt;</operator><name>iCursorType</name></name> <operator>&lt;</operator> <name>QUERY_FULLTEXT</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* TODO(shess) Handle SQLITE_SCHEMA AND SQLITE_BUSY. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>SQLITE_ROW</name></expr>:</case>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      <case>case <expr><name>SQLITE_DONE</name></expr>:</case>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      <default>default:</default>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></switch>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* full-text query */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>( <expr><name><name>c</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>nData</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>dlrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* TODO(shess) Handle SQLITE_SCHEMA AND SQLITE_BUSY. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>   <comment type="block">/* the case we expect */</comment>
      <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* an error occurred; abort */</comment>
    <return>return <expr><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> ?</condition><then> <expr><name>SQLITE_ERROR</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* TODO(shess) If we pushed LeafReader to the top of the file, or to
** another file, term_select() could be pushed above
** docListOfTerm().
*/</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>termSelect</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isPrefix</name></decl></parameter>,
                      <parameter><decl><type><name>DocListType</name></type> <name>iType</name></decl></parameter>, <parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Return a DocList corresponding to the query term *pTerm.  If *pTerm
** is the first term of a phrase query, go ahead and evaluate the phrase
** query and return the doclist for the entire phrase query.
**
** The resulting DL_DOCIDS doclist is stored in pResult, which is
** overwritten.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>docListOfTerm</name><parameter_list>(
  <parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,   <comment type="block">/* The full text index */</comment>
  <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>,        <comment type="block">/* column to restrict to.  No restriction if &gt;=nColumn */</comment>
  <parameter><decl><type><name>QueryTerm</name> <modifier>*</modifier></type><name>pQTerm</name></decl></parameter>,  <comment type="block">/* Term we are looking for, or 1st term of a phrase */</comment>
  <parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>pResult</name></decl></parameter> <comment type="block">/* Write the result here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DataBuffer</name></type> <name>left</name></decl>, <decl><type ref="prev"/><name>right</name></decl>, <decl><type ref="prev"/><name>new</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* No phrase search if no position info. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pQTerm</name><operator>-&gt;</operator><name>nPhrase</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>DL_DEFAULT</name><operator>!=</operator><name>DL_DOCIDS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This code should never be called with buffered updates. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>v</name><operator>-&gt;</operator><name>nPendingData</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>termSelect</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name><name>pQTerm</name><operator>-&gt;</operator><name>pTerm</name></name></expr></argument>, <argument><expr><name><name>pQTerm</name><operator>-&gt;</operator><name>nTerm</name></name></expr></argument>, <argument><expr><name><name>pQTerm</name><operator>-&gt;</operator><name>isPrefix</name></name></expr></argument>,
                  <argument><expr><ternary><condition><expr><literal type="number">0</literal><operator>&lt;</operator><name><name>pQTerm</name><operator>-&gt;</operator><name>nPhrase</name></name></expr> ?</condition><then> <expr><name>DL_POSITIONS</name></expr> </then><else>: <expr><name>DL_DOCIDS</name></expr></else></ternary></expr></argument>, <argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name><name>pQTerm</name><operator>-&gt;</operator><name>nPhrase</name></name> <operator>&amp;&amp;</operator> <name><name>left</name><operator>.</operator><name>nData</name></name><operator>&gt;</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>termSelect</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name><name>pQTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pTerm</name></expr></argument>, <argument><expr><name><name>pQTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nTerm</name></expr></argument>,
                    <argument><expr><name><name>pQTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isPrefix</name></expr></argument>, <argument><expr><name>DL_POSITIONS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>docListPhraseMerge</name><argument_list>(<argument><expr><name><name>left</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>left</name><operator>.</operator><name>nData</name></name></expr></argument>, <argument><expr><name><name>right</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>right</name><operator>.</operator><name>nData</name></name></expr></argument>,
                       <argument><expr><ternary><condition><expr><name>i</name><operator>&lt;</operator><name><name>pQTerm</name><operator>-&gt;</operator><name>nPhrase</name></name></expr> ?</condition><then> <expr><name>DL_POSITIONS</name></expr> </then><else>: <expr><name>DL_DOCIDS</name></expr></else></ternary></expr></argument>, <argument><expr><operator>&amp;</operator><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>left</name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add a new term pTerm[0..nTerm-1] to the query *q.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>queryAdd</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>q</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>QueryTerm</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>++</operator><name><name>q</name><operator>-&gt;</operator><name>nTerms</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>pTerms</name></name> <operator>=</operator> <call><name>sqlite3_realloc</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>pTerms</name></name></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>nTerms</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>pTerms</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>q</name><operator>-&gt;</operator><name>pTerms</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>nTerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>t</name> <operator>=</operator> <operator>&amp;</operator><name><name>q</name><operator>-&gt;</operator><name>pTerms</name><index>[<expr><name><name>q</name><operator>-&gt;</operator><name>nTerms</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CLEAR</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>pTerm</name></name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nTerm</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>pTerm</name></name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>pTerm</name><index>[<expr><name>nTerm</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>nTerm</name></name> <operator>=</operator> <name>nTerm</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>isOr</name></name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>nextIsOr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>isPrefix</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>nextIsOr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>nextColumn</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>nextColumn</name></name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>dfltColumn</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Check to see if the string zToken[0...nToken-1] matches any
** column name in the virtual table.   If it does,
** return the zero-indexed column number.  If not, return -1.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>checkColumnSpecifier</name><parameter_list>(
  <parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>,    <comment type="block">/* The virtual table */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zToken</name></decl></parameter>,      <comment type="block">/* Text of the token */</comment>
  <parameter><decl><type><name>int</name></type> <name>nToken</name></decl></parameter>               <comment type="block">/* Number of characters in the token */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pVtab</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>azColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>zToken</name></expr></argument>, <argument><expr><name>nToken</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
        <operator>&amp;&amp;</operator> <name><name>pVtab</name><operator>-&gt;</operator><name>azColumn</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>nToken</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>i</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Parse the text at pSegment[0..nSegment-1].  Add additional terms
** to the query being assemblied in pQuery.
**
** inPhrase is true if pSegment[0..nSegement-1] is contained within
** double-quotes.  If inPhrase is true, then the first term
** is marked with the number of terms in the phrase less one and
** OR and "-" syntax is ignored.  If inPhrase is false, then every
** term found is marked with nPhrase=0 and OR and "-" syntax is significant.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>tokenizeSegment</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name></decl></parameter>,          <comment type="block">/* The tokenizer to use */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pSegment</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nSegment</name></decl></parameter>,     <comment type="block">/* Query expression being parsed */</comment>
  <parameter><decl><type><name>int</name></type> <name>inPhrase</name></decl></parameter>,                           <comment type="block">/* True if within "..." */</comment>
  <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>pQuery</name></decl></parameter>                           <comment type="block">/* Append results here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_tokenizer_module</name> <modifier>*</modifier></type><name>pModule</name> <init>= <expr><name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>firstIndex</name> <init>= <expr><name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name><name>pModule</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pTokenizer</name></expr></argument>, <argument><expr><name>pSegment</name></expr></argument>, <argument><expr><name>nSegment</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCursor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pCursor</name><operator>-&gt;</operator><name>pTokenizer</name></name> <operator>=</operator> <name>pTokenizer</name></expr>;</expr_stmt>

  <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pToken</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nToken</name></decl>, <decl><type ref="prev"/><name>iBegin</name></decl>, <decl><type ref="prev"/><name>iEnd</name></decl>, <decl><type ref="prev"/><name>iPos</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xNext</name></name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>pToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nToken</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>iBegin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>inPhrase</name> <operator>&amp;&amp;</operator>
        <name><name>pSegment</name><index>[<expr><name>iEnd</name></expr>]</index></name><operator>==</operator><literal type="char">':'</literal> <operator>&amp;&amp;</operator>
         <operator>(</operator><name>iCol</name> <operator>=</operator> <call><name>checkColumnSpecifier</name><argument_list>(<argument><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pFts</name></name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>, <argument><expr><name>nToken</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>nextColumn</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>inPhrase</name> <operator>&amp;&amp;</operator> <name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nToken</name><operator>==</operator><literal type="number">2</literal>
         <operator>&amp;&amp;</operator> <name><name>pSegment</name><index>[<expr><name>iBegin</name></expr>]</index></name><operator>==</operator><literal type="char">'O'</literal> <operator>&amp;&amp;</operator> <name><name>pSegment</name><index>[<expr><name>iBegin</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'R'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>nextIsOr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>queryAdd</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>, <argument><expr><name>nToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>inPhrase</name> <operator>&amp;&amp;</operator> <name>iBegin</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pSegment</name><index>[<expr><name>iBegin</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pTerms</name><index>[<expr><name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isNot</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iEnd</name><operator>&lt;</operator><name>nSegment</name> <operator>&amp;&amp;</operator> <name><name>pSegment</name><index>[<expr><name>iEnd</name></expr>]</index></name><operator>==</operator><literal type="char">'*'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pTerms</name><index>[<expr><name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isPrefix</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pTerms</name><index>[<expr><name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iPhrase</name> <operator>=</operator> <name>nTerm</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>inPhrase</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nTerm</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name>inPhrase</name> <operator>&amp;&amp;</operator> <name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name><operator>&gt;</operator><name>firstIndex</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pTerms</name><index>[<expr><name>firstIndex</name></expr>]</index></name><operator>.</operator><name>nPhrase</name> <operator>=</operator> <name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name> <operator>-</operator> <name>firstIndex</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><call><name><name>pModule</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parse a query string, yielding a Query object pQuery.
**
** The calling function will need to queryClear() to clean up
** the dynamically allocated memory held by pQuery.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>parseQuery</name><parameter_list>(
  <parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,        <comment type="block">/* The fulltext index */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zInput</name></decl></parameter>,      <comment type="block">/* Input text of the query string */</comment>
  <parameter><decl><type><name>int</name></type> <name>nInput</name></decl></parameter>,              <comment type="block">/* Size of the input text */</comment>
  <parameter><decl><type><name>int</name></type> <name>dfltColumn</name></decl></parameter>,          <comment type="block">/* Default column of the index to match against */</comment>
  <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>pQuery</name></decl></parameter>            <comment type="block">/* Write the parse results here. */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iInput</name></decl>, <decl><type ref="prev"/><name>inPhrase</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>zInput</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nInput</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nInput</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nInput</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zInput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pTerms</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>nextIsOr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>nextColumn</name></name> <operator>=</operator> <name>dfltColumn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>dfltColumn</name></name> <operator>=</operator> <name>dfltColumn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pFts</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>iInput</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iInput</name><operator>&lt;</operator><name>nInput</name></expr>;</condition> <incr><expr><operator>++</operator><name>iInput</name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>iInput</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nInput</name> <operator>&amp;&amp;</operator> <name><name>zInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'"'</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content/>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><name>iInput</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>tokenizeSegment</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></argument>, <argument><expr><name>zInput</name><operator>+</operator><name>iInput</name></expr></argument>, <argument><expr><name>i</name><operator>-</operator><name>iInput</name></expr></argument>, <argument><expr><name>inPhrase</name></expr></argument>,
                       <argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iInput</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name>nInput</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'"'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>inPhrase</name> <operator>=</operator> <operator>!</operator><name>inPhrase</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>inPhrase</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* unmatched quote */</comment>
    <expr_stmt><expr><call><name>queryClear</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* TODO(shess) Refactor the code to remove this forward decl. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>flushPendingTerms</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Perform a full-text query using the search expression in
** zInput[0..nInput-1].  Return a list of matching documents
** in pResult.
**
** Queries must match column iColumn.  Or if iColumn&gt;=nColumn
** they are allowed to match against any column.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextQuery</name><parameter_list>(
  <parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,      <comment type="block">/* The full text index */</comment>
  <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>,           <comment type="block">/* Match against this column by default */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zInput</name></decl></parameter>,    <comment type="block">/* The query string */</comment>
  <parameter><decl><type><name>int</name></type> <name>nInput</name></decl></parameter>,            <comment type="block">/* Number of bytes in zInput[] */</comment>
  <parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>pResult</name></decl></parameter>,   <comment type="block">/* Write the result doclist here */</comment>
  <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>pQuery</name></decl></parameter>          <comment type="block">/* Put parsed query string here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>iNext</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DataBuffer</name></type> <name>left</name></decl>, <decl><type ref="prev"/><name>right</name></decl>, <decl><type ref="prev"/><name>or</name></decl>, <decl><type ref="prev"/><name>new</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nNot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>QueryTerm</name> <modifier>*</modifier></type><name>aTerm</name></decl>;</decl_stmt>

  <comment type="block">/* TODO(shess) Instead of flushing pendingTerms, we could query for
  ** the relevant term and merge the doclist into what we receive from
  ** the database.  Wait and see if this is a common issue, first.
  **
  ** A good reason not to flush is to not generate update-related
  ** error codes from here.
  */</comment>

  <comment type="block">/* Flush any buffered updates before executing the query. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>flushPendingTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* TODO(shess) I think that the queryClear() calls below are not
  ** necessary, because fulltextClose() already clears the query.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>parseQuery</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>zInput</name></expr></argument>, <argument><expr><name>nInput</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Empty or NULL queries return no results. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><name>pResult</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Merge AND terms. */</comment>
  <comment type="block">/* TODO(shess) I think we can early-exit if( i&gt;nNot &amp;&amp; left.nData==0 ). */</comment>
  <expr_stmt><expr><name>aTerm</name> <operator>=</operator> <name><name>pQuery</name><operator>-&gt;</operator><name>pTerms</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name></expr>;</condition> <incr><expr><name>i</name><operator>=</operator><name>iNext</name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isNot</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Handle all NOT terms in a separate pass */</comment>
      <expr_stmt><expr><name>nNot</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>iNext</name> <operator>=</operator> <name>i</name> <operator>+</operator> <name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nPhrase</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iNext</name> <operator>=</operator> <name>i</name> <operator>+</operator> <name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nPhrase</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>docListOfTerm</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iColumn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><name>nNot</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>queryClear</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <while>while<condition>( <expr><name>iNext</name><operator>&lt;</operator><name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name> <operator>&amp;&amp;</operator> <name><name>aTerm</name><index>[<expr><name>iNext</name></expr>]</index></name><operator>.</operator><name>isOr</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>docListOfTerm</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>aTerm</name><index>[<expr><name>iNext</name></expr>]</index></name><operator>.</operator><name>iColumn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aTerm</name><index>[<expr><name>iNext</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>or</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iNext</name> <operator>+=</operator> <name><name>aTerm</name><index>[<expr><name>iNext</name></expr>]</index></name><operator>.</operator><name>nPhrase</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>i</name><operator>!=</operator><name>nNot</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>queryClear</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>docListOrMerge</name><argument_list>(<argument><expr><name><name>right</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>right</name><operator>.</operator><name>nData</name></name></expr></argument>, <argument><expr><name><name>or</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>or</name><operator>.</operator><name>nData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>or</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>right</name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>nNot</name></expr> )</condition><block>{<block_content>           <comment type="block">/* first term processed. */</comment>
      <expr_stmt><expr><name>left</name> <operator>=</operator> <name>right</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>docListAndMerge</name><argument_list>(<argument><expr><name><name>left</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>left</name><operator>.</operator><name>nData</name></name></expr></argument>, <argument><expr><name><name>right</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>right</name><operator>.</operator><name>nData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>left</name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>nNot</name><operator>==</operator><name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* We do not yet know how to handle a query of only NOT terms */</comment>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Do the EXCEPT terms */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name></expr>;</condition>  <incr><expr><name>i</name> <operator>+=</operator> <name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nPhrase</name> <operator>+</operator> <literal type="number">1</literal></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isNot</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>docListOfTerm</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iColumn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>queryClear</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>docListExceptMerge</name><argument_list>(<argument><expr><name><name>left</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>left</name><operator>.</operator><name>nData</name></name></expr></argument>, <argument><expr><name><name>right</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>right</name><operator>.</operator><name>nData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>left</name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is the xFilter interface for the virtual table.  See
** the virtual table xFilter method documentation for additional
** information.
**
** If idxNum==QUERY_GENERIC then do a full table scan against
** the %_content table.
**
** If idxNum==QUERY_ROWID then do a rowid lookup for a single entry
** in the %_content table.
**
** If idxNum&gt;=QUERY_FULLTEXT then use the full text index.  The
** column on the left-hand side of the MATCH operator is column
** number idxNum-QUERY_FULLTEXT, 0 indexed.  argv[0] is the right-hand
** side of the MATCH operator.
*/</comment>
<comment type="block">/* TODO(shess) Upgrade the cursor initialization and destruction to
** account for fulltextFilter() being called multiple times on the
** same cursor.  The current solution is very fragile.  Apply fix to
** fts2 as appropriate.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>,     <comment type="block">/* The cursor used for this query */</comment>
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,   <comment type="block">/* Which indexing scheme to use */</comment>
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>    <comment type="block">/* Arguments for the indexing scheme */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>cursor_vtab</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS2 Filter %p\n"</literal><operator>,</operator><name>pCursor</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the cursor has a statement that was not prepared according to
  ** idxNum, clear it.  I believe all calls to fulltextFilter with a
  ** given cursor will have the same idxNum , but in this case it's
  ** easy to be safe.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>iCursorType</name></name><operator>!=</operator><name>idxNum</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Get a fresh statement appropriate to idxNum. */</comment>
  <comment type="block">/* TODO(shess): Add a prepared-statement cache in the vt structure.
  ** The cache must handle multiple open cursors.  Easier to cache the
  ** statement variants at the vt to reduce malloc/realloc/free here.
  ** Or we could have a StringBuffer variant which allowed stack
  ** construction for small values.
  */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"select rowid, * from %%_content %s"</literal></expr></argument>,
                                 <argument><expr><ternary><condition><expr><name>idxNum</name><operator>==</operator><name>QUERY_GENERIC</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"where rowid=?"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_prepare</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>iCursorType</name></name> <operator>=</operator> <name>idxNum</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>c</name><operator>-&gt;</operator><name>iCursorType</name></name><operator>==</operator><name>idxNum</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <switch>switch<condition>( <expr><name>idxNum</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>QUERY_GENERIC</name></expr>:</case>
      <break>break;</break>

    <case>case <expr><name>QUERY_ROWID</name></expr>:</case>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>

    <default>default:</default>   <comment type="block">/* full-text search */</comment>
    <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zQuery</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idxNum</name><operator>&lt;=</operator><name>QUERY_FULLTEXT</name><operator>+</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>queryClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>q</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>c</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>nData</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* This case happens if the same cursor is used repeatedly. */</comment>
        <expr_stmt><expr><call><name>dlrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dataBufferReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fulltextQuery</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>idxNum</name><operator>-</operator><name>QUERY_FULLTEXT</name></expr></argument>, <argument><expr><name>zQuery</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>q</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>c</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>nData</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>dlrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>, <argument><expr><name>DL_DOCIDS</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>

  <return>return <expr><call><name>fulltextNext</name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This is the xEof method of the virtual table.  The SQLite core
** calls this routine to find out if it has reached the end of
** a query's results set.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>c</name><operator>-&gt;</operator><name>eof</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This is the xColumn method of the virtual table.  The SQLite
** core calls this method during a query when it needs the value
** of a column from the virtual table.  This method needs to use
** one of the sqlite3_result_*() routines to store the requested
** value back in the pContext.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextColumn</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>,
                          <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idxCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>cursor_vtab</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>idxCol</name><operator>&lt;</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>idxCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>idxCol</name><operator>==</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The extra column whose name is the same as the table.
    ** Return a blob which is a pointer to the cursor
    */</comment>
    <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This is the xRowid method.  The SQLite core calls this routine to
** retrive the rowid for the current row of the result set.  The
** rowid should be written to *pRowid.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add all terms in [zText] to pendingTerms table.  If [iColumn] &gt; 0,
** we also store positions and offsets in the hash table using that
** column number.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>buildTerms</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pToken</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTokenBytes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iStartOffset</name></decl>, <decl><type ref="prev"/><name>iEndOffset</name></decl>, <decl><type ref="prev"/><name>iPosition</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pTokenizer</name></expr></argument>, <argument><expr><name>zText</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>pCursor</name><operator>-&gt;</operator><name>pTokenizer</name></name> <operator>=</operator> <name>pTokenizer</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name><operator>=</operator><call><name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xNext</name></name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>,
                                                   <argument><expr><operator>&amp;</operator><name>pToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nTokenBytes</name></expr></argument>,
                                                   <argument><expr><operator>&amp;</operator><name>iStartOffset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iEndOffset</name></expr></argument>,
                                                   <argument><expr><operator>&amp;</operator><name>iPosition</name></expr></argument>)</argument_list></call><operator>)</operator></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>DLCollector</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>                   <comment type="block">/* Size of doclist before our update. */</comment>

    <comment type="block">/* Positions can't be negative; we use -1 as a terminator
     * internally.  Token can't be NULL or empty. */</comment>
    <if_stmt><if>if<condition>( <expr><name>iPosition</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>pToken</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>nTokenBytes</name> <operator>==</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>fts2HashFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>pendingTerms</name></name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>, <argument><expr><name>nTokenBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><name>NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nData</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>dlcNew</name><argument_list>(<argument><expr><name>iDocid</name></expr></argument>, <argument><expr><name>DL_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts2HashInsert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>pendingTerms</name></name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>, <argument><expr><name>nTokenBytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Overhead for our hash table entry, the key, and the value. */</comment>
      <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nPendingData</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>fts2HashElem</name></expr></argument>)</argument_list></sizeof><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>nTokenBytes</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>nData</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>b</name><operator>.</operator><name>nData</name></name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>dlw</name><operator>.</operator><name>iPrevDocid</name></name><operator>!=</operator><name>iDocid</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>dlcNext</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>dlcAddPos</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name>iPosition</name></expr></argument>, <argument><expr><name>iStartOffset</name></expr></argument>, <argument><expr><name>iEndOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Accumulate data added by dlcNew or dlcNext, and dlcAddPos. */</comment>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nPendingData</name></name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>b</name><operator>.</operator><name>nData</name></name><operator>-</operator><name>nData</name></expr>;</expr_stmt>
  </block_content>}</block></while>

  <comment type="block">/* TODO(shess) Check return?  Should this be able to cause errors at
  ** this point?  Actually, same question about sqlite3_finalize(),
  ** though one could argue that failure there means that the data is
  ** not durable.  *ponder*
  */</comment>
  <expr_stmt><expr><call><name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_DONE</name> <operator>==</operator> <name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add doclists for all terms in [pValues] to pendingTerms table. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>insertTerms</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iRowid</name></decl></parameter>,
                       <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>pValues</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr> ;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zText</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>pValues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>buildTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>, <argument><expr><name>zText</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add empty doclists for all terms in the given row's content to
** pendingTerms.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>deleteTerms</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pValues</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* TODO(shess) Should we allow such tables at all? */</comment>
  <if_stmt><if>if<condition>( <expr><name>DL_DEFAULT</name><operator>==</operator><name>DL_DOCIDS</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>content_select</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>buildTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>, <argument><expr><name><name>pValues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>freeStringArray</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>, <argument><expr><name>pValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* TODO(shess) Refactor the code to remove this forward decl. */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>initPendingTerms</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Insert a row into the %_content table; set *piRowid to be the ID of the
** new row.  Add doclists for terms to pendingTerms.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>index_insert</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pRequestRowid</name></decl></parameter>,
                        <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>pValues</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>piRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>content_insert</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pRequestRowid</name></expr></argument>, <argument><expr><name>pValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* execute an SQL INSERT */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>piRowid</name> <operator>=</operator> <call><name>sqlite3_last_insert_rowid</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>initPendingTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>*</operator><name>piRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>insertTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>*</operator><name>piRowid</name></expr></argument>, <argument><expr><name>pValues</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Delete a row from the %_content table; add empty doclists for terms
** to pendingTerms.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>index_delete</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iRow</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>initPendingTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iRow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>deleteTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>content_delete</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iRow</name></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* execute an SQL DELETE */</comment>
</block_content>}</block></function>

<comment type="block">/* Update a row in the %_content table; add delete doclists to
** pendingTerms for old terms not in the new data, add insert doclists
** to pendingTerms for terms in the new data.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>index_update</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iRow</name></decl></parameter>,
                        <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>pValues</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>initPendingTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iRow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Generate an empty doclist for each term that previously appeared in this
   * row. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>deleteTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>content_update</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pValues</name></expr></argument>, <argument><expr><name>iRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* execute an SQL UPDATE */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Now add positions for terms which appear in the updated row. */</comment>
  <return>return <expr><call><name>insertTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iRow</name></expr></argument>, <argument><expr><name>pValues</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*******************************************************************/</comment>
<comment type="block">/* InteriorWriter is used to collect terms and block references into
** interior nodes in %_segments.  See commentary at top of file for
** format.
*/</comment>

<comment type="block">/* How large interior nodes can grow. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTERIOR_MAX</name></cpp:macro> <cpp:value>2048</cpp:value></cpp:define>

<comment type="block">/* Minimum number of terms per interior node (except the root). This
** prevents large terms from making the tree too skinny - must be &gt;0
** so that the tree always makes progress.  Note that the min tree
** fanout will be INTERIOR_MIN_TERMS+1.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTERIOR_MIN_TERMS</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>INTERIOR_MIN_TERMS</name><operator>&lt;</operator><literal type="number">1</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> INTERIOR_MIN_TERMS must be greater than 0.</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ROOT_MAX controls how much data is stored inline in the segment
** directory.
*/</comment>
<comment type="block">/* TODO(shess) Push ROOT_MAX down to whoever is writing things.  It's
** only here so that interiorWriterRootInfo() and leafWriterRootInfo()
** can both see it, but if the caller passed it in, we wouldn't even
** need a define.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROOT_MAX</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ROOT_MAX</name><operator>&lt;</operator><name>VARINT_MAX</name><operator>*</operator><literal type="number">2</literal></expr></cpp:if>
<cpp:error># <cpp:directive>error</cpp:directive> ROOT_MAX must have enough space for a header.</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* InteriorBlock stores a linked-list of interior blocks while a lower
** layer is being constructed.
*/</comment>
<typedef>typedef <type><struct>struct <name>InteriorBlock</name> <block>{
  <decl_stmt><decl><type><name>DataBuffer</name></type> <name>term</name></decl>;</decl_stmt>           <comment type="block">/* Leftmost term in block's subtree. */</comment>
  <decl_stmt><decl><type><name>DataBuffer</name></type> <name>data</name></decl>;</decl_stmt>           <comment type="block">/* Accumulated data for the block. */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>InteriorBlock</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
}</block></struct></type> <name>InteriorBlock</name>;</typedef>

<function><type><specifier>static</specifier> <name>InteriorBlock</name> <modifier>*</modifier></type><name>interiorBlockNew</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>iHeight</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iChildBlock</name></decl></parameter>,
                                       <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>InteriorBlock</name> <modifier>*</modifier></type><name>block</name> <init>= <expr><call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>InteriorBlock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><name>VARINT_MAX</name><operator>+</operator><name>VARINT_MAX</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>block</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>block</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>block</name><operator>-&gt;</operator><name>term</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dataBufferReplace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>block</name><operator>-&gt;</operator><name>term</name></name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>iHeight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name>c</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>iChildBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>block</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>INTERIOR_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dataBufferReplace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>block</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>block</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/* Verify that the data is readable as an interior node. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>interiorBlockValidate</name><parameter_list>(<parameter><decl><type><name>InteriorBlock</name> <modifier>*</modifier></type><name>pBlock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><name><name>pBlock</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name> <init>= <expr><name><name>pBlock</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>iDummy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iBlockid</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nData</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pData</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pData</name><operator>+</operator><name>nData</name><operator>&gt;</operator><name>pData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Must lead with height of node as a varint(n), n&gt;0 */</comment>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDummy</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;</operator><name>nData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pData</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nData</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>

  <comment type="block">/* Must contain iBlockid. */</comment>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getVarint</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBlockid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;=</operator><name>nData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pData</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nData</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>

  <comment type="block">/* Zero or more terms of positive length */</comment>
  <if_stmt><if>if<condition>( <expr><name>nData</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* First term is not delta-encoded. */</comment>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDummy</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><name>iDummy</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><name>iDummy</name><operator>&lt;=</operator><name>nData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pData</name> <operator>+=</operator> <name>n</name><operator>+</operator><name>iDummy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nData</name> <operator>-=</operator> <name>n</name><operator>+</operator><name>iDummy</name></expr>;</expr_stmt>

    <comment type="block">/* Following terms delta-encoded. */</comment>
    <while>while<condition>( <expr><name>nData</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Length of shared prefix. */</comment>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDummy</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;</operator><name>nData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pData</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nData</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>

      <comment type="block">/* Length and data of distinct suffix. */</comment>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDummy</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><name>iDummy</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><name>iDummy</name><operator>&lt;=</operator><name>nData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pData</name> <operator>+=</operator> <name>n</name><operator>+</operator><name>iDummy</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nData</name> <operator>-=</operator> <name>n</name><operator>+</operator><name>iDummy</name></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_VALID_INTERIOR_BLOCK</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>interiorBlockValidate(x)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_VALID_INTERIOR_BLOCK</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>assert( 1 )</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct <name>InteriorWriter</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iHeight</name></decl>;</decl_stmt>                   <comment type="block">/* from 0 at leaves. */</comment>
  <decl_stmt><decl><type><name>InteriorBlock</name> <modifier>*</modifier></type><name>first</name></decl>, <modifier>*</modifier><name>last</name>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>InteriorWriter</name></name> <modifier>*</modifier></type><name>parentWriter</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>DataBuffer</name></type> <name>term</name></decl>;</decl_stmt>               <comment type="block">/* Last term written to block "last". */</comment>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iOpeningChildBlock</name></decl>;</decl_stmt> <comment type="block">/* First child block in block "last". */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iLastChildBlock</name></decl>;</decl_stmt>  <comment type="block">/* for consistency checks. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>InteriorWriter</name>;</typedef>

<comment type="block">/* Initialize an interior node where pTerm[nTerm] marks the leftmost
** term in the tree.  iChildBlock is the leftmost child block at the
** next level down the tree.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>interiorWriterInit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>iHeight</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,
                               <parameter><decl><type><name>sqlite_int64</name></type> <name>iChildBlock</name></decl></parameter>,
                               <parameter><decl><type><name>InteriorWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>InteriorBlock</name> <modifier>*</modifier></type><name>block</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iHeight</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CLEAR</name><argument_list>(<argument><expr><name>pWriter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iHeight</name></name> <operator>=</operator> <name>iHeight</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iOpeningChildBlock</name></name> <operator>=</operator> <name>iChildBlock</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iLastChildBlock</name></name> <operator>=</operator> <name>iChildBlock</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>interiorBlockNew</name><argument_list>(<argument><expr><name>iHeight</name></expr></argument>, <argument><expr><name>iChildBlock</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name>block</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ASSERT_VALID_INTERIOR_BLOCK</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>last</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>term</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Append the child node rooted at iChildBlock to the interior node,
** with pTerm[nTerm] as the leftmost term in iChildBlock's subtree.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>interiorWriterAppend</name><parameter_list>(<parameter><decl><type><name>InteriorWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,
                                 <parameter><decl><type><name>sqlite_int64</name></type> <name>iChildBlock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><name>VARINT_MAX</name><operator>+</operator><name>VARINT_MAX</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>nPrefix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>ASSERT_VALID_INTERIOR_BLOCK</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>last</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The first term written into an interior node is actually
  ** associated with the second child added (the first child was added
  ** in interiorWriterInit, or in the if clause at the bottom of this
  ** function).  That term gets encoded straight up, with nPrefix left
  ** at 0.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pWriter</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>nData</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <while>while<condition>( <expr><name>nPrefix</name><operator>&lt;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>nData</name></name> <operator>&amp;&amp;</operator>
           <name><name>pTerm</name><index>[<expr><name>nPrefix</name></expr>]</index></name><operator>==</operator><name><name>pWriter</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>pData</name><index>[<expr><name>nPrefix</name></expr>]</index></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nPrefix</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>nPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name>c</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>nTerm</name><operator>-</operator><name>nPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iLastChildBlock</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iLastChildBlock</name></name><operator>==</operator><name>iChildBlock</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Overflow to a new block if the new term makes the current block
  ** too big, and the current block already has enough terms.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pWriter</name><operator>-&gt;</operator><name>last</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name><operator>+</operator><name>n</name><operator>+</operator><name>nTerm</name><operator>-</operator><name>nPrefix</name><operator>&gt;</operator><name>INTERIOR_MAX</name> <operator>&amp;&amp;</operator>
      <name>iChildBlock</name><operator>-</operator><name><name>pWriter</name><operator>-&gt;</operator><name>iOpeningChildBlock</name></name><operator>&gt;</operator><name>INTERIOR_MIN_TERMS</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <call><name>interiorBlockNew</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iHeight</name></name></expr></argument>, <argument><expr><name>iChildBlock</name></expr></argument>,
                                           <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>last</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iOpeningChildBlock</name></name> <operator>=</operator> <name>iChildBlock</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dataBufferReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>term</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>dataBufferAppend2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>last</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>,
                      <argument><expr><name>pTerm</name><operator>+</operator><name>nPrefix</name></expr></argument>, <argument><expr><name>nTerm</name><operator>-</operator><name>nPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dataBufferReplace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>term</name></name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>ASSERT_VALID_INTERIOR_BLOCK</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>last</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Free the space used by pWriter, including the linked-list of
** InteriorBlocks, and parentWriter, if present.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>interiorWriterDestroy</name><parameter_list>(<parameter><decl><type><name>InteriorWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>InteriorBlock</name> <modifier>*</modifier></type><name>block</name> <init>= <expr><name><name>pWriter</name><operator>-&gt;</operator><name>first</name></name></expr></init></decl>;</decl_stmt>

  <while>while<condition>( <expr><name>block</name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>InteriorBlock</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><name>block</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>block</name> <operator>=</operator> <name><name>block</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>term</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name><name>pWriter</name><operator>-&gt;</operator><name>parentWriter</name></name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>interiorWriterDestroy</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>parentWriter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>parentWriter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>term</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SCRAMBLE</name><argument_list>(<argument><expr><name>pWriter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* If pWriter can fit entirely in ROOT_MAX, return it as the root info
** directly, leaving *piEndBlockid unchanged.  Otherwise, flush
** pWriter to %_segments, building a new layer of interior nodes, and
** recursively ask for their root into.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>interiorWriterRootInfo</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>InteriorWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>,
                                  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppRootInfo</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnRootInfo</name></decl></parameter>,
                                  <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>piEndBlockid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>InteriorBlock</name> <modifier>*</modifier></type><name>block</name> <init>= <expr><name><name>pWriter</name><operator>-&gt;</operator><name>first</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iBlockid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <comment type="block">/* If we can fit the segment inline */</comment>
  <if_stmt><if>if<condition>( <expr><name>block</name><operator>==</operator><name><name>pWriter</name><operator>-&gt;</operator><name>last</name></name> <operator>&amp;&amp;</operator> <name><name>block</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name><operator>&lt;</operator><name>ROOT_MAX</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppRootInfo</name> <operator>=</operator> <name><name>block</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnRootInfo</name> <operator>=</operator> <name><name>block</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Flush the first block to %_segments, and create a new level of
  ** interior node.
  */</comment>
  <expr_stmt><expr><call><name>ASSERT_VALID_INTERIOR_BLOCK</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>block_insert</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBlockid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>piEndBlockid</name> <operator>=</operator> <name>iBlockid</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>parentWriter</name></name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>pWriter</name><operator>-&gt;</operator><name>parentWriter</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>interiorWriterInit</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iHeight</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,
                     <argument><expr><name><name>block</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>nData</name></name></expr></argument>,
                     <argument><expr><name>iBlockid</name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>parentWriter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Flush additional blocks and append to the higher interior
  ** node.
  */</comment>
  <for>for<control>(<init><expr><name>block</name><operator>=</operator><name><name>block</name><operator>-&gt;</operator><name>next</name></name></expr>;</init> <condition><expr><name>block</name><operator>!=</operator><name>NULL</name></expr>;</condition> <incr><expr><name>block</name><operator>=</operator><name><name>block</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>ASSERT_VALID_INTERIOR_BLOCK</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>block_insert</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBlockid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>piEndBlockid</name> <operator>=</operator> <name>iBlockid</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>interiorWriterAppend</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>parentWriter</name></name></expr></argument>,
                         <argument><expr><name><name>block</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>nData</name></name></expr></argument>, <argument><expr><name>iBlockid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Parent node gets the chance to be the root. */</comment>
  <return>return <expr><call><name>interiorWriterRootInfo</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>parentWriter</name></name></expr></argument>,
                                <argument><expr><name>ppRootInfo</name></expr></argument>, <argument><expr><name>pnRootInfo</name></expr></argument>, <argument><expr><name>piEndBlockid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/****************************************************************/</comment>
<comment type="block">/* InteriorReader is used to read off the data from an interior node
** (see comment at top of file for the format).
*/</comment>
<typedef>typedef <type><struct>struct <name>InteriorReader</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>DataBuffer</name></type> <name>term</name></decl>;</decl_stmt>          <comment type="block">/* previous term, for decoding term delta. */</comment>

  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iBlockid</name></decl>;</decl_stmt>
}</block></struct></type> <name>InteriorReader</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>interiorReaderDestroy</name><parameter_list>(<parameter><decl><type><name>InteriorReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>term</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SCRAMBLE</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* TODO(shess) The assertions are great, but what if we're in NDEBUG
** and the blob is empty or otherwise contains suspect data?
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>interiorReaderInit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>,
                               <parameter><decl><type><name>InteriorReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>nTerm</name></decl>;</decl_stmt>

  <comment type="block">/* Require at least the leading flag byte */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nData</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>!=</operator><literal type="char">'\0'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>CLEAR</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Decode the base blockid, and set the cursor to the first term. */</comment>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getVarint</name><argument_list>(<argument><expr><name>pData</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>iBlockid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">1</literal><operator>+</operator><name>n</name><operator>&lt;=</operator><name>nData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <name>pData</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <name>nData</name><operator>-</operator><operator>(</operator><literal type="number">1</literal><operator>+</operator><name>n</name><operator>)</operator></expr>;</expr_stmt>

  <comment type="block">/* A single-child interior node (such as when a leaf node was too
  ** large for the segment directory) won't have any terms.
  ** Otherwise, decode the first term.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>term</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>term</name></name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dataBufferReplace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>term</name></name></expr></argument>, <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><name>nTerm</name><operator>&lt;=</operator><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name> <operator>+=</operator> <name>n</name><operator>+</operator><name>nTerm</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name> <operator>-=</operator> <name>n</name><operator>+</operator><name>nTerm</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>interiorReaderAtEnd</name><parameter_list>(<parameter><decl><type><name>InteriorReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>nData</name></name><operator>==</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sqlite_int64</name></type> <name>interiorReaderCurrentBlockid</name><parameter_list>(<parameter><decl><type><name>InteriorReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>iBlockid</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>interiorReaderTermBytes</name><parameter_list>(<parameter><decl><type><name>InteriorReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>interiorReaderAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>nData</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>interiorReaderTerm</name><parameter_list>(<parameter><decl><type><name>InteriorReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>interiorReaderAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>pData</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Step forward to the next term in the node. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>interiorReaderStep</name><parameter_list>(<parameter><decl><type><name>InteriorReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>interiorReaderAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the last term has been read, signal eof, else construct the
  ** next term.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>dataBufferReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>term</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>nPrefix</name></decl>, <decl><type ref="prev"/><name>nSuffix</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Truncate the current term and append suffix data. */</comment>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>nData</name></name> <operator>=</operator> <name>nPrefix</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>term</name></name></expr></argument>, <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>nSuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><name>nSuffix</name><operator>&lt;=</operator><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name> <operator>+=</operator> <name>n</name><operator>+</operator><name>nSuffix</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name> <operator>-=</operator> <name>n</name><operator>+</operator><name>nSuffix</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iBlockid</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Compare the current term to pTerm[nTerm], returning strcmp-style
** results.  If isPrefix, equality means equal through nTerm bytes.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>interiorReaderTermCmp</name><parameter_list>(<parameter><decl><type><name>InteriorReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isPrefix</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pReaderTerm</name> <init>= <expr><call><name>interiorReaderTerm</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nReaderTerm</name> <init>= <expr><call><name>interiorReaderTermBytes</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><ternary><condition><expr><name>nReaderTerm</name><operator>&lt;</operator><name>nTerm</name></expr> ?</condition><then> <expr><name>nReaderTerm</name></expr> </then><else>: <expr><name>nTerm</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>nReaderTerm</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nTerm</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>pReaderTerm</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>c</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>isPrefix</name> <operator>&amp;&amp;</operator> <name>n</name><operator>==</operator><name>nTerm</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>nReaderTerm</name> <operator>-</operator> <name>nTerm</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/****************************************************************/</comment>
<comment type="block">/* LeafWriter is used to collect terms and associated doclist data
** into leaf blocks in %_segments (see top of file for format info).
** Expected usage is:
**
** LeafWriter writer;
** leafWriterInit(0, 0, &amp;writer);
** while( sorted_terms_left_to_process ){
**   // data is doclist data for that term.
**   rc = leafWriterStep(v, &amp;writer, pTerm, nTerm, pData, nData);
**   if( rc!=SQLITE_OK ) goto err;
** }
** rc = leafWriterFinalize(v, &amp;writer);
**err:
** leafWriterDestroy(&amp;writer);
** return rc;
**
** leafWriterStep() may write a collected leaf out to %_segments.
** leafWriterFinalize() finishes writing any buffered data and stores
** a root node in %_segdir.  leafWriterDestroy() frees all buffers and
** InteriorWriters allocated as part of writing this segment.
**
** TODO(shess) Document leafWriterStepMerge().
*/</comment>

<comment type="block">/* Put terms with data this big in their own block. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STANDALONE_MIN</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>

<comment type="block">/* Keep leaf blocks below this size. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAF_MAX</name></cpp:macro> <cpp:value>2048</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>LeafWriter</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>iLevel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iStartBlockid</name></decl>;</decl_stmt>     <comment type="block">/* needed to create the root info */</comment>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iEndBlockid</name></decl>;</decl_stmt>       <comment type="block">/* when we're done writing. */</comment>

  <decl_stmt><decl><type><name>DataBuffer</name></type> <name>term</name></decl>;</decl_stmt>                <comment type="block">/* previous encoded term */</comment>
  <decl_stmt><decl><type><name>DataBuffer</name></type> <name>data</name></decl>;</decl_stmt>                <comment type="block">/* encoding buffer */</comment>

  <comment type="block">/* bytes of first term in the current node which distinguishes that
  ** term from the last term of the previous node.
  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTermDistinct</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>InteriorWriter</name></type> <name>parentWriter</name></decl>;</decl_stmt>    <comment type="block">/* if we overflow */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>has_parent</name></decl>;</decl_stmt>
}</block></struct></type> <name>LeafWriter</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>leafWriterInit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>LeafWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>CLEAR</name><argument_list>(<argument><expr><name>pWriter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iLevel</name></name> <operator>=</operator> <name>iLevel</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>idx</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>term</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Start out with a reasonably sized block, though it can grow. */</comment>
  <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>LEAF_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<comment type="block">/* Verify that the data is readable as a leaf node. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>leafNodeValidate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>iDummy</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>nData</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nData</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pData</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pData</name><operator>+</operator><name>nData</name><operator>&gt;</operator><name>pData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Must lead with a varint(0) */</comment>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDummy</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;</operator><name>nData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pData</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nData</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>

  <comment type="block">/* Leading term length and data must fit in buffer. */</comment>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDummy</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><name>iDummy</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><name>iDummy</name><operator>&lt;</operator><name>nData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pData</name> <operator>+=</operator> <name>n</name><operator>+</operator><name>iDummy</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nData</name> <operator>-=</operator> <name>n</name><operator>+</operator><name>iDummy</name></expr>;</expr_stmt>

  <comment type="block">/* Leading term's doclist length and data must fit. */</comment>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDummy</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><name>iDummy</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><name>iDummy</name><operator>&lt;=</operator><name>nData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ASSERT_VALID_DOCLIST</name><argument_list>(<argument><expr><name>DL_DEFAULT</name></expr></argument>, <argument><expr><name>pData</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>iDummy</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pData</name> <operator>+=</operator> <name>n</name><operator>+</operator><name>iDummy</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nData</name> <operator>-=</operator> <name>n</name><operator>+</operator><name>iDummy</name></expr>;</expr_stmt>

  <comment type="block">/* Verify that trailing terms and doclists also are readable. */</comment>
  <while>while<condition>( <expr><name>nData</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDummy</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;</operator><name>nData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pData</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nData</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDummy</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><name>iDummy</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><name>iDummy</name><operator>&lt;</operator><name>nData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pData</name> <operator>+=</operator> <name>n</name><operator>+</operator><name>iDummy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nData</name> <operator>-=</operator> <name>n</name><operator>+</operator><name>iDummy</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDummy</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><name>iDummy</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><name>iDummy</name><operator>&lt;=</operator><name>nData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ASSERT_VALID_DOCLIST</name><argument_list>(<argument><expr><name>DL_DEFAULT</name></expr></argument>, <argument><expr><name>pData</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>iDummy</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pData</name> <operator>+=</operator> <name>n</name><operator>+</operator><name>iDummy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nData</name> <operator>-=</operator> <name>n</name><operator>+</operator><name>iDummy</name></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_VALID_LEAF_NODE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>leafNodeValidate(p, n)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_VALID_LEAF_NODE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>assert( 1 )</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Flush the current leaf node to %_segments, and adding the resulting
** blockid and the starting term to the interior node which will
** contain it.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>leafWriterInternalFlush</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>LeafWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>,
                                   <parameter><decl><type><name>int</name></type> <name>iData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iBlockid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pStartingTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nStartingTerm</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

  <comment type="block">/* Must have the leading varint(0) flag, plus at least some
  ** valid-looking data.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nData</name><operator>&gt;</operator><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iData</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iData</name><operator>+</operator><name>nData</name><operator>&lt;=</operator><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ASSERT_VALID_LEAF_NODE</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name><operator>+</operator><name>iData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>block_insert</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name><operator>+</operator><name>iData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBlockid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iBlockid</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reconstruct the first term in the leaf for purposes of building
  ** the interior node.
  */</comment>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name><operator>+</operator><name>iData</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nStartingTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pStartingTerm</name> <operator>=</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name><operator>+</operator><name>iData</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name><operator>&gt;</operator><name>iData</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>n</name><operator>+</operator><name>nStartingTerm</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nTermDistinct</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nTermDistinct</name></name><operator>&lt;=</operator><name>nStartingTerm</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nStartingTerm</name> <operator>=</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>nTermDistinct</name></name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pWriter</name><operator>-&gt;</operator><name>has_parent</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>interiorWriterAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>parentWriter</name></name></expr></argument>,
                         <argument><expr><name>pStartingTerm</name></expr></argument>, <argument><expr><name>nStartingTerm</name></expr></argument>, <argument><expr><name>iBlockid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>interiorWriterInit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pStartingTerm</name></expr></argument>, <argument><expr><name>nStartingTerm</name></expr></argument>, <argument><expr><name>iBlockid</name></expr></argument>,
                       <argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>parentWriter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>has_parent</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Track the span of this segment's leaf nodes. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pWriter</name><operator>-&gt;</operator><name>iEndBlockid</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iEndBlockid</name></name> <operator>=</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>iStartBlockid</name></name> <operator>=</operator> <name>iBlockid</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iEndBlockid</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iBlockid</name><operator>==</operator><name><name>pWriter</name><operator>-&gt;</operator><name>iEndBlockid</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>leafWriterFlush</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>LeafWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>leafWriterInternalFlush</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pWriter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Re-initialize the output buffer. */</comment>
  <expr_stmt><expr><call><name>dataBufferReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Fetch the root info for the segment.  If the entire leaf fits
** within ROOT_MAX, then it will be returned directly, otherwise it
** will be flushed and the root info will be returned from the
** interior node.  *piEndBlockid is set to the blockid of the last
** interior or leaf node written to disk (0 if none are written at
** all).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>leafWriterRootInfo</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>LeafWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>,
                              <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppRootInfo</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnRootInfo</name></decl></parameter>,
                              <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>piEndBlockid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* we can fit the segment entirely inline */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>pWriter</name><operator>-&gt;</operator><name>has_parent</name></name> <operator>&amp;&amp;</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name><operator>&lt;</operator><name>ROOT_MAX</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ppRootInfo</name> <operator>=</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pnRootInfo</name> <operator>=</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>piEndBlockid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Flush remaining leaf data. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>leafWriterFlush</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pWriter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* We must have flushed a leaf at some point. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>has_parent</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Tenatively set the end leaf blockid as the end blockid.  If the
  ** interior node can be returned inline, this will be the final
  ** blockid, otherwise it will be overwritten by
  ** interiorWriterRootInfo().
  */</comment>
  <expr_stmt><expr><operator>*</operator><name>piEndBlockid</name> <operator>=</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>iEndBlockid</name></name></expr>;</expr_stmt>

  <return>return <expr><call><name>interiorWriterRootInfo</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>parentWriter</name></name></expr></argument>,
                                <argument><expr><name>ppRootInfo</name></expr></argument>, <argument><expr><name>pnRootInfo</name></expr></argument>, <argument><expr><name>piEndBlockid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Collect the rootInfo data and store it into the segment directory.
** This has the effect of flushing the segment's leaf data to
** %_segments, and also flushing any interior nodes to %_segments.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>leafWriterFinalize</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>LeafWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iEndBlockid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pRootInfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>, <decl><type ref="prev"/><name>nRootInfo</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>leafWriterRootInfo</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pWriter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRootInfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nRootInfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iEndBlockid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Don't bother storing an entirely empty segment. */</comment>
  <if_stmt><if>if<condition>( <expr><name>iEndBlockid</name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nRootInfo</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>segdir_set</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iLevel</name></name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>,
                    <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iStartBlockid</name></name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>iEndBlockid</name></name></expr></argument>,
                    <argument><expr><name>iEndBlockid</name></expr></argument>, <argument><expr><name>pRootInfo</name></expr></argument>, <argument><expr><name>nRootInfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>leafWriterDestroy</name><parameter_list>(<parameter><decl><type><name>LeafWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>pWriter</name><operator>-&gt;</operator><name>has_parent</name></name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>interiorWriterDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>parentWriter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>term</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Encode a term into the leafWriter, delta-encoding as appropriate.
** Returns the length of the new term which distinguishes it from the
** previous term, which can be used to set nTermDistinct when a node
** boundary is crossed.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>leafWriterEncodeTerm</name><parameter_list>(<parameter><decl><type><name>LeafWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><name>VARINT_MAX</name><operator>+</operator><name>VARINT_MAX</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>nPrefix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nTerm</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>nPrefix</name><operator>&lt;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>nData</name></name> <operator>&amp;&amp;</operator>
         <name><name>pTerm</name><index>[<expr><name>nPrefix</name></expr>]</index></name><operator>==</operator><name><name>pWriter</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>pData</name><index>[<expr><name>nPrefix</name></expr>]</index></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nPrefix</name><operator>++</operator></expr>;</expr_stmt>
    <comment type="block">/* Failing this implies that the terms weren't in order. */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nPrefix</name><operator>&lt;</operator><name>nTerm</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Encode the node header and leading term as:
    **  varint(0)
    **  varint(nTerm)
    **  char pTerm[nTerm]
    */</comment>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name>c</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dataBufferAppend2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <comment type="block">/* Delta-encode the term as:
    **  varint(nPrefix)
    **  varint(nSuffix)
    **  char pTermSuffix[nSuffix]
    */</comment>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>nPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name>c</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>nTerm</name><operator>-</operator><name>nPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dataBufferAppend2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>pTerm</name><operator>+</operator><name>nPrefix</name></expr></argument>, <argument><expr><name>nTerm</name><operator>-</operator><name>nPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>dataBufferReplace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>term</name></name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>nPrefix</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Used to avoid a memmove when a large amount of doclist data is in
** the buffer.  This constructs a node and term header before
** iDoclistData and flushes the resulting complete node using
** leafWriterInternalFlush().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>leafWriterInlineFlush</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>LeafWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,
                                 <parameter><decl><type><name>int</name></type> <name>iDoclistData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><name>VARINT_MAX</name><operator>+</operator><name>VARINT_MAX</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iData</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name>putVarint</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name>c</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* There should always be room for the header.  Even if pTerm shared
  ** a substantial prefix with the previous term, the entire prefix
  ** could be constructed from earlier data in the doclist, so there
  ** should be room.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDoclistData</name><operator>&gt;=</operator><name>n</name><operator>+</operator><name>nTerm</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iData</name> <operator>=</operator> <name>iDoclistData</name><operator>-</operator><operator>(</operator><name>n</name><operator>+</operator><name>nTerm</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name><operator>+</operator><name>iData</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name><operator>+</operator><name>iData</name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>leafWriterInternalFlush</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pWriter</name></expr></argument>, <argument><expr><name>iData</name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name><operator>-</operator><name>iData</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Push pTerm[nTerm] along with the doclist data to the leaf layer of
** %_segments.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>leafWriterStepMerge</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>LeafWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>,
                               <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,
                               <parameter><decl><type><name>DLReader</name> <modifier>*</modifier></type><name>pReaders</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nReaders</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><name>VARINT_MAX</name><operator>+</operator><name>VARINT_MAX</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iTermData</name> <init>= <expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name></expr></init></decl>, <decl><type ref="prev"/><name>iDoclistData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nData</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>nActualData</name></decl>, <decl><type ref="prev"/><name>nActual</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>, <decl><type ref="prev"/><name>nTermDistinct</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>ASSERT_VALID_LEAF_NODE</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nTermDistinct</name> <operator>=</operator> <call><name>leafWriterEncodeTerm</name><argument_list>(<argument><expr><name>pWriter</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Remember nTermDistinct if opening a new node. */</comment>
  <if_stmt><if>if<condition>( <expr><name>iTermData</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nTermDistinct</name></name> <operator>=</operator> <name>nTermDistinct</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>iDoclistData</name> <operator>=</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name></expr>;</expr_stmt>

  <comment type="block">/* Estimate the length of the merged doclist so we can leave space
  ** to encode it.
  */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>nData</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nReaders</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>nData</name> <operator>+=</operator> <call><name>dlrAllDataBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReaders</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>docListMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>pReaders</name></expr></argument>, <argument><expr><name>nReaders</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ASSERT_VALID_DOCLIST</name><argument_list>(<argument><expr><name>DL_DEFAULT</name></expr></argument>,
                       <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name><operator>+</operator><name>iDoclistData</name><operator>+</operator><name>n</name></expr></argument>,
                       <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name><operator>-</operator><name>iDoclistData</name><operator>-</operator><name>n</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The actual amount of doclist data at this point could be smaller
  ** than the length we encoded.  Additionally, the space required to
  ** encode this length could be smaller.  For small doclists, this is
  ** not a big deal, we can just use memmove() to adjust things.
  */</comment>
  <expr_stmt><expr><name>nActualData</name> <operator>=</operator> <name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name><operator>-</operator><operator>(</operator><name>iDoclistData</name><operator>+</operator><name>n</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>nActual</name> <operator>=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>nActualData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nActualData</name><operator>&lt;=</operator><name>nData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nActual</name><operator>&lt;=</operator><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the new doclist is big enough for force a standalone leaf
  ** node, we can immediately flush it inline without doing the
  ** memmove().
  */</comment>
  <comment type="block">/* TODO(shess) This test matches leafWriterStep(), which does this
  ** test before it knows the cost to varint-encode the term and
  ** doclist lengths.  At some point, change to
  ** pWriter-&gt;data.nData-iTermData&gt;STANDALONE_MIN.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nTerm</name><operator>+</operator><name>nActualData</name><operator>&gt;</operator><name>STANDALONE_MIN</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Push leaf node from before this term. */</comment>
    <if_stmt><if>if<condition>( <expr><name>iTermData</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>leafWriterInternalFlush</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pWriter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iTermData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

      <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nTermDistinct</name></name> <operator>=</operator> <name>nTermDistinct</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Fix the encoded doclist length. */</comment>
    <expr_stmt><expr><name>iDoclistData</name> <operator>+=</operator> <name>n</name> <operator>-</operator> <name>nActual</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name><operator>+</operator><name>iDoclistData</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>nActual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Push the standalone leaf node. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>leafWriterInlineFlush</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pWriter</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>iDoclistData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Leave the node empty. */</comment>
    <expr_stmt><expr><call><name>dataBufferReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pWriter</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* At this point, we know that the doclist was small, so do the
  ** memmove if indicated.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nActual</name><operator>&lt;</operator><name>n</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name><operator>+</operator><name>iDoclistData</name><operator>+</operator><name>nActual</name></expr></argument>,
            <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name><operator>+</operator><name>iDoclistData</name><operator>+</operator><name>n</name></expr></argument>,
            <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name><operator>-</operator><operator>(</operator><name>iDoclistData</name><operator>+</operator><name>n</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name> <operator>-=</operator> <name>n</name><operator>-</operator><name>nActual</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Replace written length with actual length. */</comment>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name><operator>+</operator><name>iDoclistData</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>nActual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the node is too large, break things up. */</comment>
  <comment type="block">/* TODO(shess) This test matches leafWriterStep(), which does this
  ** test before it knows the cost to varint-encode the term and
  ** doclist lengths.  At some point, change to
  ** pWriter-&gt;data.nData&gt;LEAF_MAX.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>iTermData</name><operator>+</operator><name>nTerm</name><operator>+</operator><name>nActualData</name><operator>&gt;</operator><name>LEAF_MAX</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Flush out the leading data as a node */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>leafWriterInternalFlush</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pWriter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iTermData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>nTermDistinct</name></name> <operator>=</operator> <name>nTermDistinct</name></expr>;</expr_stmt>

    <comment type="block">/* Rebuild header using the current term */</comment>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>putVarint</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <name>nTerm</name></expr>;</expr_stmt>

    <comment type="block">/* There should always be room, because the previous encoding
    ** included all data necessary to construct the term.
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>&lt;</operator><name>iDoclistData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* So long as STANDALONE_MIN is half or less of LEAF_MAX, the
    ** following memcpy() is safe (as opposed to needing a memmove).
    */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">2</literal><operator>*</operator><name>STANDALONE_MIN</name><operator>&lt;=</operator><name>LEAF_MAX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name><operator>-</operator><name>iDoclistData</name><operator>&lt;</operator><name>iDoclistData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name><operator>+</operator><name>n</name></expr></argument>,
           <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name><operator>+</operator><name>iDoclistData</name></expr></argument>,
           <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name><operator>-</operator><name>iDoclistData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name> <operator>-=</operator> <name>iDoclistData</name><operator>-</operator><name>n</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>ASSERT_VALID_LEAF_NODE</name><argument_list>(<argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>pWriter</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Push pTerm[nTerm] along with the doclist data to the leaf layer of
** %_segments.
*/</comment>
<comment type="block">/* TODO(shess) Revise writeZeroSegment() so that doclists are
** constructed directly in pWriter-&gt;data.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>leafWriterStep</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>LeafWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DLReader</name></type> <name>reader</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>dlrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>, <argument><expr><name>DL_DEFAULT</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>leafWriterStepMerge</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pWriter</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************/</comment>
<comment type="block">/* LeafReader is used to iterate over an individual leaf node. */</comment>
<typedef>typedef <type><struct>struct <name>LeafReader</name> <block>{
  <decl_stmt><decl><type><name>DataBuffer</name></type> <name>term</name></decl>;</decl_stmt>          <comment type="block">/* copy of current term. */</comment>

  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>        <comment type="block">/* data for current term. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
}</block></struct></type> <name>LeafReader</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>leafReaderDestroy</name><parameter_list>(<parameter><decl><type><name>LeafReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>term</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SCRAMBLE</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>leafReaderAtEnd</name><parameter_list>(<parameter><decl><type><name>LeafReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name><operator>&lt;=</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Access the current term. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>leafReaderTermBytes</name><parameter_list>(<parameter><decl><type><name>LeafReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>nData</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>leafReaderTerm</name><parameter_list>(<parameter><decl><type><name>LeafReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>nData</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>pData</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Access the doclist data for the current term. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>leafReaderDataBytes</name><parameter_list>(<parameter><decl><type><name>LeafReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>nData</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>nData</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>leafReaderData</name><parameter_list>(<parameter><decl><type><name>LeafReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>nData</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>nData</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name><operator>+</operator><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>leafReaderInit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>,
                           <parameter><decl><type><name>LeafReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nData</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pData</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="char">'\0'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>CLEAR</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read the first term, skipping the header byte. */</comment>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name>pData</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>term</name></name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dataBufferReplace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>term</name></name></expr></argument>, <argument><expr><name>pData</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Position after the first term. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">1</literal><operator>+</operator><name>n</name><operator>+</operator><name>nTerm</name><operator>&lt;</operator><name>nData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <name>pData</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>n</name><operator>+</operator><name>nTerm</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <name>nData</name><operator>-</operator><literal type="number">1</literal><operator>-</operator><name>n</name><operator>-</operator><name>nTerm</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Step the reader forward to the next term. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>leafReaderStep</name><parameter_list>(<parameter><decl><type><name>LeafReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>nData</name></decl>, <decl><type ref="prev"/><name>nPrefix</name></decl>, <decl><type ref="prev"/><name>nSuffix</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>leafReaderAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Skip previous entry's data block. */</comment>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><name>nData</name><operator>&lt;=</operator><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name> <operator>+=</operator> <name>n</name><operator>+</operator><name>nData</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name> <operator>-=</operator> <name>n</name><operator>+</operator><name>nData</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>leafReaderAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* Construct the new term using a prefix from the old term plus a
    ** suffix from the leaf data.
    */</comment>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nPrefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nSuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>n</name><operator>+</operator><name>nSuffix</name><operator>&lt;</operator><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>nData</name></name> <operator>=</operator> <name>nPrefix</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>term</name></name></expr></argument>, <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name><operator>+</operator><name>n</name></expr></argument>, <argument><expr><name>nSuffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pData</name></name> <operator>+=</operator> <name>n</name><operator>+</operator><name>nSuffix</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>nData</name></name> <operator>-=</operator> <name>n</name><operator>+</operator><name>nSuffix</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* strcmp-style comparison of pReader's current term against pTerm.
** If isPrefix, equality means equal through nTerm bytes.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>leafReaderTermCmp</name><parameter_list>(<parameter><decl><type><name>LeafReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isPrefix</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><ternary><condition><expr><name><name>pReader</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>nData</name></name><operator>&lt;</operator><name>nTerm</name></expr> ?</condition><then> <expr><name><name>pReader</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>nData</name></name></expr> </then><else>: <expr><name>nTerm</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pReader</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>nData</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><name>nTerm</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>c</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>isPrefix</name> <operator>&amp;&amp;</operator> <name>n</name><operator>==</operator><name>nTerm</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>term</name><operator>.</operator><name>nData</name></name> <operator>-</operator> <name>nTerm</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************/</comment>
<comment type="block">/* LeavesReader wraps LeafReader to allow iterating over the entire
** leaf layer of the tree.
*/</comment>
<typedef>typedef <type><struct>struct <name>LeavesReader</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>                  <comment type="block">/* Index within the segment. */</comment>

  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>      <comment type="block">/* Statement we're streaming leaves from. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eof</name></decl>;</decl_stmt>                  <comment type="block">/* we've seen SQLITE_DONE from pStmt. */</comment>

  <decl_stmt><decl><type><name>LeafReader</name></type> <name>leafReader</name></decl>;</decl_stmt>    <comment type="block">/* reader for the current leaf. */</comment>
  <decl_stmt><decl><type><name>DataBuffer</name></type> <name>rootData</name></decl>;</decl_stmt>      <comment type="block">/* root data for inline. */</comment>
}</block></struct></type> <name>LeavesReader</name>;</typedef>

<comment type="block">/* Access the current term. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>leavesReaderTermBytes</name><parameter_list>(<parameter><decl><type><name>LeavesReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pReader</name><operator>-&gt;</operator><name>eof</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>leafReaderTermBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>leafReader</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>leavesReaderTerm</name><parameter_list>(<parameter><decl><type><name>LeavesReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pReader</name><operator>-&gt;</operator><name>eof</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>leafReaderTerm</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>leafReader</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Access the doclist data for the current term. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>leavesReaderDataBytes</name><parameter_list>(<parameter><decl><type><name>LeavesReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pReader</name><operator>-&gt;</operator><name>eof</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>leafReaderDataBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>leafReader</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>leavesReaderData</name><parameter_list>(<parameter><decl><type><name>LeavesReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><name><name>pReader</name><operator>-&gt;</operator><name>eof</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>leafReaderData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>leafReader</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>leavesReaderAtEnd</name><parameter_list>(<parameter><decl><type><name>LeavesReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>eof</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* loadSegmentLeaves() may not read all the way to SQLITE_DONE, thus
** leaving the statement handle open, which locks the table.
*/</comment>
<comment type="block">/* TODO(shess) This "solution" is not satisfactory.  Really, there
** should be check-in function for all statement handles which
** arranges to call sqlite3_reset().  This most likely will require
** modification to control flow all over the place, though, so for now
** just punt.
**
** Note the current system assumes that segment merges will run to
** completion, which is why this particular probably hasn't arisen in
** this case.  Probably a brittle assumption.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>leavesReaderReset</name><parameter_list>(<parameter><decl><type><name>LeavesReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>leavesReaderDestroy</name><parameter_list>(<parameter><decl><type><name>LeavesReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* If idx is -1, that means we're using a non-cached statement
  ** handle in the optimize() case, so we need to release it.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>pReader</name><operator>-&gt;</operator><name>pStmt</name></name><operator>!=</operator><name>NULL</name> <operator>&amp;&amp;</operator> <name><name>pReader</name><operator>-&gt;</operator><name>idx</name></name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>leafReaderDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>leafReader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>rootData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SCRAMBLE</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Initialize pReader with the given root data (if iStartBlockid==0
** the leaf data was entirely contained in the root), or from the
** stream of blocks between iStartBlockid and iEndBlockid, inclusive.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>leavesReaderInit</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
                            <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,
                            <parameter><decl><type><name>sqlite_int64</name></type> <name>iStartBlockid</name></decl></parameter>,
                            <parameter><decl><type><name>sqlite_int64</name></type> <name>iEndBlockid</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pRootData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nRootData</name></decl></parameter>,
                            <parameter><decl><type><name>LeavesReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>CLEAR</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>idx</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>rootData</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iStartBlockid</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* Entire leaf level fit in root data. */</comment>
    <expr_stmt><expr><call><name>dataBufferReplace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>rootData</name></name></expr></argument>, <argument><expr><name>pRootData</name></expr></argument>, <argument><expr><name>nRootData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>leafReaderInit</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>rootData</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>rootData</name><operator>.</operator><name>nData</name></name></expr></argument>,
                   <argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>leafReader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_leaf_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iStartBlockid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>iEndBlockid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>pStmt</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>leafReaderInit</name><argument_list>(<argument><expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>leafReader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Step the current leaf forward to the next term.  If we reach the
** end of the current leaf, step forward to the next leaf block.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>leavesReaderStep</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>LeavesReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>leavesReaderAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>leafReaderStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>leafReader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>leafReaderAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>leafReader</name></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pReader</name><operator>-&gt;</operator><name>rootData</name><operator>.</operator><name>pData</name></name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <return>return <expr><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>leafReaderDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>leafReader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>leafReaderInit</name><argument_list>(<argument><expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>leafReader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Order LeavesReaders by their term, ignoring idx.  Readers at eof
** always sort to the end.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>leavesReaderTermCmp</name><parameter_list>(<parameter><decl><type><name>LeavesReader</name> <modifier>*</modifier></type><name>lr1</name></decl></parameter>, <parameter><decl><type><name>LeavesReader</name> <modifier>*</modifier></type><name>lr2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>leavesReaderAtEnd</name><argument_list>(<argument><expr><name>lr1</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>leavesReaderAtEnd</name><argument_list>(<argument><expr><name>lr2</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>leavesReaderAtEnd</name><argument_list>(<argument><expr><name>lr2</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>leafReaderTermCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lr1</name><operator>-&gt;</operator><name>leafReader</name></name></expr></argument>,
                           <argument><expr><call><name>leavesReaderTerm</name><argument_list>(<argument><expr><name>lr2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>leavesReaderTermBytes</name><argument_list>(<argument><expr><name>lr2</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Similar to leavesReaderTermCmp(), with additional ordering by idx
** so that older segments sort before newer segments.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>leavesReaderCmp</name><parameter_list>(<parameter><decl><type><name>LeavesReader</name> <modifier>*</modifier></type><name>lr1</name></decl></parameter>, <parameter><decl><type><name>LeavesReader</name> <modifier>*</modifier></type><name>lr2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>leavesReaderTermCmp</name><argument_list>(<argument><expr><name>lr1</name></expr></argument>, <argument><expr><name>lr2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>c</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name><name>lr1</name><operator>-&gt;</operator><name>idx</name></name><operator>-</operator><name><name>lr2</name><operator>-&gt;</operator><name>idx</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Assume that pLr[1]..pLr[nLr] are sorted.  Bubble pLr[0] into its
** sorted position.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>leavesReaderReorder</name><parameter_list>(<parameter><decl><type><name>LeavesReader</name> <modifier>*</modifier></type><name>pLr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name>nLr</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>leavesReaderCmp</name><argument_list>(<argument><expr><name>pLr</name></expr></argument>, <argument><expr><name>pLr</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>LeavesReader</name></type> <name>tmp</name> <init>= <expr><name><name>pLr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pLr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pLr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nLr</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLr</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Initializes pReaders with the segments from level iLevel, returning
** the number of segments in *piReaders.  Leaves pReaders in sorted
** order.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>leavesReadersInit</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>,
                             <parameter><decl><type><name>LeavesReader</name> <modifier>*</modifier></type><name>pReaders</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>piReaders</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SEGDIR_SELECT_LEVEL_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iStart</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iEnd</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pRootData</name> <init>= <expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nRootData</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;</operator><name>MERGE_COUNT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>leavesReaderInit</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>iStart</name></expr></argument>, <argument><expr><name>iEnd</name></expr></argument>, <argument><expr><name>pRootData</name></expr></argument>, <argument><expr><name>nRootData</name></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name><name>pReaders</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
    <while>while<condition>( <expr><name>i</name><operator>--</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>leavesReaderDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReaders</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>piReaders</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

  <comment type="block">/* Leave our results sorted by term, then age. */</comment>
  <while>while<condition>( <expr><name>i</name><operator>--</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>leavesReaderReorder</name><argument_list>(<argument><expr><name>pReaders</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><operator>*</operator><name>piReaders</name><operator>-</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Merge doclists from pReaders[nReaders] into a single doclist, which
** is written to pWriter.  Assumes pReaders is ordered oldest to
** newest.
*/</comment>
<comment type="block">/* TODO(shess) Consider putting this inline in segmentMerge(). */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>leavesReadersMerge</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
                              <parameter><decl><type><name>LeavesReader</name> <modifier>*</modifier></type><name>pReaders</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nReaders</name></decl></parameter>,
                              <parameter><decl><type><name>LeafWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DLReader</name></type> <name><name>dlReaders</name><index>[<expr><name>MERGE_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name> <init>= <expr><call><name>leavesReaderTerm</name><argument_list>(<argument><expr><name>pReaders</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nTerm</name> <init>= <expr><call><name>leavesReaderTermBytes</name><argument_list>(<argument><expr><name>pReaders</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nReaders</name><operator>&lt;=</operator><name>MERGE_COUNT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nReaders</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>dlrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dlReaders</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>DL_DEFAULT</name></expr></argument>,
            <argument><expr><call><name>leavesReaderData</name><argument_list>(<argument><expr><name>pReaders</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>leavesReaderDataBytes</name><argument_list>(<argument><expr><name>pReaders</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <return>return <expr><call><name>leafWriterStepMerge</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pWriter</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>dlReaders</name></expr></argument>, <argument><expr><name>nReaders</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Forward ref due to mutual recursion with segdirNextIndex(). */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>segmentMerge</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Put the next available index at iLevel into *pidx.  If iLevel
** already has MERGE_COUNT segments, they are merged to a higher
** level to make room.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>segdirNextIndex</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pidx</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>segdir_max_index</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>, <argument><expr><name>pidx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>              <comment type="block">/* No segments at iLevel. */</comment>
    <expr_stmt><expr><operator>*</operator><name>pidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pidx</name><operator>==</operator><operator>(</operator><name>MERGE_COUNT</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segmentMerge</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>pidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><operator>(</operator><operator>*</operator><name>pidx</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Merge MERGE_COUNT segments at iLevel into a new segment at
** iLevel+1.  If iLevel+1 is already full of segments, those will be
** merged to make room.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>segmentMerge</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iLevel</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LeafWriter</name></type> <name>writer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LeavesReader</name></type> <name><name>lrs</name><index>[<expr><name>MERGE_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>, <decl><type ref="prev"/><name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Determine the next available segment index at the next level,
  ** merging as necessary.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segdirNextIndex</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iLevel</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* TODO(shess) This assumes that we'll always see exactly
  ** MERGE_COUNT segments to merge at a given level.  That will be
  ** broken if we allow the developer to request preemptive or
  ** deferred merging.
  */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lrs</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lrs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>leavesReadersInit</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>, <argument><expr><name>lrs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><name>MERGE_COUNT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>leafWriterInit</name><argument_list>(<argument><expr><name>iLevel</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Since leavesReaderReorder() pushes readers at eof to the end,
  ** when the first reader is empty, all will be empty.
  */</comment>
  <while>while<condition>( <expr><operator>!</operator><call><name>leavesReaderAtEnd</name><argument_list>(<argument><expr><name>lrs</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* Figure out how many readers share their next term. */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>MERGE_COUNT</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>leavesReaderAtEnd</name><argument_list>(<argument><expr><name>lrs</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>!=</operator><call><name>leavesReaderTermCmp</name><argument_list>(<argument><expr><name>lrs</name></expr></argument>, <argument><expr><name>lrs</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>leavesReadersMerge</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>lrs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Step forward those that were merged. */</comment>
    <while>while<condition>( <expr><name>i</name><operator>--</operator><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>leavesReaderStep</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>lrs</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

      <comment type="block">/* Reorder by term, then by age. */</comment>
      <expr_stmt><expr><call><name>leavesReaderReorder</name><argument_list>(<argument><expr><name>lrs</name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>MERGE_COUNT</name><operator>-</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></while>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>MERGE_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>leavesReaderDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>leafWriterFinalize</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>leafWriterDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Delete the merged segment data. */</comment>
  <return>return <expr><call><name>segdir_delete</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iLevel</name></expr></argument>)</argument_list></call></expr>;</return>

 <label><name>err</name>:</label>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>MERGE_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>leavesReaderDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>leafWriterDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Accumulate the union of *acc and *pData into *acc. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListAccumulateUnion</name><parameter_list>(<parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>acc</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>DataBuffer</name></type> <name>tmp</name> <init>= <expr><operator>*</operator><name>acc</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><name>acc</name></expr></argument>, <argument><expr><name><name>tmp</name><operator>.</operator><name>nData</name></name><operator>+</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>docListUnion</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>tmp</name><operator>.</operator><name>nData</name></name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>acc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* TODO(shess) It might be interesting to explore different merge
** strategies, here.  For instance, since this is a sorted merge, we
** could easily merge many doclists in parallel.  With some
** comprehension of the storage format, we could merge all of the
** doclists within a leaf node directly from the leaf node's storage.
** It may be worthwhile to merge smaller doclists before larger
** doclists, since they can be traversed more quickly - but the
** results may have less overlap, making them more expensive in a
** different way.
*/</comment>

<comment type="block">/* Scan pReader for pTerm/nTerm, and merge the term's doclist over
** *out (any doclists with duplicate docids overwrite those in *out).
** Internal function for loadSegmentLeaf().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>loadSegmentLeavesInt</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>LeavesReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isPrefix</name></decl></parameter>,
                                <parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* doclist data is accumulated into pBuffers similar to how one does
  ** increment in binary arithmetic.  If index 0 is empty, the data is
  ** stored there.  If there is data there, it is merged and the
  ** results carried into position 1, with further merge-and-carry
  ** until an empty position is found.
  */</comment>
  <decl_stmt><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>pBuffers</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nBuffers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>nMaxBuffers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nTerm</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>rc</name><operator>=</operator><name>SQLITE_OK</name></expr>;</init> <condition><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>leavesReaderAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr>;</condition>
      <incr><expr><name>rc</name><operator>=</operator><call><name>leavesReaderStep</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <comment type="block">/* TODO(shess) Really want leavesReaderTermCmp(), but that name is
    ** already taken to compare the terms of two LeavesReaders.  Think
    ** on a better name.  [Meanwhile, break encapsulation rather than
    ** use a confusing name.]
    */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>leafReaderTermCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>leafReader</name></name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>isPrefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>      <comment type="block">/* Past any possible matches. */</comment>
    <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><call><name>leavesReaderData</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iBuffer</name></decl>, <decl><type ref="prev"/><name>nData</name> <init>= <expr><call><name>leavesReaderDataBytes</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Find the first empty buffer. */</comment>
      <for>for<control>(<init><expr><name>iBuffer</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iBuffer</name><operator>&lt;</operator><name>nBuffers</name></expr>;</condition> <incr><expr><operator>++</operator><name>iBuffer</name></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>==</operator><name><name>pBuffers</name><index>[<expr><name>iBuffer</name></expr>]</index></name><operator>.</operator><name>nData</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>

      <comment type="block">/* Out of buffers, add an empty one. */</comment>
      <if_stmt><if>if<condition>( <expr><name>iBuffer</name><operator>==</operator><name>nBuffers</name></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>nBuffers</name><operator>==</operator><name>nMaxBuffers</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>nMaxBuffers</name> <operator>+=</operator> <literal type="number">20</literal></expr>;</expr_stmt>

          <comment type="block">/* Manual realloc so we can handle NULL appropriately. */</comment>
          <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nMaxBuffers</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pBuffers</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><name>NULL</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
            <break>break;</break>
          </block_content>}</block></if></if_stmt>

          <if_stmt><if>if<condition>( <expr><name>nBuffers</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pBuffers</name><operator>!=</operator><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pBuffers</name></expr></argument>, <argument><expr><name>nBuffers</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pBuffers</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pBuffers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>pBuffers</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pBuffers</name><index>[<expr><name>nBuffers</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nBuffers</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <comment type="block">/* At this point, must have an empty at iBuffer. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>iBuffer</name><operator>&lt;</operator><name>nBuffers</name> <operator>&amp;&amp;</operator> <name><name>pBuffers</name><index>[<expr><name>iBuffer</name></expr>]</index></name><operator>.</operator><name>nData</name><operator>==</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If empty was first buffer, no need for merge logic. */</comment>
      <if_stmt><if>if<condition>( <expr><name>iBuffer</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>dataBufferReplace</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* pAcc is the empty buffer the merged data will end up in. */</comment>
        <decl_stmt><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>pAcc</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>pBuffers</name><index>[<expr><name>iBuffer</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>pBuffers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Handle position 0 specially to avoid need to prime pAcc
        ** with pData/nData.
        */</comment>
        <expr_stmt><expr><call><name>dataBufferSwap</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pAcc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>docListAccumulateUnion</name><argument_list>(<argument><expr><name>pAcc</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Accumulate remaining doclists into pAcc. */</comment>
        <for>for<control>(<init><expr><operator>++</operator><name>p</name></expr>;</init> <condition><expr><name>p</name><operator>&lt;</operator><name>pAcc</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block>{<block_content>
          <expr_stmt><expr><call><name>docListAccumulateUnion</name><argument_list>(<argument><expr><name>pAcc</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* dataBufferReset() could allow a large doclist to blow up
          ** our memory requirements.
          */</comment>
          <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nCapacity</name></name><operator>&lt;</operator><literal type="number">1024</literal></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><call><name>dataBufferReset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Union all the doclists together into *out. */</comment>
  <comment type="block">/* TODO(shess) What if *out is big?  Sigh. */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>nBuffers</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iBuffer</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>iBuffer</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iBuffer</name><operator>&lt;</operator><name>nBuffers</name></expr>;</condition> <incr><expr><operator>++</operator><name>iBuffer</name></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pBuffers</name><index>[<expr><name>iBuffer</name></expr>]</index></name><operator>.</operator><name>nData</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name><name>out</name><operator>-&gt;</operator><name>nData</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>dataBufferSwap</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pBuffers</name><index>[<expr><name>iBuffer</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>docListAccumulateUnion</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>pBuffers</name><index>[<expr><name>iBuffer</name></expr>]</index></name><operator>.</operator><name>pData</name></expr></argument>,
                                 <argument><expr><name><name>pBuffers</name><index>[<expr><name>iBuffer</name></expr>]</index></name><operator>.</operator><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <while>while<condition>( <expr><name>nBuffers</name><operator>--</operator></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pBuffers</name><index>[<expr><name>nBuffers</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>pBuffers</name><operator>!=</operator><name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pBuffers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Call loadSegmentLeavesInt() with pData/nData as input. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>loadSegmentLeaf</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isPrefix</name></decl></parameter>,
                           <parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>LeavesReader</name></type> <name>reader</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nData</name><operator>&gt;</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pData</name><operator>==</operator><literal type="char">'\0'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>leavesReaderInit</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>loadSegmentLeavesInt</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>isPrefix</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>leavesReaderReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>leavesReaderDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Call loadSegmentLeavesInt() with the leaf nodes from iStartLeaf to
** iEndLeaf (inclusive) as input, and merge the resulting doclist into
** out.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>loadSegmentLeaves</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
                             <parameter><decl><type><name>sqlite_int64</name></type> <name>iStartLeaf</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iEndLeaf</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isPrefix</name></decl></parameter>,
                             <parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LeavesReader</name></type> <name>reader</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iStartLeaf</name><operator>&lt;=</operator><name>iEndLeaf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>leavesReaderInit</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iStartLeaf</name></expr></argument>, <argument><expr><name>iEndLeaf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>loadSegmentLeavesInt</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>isPrefix</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>leavesReaderReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>leavesReaderDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Taking pData/nData as an interior node, find the sequence of child
** nodes which could include pTerm/nTerm/isPrefix.  Note that the
** interior node terms logically come between the blocks, so there is
** one more blockid than there are terms (that block contains terms &gt;=
** the last interior-node term).
*/</comment>
<comment type="block">/* TODO(shess) The calling code may already know that the end child is
** not worth calculating, because the end may be in a later sibling
** node.  Consider whether breaking symmetry is worthwhile.  I suspect
** it is not worthwhile.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>getChildrenContaining</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>,
                                  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isPrefix</name></decl></parameter>,
                                  <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>piStartChild</name></decl></parameter>,
                                  <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>piEndChild</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>InteriorReader</name></type> <name>reader</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nData</name><operator>&gt;</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pData</name><operator>!=</operator><literal type="char">'\0'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>interiorReaderInit</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Scan for the first child which could contain pTerm/nTerm. */</comment>
  <while>while<condition>( <expr><operator>!</operator><call><name>interiorReaderAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>interiorReaderTermCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>interiorReaderStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><operator>*</operator><name>piStartChild</name> <operator>=</operator> <call><name>interiorReaderCurrentBlockid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Keep scanning to find a term greater than our term, using prefix
  ** comparison if indicated.  If isPrefix is false, this will be the
  ** same blockid as the starting block.
  */</comment>
  <while>while<condition>( <expr><operator>!</operator><call><name>interiorReaderAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>interiorReaderTermCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>isPrefix</name></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>interiorReaderStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><operator>*</operator><name>piEndChild</name> <operator>=</operator> <call><name>interiorReaderCurrentBlockid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>interiorReaderDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Children must ascend, and if !prefix, both must be the same. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>piEndChild</name><operator>&gt;=</operator><operator>*</operator><name>piStartChild</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>isPrefix</name> <operator>||</operator> <operator>*</operator><name>piStartChild</name><operator>==</operator><operator>*</operator><name>piEndChild</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Read block at iBlockid and pass it with other params to
** getChildrenContaining().
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>loadAndGetChildrenContaining</name><parameter_list>(
  <parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
  <parameter><decl><type><name>sqlite_int64</name></type> <name>iBlockid</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isPrefix</name></decl></parameter>,
  <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>piStartChild</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>piEndChild</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iBlockid</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pTerm</name><operator>!=</operator><name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nTerm</name><operator>!=</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* TODO(shess) Why not allow this? */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>piStartChild</name><operator>!=</operator><name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>piEndChild</name><operator>!=</operator><name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>BLOCK_SELECT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iBlockid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>getChildrenContaining</name><argument_list>(<argument><expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>isPrefix</name></expr></argument>, <argument><expr><name>piStartChild</name></expr></argument>, <argument><expr><name>piEndChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We expect only one row.  We must execute another sqlite3_step()
   * to complete the iteration; otherwise the table will remain
   * locked. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Traverse the tree represented by pData[nData] looking for
** pTerm[nTerm], placing its doclist into *out.  This is internal to
** loadSegment() to make error-handling cleaner.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>loadSegmentInt</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>,
                          <parameter><decl><type><name>sqlite_int64</name></type> <name>iLeavesEnd</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isPrefix</name></decl></parameter>,
                          <parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* Special case where root is a leaf. */</comment>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>pData</name><operator>==</operator><literal type="char">'\0'</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>loadSegmentLeaf</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>isPrefix</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iStartChild</name></decl>, <decl><type ref="prev"/><name>iEndChild</name></decl>;</decl_stmt>

    <comment type="block">/* Process pData as an interior node, then loop down the tree
    ** until we find the set of leaf nodes to scan for the term.
    */</comment>
    <expr_stmt><expr><call><name>getChildrenContaining</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>isPrefix</name></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name>iStartChild</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iEndChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><name>iStartChild</name><operator>&gt;</operator><name>iLeavesEnd</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iNextStart</name></decl>, <decl><type ref="prev"/><name>iNextEnd</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>loadAndGetChildrenContaining</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iStartChild</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>isPrefix</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>iNextStart</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNextEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

      <comment type="block">/* If we've branched, follow the end branch, too. */</comment>
      <if_stmt><if>if<condition>( <expr><name>iStartChild</name><operator>!=</operator><name>iEndChild</name></expr> )</condition><block>{<block_content>
        <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iDummy</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>loadAndGetChildrenContaining</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iEndChild</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>isPrefix</name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name>iDummy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iNextEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iNextStart</name><operator>&lt;=</operator><name>iNextEnd</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iStartChild</name> <operator>=</operator> <name>iNextStart</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>iEndChild</name> <operator>=</operator> <name>iNextEnd</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iStartChild</name><operator>&lt;=</operator><name>iLeavesEnd</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iEndChild</name><operator>&lt;=</operator><name>iLeavesEnd</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Scan through the leaf segments for doclists. */</comment>
    <return>return <expr><call><name>loadSegmentLeaves</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iStartChild</name></expr></argument>, <argument><expr><name>iEndChild</name></expr></argument>,
                             <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>isPrefix</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Call loadSegmentInt() to collect the doclist for pTerm/nTerm, then
** merge its doclist over *out (any duplicate doclists read from the
** segment rooted at pData will overwrite those in *out).
*/</comment>
<comment type="block">/* TODO(shess) Consider changing this to determine the depth of the
** leaves using either the first characters of interior nodes (when
** ==1, we're one level above the leaves), or the first character of
** the root (which will describe the height of the tree directly).
** Either feels somewhat tricky to me.
*/</comment>
<comment type="block">/* TODO(shess) The current merge is likely to be slow for large
** doclists (though it should process from newest/smallest to
** oldest/largest, so it may not be that bad).  It might be useful to
** modify things to allow for N-way merging.  This could either be
** within a segment, with pairwise merges across segments, or across
** all segments at once.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>loadSegment</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>,
                       <parameter><decl><type><name>sqlite_int64</name></type> <name>iLeavesEnd</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isPrefix</name></decl></parameter>,
                       <parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DataBuffer</name></type> <name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nData</name><operator>&gt;</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This code should never be called with buffered updates. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>v</name><operator>-&gt;</operator><name>nPendingData</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>loadSegmentInt</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>iLeavesEnd</name></expr></argument>,
                      <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>isPrefix</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name><name>result</name><operator>.</operator><name>nData</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>out</name><operator>-&gt;</operator><name>nData</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>DataBuffer</name></type> <name>tmp</name> <init>= <expr><operator>*</operator><name>out</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>DataBuffer</name></type> <name>merged</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>DLReader</name></type> <name><name>readers</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>dlrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>DL_DEFAULT</name></expr></argument>, <argument><expr><name><name>out</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>out</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dlrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>DL_DEFAULT</name></expr></argument>, <argument><expr><name><name>result</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>.</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merged</name></expr></argument>, <argument><expr><name><name>out</name><operator>-&gt;</operator><name>nData</name></name><operator>+</operator><name><name>result</name><operator>.</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>docListMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merged</name></expr></argument>, <argument><expr><name>readers</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name>merged</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dlrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dlrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Scan the database and merge together the posting lists for the term
** into *out.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>termSelect</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isPrefix</name></decl></parameter>,
                      <parameter><decl><type><name>DocListType</name></type> <name>iType</name></decl></parameter>, <parameter><decl><type><name>DataBuffer</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DataBuffer</name></type> <name>doclist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SEGDIR_SELECT_ALL_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* This code should never be called with buffered updates. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>v</name><operator>-&gt;</operator><name>nPendingData</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Traverse the segments from oldest to newest so that newer doclist
  ** elements for given docids overwrite older elements.
  */</comment>
  <while>while<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nData</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite_int64</name></type> <name>iLeavesEnd</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>loadSegment</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>iLeavesEnd</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>isPrefix</name></expr></argument>,
                     <argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>doclist</name><operator>.</operator><name>nData</name></name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* TODO(shess) The old term_select_all() code applied the column
      ** restrict as we merged segments, leading to smaller buffers.
      ** This is probably worthwhile to bring back, once the new storage
      ** system is checked in.
      */</comment>
      <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>==</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iColumn</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>docListTrim</name><argument_list>(<argument><expr><name>DL_DEFAULT</name></expr></argument>, <argument><expr><name><name>doclist</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>doclist</name><operator>.</operator><name>nData</name></name></expr></argument>,
                  <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name>iType</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

 <label><name>err</name>:</label>
  <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/****************************************************************/</comment>
<comment type="block">/* Used to hold hashtable data for sorting. */</comment>
<typedef>typedef <type><struct>struct <name>TermData</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DLCollector</name> <modifier>*</modifier></type><name>pCollector</name></decl>;</decl_stmt>
}</block></struct></type> <name>TermData</name>;</typedef>

<comment type="block">/* Orders TermData elements in strcmp fashion ( &lt;0 for less-than, 0
** for equal, &gt;0 for greater-than).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>termDataCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>av</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>bv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>TermData</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>TermData</name> <operator>*</operator><operator>)</operator><name>av</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>TermData</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>TermData</name> <operator>*</operator><operator>)</operator><name>bv</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><ternary><condition><expr><name><name>a</name><operator>-&gt;</operator><name>nTerm</name></name><operator>&lt;</operator><name><name>b</name><operator>-&gt;</operator><name>nTerm</name></name></expr> ?</condition><then> <expr><name><name>a</name><operator>-&gt;</operator><name>nTerm</name></name></expr> </then><else>: <expr><name><name>b</name><operator>-&gt;</operator><name>nTerm</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>pTerm</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>pTerm</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>c</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name><name>a</name><operator>-&gt;</operator><name>nTerm</name></name><operator>-</operator><name><name>b</name><operator>-&gt;</operator><name>nTerm</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Order pTerms data by term, then write a new level 0 segment using
** LeafWriter.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>writeZeroSegment</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>fts2Hash</name> <modifier>*</modifier></type><name>pTerms</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fts2HashElem</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TermData</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LeafWriter</name></type> <name>writer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DataBuffer</name></type> <name>dl</name></decl>;</decl_stmt>

  <comment type="block">/* Determine the next index at level 0, merging as necessary. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segdirNextIndex</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>fts2HashCount</name><argument_list>(<argument><expr><name>pTerms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pData</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>n</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TermData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>e</name> <operator>=</operator> <call><name>fts2HashFirst</name><argument_list>(<argument><expr><name>pTerms</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>e</name> <operator>=</operator> <call><name>fts2HashNext</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;</operator><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pTerm</name> <operator>=</operator> <call><name>fts2HashKey</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nTerm</name> <operator>=</operator> <call><name>fts2HashKeysize</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pCollector</name> <operator>=</operator> <call><name>fts2HashData</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* TODO(shess) Should we allow user-defined collation sequences,
  ** here?  I think we only need that once we support prefix searches.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>termDataCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* TODO(shess) Refactor so that we can write directly to the segment
  ** DataBuffer, as happens for segment merges.
  */</comment>
  <expr_stmt><expr><call><name>leafWriterInit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>dataBufferReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dlcAddDoclist</name><argument_list>(<argument><expr><name><name>pData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pCollector</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>leafWriterStep</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>,
                        <argument><expr><name><name>pData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pTerm</name></expr></argument>, <argument><expr><name><name>pData</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nTerm</name></expr></argument>, <argument><expr><name><name>dl</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>dl</name><operator>.</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>leafWriterFinalize</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

 <label><name>err</name>:</label>
  <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>leafWriterDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* If pendingTerms has data, free it. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>clearPendingTerms</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>v</name><operator>-&gt;</operator><name>nPendingData</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>fts2HashElem</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>e</name><operator>=</operator><call><name>fts2HashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>pendingTerms</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>e</name><operator>=</operator><call><name>fts2HashNext</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
      <expr_stmt><expr><call><name>dlcDelete</name><argument_list>(<argument><expr><call><name>fts2HashData</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>fts2HashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>pendingTerms</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nPendingData</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* If pendingTerms has data, flush it to a level-zero segment, and
** free it.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>flushPendingTerms</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>v</name><operator>-&gt;</operator><name>nPendingData</name></name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>writeZeroSegment</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>pendingTerms</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>clearPendingTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* If pendingTerms is "too big", or docid is out of order, flush it.
** Regardless, be certain that pendingTerms is initialized for use.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>initPendingTerms</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* TODO(shess) Explore whether partially flushing the buffer on
  ** forced-flush would provide better performance.  I suspect that if
  ** we ordered the doclists by size and flushed the largest until the
  ** buffer was half empty, that would let the less frequent terms
  ** generate longer doclists.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>iDocid</name><operator>&lt;=</operator><name><name>v</name><operator>-&gt;</operator><name>iPrevDocid</name></name> <operator>||</operator> <name><name>v</name><operator>-&gt;</operator><name>nPendingData</name></name><operator>&gt;</operator><name>kPendingThreshold</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>flushPendingTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>v</name><operator>-&gt;</operator><name>nPendingData</name></name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>fts2HashInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>pendingTerms</name></name></expr></argument>, <argument><expr><name>FTS2_HASH_STRING</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nPendingData</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>iPrevDocid</name></name> <operator>=</operator> <name>iDocid</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function implements the xUpdate callback; it is the top-level entry
 * point for inserting, deleting or updating a row in a full-text table. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextUpdate</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppArg</name></decl></parameter>,
                   <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator> <name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS2 Update %p\n"</literal><operator>,</operator> <name>pVtab</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>index_delete</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>ppArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* If we just deleted the last row in the table, clear out the
      ** index data.
      */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>content_exists</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Clear the pending terms so we don't flush a useless level-0
        ** segment when the transaction closes.
        */</comment>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>clearPendingTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segdir_delete_all</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>ppArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* An update:
     * ppArg[0] = old rowid
     * ppArg[1] = new rowid
     * ppArg[2..2+v-&gt;nColumn-1] = values
     * ppArg[2+v-&gt;nColumn] = value for magic column (we ignore this)
     */</comment>
    <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>rowid</name> <init>= <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>ppArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>ppArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SQLITE_INTEGER</name> <operator>||</operator>
      <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>ppArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>rowid</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>  <comment type="block">/* we don't allow changing the rowid */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">2</literal><operator>+</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>index_update</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>rowid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ppArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* An insert:
     * ppArg[1] = requested rowid
     * ppArg[2..2+v-&gt;nColumn-1] = values
     * ppArg[2+v-&gt;nColumn] = value for magic column (we ignore this)
     */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">2</literal><operator>+</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>index_insert</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>ppArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ppArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextSync</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS2 xSync()\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>flushPendingTerms</name><argument_list>(<argument><expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextBegin</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator> <name>pVtab</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS2 xBegin()\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Any buffered updates should have been cleared by the previous
  ** transaction.
  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>v</name><operator>-&gt;</operator><name>nPendingData</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>clearPendingTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextCommit</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator> <name>pVtab</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS2 xCommit()\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Buffered updates should have been cleared by fulltextSync(). */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>v</name><operator>-&gt;</operator><name>nPendingData</name></name><operator>&lt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>clearPendingTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextRollback</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS2 xRollback()\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>clearPendingTerms</name><argument_list>(<argument><expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator><name>pVtab</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the snippet() function for FTS2
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>snippetFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_BLOB</name> <operator>||</operator>
      <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></sizeof></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"illegal first argument to html_snippet"</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStart</name> <init>= <expr><literal type="string">"&lt;b&gt;"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><literal type="string">"&lt;/b&gt;"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEllipsis</name> <init>= <expr><literal type="string">"&lt;b&gt;...&lt;/b&gt;"</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pCursor</name></expr></argument>, <argument><expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&gt;=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zStart</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&gt;=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&gt;=</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zEllipsis</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>snippetAllOffsets</name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>snippetText</name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>, <argument><expr><name>zStart</name></expr></argument>, <argument><expr><name>zEnd</name></expr></argument>, <argument><expr><name>zEllipsis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>zSnippet</name></name></expr></argument>,
                        <argument><expr><name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>nSnippet</name></name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the offsets() function for FTS2
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>snippetOffsetsFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_BLOB</name> <operator>||</operator>
      <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></sizeof></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"illegal first argument to offsets"</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pCursor</name></expr></argument>, <argument><expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>snippetAllOffsets</name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>snippetOffsetText</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>,
                        <argument><expr><name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>zOffset</name></name></expr></argument>, <argument><expr><name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>nOffset</name></name></expr></argument>,
                        <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* OptLeavesReader is nearly identical to LeavesReader, except that
** where LeavesReader is geared towards the merging of complete
** segment levels (with exactly MERGE_COUNT segments), OptLeavesReader
** is geared towards implementation of the optimize() function, and
** can merge all segments simultaneously.  This version may be
** somewhat less efficient than LeavesReader because it merges into an
** accumulator rather than doing an N-way merge, but since segment
** size grows exponentially (so segment count logrithmically) this is
** probably not an immediate problem.
*/</comment>
<comment type="block">/* TODO(shess): Prove that assertion, or extend the merge code to
** merge tree fashion (like the prefix-searching code does).
*/</comment>
<comment type="block">/* TODO(shess): OptLeavesReader and LeavesReader could probably be
** merged with little or no loss of performance for LeavesReader.  The
** merged code would need to handle &gt;MERGE_COUNT segments, and would
** also need to be able to optionally optimize away deletes.
*/</comment>
<typedef>typedef <type><struct>struct <name>OptLeavesReader</name> <block>{
  <comment type="block">/* Segment number, to order readers by age. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>segment</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LeavesReader</name></type> <name>reader</name></decl>;</decl_stmt>
}</block></struct></type> <name>OptLeavesReader</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type> <name>optLeavesReaderAtEnd</name><parameter_list>(<parameter><decl><type><name>OptLeavesReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>leavesReaderAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>optLeavesReaderTermBytes</name><parameter_list>(<parameter><decl><type><name>OptLeavesReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>leavesReaderTermBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>optLeavesReaderData</name><parameter_list>(<parameter><decl><type><name>OptLeavesReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>leavesReaderData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>optLeavesReaderDataBytes</name><parameter_list>(<parameter><decl><type><name>OptLeavesReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>leavesReaderDataBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>optLeavesReaderTerm</name><parameter_list>(<parameter><decl><type><name>OptLeavesReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>leavesReaderTerm</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>optLeavesReaderStep</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>OptLeavesReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>leavesReaderStep</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>optLeavesReaderTermCmp</name><parameter_list>(<parameter><decl><type><name>OptLeavesReader</name> <modifier>*</modifier></type><name>lr1</name></decl></parameter>, <parameter><decl><type><name>OptLeavesReader</name> <modifier>*</modifier></type><name>lr2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>leavesReaderTermCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lr1</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lr2</name><operator>-&gt;</operator><name>reader</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* Order by term ascending, segment ascending (oldest to newest), with
** exhausted readers to the end.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>optLeavesReaderCmp</name><parameter_list>(<parameter><decl><type><name>OptLeavesReader</name> <modifier>*</modifier></type><name>lr1</name></decl></parameter>, <parameter><decl><type><name>OptLeavesReader</name> <modifier>*</modifier></type><name>lr2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>optLeavesReaderTermCmp</name><argument_list>(<argument><expr><name>lr1</name></expr></argument>, <argument><expr><name>lr2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>c</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>c</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name><name>lr1</name><operator>-&gt;</operator><name>segment</name></name><operator>-</operator><name><name>lr2</name><operator>-&gt;</operator><name>segment</name></name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* Bubble pLr[0] to appropriate place in pLr[1..nLr-1].  Assumes that
** pLr[1..nLr-1] is already sorted.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>optLeavesReaderReorder</name><parameter_list>(<parameter><decl><type><name>OptLeavesReader</name> <modifier>*</modifier></type><name>pLr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nLr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name>nLr</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>optLeavesReaderCmp</name><argument_list>(<argument><expr><name>pLr</name></expr></argument>, <argument><expr><name>pLr</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>OptLeavesReader</name></type> <name>tmp</name> <init>= <expr><name><name>pLr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pLr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>pLr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pLr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nLr</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLr</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* optimize() helper function.  Put the readers in order and iterate
** through them, merging doclists for matching terms into pWriter.
** Returns SQLITE_OK on success, or the SQLite error code which
** prevented success.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>optimizeInternal</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
                            <parameter><decl><type><name>OptLeavesReader</name> <modifier>*</modifier></type><name>readers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nReaders</name></decl></parameter>,
                            <parameter><decl><type><name>LeafWriter</name> <modifier>*</modifier></type><name>pWriter</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DataBuffer</name></type> <name>doclist</name></decl>, <decl><type ref="prev"/><name>merged</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>

  <comment type="block">/* Order the readers. */</comment>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name>nReaders</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>i</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>optLeavesReaderReorder</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>nReaders</name><operator>-</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>, <argument><expr><name>LEAF_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merged</name></expr></argument>, <argument><expr><name>LEAF_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Exhausted readers bubble to the end, so when the first reader is
  ** at eof, all are at eof.
  */</comment>
  <while>while<condition>( <expr><operator>!</operator><call><name>optLeavesReaderAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>

    <comment type="block">/* Figure out how many readers share the next term. */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nReaders</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>optLeavesReaderAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><literal type="number">0</literal><operator>!=</operator><call><name>optLeavesReaderTermCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Special-case for no merge. */</comment>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <comment type="block">/* Trim deletions from the doclist. */</comment>
      <expr_stmt><expr><call><name>dataBufferReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>docListTrim</name><argument_list>(<argument><expr><name>DL_DEFAULT</name></expr></argument>,
                  <argument><expr><call><name>optLeavesReaderData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><call><name>optLeavesReaderDataBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>DL_DEFAULT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>DLReader</name></type> <name><name>dlReaders</name><index>[<expr><name>MERGE_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>iReader</name></decl>, <decl><type ref="prev"/><name>nReaders</name></decl>;</decl_stmt>

      <comment type="block">/* Prime the pipeline with the first reader's doclist.  After
      ** one pass index 0 will reference the accumulated doclist.
      */</comment>
      <expr_stmt><expr><call><name>dlrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dlReaders</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>DL_DEFAULT</name></expr></argument>,
              <argument><expr><call><name>optLeavesReaderData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><call><name>optLeavesReaderDataBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iReader</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iReader</name><operator>&lt;</operator><name>i</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Must execute the loop at least once. */</comment>
      <while>while<condition>( <expr><name>iReader</name><operator>&lt;</operator><name>i</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Merge 16 inputs per pass. */</comment>
        <for>for<control>( <init><expr><name>nReaders</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>iReader</name><operator>&lt;</operator><name>i</name> <operator>&amp;&amp;</operator> <name>nReaders</name><operator>&lt;</operator><name>MERGE_COUNT</name></expr>;</condition>
             <incr><expr><name>iReader</name><operator>++</operator></expr><operator>,</operator> <expr><name>nReaders</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
          <expr_stmt><expr><call><name>dlrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dlReaders</name><index>[<expr><name>nReaders</name></expr>]</index></name></expr></argument>, <argument><expr><name>DL_DEFAULT</name></expr></argument>,
                  <argument><expr><call><name>optLeavesReaderData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><name>iReader</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><call><name>optLeavesReaderDataBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><name>iReader</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Merge doclists and swap result into accumulator. */</comment>
        <expr_stmt><expr><call><name>dataBufferReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>docListMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merged</name></expr></argument>, <argument><expr><name>dlReaders</name></expr></argument>, <argument><expr><name>nReaders</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>merged</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>merged</name> <operator>=</operator> <name>doclist</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>doclist</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

        <while>while<condition>( <expr><name>nReaders</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>dlrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dlReaders</name><index>[<expr><name>nReaders</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="block">/* Accumulated doclist to reader 0 for next pass. */</comment>
        <expr_stmt><expr><call><name>dlrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dlReaders</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>DL_DEFAULT</name></expr></argument>, <argument><expr><name><name>doclist</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>doclist</name><operator>.</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>

      <comment type="block">/* Destroy reader that was left in the pipeline. */</comment>
      <expr_stmt><expr><call><name>dlrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dlReaders</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Trim deletions from the doclist. */</comment>
      <expr_stmt><expr><call><name>dataBufferReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>docListTrim</name><argument_list>(<argument><expr><name>DL_DEFAULT</name></expr></argument>, <argument><expr><name><name>doclist</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>doclist</name><operator>.</operator><name>nData</name></name></expr></argument>,
                  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>DL_DEFAULT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Only pass doclists with hits (skip if all hits deleted). */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>merged</name><operator>.</operator><name>nData</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>leafWriterStep</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pWriter</name></expr></argument>,
                          <argument><expr><call><name>optLeavesReaderTerm</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>optLeavesReaderTermBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name><name>merged</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>merged</name><operator>.</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Step merged readers to next term and reorder. */</comment>
    <while>while<condition>( <expr><name>i</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>optLeavesReaderStep</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>optLeavesReaderReorder</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>nReaders</name><operator>-</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></while>

 <label><name>err</name>:</label>
  <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Implement optimize() function for FTS3.  optimize(t) merges all
** segments in the fts index into a single segment.  't' is the magic
** table-named column.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>optimizeFunc</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>,
                         <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"excess arguments to optimize()"</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_BLOB</name> <operator>||</operator>
            <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></sizeof></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"illegal first argument to optimize"</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>, <decl><type ref="prev"/><name>iMaxLevel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>OptLeavesReader</name> <modifier>*</modifier></type><name>readers</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nReaders</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LeafWriter</name></type> <name>writer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pCursor</name></expr></argument>, <argument><expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>cursor_vtab</name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Flush any buffered updates before optimizing. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>flushPendingTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segdir_count</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nReaders</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iMaxLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>nReaders</name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <name>nReaders</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"Index already optimal"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                          <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SEGDIR_SELECT_ALL_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>readers</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nReaders</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>readers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>readers</name><operator>==</operator><name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Note that there will already be a segment at this position
    ** until we call segdir_delete() on iMaxLevel.
    */</comment>
    <expr_stmt><expr><call><name>leafWriterInit</name><argument_list>(<argument><expr><name>iMaxLevel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iStart</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iEnd</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pRootData</name> <init>= <expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>nRootData</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&lt;</operator><name>nReaders</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>leavesReaderInit</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>iStart</name></expr></argument>, <argument><expr><name>iEnd</name></expr></argument>, <argument><expr><name>pRootData</name></expr></argument>, <argument><expr><name>nRootData</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

      <expr_stmt><expr><name><name>readers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>segment</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* If we managed to successfully read them all, optimize them. */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>==</operator><name>nReaders</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>optimizeInternal</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>readers</name></expr></argument>, <argument><expr><name>nReaders</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <while>while<condition>( <expr><name>i</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>leavesReaderDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>readers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>readers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If we've successfully gotten to here, delete the old segments
    ** and flush the interior structure of the new segment.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <for>for<control>( <init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>iMaxLevel</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>segdir_delete</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>leafWriterFinalize</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>leafWriterDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"Index optimized"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>

    <comment type="block">/* TODO(shess): Error-handling needs to be improved along the
    ** lines of the dump_ functions.
    */</comment>
 <label><name>err</name>:</label>
    <block>{<block_content>
      <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"Error in optimize: %s"</literal></expr></argument>,
                       <argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
<comment type="block">/* Generate an error of the form "&lt;prefix&gt;: &lt;msg&gt;".  If msg is NULL,
** pull the error from the context's db handle.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>generateError</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>msg</name><operator>==</operator><name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><call><name>sqlite3_context_db_handle</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Helper function to collect the set of terms in the segment into
** pTerms.  The segment is defined by the leaf nodes between
** iStartBlockid and iEndBlockid, inclusive, or by the contents of
** pRootData if iStartBlockid is 0 (in which case the entire segment
** fit in a leaf).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>collectSegmentTerms</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
                               <parameter><decl><type><name>fts2Hash</name> <modifier>*</modifier></type><name>pTerms</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite_int64</name></type> <name>iStartBlockid</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite_int64</name></type> <name>iEndBlockid</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pRootData</name> <init>= <expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nRootData</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LeavesReader</name></type> <name>reader</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>leavesReaderInit</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>iStartBlockid</name></expr></argument>, <argument><expr><name>iEndBlockid</name></expr></argument>,
                            <argument><expr><name>pRootData</name></expr></argument>, <argument><expr><name>nRootData</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>leavesReaderAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name> <init>= <expr><call><name>leavesReaderTerm</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nTerm</name> <init>= <expr><call><name>leavesReaderTermBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>oldValue</name> <init>= <expr><call><name>sqlite3Fts2HashFind</name><argument_list>(<argument><expr><name>pTerms</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>newValue</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>oldValue</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

    <comment type="block">/* From the comment before sqlite3Fts2HashInsert in fts2_hash.c,
    ** the data value passed is returned in case of malloc failure.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>newValue</name><operator>==</operator><call><name>sqlite3Fts2HashInsert</name><argument_list>(<argument><expr><name>pTerms</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>newValue</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>leavesReaderStep</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>leavesReaderDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Helper function to build the result string for dump_terms(). */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>generateTermsResult</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>, <parameter><decl><type><name>fts2Hash</name> <modifier>*</modifier></type><name>pTerms</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iTerm</name></decl>, <decl><type ref="prev"/><name>nTerms</name></decl>, <decl><type ref="prev"/><name>nResultBytes</name></decl>, <decl><type ref="prev"/><name>iByte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TermData</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fts2HashElem</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

  <comment type="block">/* Iterate pTerms to generate an array of terms in pData for
  ** sorting.
  */</comment>
  <expr_stmt><expr><name>nTerms</name> <operator>=</operator> <call><name>fts2HashCount</name><argument_list>(<argument><expr><name>pTerms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nTerms</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pData</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nTerms</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TermData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pData</name><operator>==</operator><name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>nResultBytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>iTerm</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>e</name> <operator>=</operator> <call><name>fts2HashFirst</name><argument_list>(<argument><expr><name>pTerms</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>iTerm</name><operator>++</operator></expr><operator>,</operator> <expr><name>e</name> <operator>=</operator> <call><name>fts2HashNext</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>nResultBytes</name> <operator>+=</operator> <call><name>fts2HashKeysize</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>   <comment type="block">/* Term plus trailing space */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iTerm</name><operator>&lt;</operator><name>nTerms</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pData</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>.</operator><name>pTerm</name> <operator>=</operator> <call><name>fts2HashKey</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pData</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>.</operator><name>nTerm</name> <operator>=</operator> <call><name>fts2HashKeysize</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pData</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>.</operator><name>pCollector</name> <operator>=</operator> <call><name>fts2HashData</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* unused */</comment>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iTerm</name><operator>==</operator><name>nTerms</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nResultBytes</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* nTerms&gt;0, nResultsBytes must be, too. */</comment>
  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name>nResultBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>result</name><operator>==</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>nTerms</name><operator>&gt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nTerms</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>termDataCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Read the terms in order to build the result. */</comment>
  <expr_stmt><expr><name>iByte</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>iTerm</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iTerm</name><operator>&lt;</operator><name>nTerms</name></expr>;</condition> <incr><expr><operator>++</operator><name>iTerm</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name><operator>+</operator><name>iByte</name></expr></argument>, <argument><expr><name><name>pData</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>.</operator><name>pTerm</name></expr></argument>, <argument><expr><name><name>pData</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>.</operator><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iByte</name> <operator>+=</operator> <name><name>pData</name><index>[<expr><name>iTerm</name></expr>]</index></name><operator>.</operator><name>nTerm</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><index>[<expr><name>iByte</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iByte</name><operator>==</operator><name>nResultBytes</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>result</name><index>[<expr><name>nResultBytes</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">' '</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>result</name><index>[<expr><name>nResultBytes</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

  <comment type="block">/* Passes away ownership of result. */</comment>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>nResultBytes</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Implements dump_terms() for use in inspecting the fts2 index from
** tests.  TEXT result containing the ordered list of terms joined by
** spaces.  dump_terms(t, level, idx) dumps the terms for the segment
** specified by level, idx (in %_segdir), while dump_terms(t) dumps
** all terms in the index.  In both cases t is the fts table's magic
** table-named column.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dumpTermsFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>!=</operator><literal type="number">3</literal> <operator>&amp;&amp;</operator> <name>argc</name><operator>!=</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>generateError</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"dump_terms"</literal></expr></argument>, <argument><expr><literal type="string">"incorrect arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_BLOB</name> <operator>||</operator>
            <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></sizeof></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>generateError</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"dump_terms"</literal></expr></argument>, <argument><expr><literal type="string">"illegal first argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>fts2Hash</name></type> <name>terms</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pCursor</name></expr></argument>, <argument><expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>cursor_vtab</name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If passed only the cursor column, get all segments.  Otherwise
    ** get the segment described by the following two arguments.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SEGDIR_SELECT_ALL_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SEGDIR_SELECT_SEGMENT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>generateError</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"dump_terms"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Collect the terms for each segment. */</comment>
    <expr_stmt><expr><call><name>sqlite3Fts2HashInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>terms</name></expr></argument>, <argument><expr><name>FTS2_HASH_STRING</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>collectSegmentTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>terms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>generateError</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"dump_terms"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nTerms</name> <init>= <expr><call><name>fts2HashCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name>terms</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><name>nTerms</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>generateTermsResult</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>terms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>generateError</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"dump_terms"</literal></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
        <comment type="block">/* The specific segment asked for could not be found. */</comment>
        <expr_stmt><expr><call><name>generateError</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"dump_terms"</literal></expr></argument>, <argument><expr><literal type="string">"segment not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* No segments found. */</comment>
        <comment type="block">/* TODO(shess): It should be impossible to reach this.  This
        ** case can only happen for an empty table, in which case
        ** SQLite has no rows to call this function on.
        */</comment>
        <expr_stmt><expr><call><name>sqlite3_result_null</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>sqlite3Fts2HashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>terms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Expand the DL_DEFAULT doclist in pData into a text result in
** pContext.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>createDoclistResult</name><parameter_list>(<parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DataBuffer</name></type> <name>dump</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DLReader</name></type> <name>dlReader</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pData</name><operator>!=</operator><name>NULL</name> <operator>&amp;&amp;</operator> <name>nData</name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dump</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dlrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dlReader</name></expr></argument>, <argument><expr><name>DL_DEFAULT</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>( <init>;</init> <condition><expr><operator>!</operator><call><name>dlrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dlReader</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><call><name>dlrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dlReader</name></expr></argument>)</argument_list></call></expr></incr> )</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PLReader</name></type> <name>plReader</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>plrInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dlReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>DL_DEFAULT</name><operator>==</operator><name>DL_DOCIDS</name> <operator>||</operator> <call><name>plrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"[%lld] "</literal></expr></argument>, <argument><expr><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dlReader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dump</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iColumn</name> <init>= <expr><call><name>plrColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"[%lld %d["</literal></expr></argument>,
                       <argument><expr><call><name>dlrDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dlReader</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dump</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <for>for<control>( <init>;</init> <condition><expr><operator>!</operator><call><name>plrAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><call><name>plrStep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>)</argument_list></call></expr></incr> )</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>plrColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>)</argument_list></call><operator>!=</operator><name>iColumn</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>iColumn</name> <operator>=</operator> <call><name>plrColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"] %d["</literal></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>dump</name><operator>.</operator><name>nData</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>dump</name><operator>.</operator><name>nData</name></name><operator>--</operator></expr>;</expr_stmt>                     <comment type="block">/* Overwrite trailing space. */</comment>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>dump</name><operator>.</operator><name>pData</name><index>[<expr><name><name>dump</name><operator>.</operator><name>nData</name></name></expr>]</index></name><operator>==</operator><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dump</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>( <expr><name>DL_DEFAULT</name><operator>==</operator><name>DL_POSITIONS_OFFSETS</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d,%d,%d "</literal></expr></argument>,
                           <argument><expr><call><name>plrPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>plrStartOffset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>plrEndOffset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>DL_DEFAULT</name><operator>==</operator><name>DL_POSITIONS</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d "</literal></expr></argument>, <argument><expr><call><name>plrPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if><else>else<block>{<block_content>
          <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>NULL</name><operator>==</operator><literal type="string">"Unhandled DL_DEFAULT value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dump</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><call><name>plrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>plReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>dump</name><operator>.</operator><name>nData</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>dump</name><operator>.</operator><name>nData</name></name><operator>--</operator></expr>;</expr_stmt>                     <comment type="block">/* Overwrite trailing space. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>dump</name><operator>.</operator><name>pData</name><index>[<expr><name><name>dump</name><operator>.</operator><name>nData</name></name></expr>]</index></name><operator>==</operator><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dataBufferAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dump</name></expr></argument>, <argument><expr><literal type="string">"]] "</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>dlrDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dlReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>dump</name><operator>.</operator><name>nData</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dump</name><operator>.</operator><name>nData</name></name><operator>--</operator></expr>;</expr_stmt>                     <comment type="block">/* Overwrite trailing space. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>dump</name><operator>.</operator><name>pData</name><index>[<expr><name><name>dump</name><operator>.</operator><name>nData</name></name></expr>]</index></name><operator>==</operator><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dump</name><operator>.</operator><name>pData</name><index>[<expr><name><name>dump</name><operator>.</operator><name>nData</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>dump</name><operator>.</operator><name>nData</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Passes ownership of dump's buffer to pContext. */</comment>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><name><name>dump</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>dump</name><operator>.</operator><name>nData</name></name></expr></argument>, <argument><expr><name>sqlite3_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dump</name><operator>.</operator><name>pData</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dump</name><operator>.</operator><name>nData</name></name> <operator>=</operator> <name><name>dump</name><operator>.</operator><name>nCapacity</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Implements dump_doclist() for use in inspecting the fts2 index from
** tests.  TEXT result containing a string representation of the
** doclist for the indicated term.  dump_doclist(t, term, level, idx)
** dumps the doclist for term from the segment specified by level, idx
** (in %_segdir), while dump_doclist(t, term) dumps the logical
** doclist for the term across all segments.  The per-segment doclist
** can contain deletions, while the full-index doclist will not
** (deletions are omitted).
**
** Result formats differ with the setting of DL_DEFAULTS.  Examples:
**
** DL_DOCIDS: [1] [3] [7]
** DL_POSITIONS: [1 0[0 4] 1[17]] [3 1[5]]
** DL_POSITIONS_OFFSETS: [1 0[0,0,3 4,23,26] 1[17,102,105]] [3 1[5,20,23]]
**
** In each case the number after the outer '[' is the docid.  In the
** latter two cases, the number before the inner '[' is the column
** associated with the values within.  For DL_POSITIONS the numbers
** within are the positions, for DL_POSITIONS_OFFSETS they are the
** position, the start offset, and the end offset.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dumpDoclistFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>!=</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>argc</name><operator>!=</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>generateError</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"dump_doclist"</literal></expr></argument>, <argument><expr><literal type="string">"incorrect arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_BLOB</name> <operator>||</operator>
            <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></sizeof></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>generateError</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"dump_doclist"</literal></expr></argument>, <argument><expr><literal type="string">"illegal first argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>==</operator><name>NULL</name> <operator>||</operator>
            <call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index><operator>==</operator><literal type="char">'\0'</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>generateError</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"dump_doclist"</literal></expr></argument>, <argument><expr><literal type="string">"empty second argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nTerm</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>pTerm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataBuffer</name></type> <name>doclist</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pCursor</name></expr></argument>, <argument><expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>cursor_vtab</name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>dataBufferInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* termSelect() yields the same logical doclist that queries are
    ** run against.
    */</comment>
    <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>termSelect</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>DL_DEFAULT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Get our specific segment's information. */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>SEGDIR_SELECT_SEGMENT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>generateError</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"dump_doclist"</literal></expr></argument>, <argument><expr><literal type="string">"segment not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Found a segment, load it into doclist. */</comment>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite_int64</name></type> <name>iLeavesEnd</name> <init>= <expr><call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name> <init>= <expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nData</name> <init>= <expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <comment type="block">/* loadSegment() is used by termSelect() to load each
          ** segment's data.
          */</comment>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>loadSegment</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>, <argument><expr><name>iLeavesEnd</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Should not have more than one matching segment. */</comment>
            <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
              <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>generateError</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"dump_doclist"</literal></expr></argument>, <argument><expr><literal type="string">"invalid segdir"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>doclist</name><operator>.</operator><name>nData</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>createDoclistResult</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><name><name>doclist</name><operator>.</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>doclist</name><operator>.</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <comment type="block">/* TODO(shess): This can happen if the term is not present, or
        ** if all instances of the term have been deleted and this is
        ** an all-index dump.  It may be interesting to distinguish
        ** these cases.
        */</comment>
        <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_NOMEM</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Handle out-of-memory cases specially because if they are
      ** generated in fts2 code they may not be reflected in the db
      ** handle.
      */</comment>
      <comment type="block">/* TODO(shess): Handle this more comprehensively.
      ** sqlite3ErrStr() has what I need, but is internal.
      */</comment>
      <expr_stmt><expr><call><name>generateError</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"dump_doclist"</literal></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>generateError</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"dump_doclist"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>dataBufferDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** This routine implements the xFindFunction method for the FTS2
** virtual table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextFindFunction</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><modifier>*</modifier><name>pxFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>,<argument><expr><literal type="string">"snippet"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pxFunc</name> <operator>=</operator> <name>snippetFunc</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>,<argument><expr><literal type="string">"offsets"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pxFunc</name> <operator>=</operator> <name>snippetOffsetsFunc</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>,<argument><expr><literal type="string">"optimize"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pxFunc</name> <operator>=</operator> <name>optimizeFunc</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
    <comment type="block">/* NOTE(shess): These functions are present only for testing
    ** purposes.  No particular effort is made to optimize their
    ** execution or how they build their results.
    */</comment>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>,<argument><expr><literal type="string">"dump_terms"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* fprintf(stderr, "Found dump_terms\n"); */</comment>
    <expr_stmt><expr><operator>*</operator><name>pxFunc</name> <operator>=</operator> <name>dumpTermsFunc</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>,<argument><expr><literal type="string">"dump_doclist"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* fprintf(stderr, "Found dump_doclist\n"); */</comment>
    <expr_stmt><expr><operator>*</operator><name>pxFunc</name> <operator>=</operator> <name>dumpDoclistFunc</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Rename an fts2 table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextRename</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_NOMEM</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(
    <argument><expr><literal type="string">"ALTER TABLE %Q.'%q_content'  RENAME TO '%q_content';"</literal>
    <literal type="string">"ALTER TABLE %Q.'%q_segments' RENAME TO '%q_segments';"</literal>
    <literal type="string">"ALTER TABLE %Q.'%q_segdir'   RENAME TO '%q_segdir';"</literal></expr></argument>
    , <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument> 
    , <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument> 
    , <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>
  )</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_module</name></type> <name>fts2Module</name> <init>= <expr><block>{
  <comment type="block">/* iVersion      */</comment> <expr><literal type="number">0</literal></expr>,
  <comment type="block">/* xCreate       */</comment> <expr><name>fulltextCreate</name></expr>,
  <comment type="block">/* xConnect      */</comment> <expr><name>fulltextConnect</name></expr>,
  <comment type="block">/* xBestIndex    */</comment> <expr><name>fulltextBestIndex</name></expr>,
  <comment type="block">/* xDisconnect   */</comment> <expr><name>fulltextDisconnect</name></expr>,
  <comment type="block">/* xDestroy      */</comment> <expr><name>fulltextDestroy</name></expr>,
  <comment type="block">/* xOpen         */</comment> <expr><name>fulltextOpen</name></expr>,
  <comment type="block">/* xClose        */</comment> <expr><name>fulltextClose</name></expr>,
  <comment type="block">/* xFilter       */</comment> <expr><name>fulltextFilter</name></expr>,
  <comment type="block">/* xNext         */</comment> <expr><name>fulltextNext</name></expr>,
  <comment type="block">/* xEof          */</comment> <expr><name>fulltextEof</name></expr>,
  <comment type="block">/* xColumn       */</comment> <expr><name>fulltextColumn</name></expr>,
  <comment type="block">/* xRowid        */</comment> <expr><name>fulltextRowid</name></expr>,
  <comment type="block">/* xUpdate       */</comment> <expr><name>fulltextUpdate</name></expr>,
  <comment type="block">/* xBegin        */</comment> <expr><name>fulltextBegin</name></expr>,
  <comment type="block">/* xSync         */</comment> <expr><name>fulltextSync</name></expr>,
  <comment type="block">/* xCommit       */</comment> <expr><name>fulltextCommit</name></expr>,
  <comment type="block">/* xRollback     */</comment> <expr><name>fulltextRollback</name></expr>,
  <comment type="block">/* xFindFunction */</comment> <expr><name>fulltextFindFunction</name></expr>,
  <comment type="block">/* xRename */</comment>       <expr><name>fulltextRename</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>hashDestroy</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fts2Hash</name> <modifier>*</modifier></type><name>pHash</name> <init>= <expr><operator>(</operator><name>fts2Hash</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3Fts2HashClear</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** The fts2 built-in tokenizers - "simple" and "porter" - are implemented
** in files fts2_tokenizer1.c and fts2_porter.c respectively. The following
** two forward declarations are for functions declared in these files
** used to retrieve the respective implementations.
**
** Calling sqlite3Fts2SimpleTokenizerModule() sets the value pointed
** to by the argument to point a the "simple" tokenizer implementation.
** Function ...PorterTokenizerModule() sets *pModule to point to the
** porter tokenizer/stemmer implementation.
*/</comment>
<function_decl><type><name>void</name></type> <name>sqlite3Fts2SimpleTokenizerModule</name><parameter_list>(<parameter><decl><type><name>sqlite3_tokenizer_module</name> <specifier>const</specifier><modifier>*</modifier><modifier>*</modifier></type><name>ppModule</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqlite3Fts2PorterTokenizerModule</name><parameter_list>(<parameter><decl><type><name>sqlite3_tokenizer_module</name> <specifier>const</specifier><modifier>*</modifier><modifier>*</modifier></type><name>ppModule</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sqlite3Fts2IcuTokenizerModule</name><parameter_list>(<parameter><decl><type><name>sqlite3_tokenizer_module</name> <specifier>const</specifier><modifier>*</modifier><modifier>*</modifier></type><name>ppModule</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>sqlite3Fts2InitHashTable</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>fts2Hash</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Initialize the fts2 extension. If this extension is built as part
** of the sqlite library, then this function is called directly by
** SQLite. If fts2 is built as a dynamically loadable extension, this
** function is called by the sqlite3_extension_init() entry point.
*/</comment>
<function><type><name>int</name></type> <name>sqlite3Fts2Init</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fts2Hash</name> <modifier>*</modifier></type><name>pHash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_tokenizer_module</name> <modifier>*</modifier></type><name>pSimple</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_tokenizer_module</name> <modifier>*</modifier></type><name>pPorter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_tokenizer_module</name> <modifier>*</modifier></type><name>pIcu</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>sqlite3Fts2SimpleTokenizerModule</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pSimple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3Fts2PorterTokenizerModule</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pPorter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_ENABLE_ICU</name></cpp:ifdef>
  <expr_stmt><expr><call><name>sqlite3Fts2IcuTokenizerModule</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pIcu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Allocate and initialize the hash-table used to store tokenizers. */</comment>
  <expr_stmt><expr><name>pHash</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fts2Hash</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>pHash</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Fts2HashInit</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><name>FTS2_HASH_STRING</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Load the built-in tokenizers into the hash table */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3Fts2HashInsert</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><literal type="string">"simple"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pSimple</name></expr></argument>)</argument_list></call>
     <operator>||</operator> <call><name>sqlite3Fts2HashInsert</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><literal type="string">"porter"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pPorter</name></expr></argument>)</argument_list></call> 
     <operator>||</operator> <operator>(</operator><name>pIcu</name> <operator>&amp;&amp;</operator> <call><name>sqlite3Fts2HashInsert</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>, <argument><expr><literal type="string">"icu"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pIcu</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
    )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Create the virtual table wrapper around the hash-table and overload 
  ** the two scalar functions. If this is successful, register the
  ** module with sqlite.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><name>rc</name> 
   <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3Fts2InitHashTable</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pHash</name></expr></argument>, <argument><expr><literal type="string">"fts2_tokenizer"</literal></expr></argument>)</argument_list></call><operator>)</operator>
   <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_overload_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"snippet"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator>
   <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_overload_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"offsets"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator>
   <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_overload_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"optimize"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_TEST</name></cpp:ifdef>
   <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_overload_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"dump_terms"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator>
   <operator>&amp;&amp;</operator> <name>SQLITE_OK</name><operator>==</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>sqlite3_overload_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"dump_doclist"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  )</condition><block>{<block_content>
    <return>return <expr><call><name>sqlite3_create_module_v2</name><argument_list>(
        <argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"fts2"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fts2Module</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>pHash</name></expr></argument>, <argument><expr><name>hashDestroy</name></expr></argument>
    )</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* An error has occurred. Delete the hash table and return the error code. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pHash</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Fts2HashClear</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_CORE</name></expr></cpp:if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_fts2_init</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, 
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <macro><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument>pApi</argument>)</argument_list></macro>
  <return>return <expr><call><name>sqlite3Fts2Init</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS2) */</comment>
</unit>
