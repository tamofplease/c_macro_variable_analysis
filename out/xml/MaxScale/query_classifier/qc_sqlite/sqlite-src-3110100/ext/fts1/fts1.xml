<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/ext/fts1/fts1.c"><comment type="block">/* fts1 has a design flaw which can lead to database corruption (see
** below).  It is recommended not to use it any longer, instead use
** fts3 (or higher).  If you believe that your use of fts1 is safe,
** add -DSQLITE_ENABLE_BROKEN_FTS1=1 to your CFLAGS.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_CORE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_FTS1</name></expr></argument>)</argument_list></call><operator>)</operator> \
        <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_BROKEN_FTS1</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> fts1 has a design flaw and has been deprecated.</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* The flaw is that fts1 uses the content table's unaliased rowid as
** the unique docid.  fts1 embeds the rowid in the index it builds,
** and expects the rowid to not change.  The SQLite VACUUM operation
** will renumber such rowids, thereby breaking fts1.  If you are using
** fts1 in a system which has disabled VACUUM, then you can continue
** to use it safely.  Note that PRAGMA auto_vacuum does NOT disable
** VACUUM, though systems using auto_vacuum are unlikely to invoke
** VACUUM.
**
** fts1 should be safe even across VACUUM if you only insert documents
** and never delete.
*/</comment>

<comment type="block">/* The author disclaims copyright to this source code.
 *
 * This is an SQLite module implementing full-text search.
 */</comment>

<comment type="block">/*
** The code in this file is only compiled if:
**
**     * The FTS1 module is being built as an extension
**       (in which case SQLITE_CORE is not defined), or
**
**     * The FTS1 module is being built into the core of
**       SQLite (in which case SQLITE_ENABLE_FTS1 is defined).
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_CORE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_FTS1</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_ENABLE_FTS1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_CORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>SQLITE_CORE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fts1.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fts1_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fts1_tokenizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3ext.h"</cpp:file></cpp:include>
<macro><name>SQLITE_EXTENSION_INIT1</name></macro>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>TRACE</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>printf A; fflush(stdout)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>TRACE</name><parameter_list>(<parameter><type><name>A</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* utility functions */</comment>

<typedef>typedef <type><struct>struct <name>StringBuffer</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>      <comment type="block">/* length, not including null terminator */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>alloced</name></decl>;</decl_stmt>  <comment type="block">/* Space allocated for s[] */</comment> 
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>      <comment type="block">/* Content of the string */</comment>
}</block></struct></type> <name>StringBuffer</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>initStringBuffer</name><parameter_list>(<parameter><decl><type><name>StringBuffer</name> <modifier>*</modifier></type><name>sb</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>alloced</name></name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>nappend</name><parameter_list>(<parameter><decl><type><name>StringBuffer</name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFrom</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nFrom</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>sb</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <name>nFrom</name> <operator>&gt;=</operator> <name><name>sb</name><operator>-&gt;</operator><name>alloced</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>alloced</name></name> <operator>=</operator> <name><name>sb</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <name>nFrom</name> <operator>+</operator> <literal type="number">100</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>sb</name><operator>-&gt;</operator><name>alloced</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>sb</name><operator>-&gt;</operator><name>s</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>initStringBuffer</name><argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>sb</name><operator>-&gt;</operator><name>s</name></name> <operator>+</operator> <name><name>sb</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>zFrom</name></expr></argument>, <argument><expr><name>nFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <name>nFrom</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sb</name><operator>-&gt;</operator><name>s</name><index>[<expr><name><name>sb</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><name>StringBuffer</name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFrom</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>nappend</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>zFrom</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>zFrom</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* We encode variable-length integers in little-endian order using seven bits
 * per byte as follows:
**
** KEY:
**         A = 0xxxxxxx    7 bits of data and one flag bit
**         B = 1xxxxxxx    7 bits of data and one flag bit
**
**  7 bits - A
** 14 bits - BA
** 21 bits - BBA
** and so on.
*/</comment>

<comment type="block">/* We may need up to VARINT_MAX bytes to store an encoded 64-bit integer. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARINT_MAX</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<comment type="block">/* Write a 64-bit variable-length integer to memory starting at p[0].
 * The length of data written will be between 1 and VARINT_MAX bytes.
 * The number of bytes written is returned. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>putVarint</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_uint64</name></type> <name>vu</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>vu</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>vu</name> <operator>&gt;&gt;=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>vu</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition>;</do>
  <expr_stmt><expr><name><name>q</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>  <comment type="block">/* turn off high bit in final byte */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>q</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>&lt;=</operator> <name>VARINT_MAX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>q</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Read a 64-bit variable-length integer from memory starting at p[0].
 * Return the number of bytes read, or 0 on error.
 * The value is stored in *v. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getVarint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_uint64</name></type> <name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>y</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><operator>(</operator><operator>*</operator><name>q</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>x</name> <operator>+=</operator> <name>y</name> <operator>*</operator> <operator>(</operator><operator>*</operator><name>q</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>y</name> <operator>&lt;&lt;=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>q</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>&gt;=</operator> <name>VARINT_MAX</name></expr> )</condition><block>{<block_content>  <comment type="block">/* bad data */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>x</name> <operator>+=</operator> <name>y</name> <operator>*</operator> <operator>(</operator><operator>*</operator><name>q</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>(</operator><name>sqlite_int64</name><operator>)</operator> <name>x</name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>q</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>getVarint32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pi</name></decl></parameter>)</parameter_list><block>{<block_content>
 <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>i</name></decl>;</decl_stmt>
 <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>getVarint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
 <expr_stmt><expr><operator>*</operator><name>pi</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>i</name></expr>;</expr_stmt>
 <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pi</name><operator>==</operator><name>i</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
 <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*** Document lists ***
 *
 * A document list holds a sorted list of varint-encoded document IDs.
 *
 * A doclist with type DL_POSITIONS_OFFSETS is stored like this:
 *
 * array {
 *   varint docid;
 *   array {
 *     varint position;     (delta from previous position plus POS_BASE)
 *     varint startOffset;  (delta from previous startOffset)
 *     varint endOffset;    (delta from startOffset)
 *   }
 * }
 *
 * Here, array { X } means zero or more occurrences of X, adjacent in memory.
 *
 * A position list may hold positions for text in multiple columns.  A position
 * POS_COLUMN is followed by a varint containing the index of the column for
 * following positions in the list.  Any positions appearing before any
 * occurrences of POS_COLUMN are for column 0.
 *
 * A doclist with type DL_POSITIONS is like the above, but holds only docids
 * and positions without offset information.
 *
 * A doclist with type DL_DOCIDS is like the above, but holds only docids
 * without positions or offset information.
 *
 * On disk, every document list has positions and offsets, so we don't bother
 * to serialize a doclist's type.
 * 
 * We don't yet delta-encode document IDs; doing so will probably be a
 * modest win.
 *
 * NOTE(shess) I've thought of a slightly (1%) better offset encoding.
 * After the first offset, estimate the next offset by using the
 * current token position and the previous token position and offset,
 * offset to handle some variance.  So the estimate would be
 * (iPosition*w-&gt;iStartOffset/w-&gt;iPosition-64), which is delta-encoded
 * as normal.  Offsets more than 64 chars from the estimate are
 * encoded as the delta to the previous start offset + 128.  An
 * additional tiny increment can be gained by using the end offset of
 * the previous token to make the estimate a tiny bit more precise.
*/</comment>

<comment type="block">/* It is not safe to call isspace(), tolower(), or isalnum() on
** hi-bit-set characters.  This is the same solution used in the
** tokenizer.
*/</comment>
<comment type="block">/* TODO(shess) The snippet-generation code should be using the
** tokenizer-generated tokens rather than doing its own local
** tokenization.
*/</comment>
<comment type="block">/* TODO(shess) Is __isascii() a portable version of (c&amp;0x80)==0? */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>safe_isspace</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>c</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>safe_tolower</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>c</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>c</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>safe_isalnum</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">0x80</literal><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>isalnum</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>c</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><enum>enum <name>DocListType</name> <block>{
  <decl><name>DL_DOCIDS</name></decl>,              <comment type="block">/* docids only */</comment>
  <decl><name>DL_POSITIONS</name></decl>,           <comment type="block">/* docids + positions */</comment>
  <decl><name>DL_POSITIONS_OFFSETS</name></decl>    <comment type="block">/* docids + positions + offsets */</comment>
}</block></enum></type> <name>DocListType</name>;</typedef>

<comment type="block">/*
** By default, only positions and not offsets are stored in the doclists.
** To change this so that offsets are stored too, compile with
**
**          -DDL_DEFAULT=DL_POSITIONS_OFFSETS
**
*/</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DL_DEFAULT</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>DL_DEFAULT</name></cpp:macro> <cpp:value>DL_POSITIONS</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct <name>DocList</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DocListType</name></type> <name>iType</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iLastColumn</name></decl>;</decl_stmt>    <comment type="block">/* the last column written */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLastPos</name></decl>;</decl_stmt>       <comment type="block">/* the last position written */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLastOffset</name></decl>;</decl_stmt>    <comment type="block">/* the last start offset written */</comment>
}</block></struct></type> <name>DocList</name>;</typedef>

<enum>enum <block>{
  <decl><name>POS_END</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,        <comment type="block">/* end of this position list */</comment>
  <decl><name>POS_COLUMN</name></decl>,         <comment type="block">/* followed by new column number */</comment>
  <decl><name>POS_BASE</name></decl>
}</block>;</enum>

<comment type="block">/* Initialize a new DocList to hold the given data. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListInit</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>DocListType</name></type> <name>iType</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <name>nData</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nData</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>iType</name></name> <operator>=</operator> <name>iType</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>iLastColumn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>iLastPos</name></name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>iLastOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Create a new dynamically-allocated DocList. */</comment>
<function><type><specifier>static</specifier> <name>DocList</name> <modifier>*</modifier></type><name>docListNew</name><parameter_list>(<parameter><decl><type><name>DocListType</name></type> <name>iType</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><operator>(</operator><name>DocList</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DocList</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>docListInit</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>iType</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>d</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>docListDestroy</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">0x55</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>d</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>docListDelete</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>docListDestroy</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>docListEnd</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name> <operator>+</operator> <name><name>d</name><operator>-&gt;</operator><name>nData</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Append a varint to a DocList's data. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>appendVarint</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><name>VARINT_MAX</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>putVarint</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>nData</name></name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name> <operator>+</operator> <name><name>d</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>nData</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>docListAddDocid</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>appendVarint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>d</name><operator>-&gt;</operator><name>iType</name></name><operator>&gt;=</operator><name>DL_POSITIONS</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>appendVarint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>POS_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* initially empty position list */</comment>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>iLastColumn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>iLastPos</name></name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>iLastOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* helper function for docListAddPos and docListAddPosOffset */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>addPos</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iPos</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>d</name><operator>-&gt;</operator><name>nData</name></name><operator>&gt;</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>--</operator><name><name>d</name><operator>-&gt;</operator><name>nData</name></name></expr>;</expr_stmt>  <comment type="block">/* remove previous terminator */</comment>
  <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>!=</operator><name><name>d</name><operator>-&gt;</operator><name>iLastColumn</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iColumn</name><operator>&gt;</operator><name><name>d</name><operator>-&gt;</operator><name>iLastColumn</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendVarint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>POS_COLUMN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendVarint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>iLastColumn</name></name> <operator>=</operator> <name>iColumn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>iLastPos</name></name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>iLastOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iPos</name><operator>&gt;=</operator><name><name>d</name><operator>-&gt;</operator><name>iLastPos</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>appendVarint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>iPos</name><operator>-</operator><name><name>d</name><operator>-&gt;</operator><name>iLastPos</name></name><operator>+</operator><name>POS_BASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>iLastPos</name></name> <operator>=</operator> <name>iPos</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add a position to the last position list in a doclist. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListAddPos</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iPos</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>d</name><operator>-&gt;</operator><name>iType</name></name><operator>==</operator><name>DL_POSITIONS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>addPos</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name>iPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>appendVarint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>POS_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* add new terminator */</comment>
</block_content>}</block></function>

<comment type="block">/*
** Add a position and starting and ending offsets to a doclist.
**
** If the doclist is setup to handle only positions, then insert
** the position only and ignore the offsets.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListAddPosOffset</name><parameter_list>(
  <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>,             <comment type="block">/* Doclist under construction */</comment>
  <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>,            <comment type="block">/* Column the inserted term is part of */</comment>
  <parameter><decl><type><name>int</name></type> <name>iPos</name></decl></parameter>,               <comment type="block">/* Position of the inserted term */</comment>
  <parameter><decl><type><name>int</name></type> <name>iStartOffset</name></decl></parameter>,       <comment type="block">/* Starting offset of inserted term */</comment>
  <parameter><decl><type><name>int</name></type> <name>iEndOffset</name></decl></parameter>          <comment type="block">/* Ending offset of inserted term */</comment>
)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>d</name><operator>-&gt;</operator><name>iType</name></name><operator>&gt;=</operator><name>DL_POSITIONS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>addPos</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name>iPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>d</name><operator>-&gt;</operator><name>iType</name></name><operator>==</operator><name>DL_POSITIONS_OFFSETS</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iStartOffset</name><operator>&gt;=</operator><name><name>d</name><operator>-&gt;</operator><name>iLastOffset</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendVarint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>iStartOffset</name><operator>-</operator><name><name>d</name><operator>-&gt;</operator><name>iLastOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>iLastOffset</name></name> <operator>=</operator> <name>iStartOffset</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iEndOffset</name><operator>&gt;=</operator><name>iStartOffset</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendVarint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>iEndOffset</name><operator>-</operator><name>iStartOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>appendVarint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>POS_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* add new terminator */</comment>
</block_content>}</block></function>

<comment type="block">/*
** A DocListReader object is a cursor into a doclist.  Initialize
** the cursor to the beginning of the doclist by calling readerInit().
** Then use routines
**
**      peekDocid()
**      readDocid()
**      readPosition()
**      skipPositionList()
**      and so forth...
**
** to read information out of the doclist.  When we reach the end
** of the doclist, atEnd() returns TRUE.
*/</comment>
<typedef>typedef <type><struct>struct <name>DocListReader</name> <block>{
  <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pDoclist</name></decl>;</decl_stmt>  <comment type="block">/* The document list we are stepping through */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>            <comment type="block">/* Pointer to next unread byte in the doclist */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLastColumn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iLastPos</name></decl>;</decl_stmt>  <comment type="block">/* the last position read, or -1 when not in a position list */</comment>
}</block></struct></type> <name>DocListReader</name>;</typedef>

<comment type="block">/*
** Initialize the DocListReader r to point to the beginning of pDoclist.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>readerInit</name><parameter_list>(<parameter><decl><type><name>DocListReader</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pDoclist</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>pDoclist</name></name> <operator>=</operator> <name>pDoclist</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pDoclist</name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name><name>pDoclist</name><operator>-&gt;</operator><name>pData</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>iLastColumn</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>iLastPos</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Return TRUE if we have reached then end of pReader and there is
** nothing else left to read.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>atEnd</name><parameter_list>(<parameter><decl><type><name>DocListReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>pDoclist</name></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name> <operator>&gt;=</operator> <call><name>docListEnd</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pDoclist</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Peek at the next docid without advancing the read pointer. 
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite_int64</name></type> <name>peekDocid</name><parameter_list>(<parameter><decl><type><name>DocListReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>ret</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>atEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>iLastPos</name></name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>getVarint</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Read the next docid.   See also nextDocid().
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite_int64</name></type> <name>readDocid</name><parameter_list>(<parameter><decl><type><name>DocListReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>ret</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>atEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>iLastPos</name></name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <call><name>getVarint</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pReader</name><operator>-&gt;</operator><name>pDoclist</name><operator>-&gt;</operator><name>iType</name></name><operator>&gt;=</operator><name>DL_POSITIONS</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iLastColumn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iLastPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Read the next position and column index from a position list.
 * Returns the position, or -1 at the end of the list. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>readPosition</name><parameter_list>(<parameter><decl><type><name>DocListReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>iColumn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iType</name> <init>= <expr><name><name>pReader</name><operator>-&gt;</operator><name>pDoclist</name><operator>-&gt;</operator><name>iType</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>pReader</name><operator>-&gt;</operator><name>iLastPos</name></name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>atEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>iType</name><operator>&lt;</operator><name>DL_POSITIONS</name></expr> )</condition><block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>POS_END</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iLastColumn</name></name> <operator>=</operator> <name><name>pReader</name><operator>-&gt;</operator><name>iLastPos</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>iColumn</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>POS_COLUMN</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pReader</name><operator>-&gt;</operator><name>iLastColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iLastPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>i</name><operator>&gt;=</operator><name>POS_BASE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iLastPos</name></name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>int</name><operator>)</operator> <name>i</name><operator>)</operator><operator>-</operator><name>POS_BASE</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iType</name><operator>&gt;=</operator><name>DL_POSITIONS_OFFSETS</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Skip over offsets, ignoring them for now. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iStart</name></decl>, <decl><type ref="prev"/><name>iEnd</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>iColumn</name> <operator>=</operator> <name><name>pReader</name><operator>-&gt;</operator><name>iLastColumn</name></name></expr>;</expr_stmt>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>iLastPos</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Skip past the end of a position list. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>skipPositionList</name><parameter_list>(<parameter><decl><type><name>DocListReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pReader</name><operator>-&gt;</operator><name>pDoclist</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>iType</name></name><operator>&gt;=</operator><name>DL_POSITIONS</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iColumn</name></decl>;</decl_stmt>
    <while>while<condition>( <expr><call><name>readPosition</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iColumn</name></expr></argument>)</argument_list></call><operator>!=</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content/>}</block></while>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Skip over a docid, including its position list if the doclist has
 * positions. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>skipDocument</name><parameter_list>(<parameter><decl><type><name>DocListReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>readDocid</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>skipPositionList</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Skip past all docids which are less than [iDocid].  Returns 1 if a docid
 * matching [iDocid] was found.  */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>skipToDocid</name><parameter_list>(<parameter><decl><type><name>DocListReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>d</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><operator>!</operator><call><name>atEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>d</name><operator>=</operator><call><name>peekDocid</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&lt;</operator><name>iDocid</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>skipDocument</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><operator>!</operator><call><name>atEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>d</name><operator>==</operator><name>iDocid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the first document in a document list.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite_int64</name></type> <name>firstDocid</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DocListReader</name></type> <name>r</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>readDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQLITE_DEBUG</name></cpp:ifdef>
<comment type="block">/*
** This routine is used for debugging purpose only.
**
** Write the content of a doclist to standard output.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>printDoclist</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DocListReader</name></type> <name>r</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>!</operator><call><name>atEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>docid</name> <init>= <expr><call><name>readDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>docid</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>skipPositionList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s%lld"</literal></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name>docid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator>  <literal type="string">","</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>iType</name></name><operator>&gt;=</operator><name>DL_POSITIONS</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iPos</name></decl>, <decl><type ref="prev"/><name>iCol</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDiv</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>( <expr><operator>(</operator><name>iPos</name> <operator>=</operator> <call><name>readPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iCol</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s%d:%d"</literal></expr></argument>, <argument><expr><name>zDiv</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>, <argument><expr><name>iPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>zDiv</name> <operator>=</operator> <literal type="string">":"</literal></expr>;</expr_stmt>
      </block_content>}</block></while>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SQLITE_DEBUG */</comment>

<comment type="block">/* Trim the given doclist to contain only positions in column
 * [iRestrictColumn]. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListRestrictColumn</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iRestrictColumn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DocListReader</name></type> <name>r</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DocList</name></type> <name>out</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>in</name><operator>-&gt;</operator><name>iType</name></name><operator>&gt;=</operator><name>DL_POSITIONS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>docListInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>DL_POSITIONS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><operator>!</operator><call><name>atEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iDocid</name> <init>= <expr><call><name>readDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iPos</name></decl>, <decl><type ref="prev"/><name>iColumn</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>docListAddDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while<condition>( <expr><operator>(</operator><name>iPos</name> <operator>=</operator> <call><name>readPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iColumn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>==</operator><name>iRestrictColumn</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>docListAddPos</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name>iPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>docListDestroy</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>in</name> <operator>=</operator> <name>out</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Trim the given doclist by discarding any docids without any remaining
 * positions. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListDiscardEmpty</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>in</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>DocListReader</name></type> <name>r</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DocList</name></type> <name>out</name></decl>;</decl_stmt>

  <comment type="block">/* TODO: It would be nice to implement this operation in place; that
   * could save a significant amount of memory in queries with long doclists. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>in</name><operator>-&gt;</operator><name>iType</name></name><operator>&gt;=</operator><name>DL_POSITIONS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>docListInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>DL_POSITIONS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><operator>!</operator><call><name>atEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iDocid</name> <init>= <expr><call><name>readDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>match</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>iPos</name></decl>, <decl><type ref="prev"/><name>iColumn</name></decl>;</decl_stmt>
    <while>while<condition>( <expr><operator>(</operator><name>iPos</name> <operator>=</operator> <call><name>readPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iColumn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>match</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>docListAddDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>match</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>docListAddPos</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name>iPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></while>

  <expr_stmt><expr><call><name>docListDestroy</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>in</name> <operator>=</operator> <name>out</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Helper function for docListUpdate() and docListAccumulate().
** Splices a doclist element into the doclist represented by r,
** leaving r pointing after the newly spliced element.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListSpliceElement</name><parameter_list>(<parameter><decl><type><name>DocListReader</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pSource</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nSource</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name><name>r</name><operator>-&gt;</operator><name>pDoclist</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pTarget</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTarget</name></decl>, <decl><type ref="prev"/><name>found</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>skipToDocid</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Describe slice in d to place pSource/nSource. */</comment>
  <expr_stmt><expr><name>pTarget</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>p</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>found</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>skipDocument</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nTarget</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>p</name></name><operator>-</operator><name>pTarget</name></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>nTarget</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* The sense of the following is that there are three possibilities.
  ** If nTarget==nSource, we should not move any memory nor realloc.
  ** If nTarget&gt;nSource, trim target and realloc.
  ** If nTarget&lt;nSource, realloc then expand target.
  */</comment>
  <if_stmt><if>if<condition>( <expr><name>nTarget</name><operator>&gt;</operator><name>nSource</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>pTarget</name><operator>+</operator><name>nSource</name></expr></argument>, <argument><expr><name>pTarget</name><operator>+</operator><name>nTarget</name></expr></argument>, <argument><expr><call><name>docListEnd</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call><operator>-</operator><operator>(</operator><name>pTarget</name><operator>+</operator><name>nTarget</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nTarget</name><operator>!=</operator><name>nSource</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iDoclist</name> <init>= <expr><name>pTarget</name><operator>-</operator><name><name>d</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>nData</name></name><operator>+</operator><name>nSource</name><operator>-</operator><name>nTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pTarget</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>pData</name></name><operator>+</operator><name>iDoclist</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nTarget</name><operator>&lt;</operator><name>nSource</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>pTarget</name><operator>+</operator><name>nSource</name></expr></argument>, <argument><expr><name>pTarget</name><operator>+</operator><name>nTarget</name></expr></argument>, <argument><expr><call><name>docListEnd</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call><operator>-</operator><operator>(</operator><name>pTarget</name><operator>+</operator><name>nTarget</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pTarget</name></expr></argument>, <argument><expr><name>pSource</name></expr></argument>, <argument><expr><name>nSource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>nData</name></name> <operator>+=</operator> <name>nSource</name><operator>-</operator><name>nTarget</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>pTarget</name><operator>+</operator><name>nSource</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Insert/update pUpdate into the doclist. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListUpdate</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pUpdate</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DocListReader</name></type> <name>reader</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>d</name><operator>!=</operator><name>NULL</name> <operator>&amp;&amp;</operator> <name>pUpdate</name><operator>!=</operator><name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>d</name><operator>-&gt;</operator><name>iType</name></name><operator>==</operator><name><name>pUpdate</name><operator>-&gt;</operator><name>iType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>docListSpliceElement</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>, <argument><expr><call><name>firstDocid</name><argument_list>(<argument><expr><name>pUpdate</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name><name>pUpdate</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>pUpdate</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Propagate elements from pUpdate to pAcc, overwriting elements with
** matching docids.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListAccumulate</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pAcc</name></decl></parameter>, <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pUpdate</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DocListReader</name></type> <name>accReader</name></decl>, <decl><type ref="prev"/><name>updateReader</name></decl>;</decl_stmt>

  <comment type="block">/* Handle edge cases where one doclist is empty. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pAcc</name><operator>!=</operator><name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pUpdate</name><operator>==</operator><name>NULL</name> <operator>||</operator> <name><name>pUpdate</name><operator>-&gt;</operator><name>nData</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pAcc</name><operator>-&gt;</operator><name>nData</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pAcc</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>pUpdate</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pAcc</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>pUpdate</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>pUpdate</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pAcc</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <name><name>pUpdate</name><operator>-&gt;</operator><name>nData</name></name></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>accReader</name></expr></argument>, <argument><expr><name>pAcc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>updateReader</name></expr></argument>, <argument><expr><name>pUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><operator>!</operator><call><name>atEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>updateReader</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pSource</name> <init>= <expr><name><name>updateReader</name><operator>.</operator><name>p</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iDocid</name> <init>= <expr><call><name>readDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>updateReader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>skipPositionList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>updateReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>docListSpliceElement</name><argument_list>(<argument><expr><operator>&amp;</operator><name>accReader</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>, <argument><expr><name>pSource</name></expr></argument>, <argument><expr><name><name>updateReader</name><operator>.</operator><name>p</name></name><operator>-</operator><name>pSource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
** Read the next docid off of pIn.  Return 0 if we reach the end.
*
* TODO: This assumes that docids are never 0, but they may actually be 0 since
* users can choose docids when inserting into a full-text table.  Fix this.
*/</comment>
<function><type><specifier>static</specifier> <name>sqlite_int64</name></type> <name>nextDocid</name><parameter_list>(<parameter><decl><type><name>DocListReader</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>skipPositionList</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><call><name>atEnd</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>readDocid</name><argument_list>(<argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** pLeft and pRight are two DocListReaders that are pointing to
** positions lists of the same document: iDocid. 
**
** If there are no instances in pLeft or pRight where the position
** of pLeft is one less than the position of pRight, then this
** routine adds nothing to pOut.
**
** If there are one or more instances where positions from pLeft
** are exactly one less than positions from pRight, then add a new
** document record to pOut.  If pOut wants to hold positions, then
** include the positions from pRight that are one more than a
** position in pLeft.  In other words:  pRight.iPos==pLeft.iPos+1.
**
** pLeft and pRight are left pointing at the next document record.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mergePosList</name><parameter_list>(
  <parameter><decl><type><name>DocListReader</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>,    <comment type="block">/* Left position list */</comment>
  <parameter><decl><type><name>DocListReader</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>,   <comment type="block">/* Right position list */</comment>
  <parameter><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl></parameter>,     <comment type="block">/* The docid from pLeft and pRight */</comment>
  <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>            <comment type="block">/* Write the merged document record here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iLeftCol</name></decl>, <decl><type ref="prev"/><name>iLeftPos</name> <init>= <expr><call><name>readPosition</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iLeftCol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iRightCol</name></decl>, <decl><type ref="prev"/><name>iRightPos</name> <init>= <expr><call><name>readPosition</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRightCol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>match</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Loop until we've reached the end of both position lists. */</comment>
  <while>while<condition>( <expr><name>iLeftPos</name><operator>!=</operator><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>iRightPos</name><operator>!=</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>iLeftCol</name><operator>==</operator><name>iRightCol</name> <operator>&amp;&amp;</operator> <name>iLeftPos</name><operator>+</operator><literal type="number">1</literal><operator>==</operator><name>iRightPos</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>match</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>docListAddDocid</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>match</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>pOut</name><operator>-&gt;</operator><name>iType</name></name><operator>&gt;=</operator><name>DL_POSITIONS</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>docListAddPos</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>iRightCol</name></expr></argument>, <argument><expr><name>iRightPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>iLeftPos</name> <operator>=</operator> <call><name>readPosition</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iLeftCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iRightPos</name> <operator>=</operator> <call><name>readPosition</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRightCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>iRightCol</name><operator>&lt;</operator><name>iLeftCol</name> <operator>||</operator>
              <operator>(</operator><name>iRightCol</name><operator>==</operator><name>iLeftCol</name> <operator>&amp;&amp;</operator> <name>iRightPos</name><operator>&lt;</operator><name>iLeftPos</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iRightPos</name> <operator>=</operator> <call><name>readPosition</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iRightCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>iLeftPos</name> <operator>=</operator> <call><name>readPosition</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iLeftCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>iLeftPos</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>skipPositionList</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iRightPos</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>skipPositionList</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* We have two doclists:  pLeft and pRight.
** Write the phrase intersection of these two doclists into pOut.
**
** A phrase intersection means that two documents only match
** if pLeft.iPos+1==pRight.iPos.
**
** The output pOut may or may not contain positions.  If pOut
** does contain positions, they are the positions of pRight.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListPhraseMerge</name><parameter_list>(
  <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>,    <comment type="block">/* Doclist resulting from the words on the left */</comment>
  <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>,   <comment type="block">/* Doclist for the next word to the right */</comment>
  <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>      <comment type="block">/* Write the combined doclist here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DocListReader</name></type> <name>left</name></decl>, <decl><type ref="prev"/><name>right</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>docidLeft</name></decl>, <decl><type ref="prev"/><name>docidRight</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>docidLeft</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>docidRight</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><name>docidLeft</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>docidRight</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>docidLeft</name><operator>&lt;</operator><name>docidRight</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>docidLeft</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>docidRight</name><operator>&lt;</operator><name>docidLeft</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>docidRight</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>mergePosList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><name>docidLeft</name></expr></argument>, <argument><expr><name>pOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>docidLeft</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>docidRight</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* We have two doclists:  pLeft and pRight.
** Write the intersection of these two doclists into pOut.
** Only docids are matched.  Position information is ignored.
**
** The output pOut never holds positions.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListAndMerge</name><parameter_list>(
  <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>,    <comment type="block">/* Doclist resulting from the words on the left */</comment>
  <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>,   <comment type="block">/* Doclist for the next word to the right */</comment>
  <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>      <comment type="block">/* Write the combined doclist here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DocListReader</name></type> <name>left</name></decl>, <decl><type ref="prev"/><name>right</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>docidLeft</name></decl>, <decl><type ref="prev"/><name>docidRight</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>iType</name></name><operator>&lt;</operator><name>DL_POSITIONS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>docidLeft</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>docidRight</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><name>docidLeft</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>docidRight</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>docidLeft</name><operator>&lt;</operator><name>docidRight</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>docidLeft</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>docidRight</name><operator>&lt;</operator><name>docidLeft</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>docidRight</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>docListAddDocid</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>docidLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>docidLeft</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>docidRight</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* We have two doclists:  pLeft and pRight.
** Write the union of these two doclists into pOut.
** Only docids are matched.  Position information is ignored.
**
** The output pOut never holds positions.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListOrMerge</name><parameter_list>(
  <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>,    <comment type="block">/* Doclist resulting from the words on the left */</comment>
  <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>,   <comment type="block">/* Doclist for the next word to the right */</comment>
  <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>      <comment type="block">/* Write the combined doclist here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DocListReader</name></type> <name>left</name></decl>, <decl><type ref="prev"/><name>right</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>docidLeft</name></decl>, <decl><type ref="prev"/><name>docidRight</name></decl>, <decl><type ref="prev"/><name>priorLeft</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>docidLeft</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>docidRight</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><name>docidLeft</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>docidRight</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>docidLeft</name><operator>&lt;=</operator><name>docidRight</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>docListAddDocid</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>docidLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><call><name>docListAddDocid</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>docidRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>priorLeft</name> <operator>=</operator> <name>docidLeft</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>docidLeft</name><operator>&lt;=</operator><name>docidRight</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>docidLeft</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>docidRight</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>docidRight</name><operator>&lt;=</operator><name>priorLeft</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>docidRight</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <while>while<condition>( <expr><name>docidLeft</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>docListAddDocid</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>docidLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>docidLeft</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <while>while<condition>( <expr><name>docidRight</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>docListAddDocid</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>docidRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>docidRight</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* We have two doclists:  pLeft and pRight.
** Write into pOut all documents that occur in pLeft but not
** in pRight.
**
** Only docids are matched.  Position information is ignored.
**
** The output pOut never holds positions.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListExceptMerge</name><parameter_list>(
  <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>,    <comment type="block">/* Doclist resulting from the words on the left */</comment>
  <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>,   <comment type="block">/* Doclist for the next word to the right */</comment>
  <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>      <comment type="block">/* Write the combined doclist here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DocListReader</name></type> <name>left</name></decl>, <decl><type ref="prev"/><name>right</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>docidLeft</name></decl>, <decl><type ref="prev"/><name>docidRight</name></decl>, <decl><type ref="prev"/><name>priorLeft</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>docidLeft</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>docidRight</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><name>docidLeft</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>docidRight</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>priorLeft</name> <operator>=</operator> <name>docidLeft</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>docidLeft</name><operator>&lt;</operator><name>docidRight</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>docListAddDocid</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>docidLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>docidLeft</name><operator>&lt;=</operator><name>docidRight</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>docidLeft</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>docidRight</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>docidRight</name><operator>&lt;=</operator><name>priorLeft</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>docidRight</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <while>while<condition>( <expr><name>docidLeft</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>docListAddDocid</name><argument_list>(<argument><expr><name>pOut</name></expr></argument>, <argument><expr><name>docidLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>docidLeft</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>string_dup_n</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>str</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  <return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Duplicate a string; the caller must free() the returned string.
 * (We don't use strdup() since it is not part of the standard C library and
 * may not be available everywhere.) */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>string_dup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>string_dup_n</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Format a string, replacing each occurrence of the % character with
 * zDb.zName.  This may be more convenient than sqlite_mprintf()
 * when one string is used repeatedly in a format string.
 * The caller must free() the returned string. */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>string_format</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>nDb</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>zDb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>nName</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>nFullTableName</name> <init>= <expr><name>nDb</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>nName</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

  <comment type="block">/* first compute length needed */</comment>
  <for>for<control>(<init><expr><name>p</name> <operator>=</operator> <name>zFormat</name></expr> ;</init> <condition><expr><operator>*</operator><name>p</name></expr> ;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><ternary><condition><expr><operator>*</operator><name>p</name><operator>==</operator><literal type="char">'%'</literal></expr> ?</condition><then> <expr><name>nFullTableName</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* for null terminator */</comment>

  <expr_stmt><expr><name>r</name> <operator>=</operator> <name>result</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>p</name> <operator>=</operator> <name>zFormat</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name><operator>==</operator><literal type="char">'%'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>nDb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name> <operator>+=</operator> <name>nDb</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name> <operator>+=</operator> <name>nName</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>r</name> <operator>==</operator> <name>result</name> <operator>+</operator> <name>len</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sql_exec</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCommand</name> <init>= <expr><call><name>string_format</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS1 sql: %s\n"</literal><operator>,</operator> <name>zCommand</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zCommand</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sql_prepare</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,
                       <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCommand</name> <init>= <expr><call><name>string_format</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>zDb</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS1 prepare: %s\n"</literal><operator>,</operator> <name>zCommand</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zCommand</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>ppStmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* end utility functions */</comment>

<comment type="block">/* Forward reference */</comment>
<typedef>typedef <type><name><name>struct</name> <name>fulltext_vtab</name></name></type> <name>fulltext_vtab</name>;</typedef>

<comment type="block">/* A single term in a query is represented by an instances of
** the following structure.
*/</comment>
<typedef>typedef <type><struct>struct <name>QueryTerm</name> <block>{
  <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>nPhrase</name></decl>;</decl_stmt> <comment type="block">/* How many following terms are part of the same phrase */</comment>
  <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>iPhrase</name></decl>;</decl_stmt> <comment type="block">/* This is the i-th term of a phrase. */</comment>
  <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>iColumn</name></decl>;</decl_stmt> <comment type="block">/* Column of the index that must match this term */</comment>
  <decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name>isOr</name></decl>;</decl_stmt>  <comment type="block">/* this term is preceded by "OR" */</comment>
  <decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name>isNot</name></decl>;</decl_stmt> <comment type="block">/* this term is preceded by "-" */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>       <comment type="block">/* text of the term.  '\000' terminated.  malloced */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name></decl>;</decl_stmt>         <comment type="block">/* Number of bytes in pTerm[] */</comment>
}</block></struct></type> <name>QueryTerm</name>;</typedef>


<comment type="block">/* A query string is parsed into a Query structure.
 *
 * We could, in theory, allow query strings to be complicated
 * nested expressions with precedence determined by parentheses.
 * But none of the major search engines do this.  (Perhaps the
 * feeling is that an parenthesized expression is two complex of
 * an idea for the average user to grasp.)  Taking our lead from
 * the major search engines, we will allow queries to be a list
 * of terms (with an implied AND operator) or phrases in double-quotes,
 * with a single optional "-" before each non-phrase term to designate
 * negation and an optional OR connector.
 *
 * OR binds more tightly than the implied AND, which is what the
 * major search engines seem to do.  So, for example:
 * 
 *    [one two OR three]     ==&gt;    one AND (two OR three)
 *    [one OR two three]     ==&gt;    (one OR two) AND three
 *
 * A "-" before a term matches all entries that lack that term.
 * The "-" must occur immediately before the term with in intervening
 * space.  This is how the search engines do it.
 *
 * A NOT term cannot be the right-hand operand of an OR.  If this
 * occurs in the query string, the NOT is ignored:
 *
 *    [one OR -two]          ==&gt;    one OR two
 *
 */</comment>
<typedef>typedef <type><struct>struct <name>Query</name> <block>{
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>pFts</name></decl>;</decl_stmt>  <comment type="block">/* The full text index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerms</name></decl>;</decl_stmt>           <comment type="block">/* Number of terms in the query */</comment>
  <decl_stmt><decl><type><name>QueryTerm</name> <modifier>*</modifier></type><name>pTerms</name></decl>;</decl_stmt>    <comment type="block">/* Array of terms.  Space obtained from malloc() */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nextIsOr</name></decl>;</decl_stmt>         <comment type="block">/* Set the isOr flag on the next inserted term */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nextColumn</name></decl>;</decl_stmt>       <comment type="block">/* Next word parsed must be in this column */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>dfltColumn</name></decl>;</decl_stmt>       <comment type="block">/* The default column */</comment>
}</block></struct></type> <name>Query</name>;</typedef>


<comment type="block">/*
** An instance of the following structure keeps track of generated
** matching-word offset information and snippets.
*/</comment>
<typedef>typedef <type><struct>struct <name>Snippet</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nMatch</name></decl>;</decl_stmt>     <comment type="block">/* Total number of matches */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nAlloc</name></decl>;</decl_stmt>     <comment type="block">/* Space allocated for aMatch[] */</comment>
  <struct>struct <name>snippetMatch</name> <block>{ <comment type="block">/* One entry for each matching term */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name>snStatus</name></decl>;</decl_stmt>       <comment type="block">/* Status flag for use while constructing snippets */</comment>
    <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>iCol</name></decl>;</decl_stmt>      <comment type="block">/* The column that contains the match */</comment>
    <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>iTerm</name></decl>;</decl_stmt>     <comment type="block">/* The index in Query.pTerms[] of the matching term */</comment>
    <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>nByte</name></decl>;</decl_stmt>     <comment type="block">/* Number of bytes in the term */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iStart</name></decl>;</decl_stmt>          <comment type="block">/* The offset to the first character of the term */</comment>
  }</block> <decl><modifier>*</modifier><name>aMatch</name></decl>;</struct>      <comment type="block">/* Points to space obtained from malloc */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zOffset</name></decl>;</decl_stmt>  <comment type="block">/* Text rendering of aMatch[] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nOffset</name></decl>;</decl_stmt>    <comment type="block">/* strlen(zOffset) */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSnippet</name></decl>;</decl_stmt> <comment type="block">/* Snippet text */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nSnippet</name></decl>;</decl_stmt>   <comment type="block">/* strlen(zSnippet) */</comment>
}</block></struct></type> <name>Snippet</name>;</typedef>


<typedef>typedef <type><enum>enum <name>QueryType</name> <block>{
  <decl><name>QUERY_GENERIC</name></decl>,   <comment type="block">/* table scan */</comment>
  <decl><name>QUERY_ROWID</name></decl>,     <comment type="block">/* lookup by rowid */</comment>
  <decl><name>QUERY_FULLTEXT</name></decl>   <comment type="block">/* QUERY_FULLTEXT + [i] is a full-text search for column i*/</comment>
}</block></enum></type> <name>QueryType</name>;</typedef>

<comment type="block">/* TODO(shess) CHUNK_MAX controls how much data we allow in segment 0
** before we start aggregating into larger segments.  Lower CHUNK_MAX
** means that for a given input we have more individual segments per
** term, which means more rows in the table and a bigger index (due to
** both more rows and bigger rowids).  But it also reduces the average
** cost of adding new elements to the segment 0 doclist, and it seems
** to reduce the number of pages read and written during inserts.  256
** was chosen by measuring insertion times for a certain input (first
** 10k documents of Enron corpus), though including query performance
** in the decision may argue for a larger value.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNK_MAX</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum <name>fulltext_statement</name> <block>{
  <decl><name>CONTENT_INSERT_STMT</name></decl>,
  <decl><name>CONTENT_SELECT_STMT</name></decl>,
  <decl><name>CONTENT_UPDATE_STMT</name></decl>,
  <decl><name>CONTENT_DELETE_STMT</name></decl>,

  <decl><name>TERM_SELECT_STMT</name></decl>,
  <decl><name>TERM_SELECT_ALL_STMT</name></decl>,
  <decl><name>TERM_INSERT_STMT</name></decl>,
  <decl><name>TERM_UPDATE_STMT</name></decl>,
  <decl><name>TERM_DELETE_STMT</name></decl>,

  <decl><name>MAX_STMT</name></decl>                     <comment type="block">/* Always at end! */</comment>
}</block></enum></type> <name>fulltext_statement</name>;</typedef>

<comment type="block">/* These must exactly match the enum above. */</comment>
<comment type="block">/* TODO(adam): Is there some risk that a statement (in particular,
** pTermSelectStmt) will be used in two cursors at once, e.g.  if a
** query joins a virtual table to itself?  If so perhaps we should
** move some of these to the cursor object.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>fulltext_zStatement</name><index>[<expr><name>MAX_STMT</name></expr>]</index></name> <init>= <expr><block>{
  <comment type="block">/* CONTENT_INSERT */</comment> <expr><name>NULL</name></expr>,  <comment type="block">/* generated in contentInsertStatement() */</comment>
  <comment type="block">/* CONTENT_SELECT */</comment> <expr><literal type="string">"select * from %_content where rowid = ?"</literal></expr>,
  <comment type="block">/* CONTENT_UPDATE */</comment> <expr><name>NULL</name></expr>,  <comment type="block">/* generated in contentUpdateStatement() */</comment>
  <comment type="block">/* CONTENT_DELETE */</comment> <expr><literal type="string">"delete from %_content where rowid = ?"</literal></expr>,

  <comment type="block">/* TERM_SELECT */</comment>
  <expr><literal type="string">"select rowid, doclist from %_term where term = ? and segment = ?"</literal></expr>,
  <comment type="block">/* TERM_SELECT_ALL */</comment>
  <expr><literal type="string">"select doclist from %_term where term = ? order by segment"</literal></expr>,
  <comment type="block">/* TERM_INSERT */</comment>
  <expr><literal type="string">"insert into %_term (rowid, term, segment, doclist) values (?, ?, ?, ?)"</literal></expr>,
  <comment type="block">/* TERM_UPDATE */</comment> <expr><literal type="string">"update %_term set doclist = ? where rowid = ?"</literal></expr>,
  <comment type="block">/* TERM_DELETE */</comment> <expr><literal type="string">"delete from %_term where rowid = ?"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
** A connection to a fulltext index is an instance of the following
** structure.  The xCreate and xConnect methods create an instance
** of this structure and xDestroy and xDisconnect free that instance.
** All other methods receive a pointer to the structure as one of their
** arguments.
*/</comment>
<struct>struct <name>fulltext_vtab</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>               <comment type="block">/* Base class used by SQLite core */</comment>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>                     <comment type="block">/* The database connection */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>                 <comment type="block">/* logical database name */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>               <comment type="block">/* virtual table name */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nColumn</name></decl>;</decl_stmt>                     <comment type="block">/* number of columns in virtual table */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azColumn</name></decl>;</decl_stmt>                 <comment type="block">/* column names.  malloced */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azContentColumn</name></decl>;</decl_stmt>          <comment type="block">/* column names in content table; malloced */</comment>
  <decl_stmt><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name></decl>;</decl_stmt>   <comment type="block">/* tokenizer for inserts and queries */</comment>

  <comment type="block">/* Precompiled statements which we keep as long as the table is
  ** open.
  */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name><name>pFulltextStatements</name><index>[<expr><name>MAX_STMT</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** When the core wants to do a query, it create a cursor using a
** call to xOpen.  This structure is an instance of a cursor.  It
** is destroyed by xClose.
*/</comment>
<typedef>typedef <type><struct>struct <name>fulltext_cursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>        <comment type="block">/* Base class used by SQLite core */</comment>
  <decl_stmt><decl><type><name>QueryType</name></type> <name>iCursorType</name></decl>;</decl_stmt>           <comment type="block">/* Copy of sqlite3_index_info.idxNum */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>             <comment type="block">/* Prepared statement in use by the cursor */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>eof</name></decl>;</decl_stmt>                         <comment type="block">/* True if at End Of Results */</comment>
  <decl_stmt><decl><type><name>Query</name></type> <name>q</name></decl>;</decl_stmt>                         <comment type="block">/* Parsed query string */</comment>
  <decl_stmt><decl><type><name>Snippet</name></type> <name>snippet</name></decl>;</decl_stmt>                 <comment type="block">/* Cached snippet for the current row */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iColumn</name></decl>;</decl_stmt>                     <comment type="block">/* Column being searched */</comment>
  <decl_stmt><decl><type><name>DocListReader</name></type> <name>result</name></decl>;</decl_stmt>  <comment type="block">/* used when iCursorType == QUERY_FULLTEXT */</comment> 
}</block></struct></type> <name>fulltext_cursor</name>;</typedef>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>fulltext_vtab</name></name> <modifier>*</modifier></type><name>cursor_vtab</name><parameter_list>(<parameter><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator> <name><name>c</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_module</name></type> <name>fulltextModule</name></decl>;</decl_stmt>   <comment type="block">/* forward declaration */</comment>

<comment type="block">/* Append a list of strings separated by commas to a StringBuffer. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>appendList</name><parameter_list>(<parameter><decl><type><name>StringBuffer</name> <modifier>*</modifier></type><name>sb</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nString</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azString</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nString</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name><name>azString</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Return a dynamically generated statement of the form
 *   insert into %_content (rowid, ...) values (?, ...)
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>contentInsertStatement</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>StringBuffer</name></type> <name>sb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>initStringBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="string">"insert into %_content (rowid, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>appendList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>azContentColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="string">") values (?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="string">", ?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>sb</name><operator>.</operator><name>s</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return a dynamically generated statement of the form
 *   update %_content set [col_0] = ?, [col_1] = ?, ...
 *                    where rowid = ?
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>contentUpdateStatement</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>StringBuffer</name></type> <name>sb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>initStringBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="string">"update %_content set "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>azContentColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="string">" = ?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><literal type="string">" where rowid = ?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>sb</name><operator>.</operator><name>s</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Puts a freshly-prepared statement determined by iStmt in *ppStmt.
** If the indicated statement has never been prepared, it is prepared
** and cached, otherwise the cached version is reset.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sql_get_statement</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>fulltext_statement</name></type> <name>iStmt</name></decl></parameter>,
                             <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iStmt</name><operator>&lt;</operator><name>MAX_STMT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name><operator>==</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <switch>switch<condition>( <expr><name>iStmt</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>CONTENT_INSERT_STMT</name></expr>:</case>
        <expr_stmt><expr><name>zStmt</name> <operator>=</operator> <call><name>contentInsertStatement</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>CONTENT_UPDATE_STMT</name></expr>:</case>
        <expr_stmt><expr><name>zStmt</name> <operator>=</operator> <call><name>contentUpdateStatement</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name>zStmt</name> <operator>=</operator> <name><name>fulltext_zStatement</name><index>[<expr><name>iStmt</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></switch>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_prepare</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name></expr></argument>,
                         <argument><expr><name>zStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>zStmt</name> <operator>!=</operator> <name><name>fulltext_zStatement</name><index>[<expr><name>iStmt</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>zStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppStmt</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Step the indicated statement, handling errors SQLITE_BUSY (by
** retrying) and SQLITE_SCHEMA (by re-preparing and transferring
** bindings to the new statement).
** TODO(adam): We should extend this function so that it can work with
** statements declared locally, not only globally cached statements.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sql_step_statement</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>fulltext_statement</name></type> <name>iStmt</name></decl></parameter>,
                              <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><operator>*</operator><name>ppStmt</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iStmt</name><operator>&lt;</operator><name>MAX_STMT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>s</name><operator>==</operator><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><operator>(</operator><name>rc</name><operator>=</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><name>SQLITE_DONE</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ERROR</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If an SQLITE_SCHEMA error has occurred, then finalizing this
     * statement is going to delete the fulltext_vtab structure. If
     * the statement just executed is in the pFulltextStatements[]
     * array, it will be finalized twice. So remove it before
     * calling sqlite3_finalize().
     */</comment>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  </block_content>}</block></while>
  <return>return <expr><name>rc</name></expr>;</return>

 <label><name>err</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like sql_step_statement(), but convert SQLITE_DONE to SQLITE_OK.
** Useful for statements like UPDATE, where we expect no results.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sql_single_step_statement</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
                                     <parameter><decl><type><name>fulltext_statement</name></type> <name>iStmt</name></decl></parameter>,
                                     <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_step_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iStmt</name></expr></argument>, <argument><expr><name>ppStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name>rc</name><operator>==</operator><name>SQLITE_DONE</name><operator>)</operator></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* insert into %_content (rowid, ...) values ([rowid], [pValues]) */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>content_insert</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>rowid</name></decl></parameter>,
                          <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>pValues</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>CONTENT_INSERT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name><name>pValues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <return>return <expr><call><name>sql_single_step_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>CONTENT_INSERT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* update %_content set col0 = pValues[0], col1 = pValues[1], ...
 *                  where rowid = [iRowid] */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>content_update</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>pValues</name></decl></parameter>,
                          <parameter><decl><type><name>sqlite_int64</name></type> <name>iRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>CONTENT_UPDATE_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name><name>pValues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>sql_single_step_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>CONTENT_UPDATE_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>freeStringArray</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nString</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pString</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nString</name></expr> ;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>pString</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>pString</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>pString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* select * from %_content where rowid = [iRow]
 * The caller must delete the returned array and all strings in it.
 * null fields will be NULL in the returned array.
 *
 * TODO: Perhaps we should return pointer/length strings here for consistency
 * with other code which uses pointer/length. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>content_select</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iRow</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>pValues</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>pValues</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>CONTENT_SELECT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_step_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>CONTENT_SELECT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>==</operator><name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>string_dup</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <comment type="block">/* We expect only one row.  We must execute another sqlite3_step()
   * to complete the iteration; otherwise the table will remain locked. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pValues</name> <operator>=</operator> <name>values</name></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>freeStringArray</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* delete from %_content where rowid = [iRow ] */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>content_delete</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iRow</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>CONTENT_DELETE_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>sql_single_step_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>CONTENT_DELETE_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* select rowid, doclist from %_term
 *  where term = [pTerm] and segment = [iSegment]
 * If found, returns SQLITE_ROW; the caller must free the
 * returned doclist.  If no rows found, returns SQLITE_DONE. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>term_select</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,
                       <parameter><decl><type><name>int</name></type> <name>iSegment</name></decl></parameter>,
                       <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>rowid</name></decl></parameter>, <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TERM_SELECT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>iSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_step_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TERM_SELECT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>rowid</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>docListInit</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>DL_DEFAULT</name></expr></argument>,
              <argument><expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We expect only one row.  We must execute another sqlite3_step()
   * to complete the iteration; otherwise the table will remain locked. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> ?</condition><then> <expr><name>SQLITE_ROW</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Load the segment doclists for term pTerm and merge them in
** appropriate order into out.  Returns SQLITE_OK if successful.  If
** there are no segments for pTerm, successfully returns an empty
** doclist in out.
**
** Each document consists of 1 or more "columns".  The number of
** columns is v-&gt;nColumn.  If iColumn==v-&gt;nColumn, then return
** position information about all columns.  If iColumn&lt;v-&gt;nColumn,
** then only return position information about the iColumn-th column
** (where the first column is 0).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>term_select_all</name><parameter_list>(
  <parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,     <comment type="block">/* The fulltext index we are querying against */</comment>
  <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>,          <comment type="block">/* If &lt;nColumn, only look at the iColumn-th column */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>,    <comment type="block">/* The term whose posting lists we want */</comment>
  <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,            <comment type="block">/* Number of bytes in pTerm */</comment>
  <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>out</name></decl></parameter>          <comment type="block">/* Write the resulting doclist here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DocList</name></type> <name>doclist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TERM_SELECT_ALL_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>docListInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>, <argument><expr><name>DL_DEFAULT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* TODO(shess) Handle schema and busy errors. */</comment>
  <while>while<condition>( <expr><operator>(</operator><name>rc</name><operator>=</operator><call><name>sql_step_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TERM_SELECT_ALL_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>DocList</name></type> <name>old</name></decl>;</decl_stmt>

    <comment type="block">/* TODO(shess) If we processed doclists from oldest to newest, we
    ** could skip the malloc() involved with the following call.  For
    ** now, I'd rather keep this logic similar to index_insert_term().
    ** We could additionally drop elements when we see deletes, but
    ** that would require a distinct version of docListAccumulate().
    */</comment>
    <expr_stmt><expr><call><name>docListInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old</name></expr></argument>, <argument><expr><name>DL_DEFAULT</name></expr></argument>,
                <argument><expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>&lt;</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr> )</condition><block>{<block_content>   <comment type="block">/* querying a single column */</comment>
      <expr_stmt><expr><call><name>docListRestrictColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* doclist contains the newer data, so write it over old.  Then
    ** steal accumulated result for doclist.
    */</comment>
    <expr_stmt><expr><call><name>docListAccumulate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>docListDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>doclist</name> <operator>=</operator> <name>old</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>docListDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>docListDiscardEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name>doclist</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* insert into %_term (rowid, term, segment, doclist)
               values ([piRowid], [pTerm], [iSegment], [doclist])
** Lets sqlite select rowid if piRowid is NULL, else uses *piRowid.
**
** NOTE(shess) piRowid is IN, with values of "space of int64" plus
** null, it is not used to pass data back to the caller.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>term_insert</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>piRowid</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,
                       <parameter><decl><type><name>int</name></type> <name>iSegment</name></decl></parameter>, <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>doclist</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TERM_INSERT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>piRowid</name><operator>==</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_null</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>*</operator><name>piRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>iSegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_blob</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>doclist</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>doclist</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>sql_single_step_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TERM_INSERT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* update %_term set doclist = [doclist] where rowid = [rowid] */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>term_update</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>rowid</name></decl></parameter>,
                       <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>doclist</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TERM_UPDATE_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_blob</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>doclist</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>doclist</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>sql_single_step_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TERM_UPDATE_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>term_delete</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>rowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TERM_DELETE_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>sql_single_step_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TERM_DELETE_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Free the memory used to contain a fulltext_vtab structure.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fulltext_vtab_destroy</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iStmt</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS1 Destroy %p\n"</literal><operator>,</operator> <name>v</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>( <init><expr><name>iStmt</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iStmt</name><operator>&lt;</operator><name>MAX_STMT</name></expr>;</condition> <incr><expr><name>iStmt</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xDestroy</name></name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>azColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>azContentColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>azContentColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Token types for parsing the arguments to xConnect or xCreate.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOKEN_EOF</name></cpp:macro>         <cpp:value>0</cpp:value></cpp:define>    <comment type="block">/* End of file */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOKEN_SPACE</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>    <comment type="block">/* Any kind of whitespace */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOKEN_ID</name></cpp:macro>          <cpp:value>2</cpp:value></cpp:define>    <comment type="block">/* An identifier */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOKEN_STRING</name></cpp:macro>      <cpp:value>3</cpp:value></cpp:define>    <comment type="block">/* A string literal */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOKEN_PUNCT</name></cpp:macro>       <cpp:value>4</cpp:value></cpp:define>    <comment type="block">/* A single punctuation character */</comment>

<comment type="block">/*
** If X is a character that can be used in an identifier then
** IdChar(X) will be true.  Otherwise it is false.
**
** For ASCII, any character with the high-order bit set is
** allowed in an identifier.  For 7-bit characters, 
** sqlite3IsIdChar[X] must be 1.
**
** Ticket #1066.  the SQL standard does not allow '$' in the
** middle of identfiers.  But many SQL implementations do. 
** SQLite will allow '$' in identifiers for compatibility.
** But the feature is undocumented.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>isIdChar</name><index>[]</index></name> <init>= <expr><block>{
<comment type="block">/* x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF */</comment>
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,  <comment type="block">/* 2x */</comment>
    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,  <comment type="block">/* 3x */</comment>
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,  <comment type="block">/* 4x */</comment>
    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>,  <comment type="block">/* 5x */</comment>
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,  <comment type="block">/* 6x */</comment>
    <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,  <comment type="block">/* 7x */</comment>
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IdChar</name><parameter_list>(<parameter><type><name>C</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(((c=C)&amp;0x80)!=0 || (c&gt;0x1f &amp;&amp; isIdChar[c-0x20]))</cpp:value></cpp:define>


<comment type="block">/*
** Return the length of the token that begins at z[0]. 
** Store the token type in *tokenType before returning.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getToken</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tokenType</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
  <switch>switch<condition>( <expr><operator>*</operator><name>z</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="number">0</literal></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>tokenType</name> <operator>=</operator> <name>TOKEN_EOF</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><literal type="char">' '</literal></expr>:</case> <case>case <expr><literal type="char">'\t'</literal></expr>:</case> <case>case <expr><literal type="char">'\n'</literal></expr>:</case> <case>case <expr><literal type="char">'\f'</literal></expr>:</case> <case>case <expr><literal type="char">'\r'</literal></expr>:</case> <block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><call><name>safe_isspace</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
      <expr_stmt><expr><operator>*</operator><name>tokenType</name> <operator>=</operator> <name>TOKEN_SPACE</name></expr>;</expr_stmt>
      <return>return <expr><name>i</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><literal type="char">'`'</literal></expr>:</case>
    <case>case <expr><literal type="char">'\''</literal></expr>:</case>
    <case>case <expr><literal type="char">'"'</literal></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>delim</name> <init>= <expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><operator>(</operator><name>c</name><operator>=</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><name>c</name><operator>==</operator><name>delim</name></expr> )</condition><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><name>delim</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if><else>else<block>{<block_content>
            <break>break;</break>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <expr_stmt><expr><operator>*</operator><name>tokenType</name> <operator>=</operator> <name>TOKEN_STRING</name></expr>;</expr_stmt>
      <return>return <expr><name>i</name> <operator>+</operator> <operator>(</operator><name>c</name><operator>!=</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block>
    <case>case <expr><literal type="char">'['</literal></expr>:</case> <block>{<block_content>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>c</name><operator>=</operator><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</init> <condition><expr><name>c</name><operator>!=</operator><literal type="char">']'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name><operator>=</operator><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>!=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
      <expr_stmt><expr><operator>*</operator><name>tokenType</name> <operator>=</operator> <name>TOKEN_ID</name></expr>;</expr_stmt>
      <return>return <expr><name>i</name></expr>;</return>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>IdChar</name><argument_list>(<argument><expr><operator>*</operator><name>z</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><call><name>IdChar</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
      <expr_stmt><expr><operator>*</operator><name>tokenType</name> <operator>=</operator> <name>TOKEN_ID</name></expr>;</expr_stmt>
      <return>return <expr><name>i</name></expr>;</return>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><operator>*</operator><name>tokenType</name> <operator>=</operator> <name>TOKEN_PUNCT</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** A token extracted from a string is an instance of the following
** structure.
*/</comment>
<typedef>typedef <type><struct>struct <name>Token</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>       <comment type="block">/* Pointer to token text.  Not '\000' terminated */</comment>
  <decl_stmt><decl><type><name>short</name> <name>int</name></type> <name>n</name></decl>;</decl_stmt>         <comment type="block">/* Length of the token text in bytes. */</comment>
}</block></struct></type> <name>Token</name>;</typedef>

<comment type="block">/*
** Given a input string (which is really one of the argv[] parameters
** passed into xConnect or xCreate) split the string up into tokens.
** Return an array of pointers to '\000' terminated strings, one string
** for each non-whitespace token.
**
** The returned array is terminated by a single NULL pointer.
**
** Space to hold the returned array is obtained from a single
** malloc and should be freed by passing the return value to free().
** The individual strings within the token list are all a part of
** the single memory allocation and will all be freed at once.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>tokenizeString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pnToken</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nToken</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Token</name> <modifier>*</modifier></type><name>aToken</name> <init>= <expr><call><name>malloc</name><argument_list>( <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>aToken</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>e</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>totalSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azToken</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCopy</name></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>n</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getToken</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>e</name><operator>!=</operator><name>TOKEN_SPACE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>aToken</name><index>[<expr><name>nToken</name></expr>]</index></name><operator>.</operator><name>z</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aToken</name><index>[<expr><name>nToken</name></expr>]</index></name><operator>.</operator><name>n</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nToken</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>totalSize</name> <operator>+=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>z</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>azToken</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>( <argument><expr><name>nToken</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>totalSize</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>zCopy</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>azToken</name><index>[<expr><name>nToken</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nToken</name><operator>--</operator></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nToken</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>azToken</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>zCopy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>aToken</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zCopy</name></expr></argument>, <argument><expr><name><name>aToken</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>zCopy</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>zCopy</name> <operator>+=</operator> <name>n</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>azToken</name><index>[<expr><name>nToken</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pnToken</name> <operator>=</operator> <name>nToken</name></expr>;</expr_stmt>
  <return>return <expr><name>azToken</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Convert an SQL-style quoted string into a normal string by removing
** the quote characters.  The conversion is done in-place.  If the
** input does not begin with a quote character, then this routine
** is a no-op.
**
** Examples:
**
**     "abc"   becomes   abc
**     'xyz'   becomes   xyz
**     [pqr]   becomes   pqr
**     `mno`   becomes   mno
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dequoteString</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>quote</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>z</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>quote</name> <operator>=</operator> <name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>quote</name></expr> )</condition><block>{<block_content>
    <case>case <expr><literal type="char">'\''</literal></expr>:</case>  <break>break;</break>
    <case>case <expr><literal type="char">'"'</literal></expr>:</case>   <break>break;</break>
    <case>case <expr><literal type="char">'`'</literal></expr>:</case>   <break>break;</break>                <comment type="block">/* For MySQL compatibility */</comment>
    <case>case <expr><literal type="char">'['</literal></expr>:</case>   <expr_stmt><expr><name>quote</name> <operator>=</operator> <literal type="char">']'</literal></expr>;</expr_stmt>  <break>break;</break>  <comment type="block">/* For MS SqlServer compatibility */</comment>
    <default>default:</default>    <return>return;</return>
  </block_content>}</block></switch>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><name>quote</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>z</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><name>quote</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>quote</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>z</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** The input azIn is a NULL-terminated list of tokens.  Remove the first
** token and all punctuation tokens.  Remove the quotes from
** around string literal tokens.
**
** Example:
**
**     input:      tokenize chinese ( 'simplifed' , 'mixed' )
**     output:     chinese simplifed mixed
**
** Another example:
**
**     input:      delimiters ( '[' , ']' , '...' )
**     output:     [ ] ...
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>tokenListToIdList</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azIn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>azIn</name></expr> )</condition><block>{<block_content>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name><operator>=</operator><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name><name>azIn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><call><name>safe_isalnum</name><argument_list>(<argument><expr><name><name>azIn</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>azIn</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>dequoteString</name><argument_list>(<argument><expr><name><name>azIn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name><name>azIn</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>azIn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>azIn</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Find the first alphanumeric token in the string zIn.  Null-terminate
** this token.  Remove any quotation marks.  And return a pointer to
** the result.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>firstToken</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zIn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzTail</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>ttype</name></decl>;</decl_stmt>
  <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getToken</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>ttype</name><operator>==</operator><name>TOKEN_SPACE</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zIn</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
    </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>ttype</name><operator>==</operator><name>TOKEN_EOF</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>pzTail</name> <operator>=</operator> <name>zIn</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name><name>zIn</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pzTail</name> <operator>=</operator> <operator>&amp;</operator><name><name>zIn</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dequoteString</name><argument_list>(<argument><expr><name>zIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>zIn</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <comment type="block">/*NOTREACHED*/</comment>
</block_content>}</block></function>

<comment type="block">/* Return true if...
**
**   *  s begins with the string t, ignoring case
**   *  s is longer than t
**   *  The first character of s beyond t is not a alphanumeric
** 
** Ignore leading space in *s.
**
** To put it another way, return true if the first token of
** s[] is t[].
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>startsWith</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><call><name>safe_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <while>while<condition>( <expr><operator>*</operator><name>t</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>safe_tolower</name><argument_list>(<argument><expr><operator>*</operator><name>s</name><operator>++</operator></expr></argument>)</argument_list></call><operator>!=</operator><call><name>safe_tolower</name><argument_list>(<argument><expr><operator>*</operator><name>t</name><operator>++</operator></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><operator>*</operator><name>s</name><operator>!=</operator><literal type="char">'_'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>safe_isalnum</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** An instance of this structure defines the "spec" of a
** full text index.  This structure is populated by parseSpec
** and use by fulltextConnect and fulltextCreate.
*/</comment>
<typedef>typedef <type><struct>struct <name>TableSpec</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDb</name></decl>;</decl_stmt>         <comment type="block">/* Logical database name */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>       <comment type="block">/* Name of the full-text index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nColumn</name></decl>;</decl_stmt>             <comment type="block">/* Number of columns to be indexed */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azColumn</name></decl>;</decl_stmt>         <comment type="block">/* Original names of columns to be indexed */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azContentColumn</name></decl>;</decl_stmt>  <comment type="block">/* Column names for %_content */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azTokenizer</name></decl>;</decl_stmt>      <comment type="block">/* Name of tokenizer and its arguments */</comment>
}</block></struct></type> <name>TableSpec</name>;</typedef>

<comment type="block">/*
** Reclaim all of the memory used by a TableSpec
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>clearTableSpec</name><parameter_list>(<parameter><decl><type><name>TableSpec</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>azColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>azContentColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>azTokenizer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Parse a CREATE VIRTUAL TABLE statement, which looks like this:
 *
 * CREATE VIRTUAL TABLE email
 *        USING fts1(subject, body, tokenize mytokenizer(myarg))
 *
 * We return parsed information in a TableSpec structure.
 * 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>parseSpec</name><parameter_list>(<parameter><decl><type><name>TableSpec</name> <modifier>*</modifier></type><name>pSpec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
                     <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>z</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zDummy</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>azArg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTokenizer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* argv[] entry describing the tokenizer */</comment>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>&gt;=</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Current interface:
  ** argv[0] - module name
  ** argv[1] - database name
  ** argv[2] - table name
  ** argv[3..] - columns, optionally followed by tokenizer specification
  **             and snippet delimiters specification.
  */</comment>

  <comment type="block">/* Make a copy of the complete argv[][] array in a single allocation.
  ** The argv[][] array is read-only and transient.  We can write to the
  ** copy in order to modify things and the copy is persistent.
  */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pSpec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pSpec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>azArg</name> <operator>=</operator> <call><name>malloc</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>argc</name> <operator>+</operator> <name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>azArg</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>azArg</name><index>[<expr><name>argc</name></expr>]</index></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>z</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></for>

  <comment type="block">/* Identify the column names and the tokenizer and delimiter arguments
  ** in the argv[][] array.
  */</comment>
  <expr_stmt><expr><name><name>pSpec</name><operator>-&gt;</operator><name>zDb</name></name> <operator>=</operator> <name><name>azArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSpec</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <name><name>azArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSpec</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pSpec</name><operator>-&gt;</operator><name>azColumn</name></name> <operator>=</operator> <name>azArg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>zTokenizer</name> <operator>=</operator> <literal type="string">"tokenize simple"</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">3</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>startsWith</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="string">"tokenize"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zTokenizer</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>azArg</name><index>[<expr><name><name>pSpec</name><operator>-&gt;</operator><name>nColumn</name></name></expr>]</index></name> <operator>=</operator> <call><name>firstToken</name><argument_list>(<argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zDummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pSpec</name><operator>-&gt;</operator><name>nColumn</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if<condition>( <expr><name><name>pSpec</name><operator>-&gt;</operator><name>nColumn</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>azArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"content"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pSpec</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/*
  ** Construct the list of content column names.
  **
  ** Each content column name will be of the form cNNAAAA
  ** where NN is the column number and AAAA is the sanitized
  ** column name.  "sanitized" means that special characters are
  ** converted to "_".  The cNN prefix guarantees that all column
  ** names are unique.
  **
  ** The AAAA suffix is not strictly necessary.  It is included
  ** for the convenience of people who might examine the generated
  ** %_content table and wonder what the columns are used for.
  */</comment>
  <expr_stmt><expr><name><name>pSpec</name><operator>-&gt;</operator><name>azContentColumn</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>( <argument><expr><name><name>pSpec</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pSpec</name><operator>-&gt;</operator><name>azContentColumn</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>clearTableSpec</name><argument_list>(<argument><expr><name>pSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pSpec</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pSpec</name><operator>-&gt;</operator><name>azContentColumn</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"c%d%s"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>azArg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>pSpec</name><operator>-&gt;</operator><name>azContentColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr> ;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>safe_isalnum</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <comment type="block">/*
  ** Parse the tokenizer specification string.
  */</comment>
  <expr_stmt><expr><name><name>pSpec</name><operator>-&gt;</operator><name>azTokenizer</name></name> <operator>=</operator> <call><name>tokenizeString</name><argument_list>(<argument><expr><name>zTokenizer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>tokenListToIdList</name><argument_list>(<argument><expr><name><name>pSpec</name><operator>-&gt;</operator><name>azTokenizer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Generate a CREATE TABLE statement that describes the schema of
** the virtual table.  Return a pointer to this schema string.
**
** Space is obtained from sqlite3_mprintf() and should be freed
** using sqlite3_free().
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>fulltextSchema</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>nColumn</name></decl></parameter>,                  <comment type="block">/* Number of columns */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type> <name>azColumn</name></decl></parameter>,  <comment type="block">/* List of columns */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTableName</name></decl></parameter>        <comment type="block">/* Name of the table */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSchema</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zNext</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zSep</name> <init>= <expr><literal type="string">"("</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>zSchema</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"CREATE TABLE x"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nColumn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>zNext</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s%s%Q"</literal></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>, <argument><expr><name>zSep</name></expr></argument>, <argument><expr><name><name>azColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSchema</name> <operator>=</operator> <name>zNext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zSep</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>zNext</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"%s,%Q)"</literal></expr></argument>, <argument><expr><name>zSchema</name></expr></argument>, <argument><expr><name>zTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSchema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>zNext</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Build a new sqlite3_vtab structure that will describe the
** fulltext index defined by spec.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>constructVtab</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,              <comment type="block">/* The SQLite database connection */</comment>
  <parameter><decl><type><name>TableSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>,          <comment type="block">/* Parsed spec information from parseSpec() */</comment>
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVTab</name></decl></parameter>,    <comment type="block">/* Write the resulting vtab structure here */</comment>
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>              <comment type="block">/* Write any error message here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_tokenizer_module</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schema</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fulltext_vtab</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>v</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>v</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* sqlite will initialize v-&gt;base */</comment>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>zDb</name></name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>zDb</name></name></expr>;</expr_stmt>       <comment type="block">/* Freed when azColumn is freed */</comment>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>zName</name></name></expr>;</expr_stmt>   <comment type="block">/* Freed when azColumn is freed */</comment>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>azContentColumn</name></name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>azContentColumn</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>azContentColumn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>azColumn</name></name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>azColumn</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>azColumn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>spec</name><operator>-&gt;</operator><name>azTokenizer</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* TODO(shess) For now, add new tokenizers as else if clauses. */</comment>
  <if_stmt><if>if<condition>( <expr><name><name>spec</name><operator>-&gt;</operator><name>azTokenizer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal> <operator>||</operator> <call><name>startsWith</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>azTokenizer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"simple"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Fts1SimpleTokenizerModule</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>startsWith</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>azTokenizer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"porter"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3Fts1PorterTokenizerModule</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pzErr</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"unknown tokenizer: %s"</literal></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>azTokenizer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>err</name>;</goto>
  </block_content>}</block></else></if_stmt>
  <for>for<control>(<init><expr><name>n</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>spec</name><operator>-&gt;</operator><name>azTokenizer</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <if_stmt><if>if<condition>( <expr><name>n</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>m</name><operator>-&gt;</operator><name>xCreate</name></name><argument_list>(<argument><expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><specifier>const</specifier><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>spec</name><operator>-&gt;</operator><name>azTokenizer</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>m</name><operator>-&gt;</operator><name>xCreate</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name></name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>

  <comment type="block">/* TODO: verify the existence of backing tables foo_content, foo_term */</comment>

  <expr_stmt><expr><name>schema</name> <operator>=</operator> <call><name>fulltextSchema</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><specifier>const</specifier><operator>*</operator><operator>)</operator><name><name>v</name><operator>-&gt;</operator><name>azColumn</name></name></expr></argument>,
                          <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppVTab</name> <operator>=</operator> <operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS1 Connect %p\n"</literal><operator>,</operator> <name>v</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>

<label><name>err</name>:</label>
  <expr_stmt><expr><call><name>fulltext_vtab_destroy</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVTab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>TableSpec</name></type> <name>spec</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>parseSpec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spec</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>constructVtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>spec</name></expr></argument>, <argument><expr><name>ppVTab</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>clearTableSpec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

  <comment type="block">/* The %_content table holds the text of each document, with
  ** the rowid used as the docid.
  **
  ** The %_term table maps each term to a document list blob
  ** containing elements sorted by ascending docid, each element
  ** encoded as:
  **
  **   docid varint-encoded
  **   token elements:
  **     position+1 varint-encoded as delta from previous position
  **     start offset varint-encoded as delta from previous start offset
  **     end offset varint-encoded as delta from start offset
  **
  ** The sentinel position of 0 indicates the end of the token list.
  **
  ** Additionally, doclist blobs are chunked into multiple segments,
  ** using segment to order the segments.  New elements are added to
  ** the segment at segment 0, until it exceeds CHUNK_MAX.  Then
  ** segment 0 is deleted, and the doclist is inserted at segment 1.
  ** If there is already a doclist at segment 1, the segment 0 doclist
  ** is merged with it, the segment 1 doclist is deleted, and the
  ** merged doclist is inserted at segment 2, repeating those
  ** operations until an insert succeeds.
  **
  ** Since this structure doesn't allow us to update elements in place
  ** in case of deletion or update, these are simply written to
  ** segment 0 (with an empty token list in case of deletion), with
  ** docListAccumulate() taking care to retain lower-segment
  ** information in preference to higher-segment information.
  */</comment>
  <comment type="block">/* TODO(shess) Provide a VACUUM type operation which both removes
  ** deleted elements which are no longer necessary, and duplicated
  ** elements.  I suspect this will probably not be necessary in
  ** practice, though.
  */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextCreate</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
                          <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>argv</name></decl></parameter>,
                          <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVTab</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TableSpec</name></type> <name>spec</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StringBuffer</name></type> <name>schema</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS1 Create\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>parseSpec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spec</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>initStringBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE %_content("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>appendList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema</name></expr></argument>, <argument><expr><name><name>spec</name><operator>.</operator><name>nColumn</name></name></expr></argument>, <argument><expr><name><name>spec</name><operator>.</operator><name>azContentColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>schema</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>spec</name><operator>.</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>spec</name><operator>.</operator><name>zName</name></name></expr></argument>, <argument><expr><name><name>schema</name><operator>.</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>schema</name><operator>.</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>spec</name><operator>.</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>spec</name><operator>.</operator><name>zName</name></name></expr></argument>,
    <argument><expr><literal type="string">"create table %_term(term text, segment integer, doclist blob, "</literal>
                        <literal type="string">"primary key(term, segment));"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>constructVtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>spec</name></expr></argument>, <argument><expr><name>ppVTab</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>out</name>:</label>
  <expr_stmt><expr><call><name>clearTableSpec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Decide how to handle an SQL query. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextBestIndex</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS1 BestIndex\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pConstraint</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pConstraint</name> <operator>=</operator> <operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>usable</name></name></expr> )</condition> <block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
          <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_EQ</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>QUERY_ROWID</name></expr>;</expr_stmt>      <comment type="block">/* lookup by rowid */</comment>
        <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS1 QUERY_ROWID\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator>
                 <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_MATCH</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* full-text search */</comment>
        <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>QUERY_FULLTEXT</name> <operator>+</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS1 QUERY_FULLTEXT %d\n"</literal><operator>,</operator> <name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else<block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></else></if_stmt>

      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

      <comment type="block">/* An arbitrary value for now.
       * TODO: Perhaps rowid matches should be considered cheaper than
       * full-text searches. */</comment>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>   

      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>QUERY_GENERIC</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS1 Disconnect %p\n"</literal><operator>,</operator> <name>pVTab</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fulltext_vtab_destroy</name><argument_list>(<argument><expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator><name>pVTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextDestroy</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator><name>pVTab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS1 Destroy %p\n"</literal><operator>,</operator> <name>pVTab</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_exec</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
                <argument><expr><literal type="string">"drop table if exists %_content;"</literal>
                <literal type="string">"drop table if exists %_term;"</literal></expr></argument>
                )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>fulltext_vtab_destroy</name><argument_list>(<argument><expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator><name>pVTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <call><name>calloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fulltext_cursor</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* sqlite will initialize c-&gt;base */</comment>
  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS1 Open %p: %p\n"</literal><operator>,</operator> <name>pVTab</name><operator>,</operator> <name>c</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Free all of the dynamically allocated memory held by *q
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>queryClear</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>q</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>q</name><operator>-&gt;</operator><name>nTerms</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>pTerms</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>pTerms</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>q</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Free all of the dynamically allocated memory held by the
** Snippet
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>snippetClear</name><parameter_list>(<parameter><decl><type><name>Snippet</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aMatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>zSnippet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
** Append a single entry to the p-&gt;aMatch[] log.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>snippetAppendMatch</name><parameter_list>(
  <parameter><decl><type><name>Snippet</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,               <comment type="block">/* Append the entry to this snippet */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iTerm</name></decl></parameter>,      <comment type="block">/* The column and query term */</comment>
  <parameter><decl><type><name>int</name></type> <name>iStart</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>     <comment type="block">/* Offset and size of the match */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>snippetMatch</name></name> <modifier>*</modifier></type><name>pMatch</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>nMatch</name></name><operator>+</operator><literal type="number">1</literal><operator>&gt;=</operator><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>aMatch</name></name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aMatch</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>aMatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>aMatch</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nMatch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nAlloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nMatch</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>pMatch</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMatch</name><operator>-&gt;</operator><name>iCol</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMatch</name><operator>-&gt;</operator><name>iTerm</name></name> <operator>=</operator> <name>iTerm</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMatch</name><operator>-&gt;</operator><name>iStart</name></name> <operator>=</operator> <name>iStart</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pMatch</name><operator>-&gt;</operator><name>nByte</name></name> <operator>=</operator> <name>nByte</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Sizing information for the circular buffer used in snippetOffsetsOfColumn()
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTS1_ROTOR_SZ</name></cpp:macro>   <cpp:value>(32)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTS1_ROTOR_MASK</name></cpp:macro> <cpp:value>(FTS1_ROTOR_SZ-1)</cpp:value></cpp:define>

<comment type="block">/*
** Add entries to pSnippet-&gt;aMatch[] for every match that occurs against
** document zDoc[0..nDoc-1] which is stored in column iColumn.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>snippetOffsetsOfColumn</name><parameter_list>(
  <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>pQuery</name></decl></parameter>,
  <parameter><decl><type><name>Snippet</name> <modifier>*</modifier></type><name>pSnippet</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDoc</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nDoc</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_tokenizer_module</name> <modifier>*</modifier></type><name>pTModule</name></decl>;</decl_stmt>  <comment type="block">/* The tokenizer module */</comment>
  <decl_stmt><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name></decl>;</decl_stmt>             <comment type="block">/* The specific tokenizer */</comment>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pTCursor</name></decl>;</decl_stmt>        <comment type="block">/* Tokenizer cursor */</comment>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl>;</decl_stmt>                <comment type="block">/* The full text index */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nColumn</name></decl>;</decl_stmt>                         <comment type="block">/* Number of columns in the index */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>QueryTerm</name> <modifier>*</modifier></type><name>aTerm</name></decl>;</decl_stmt>              <comment type="block">/* Query string terms */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name></decl>;</decl_stmt>                           <comment type="block">/* Number of query string terms */</comment>  
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>                            <comment type="block">/* Loop counters */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>                              <comment type="block">/* Return code */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>match</name></decl>, <decl><type ref="prev"/><name>prevMatch</name></decl>;</decl_stmt>       <comment type="block">/* Phrase search bitmasks */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zToken</name></decl>;</decl_stmt>                  <comment type="block">/* Next token from the tokenizer */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nToken</name></decl>;</decl_stmt>                          <comment type="block">/* Size of zToken */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iBegin</name></decl>, <decl><type ref="prev"/><name>iEnd</name></decl>, <decl><type ref="prev"/><name>iPos</name></decl>;</decl_stmt>              <comment type="block">/* Offsets of beginning and end */</comment>

  <comment type="block">/* The following variables keep a circular buffer of the last
  ** few tokens */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>iRotor</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>             <comment type="block">/* Index of current token */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>iRotorBegin</name><index>[<expr><name>FTS1_ROTOR_SZ</name></expr>]</index></name></decl>;</decl_stmt>      <comment type="block">/* Beginning offset of token */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>iRotorLen</name><index>[<expr><name>FTS1_ROTOR_SZ</name></expr>]</index></name></decl>;</decl_stmt>        <comment type="block">/* Length of token */</comment>

  <expr_stmt><expr><name>pVtab</name> <operator>=</operator> <name><name>pQuery</name><operator>-&gt;</operator><name>pFts</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nColumn</name> <operator>=</operator> <name><name>pVtab</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTokenizer</name> <operator>=</operator> <name><name>pVtab</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pTModule</name> <operator>=</operator> <name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pTModule</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pTokenizer</name></expr></argument>, <argument><expr><name>zDoc</name></expr></argument>, <argument><expr><name>nDoc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pTCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pTCursor</name><operator>-&gt;</operator><name>pTokenizer</name></name> <operator>=</operator> <name>pTokenizer</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>aTerm</name> <operator>=</operator> <name><name>pQuery</name><operator>-&gt;</operator><name>pTerms</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nTerm</name> <operator>=</operator> <name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nTerm</name><operator>&gt;=</operator><name>FTS1_ROTOR_SZ</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>nTerm</name> <operator>=</operator> <name>FTS1_ROTOR_SZ</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>prevMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pTModule</name><operator>-&gt;</operator><name>xNext</name></name><argument_list>(<argument><expr><name>pTCursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iBegin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>iRotorBegin</name><index>[<expr><name>iRotor</name><operator>&amp;</operator><name>FTS1_ROTOR_MASK</name></expr>]</index></name> <operator>=</operator> <name>iBegin</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>iRotorLen</name><index>[<expr><name>iRotor</name><operator>&amp;</operator><name>FTS1_ROTOR_MASK</name></expr>]</index></name> <operator>=</operator> <name>iEnd</name><operator>-</operator><name>iBegin</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>match</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nTerm</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iColumn</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>&gt;=</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>iCol</name><operator>&lt;</operator><name>nColumn</name> <operator>&amp;&amp;</operator> <name>iCol</name><operator>!=</operator><name>iColumn</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nTerm</name><operator>!=</operator><name>nToken</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pTerm</name></expr></argument>, <argument><expr><name>zToken</name></expr></argument>, <argument><expr><name>nToken</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iPhrase</name><operator>&gt;</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>prevMatch</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>i</name><operator>)</operator><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>match</name> <operator>|=</operator> <literal type="number">1</literal><operator>&lt;&lt;</operator><name>i</name></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><name>nTerm</name><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name><name>aTerm</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iPhrase</name><operator>==</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iPhrase</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>k</name> <init>= <expr><operator>(</operator><name>iRotor</name><operator>-</operator><name>j</name><operator>)</operator> <operator>&amp;</operator> <name>FTS1_ROTOR_MASK</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>snippetAppendMatch</name><argument_list>(<argument><expr><name>pSnippet</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name>i</name><operator>-</operator><name>j</name></expr></argument>,
                <argument><expr><name><name>iRotorBegin</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>iRotorLen</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>prevMatch</name> <operator>=</operator> <name>match</name><operator>&lt;&lt;</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>iRotor</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name><name>pTModule</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pTCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
</block_content>}</block></function>


<comment type="block">/*
** Compute all offsets for the current row of the query.  
** If the offsets have already been computed, this routine is a no-op.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>snippetAllOffsets</name><parameter_list>(<parameter><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nColumn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iColumn</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iFirst</name></decl>, <decl><type ref="prev"/><name>iLast</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>pFts</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>nMatch</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>q</name><operator>.</operator><name>nTerms</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pFts</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>q</name><operator>.</operator><name>pFts</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nColumn</name> <operator>=</operator> <name><name>pFts</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iColumn</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>iCursorType</name></name> <operator>-</operator> <name>QUERY_FULLTEXT</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>&lt;</operator><literal type="number">0</literal> <operator>||</operator> <name>iColumn</name><operator>&gt;=</operator><name>nColumn</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>iFirst</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>iLast</name> <operator>=</operator> <name>nColumn</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><name>iFirst</name> <operator>=</operator> <name>iColumn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>iLast</name> <operator>=</operator> <name>iColumn</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>iFirst</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name>iLast</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDoc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nDoc</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>zDoc</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nDoc</name> <operator>=</operator> <call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>snippetOffsetsOfColumn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>q</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>snippet</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>zDoc</name></expr></argument>, <argument><expr><name>nDoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
** Convert the information in the aMatch[] array of the snippet
** into the string zOffset[0..nOffset-1].
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>snippetOffsetText</name><parameter_list>(<parameter><decl><type><name>Snippet</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StringBuffer</name></type> <name>sb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>zBuf</name><index>[<expr><literal type="number">200</literal></expr>]</index></name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>zOffset</name></name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>initStringBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>p</name><operator>-&gt;</operator><name>nMatch</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>snippetMatch</name></name> <modifier>*</modifier></type><name>pMatch</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>zBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zBuf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zBuf</name><index>[<expr><name>cnt</name><operator>&gt;</operator><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%d %d %d %d"</literal></expr></argument>,
        <argument><expr><name><name>pMatch</name><operator>-&gt;</operator><name>iCol</name></name></expr></argument>, <argument><expr><name><name>pMatch</name><operator>-&gt;</operator><name>iTerm</name></name></expr></argument>, <argument><expr><name><name>pMatch</name><operator>-&gt;</operator><name>iStart</name></name></expr></argument>, <argument><expr><name><name>pMatch</name><operator>-&gt;</operator><name>nByte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>zBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>zOffset</name></name> <operator>=</operator> <name><name>sb</name><operator>.</operator><name>s</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>nOffset</name></name> <operator>=</operator> <name><name>sb</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** zDoc[0..nDoc-1] is phrase of text.  aMatch[0..nMatch-1] are a set
** of matching words some of which might be in zDoc.  zDoc is column
** number iCol.
**
** iBreak is suggested spot in zDoc where we could begin or end an
** excerpt.  Return a value similar to iBreak but possibly adjusted
** to be a little left or right so that the break point is better.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>wordBoundary</name><parameter_list>(
  <parameter><decl><type><name>int</name></type> <name>iBreak</name></decl></parameter>,                   <comment type="block">/* The suggested break point */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDoc</name></decl></parameter>,             <comment type="block">/* Document text */</comment>
  <parameter><decl><type><name>int</name></type> <name>nDoc</name></decl></parameter>,                     <comment type="block">/* Number of bytes in zDoc[] */</comment>
  <parameter><decl><type><name><name>struct</name> <name>snippetMatch</name></name> <modifier>*</modifier></type><name>aMatch</name></decl></parameter>,  <comment type="block">/* Matching words */</comment>
  <parameter><decl><type><name>int</name></type> <name>nMatch</name></decl></parameter>,                   <comment type="block">/* Number of entries in aMatch[] */</comment>
  <parameter><decl><type><name>int</name></type> <name>iCol</name></decl></parameter>                      <comment type="block">/* The column number for zDoc[] */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>iBreak</name><operator>&lt;=</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>iBreak</name><operator>&gt;=</operator><name>nDoc</name><operator>-</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><name>nDoc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nMatch</name> <operator>&amp;&amp;</operator> <name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCol</name><operator>&lt;</operator><name>iCol</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content/>}</block></for>
  <while>while<condition>( <expr><name>i</name><operator>&lt;</operator><name>nMatch</name> <operator>&amp;&amp;</operator> <name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iStart</name><operator>+</operator><name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nByte</name><operator>&lt;</operator><name>iBreak</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name>nMatch</name></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iStart</name><operator>&lt;</operator><name>iBreak</name><operator>+</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iStart</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>aMatch</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iStart</name><operator>+</operator><name><name>aMatch</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>nByte</name><operator>&gt;=</operator><name>iBreak</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name><name>aMatch</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iStart</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><literal type="number">10</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>safe_isspace</name><argument_list>(<argument><expr><name><name>zDoc</name><index>[<expr><name>iBreak</name><operator>-</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><name>iBreak</name> <operator>-</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>safe_isspace</name><argument_list>(<argument><expr><name><name>zDoc</name><index>[<expr><name>iBreak</name><operator>+</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <return>return <expr><name>iBreak</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>iBreak</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** If the StringBuffer does not end in white space, add a single
** space character to the end.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>appendWhiteSpace</name><parameter_list>(<parameter><decl><type><name>StringBuffer</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>len</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>safe_isspace</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>s</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>len</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Remove white space from teh end of the StringBuffer
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>trimWhiteSpace</name><parameter_list>(<parameter><decl><type><name>StringBuffer</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><name><name>p</name><operator>-&gt;</operator><name>len</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>safe_isspace</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>s</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>len</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>len</name></name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>



<comment type="block">/*
** Allowed values for Snippet.aMatch[].snStatus
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SNIPPET_IGNORE</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>   <comment type="block">/* It is ok to omit this match from the snippet */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SNIPPET_DESIRED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>   <comment type="block">/* We want to include this match in the snippet */</comment>

<comment type="block">/*
** Generate the text of a snippet.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>snippetText</name><parameter_list>(
  <parameter><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>,   <comment type="block">/* The cursor we need the snippet for */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStartMark</name></decl></parameter>,     <comment type="block">/* Markup to appear before each match */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEndMark</name></decl></parameter>,       <comment type="block">/* Markup to appear after each match */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEllipsis</name></decl></parameter>       <comment type="block">/* Ellipsis mark */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>snippetMatch</name></name> <modifier>*</modifier></type><name>aMatch</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nMatch</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDesired</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StringBuffer</name></type> <name>sb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tailCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tailOffset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nDoc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zDoc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iStart</name></decl>, <decl><type ref="prev"/><name>iEnd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>tailEllipsis</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iMatch</name></decl>;</decl_stmt>
  

  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>zSnippet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>zSnippet</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>aMatch</name> <operator>=</operator> <name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>aMatch</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>nMatch</name> <operator>=</operator> <name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>nMatch</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>initStringBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nMatch</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>snStatus</name> <operator>=</operator> <name>SNIPPET_IGNORE</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>nDesired</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pCursor</name><operator>-&gt;</operator><name>q</name><operator>.</operator><name>nTerms</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <for>for<control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nMatch</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><name><name>aMatch</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>iTerm</name><operator>==</operator><name>i</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name><name>aMatch</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>snStatus</name> <operator>=</operator> <name>SNIPPET_DESIRED</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nDesired</name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

  <expr_stmt><expr><name>iMatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>tailCol</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>tailOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>i</name><argument_list type="generic">&lt;<argument><expr><name>nMatch</name> <operator>&amp;&amp;</operator> <name>nDesired</name></expr></argument>&gt;</argument_list></name><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>snStatus</name><operator>!=</operator><name>SNIPPET_DESIRED</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nDesired</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>iCol</name> <operator>=</operator> <name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iCol</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zDoc</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name><name>pCursor</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>iCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nDoc</name> <operator>=</operator> <call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name><name>pCursor</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>iCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>iStart</name> <operator>=</operator> <name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iStart</name> <operator>-</operator> <literal type="number">40</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>iStart</name> <operator>=</operator> <call><name>wordBoundary</name><argument_list>(<argument><expr><name>iStart</name></expr></argument>, <argument><expr><name>zDoc</name></expr></argument>, <argument><expr><name>nDoc</name></expr></argument>, <argument><expr><name>aMatch</name></expr></argument>, <argument><expr><name>nMatch</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iStart</name><operator>&lt;=</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iStart</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iCol</name><operator>==</operator><name>tailCol</name> <operator>&amp;&amp;</operator> <name>iStart</name><operator>&lt;=</operator><name>tailOffset</name><operator>+</operator><literal type="number">20</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iStart</name> <operator>=</operator> <name>tailOffset</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>(</operator><name>iCol</name><operator>!=</operator><name>tailCol</name> <operator>&amp;&amp;</operator> <name>tailCol</name><operator>&gt;=</operator><literal type="number">0</literal><operator>)</operator> <operator>||</operator> <name>iStart</name><operator>!=</operator><name>tailOffset</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>trimWhiteSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>appendWhiteSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>zEllipsis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>appendWhiteSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iEnd</name> <operator>=</operator> <name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iStart</name> <operator>+</operator> <name><name>aMatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nByte</name> <operator>+</operator> <literal type="number">40</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>iEnd</name> <operator>=</operator> <call><name>wordBoundary</name><argument_list>(<argument><expr><name>iEnd</name></expr></argument>, <argument><expr><name>zDoc</name></expr></argument>, <argument><expr><name>nDoc</name></expr></argument>, <argument><expr><name>aMatch</name></expr></argument>, <argument><expr><name>nMatch</name></expr></argument>, <argument><expr><name>iCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iEnd</name><operator>&gt;=</operator><name>nDoc</name><operator>-</operator><literal type="number">10</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>iEnd</name> <operator>=</operator> <name>nDoc</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>tailEllipsis</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>tailEllipsis</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <while>while<condition>( <expr><name>iMatch</name><operator>&lt;</operator><name>nMatch</name> <operator>&amp;&amp;</operator> <name><name>aMatch</name><index>[<expr><name>iMatch</name></expr>]</index></name><operator>.</operator><name>iCol</name><operator>&lt;</operator><name>iCol</name></expr> )</condition><block>{<block_content> <expr_stmt><expr><name>iMatch</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
    <while>while<condition>( <expr><name>iStart</name><operator>&lt;</operator><name>iEnd</name></expr> )</condition><block>{<block_content>
      <while>while<condition>( <expr><name>iMatch</name><operator>&lt;</operator><name>nMatch</name> <operator>&amp;&amp;</operator> <name><name>aMatch</name><index>[<expr><name>iMatch</name></expr>]</index></name><operator>.</operator><name>iStart</name><operator>&lt;</operator><name>iStart</name>
             <operator>&amp;&amp;</operator> <name><name>aMatch</name><index>[<expr><name>iMatch</name></expr>]</index></name><operator>.</operator><name>iCol</name><operator>&lt;=</operator><name>iCol</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>iMatch</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><name>iMatch</name><operator>&lt;</operator><name>nMatch</name> <operator>&amp;&amp;</operator> <name><name>aMatch</name><index>[<expr><name>iMatch</name></expr>]</index></name><operator>.</operator><name>iStart</name><operator>&lt;</operator><name>iEnd</name>
             <operator>&amp;&amp;</operator> <name><name>aMatch</name><index>[<expr><name>iMatch</name></expr>]</index></name><operator>.</operator><name>iCol</name><operator>==</operator><name>iCol</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>nappend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zDoc</name><index>[<expr><name>iStart</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>aMatch</name><index>[<expr><name>iMatch</name></expr>]</index></name><operator>.</operator><name>iStart</name> <operator>-</operator> <name>iStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iStart</name> <operator>=</operator> <name><name>aMatch</name><index>[<expr><name>iMatch</name></expr>]</index></name><operator>.</operator><name>iStart</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>zStartMark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>nappend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zDoc</name><index>[<expr><name>iStart</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>aMatch</name><index>[<expr><name>iMatch</name></expr>]</index></name><operator>.</operator><name>nByte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>zEndMark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iStart</name> <operator>+=</operator> <name><name>aMatch</name><index>[<expr><name>iMatch</name></expr>]</index></name><operator>.</operator><name>nByte</name></expr>;</expr_stmt>
        <for>for<control>(<init><expr><name>j</name><operator>=</operator><name>iMatch</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>nMatch</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
          <if_stmt><if>if<condition>( <expr><name><name>aMatch</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>iTerm</name><operator>==</operator><name><name>aMatch</name><index>[<expr><name>iMatch</name></expr>]</index></name><operator>.</operator><name>iTerm</name>
              <operator>&amp;&amp;</operator> <name><name>aMatch</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>snStatus</name><operator>==</operator><name>SNIPPET_DESIRED</name></expr> )</condition><block>{<block_content>
            <expr_stmt><expr><name>nDesired</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>aMatch</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>snStatus</name> <operator>=</operator> <name>SNIPPET_IGNORE</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if><else>else<block>{<block_content>
        <expr_stmt><expr><call><name>nappend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zDoc</name><index>[<expr><name>iStart</name></expr>]</index></name></expr></argument>, <argument><expr><name>iEnd</name> <operator>-</operator> <name>iStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>iStart</name> <operator>=</operator> <name>iEnd</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name>tailCol</name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tailOffset</name> <operator>=</operator> <name>iEnd</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>trimWhiteSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>tailEllipsis</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>appendWhiteSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>, <argument><expr><name>zEllipsis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>zSnippet</name></name> <operator>=</operator> <name><name>sb</name><operator>.</operator><name>s</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>nSnippet</name></name> <operator>=</operator> <name><name>sb</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>  
</block_content>}</block></function>


<comment type="block">/*
** Close the cursor.  For additional information see the documentation
** on the xClose method of the virtual table interface.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS1 Close %p\n"</literal><operator>,</operator> <name>c</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>queryClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>q</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>snippetClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>snippet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>c</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>pDoclist</name></name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>docListDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>pDoclist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS1 Next %p\n"</literal><operator>,</operator> <name>pCursor</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>snippetClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>snippet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>c</name><operator>-&gt;</operator><name>iCursorType</name></name> <operator>&lt;</operator> <name>QUERY_FULLTEXT</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* TODO(shess) Handle SQLITE_SCHEMA AND SQLITE_BUSY. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <case>case <expr><name>SQLITE_ROW</name></expr>:</case>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      <case>case <expr><name>SQLITE_DONE</name></expr>:</case>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      <default>default:</default>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></switch>
  </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* full-text query */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>iDocid</name> <operator>=</operator> <call><name>nextDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>iDocid</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* TODO(shess) Handle SQLITE_SCHEMA AND SQLITE_BUSY. */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>   <comment type="block">/* the case we expect */</comment>
      <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* an error occurred; abort */</comment>
    <return>return <expr><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> ?</condition><then> <expr><name>SQLITE_ERROR</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* Return a DocList corresponding to the query term *pTerm.  If *pTerm
** is the first term of a phrase query, go ahead and evaluate the phrase
** query and return the doclist for the entire phrase query.
**
** The result is stored in pTerm-&gt;doclist.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>docListOfTerm</name><parameter_list>(
  <parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,     <comment type="block">/* The full text index */</comment>
  <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>,          <comment type="block">/* column to restrict to.  No restrition if &gt;=nColumn */</comment>
  <parameter><decl><type><name>QueryTerm</name> <modifier>*</modifier></type><name>pQTerm</name></decl></parameter>,    <comment type="block">/* Term we are looking for, or 1st term of a phrase */</comment>
  <parameter><decl><type><name>DocList</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppResult</name></decl></parameter>    <comment type="block">/* Write the result here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pLeft</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pRight</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNew</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <call><name>docListNew</name><argument_list>(<argument><expr><name>DL_POSITIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>term_select_all</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name><name>pQTerm</name><operator>-&gt;</operator><name>pTerm</name></name></expr></argument>, <argument><expr><name><name>pQTerm</name><operator>-&gt;</operator><name>nTerm</name></name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>docListDelete</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;=</operator><name><name>pQTerm</name><operator>-&gt;</operator><name>nPhrase</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>pRight</name> <operator>=</operator> <call><name>docListNew</name><argument_list>(<argument><expr><name>DL_POSITIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>term_select_all</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name><name>pQTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pTerm</name></expr></argument>, <argument><expr><name><name>pQTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nTerm</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>docListDelete</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>docListNew</name><argument_list>(<argument><expr><ternary><condition><expr><name>i</name><operator>&lt;</operator><name><name>pQTerm</name><operator>-&gt;</operator><name>nPhrase</name></name></expr> ?</condition><then> <expr><name>DL_POSITIONS</name></expr> </then><else>: <expr><name>DL_DOCIDS</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>docListPhraseMerge</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>docListDelete</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>docListDelete</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>ppResult</name> <operator>=</operator> <name>pLeft</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add a new term pTerm[0..nTerm-1] to the query *q.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>queryAdd</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>q</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>QueryTerm</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>++</operator><name><name>q</name><operator>-&gt;</operator><name>nTerms</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>pTerms</name></name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>pTerms</name></name></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>nTerms</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>pTerms</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>q</name><operator>-&gt;</operator><name>pTerms</name></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>nTerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>t</name> <operator>=</operator> <operator>&amp;</operator><name><name>q</name><operator>-&gt;</operator><name>pTerms</name><index>[<expr><name><name>q</name><operator>-&gt;</operator><name>nTerms</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>pTerm</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>nTerm</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>pTerm</name></name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>pTerm</name><index>[<expr><name>nTerm</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>nTerm</name></name> <operator>=</operator> <name>nTerm</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>isOr</name></name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>nextIsOr</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>nextIsOr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>iColumn</name></name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>nextColumn</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>nextColumn</name></name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>dfltColumn</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Check to see if the string zToken[0...nToken-1] matches any
** column name in the virtual table.   If it does,
** return the zero-indexed column number.  If not, return -1.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>checkColumnSpecifier</name><parameter_list>(
  <parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>,    <comment type="block">/* The virtual table */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zToken</name></decl></parameter>,      <comment type="block">/* Text of the token */</comment>
  <parameter><decl><type><name>int</name></type> <name>nToken</name></decl></parameter>               <comment type="block">/* Number of characters in the token */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pVtab</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>pVtab</name><operator>-&gt;</operator><name>azColumn</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>zToken</name></expr></argument>, <argument><expr><name>nToken</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal>
        <operator>&amp;&amp;</operator> <name><name>pVtab</name><operator>-&gt;</operator><name>azColumn</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>nToken</name></expr>]</index></name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <return>return <expr><name>i</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Parse the text at pSegment[0..nSegment-1].  Add additional terms
** to the query being assemblied in pQuery.
**
** inPhrase is true if pSegment[0..nSegement-1] is contained within
** double-quotes.  If inPhrase is true, then the first term
** is marked with the number of terms in the phrase less one and
** OR and "-" syntax is ignored.  If inPhrase is false, then every
** term found is marked with nPhrase=0 and OR and "-" syntax is significant.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>tokenizeSegment</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name></decl></parameter>,          <comment type="block">/* The tokenizer to use */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pSegment</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nSegment</name></decl></parameter>,     <comment type="block">/* Query expression being parsed */</comment>
  <parameter><decl><type><name>int</name></type> <name>inPhrase</name></decl></parameter>,                           <comment type="block">/* True if within "..." */</comment>
  <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>pQuery</name></decl></parameter>                           <comment type="block">/* Append results here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sqlite3_tokenizer_module</name> <modifier>*</modifier></type><name>pModule</name> <init>= <expr><name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>firstIndex</name> <init>= <expr><name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTerm</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name><name>pModule</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pTokenizer</name></expr></argument>, <argument><expr><name>pSegment</name></expr></argument>, <argument><expr><name>nSegment</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCursor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pCursor</name><operator>-&gt;</operator><name>pTokenizer</name></name> <operator>=</operator> <name>pTokenizer</name></expr>;</expr_stmt>

  <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pToken</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nToken</name></decl>, <decl><type ref="prev"/><name>iBegin</name></decl>, <decl><type ref="prev"/><name>iEnd</name></decl>, <decl><type ref="prev"/><name>iPos</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xNext</name></name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>pToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nToken</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>iBegin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>inPhrase</name> <operator>&amp;&amp;</operator>
        <name><name>pSegment</name><index>[<expr><name>iEnd</name></expr>]</index></name><operator>==</operator><literal type="char">':'</literal> <operator>&amp;&amp;</operator>
         <operator>(</operator><name>iCol</name> <operator>=</operator> <call><name>checkColumnSpecifier</name><argument_list>(<argument><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pFts</name></name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>, <argument><expr><name>nToken</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>nextColumn</name></name> <operator>=</operator> <name>iCol</name></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>inPhrase</name> <operator>&amp;&amp;</operator> <name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nToken</name><operator>==</operator><literal type="number">2</literal>
         <operator>&amp;&amp;</operator> <name><name>pSegment</name><index>[<expr><name>iBegin</name></expr>]</index></name><operator>==</operator><literal type="char">'O'</literal> <operator>&amp;&amp;</operator> <name><name>pSegment</name><index>[<expr><name>iBegin</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'R'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>nextIsOr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>queryAdd</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>, <argument><expr><name>nToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name>inPhrase</name> <operator>&amp;&amp;</operator> <name>iBegin</name><operator>&gt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pSegment</name><index>[<expr><name>iBegin</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'-'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pTerms</name><index>[<expr><name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>isNot</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pTerms</name><index>[<expr><name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iPhrase</name> <operator>=</operator> <name>nTerm</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>inPhrase</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>nTerm</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <if_stmt><if>if<condition>( <expr><name>inPhrase</name> <operator>&amp;&amp;</operator> <name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name><operator>&gt;</operator><name>firstIndex</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pTerms</name><index>[<expr><name>firstIndex</name></expr>]</index></name><operator>.</operator><name>nPhrase</name> <operator>=</operator> <name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name> <operator>-</operator> <name>firstIndex</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><call><name><name>pModule</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parse a query string, yielding a Query object pQuery.
**
** The calling function will need to queryClear() to clean up
** the dynamically allocated memory held by pQuery.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>parseQuery</name><parameter_list>(
  <parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,        <comment type="block">/* The fulltext index */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zInput</name></decl></parameter>,      <comment type="block">/* Input text of the query string */</comment>
  <parameter><decl><type><name>int</name></type> <name>nInput</name></decl></parameter>,              <comment type="block">/* Size of the input text */</comment>
  <parameter><decl><type><name>int</name></type> <name>dfltColumn</name></decl></parameter>,          <comment type="block">/* Default column of the index to match against */</comment>
  <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>pQuery</name></decl></parameter>            <comment type="block">/* Write the parse results here. */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iInput</name></decl>, <decl><type ref="prev"/><name>inPhrase</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>zInput</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nInput</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>nInput</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nInput</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>zInput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pTerms</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>nextIsOr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>nextColumn</name></name> <operator>=</operator> <name>dfltColumn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>dfltColumn</name></name> <operator>=</operator> <name>dfltColumn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pFts</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>iInput</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iInput</name><operator>&lt;</operator><name>nInput</name></expr>;</condition> <incr><expr><operator>++</operator><name>iInput</name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><name>iInput</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>nInput</name> <operator>&amp;&amp;</operator> <name><name>zInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>!=</operator><literal type="char">'"'</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content/>}</block></for>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&gt;</operator><name>iInput</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>tokenizeSegment</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></argument>, <argument><expr><name>zInput</name><operator>+</operator><name>iInput</name></expr></argument>, <argument><expr><name>i</name><operator>-</operator><name>iInput</name></expr></argument>, <argument><expr><name>inPhrase</name></expr></argument>,
                       <argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iInput</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>i</name><operator>&lt;</operator><name>nInput</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>zInput</name><index>[<expr><name>i</name></expr>]</index></name><operator>==</operator><literal type="char">'"'</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>inPhrase</name> <operator>=</operator> <operator>!</operator><name>inPhrase</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>inPhrase</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* unmatched quote */</comment>
    <expr_stmt><expr><call><name>queryClear</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Perform a full-text query using the search expression in
** zInput[0..nInput-1].  Return a list of matching documents
** in pResult.
**
** Queries must match column iColumn.  Or if iColumn&gt;=nColumn
** they are allowed to match against any column.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextQuery</name><parameter_list>(
  <parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,      <comment type="block">/* The full text index */</comment>
  <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>,           <comment type="block">/* Match against this column by default */</comment>
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zInput</name></decl></parameter>,    <comment type="block">/* The query string */</comment>
  <parameter><decl><type><name>int</name></type> <name>nInput</name></decl></parameter>,            <comment type="block">/* Number of bytes in zInput[] */</comment>
  <parameter><decl><type><name>DocList</name> <modifier>*</modifier><modifier>*</modifier></type><name>pResult</name></decl></parameter>,     <comment type="block">/* Write the result doclist here */</comment>
  <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>pQuery</name></decl></parameter>          <comment type="block">/* Put parsed query string here */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>iNext</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pLeft</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pRight</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pNew</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pOr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nNot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>QueryTerm</name> <modifier>*</modifier></type><name>aTerm</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>parseQuery</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>zInput</name></expr></argument>, <argument><expr><name>nInput</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Merge AND terms. */</comment>
  <expr_stmt><expr><name>aTerm</name> <operator>=</operator> <name><name>pQuery</name><operator>-&gt;</operator><name>pTerms</name></name></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name></expr>;</condition> <incr><expr><name>i</name><operator>=</operator><name>iNext</name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isNot</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* Handle all NOT terms in a separate pass */</comment>
      <expr_stmt><expr><name>nNot</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>iNext</name> <operator>=</operator> <name>i</name> <operator>+</operator> <name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nPhrase</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>iNext</name> <operator>=</operator> <name>i</name> <operator>+</operator> <name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nPhrase</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>docListOfTerm</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iColumn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>queryClear</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <while>while<condition>( <expr><name>iNext</name><operator>&lt;</operator><name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name> <operator>&amp;&amp;</operator> <name><name>aTerm</name><index>[<expr><name>iNext</name></expr>]</index></name><operator>.</operator><name>isOr</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>docListOfTerm</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>aTerm</name><index>[<expr><name>iNext</name></expr>]</index></name><operator>.</operator><name>iColumn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aTerm</name><index>[<expr><name>iNext</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pOr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>iNext</name> <operator>+=</operator> <name><name>aTerm</name><index>[<expr><name>iNext</name></expr>]</index></name><operator>.</operator><name>nPhrase</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>queryClear</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>docListNew</name><argument_list>(<argument><expr><name>DL_DOCIDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>docListOrMerge</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pOr</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>docListDelete</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>docListDelete</name><argument_list>(<argument><expr><name>pOr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pRight</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><name>pLeft</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <name>pRight</name></expr>;</expr_stmt>
    </block_content>}</block></if><else>else<block>{<block_content>
      <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>docListNew</name><argument_list>(<argument><expr><name>DL_DOCIDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>docListAndMerge</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>docListDelete</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>docListDelete</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name>nNot</name> <operator>&amp;&amp;</operator> <name>pLeft</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <comment type="block">/* We do not yet know how to handle a query of only NOT terms */</comment>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Do the EXCEPT terms */</comment>
  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name></expr>;</condition>  <incr><expr><name>i</name> <operator>+=</operator> <name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nPhrase</name> <operator>+</operator> <literal type="number">1</literal></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isNot</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>docListOfTerm</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iColumn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>aTerm</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>queryClear</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>docListDelete</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pNew</name> <operator>=</operator> <call><name>docListNew</name><argument_list>(<argument><expr><name>DL_DOCIDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>docListExceptMerge</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>docListDelete</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>docListDelete</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pLeft</name> <operator>=</operator> <name>pNew</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <name>pLeft</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** This is the xFilter interface for the virtual table.  See
** the virtual table xFilter method documentation for additional
** information.
**
** If idxNum==QUERY_GENERIC then do a full table scan against
** the %_content table.
**
** If idxNum==QUERY_ROWID then do a rowid lookup for a single entry
** in the %_content table.
**
** If idxNum&gt;=QUERY_FULLTEXT then use the full text index.  The
** column on the left-hand side of the MATCH operator is column
** number idxNum-QUERY_FULLTEXT, 0 indexed.  argv[0] is the right-hand
** side of the MATCH operator.
*/</comment>
<comment type="block">/* TODO(shess) Upgrade the cursor initialization and destruction to
** account for fulltextFilter() being called multiple times on the
** same cursor.  The current solution is very fragile.  Apply fix to
** fts2 as appropriate.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextFilter</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>,     <comment type="block">/* The cursor used for this query */</comment>
  <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,   <comment type="block">/* Which indexing scheme to use */</comment>
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>    <comment type="block">/* Arguments for the indexing scheme */</comment>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>cursor_vtab</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS1 Filter %p\n"</literal><operator>,</operator><name>pCursor</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>zSql</name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"select rowid, * from %%_content %s"</literal></expr></argument>,
                          <argument><expr><ternary><condition><expr><name>idxNum</name><operator>==</operator><name>QUERY_GENERIC</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"where rowid=?"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_prepare</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>iCursorType</name></name> <operator>=</operator> <name>idxNum</name></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>idxNum</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>QUERY_GENERIC</name></expr>:</case>
      <break>break;</break>

    <case>case <expr><name>QUERY_ROWID</name></expr>:</case>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>

    <default>default:</default>   <comment type="block">/* full-text search */</comment>
    <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zQuery</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pResult</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idxNum</name><operator>&lt;=</operator><name>QUERY_FULLTEXT</name><operator>+</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>queryClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>q</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fulltextQuery</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>idxNum</name><operator>-</operator><name>QUERY_FULLTEXT</name></expr></argument>, <argument><expr><name>zQuery</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pResult</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>q</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>c</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>pDoclist</name></name><operator>!=</operator><name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>docListDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>pDoclist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name>pResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>

  <return>return <expr><call><name>fulltextNext</name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This is the xEof method of the virtual table.  The SQLite core
** calls this routine to find out if it has reached the end of
** a query's results set.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>c</name><operator>-&gt;</operator><name>eof</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This is the xColumn method of the virtual table.  The SQLite
** core calls this method during a query when it needs the value
** of a column from the virtual table.  This method needs to use
** one of the sqlite3_result_*() routines to store the requested
** value back in the pContext.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextColumn</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>,
                          <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idxCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>cursor_vtab</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>idxCol</name><operator>&lt;</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pVal</name> <init>= <expr><call><name>sqlite3_column_value</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>idxCol</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_value</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><name>idxCol</name><operator>==</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* The extra column whose name is the same as the table.
    ** Return a blob which is a pointer to the cursor
    */</comment>
    <expr_stmt><expr><call><name>sqlite3_result_blob</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This is the xRowid method.  The SQLite core calls this routine to
** retrive the rowid for the current row of the result set.  The
** rowid should be written to *pRowid.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add all terms in [zText] to the given hash table.  If [iColumn] &gt; 0,
 * we also store positions and offsets in the hash table using the given
 * column number. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>buildTerms</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>fts1Hash</name> <modifier>*</modifier></type><name>terms</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iColumn</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pToken</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTokenBytes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iStartOffset</name></decl>, <decl><type ref="prev"/><name>iEndOffset</name></decl>, <decl><type ref="prev"/><name>iPosition</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pTokenizer</name></expr></argument>, <argument><expr><name>zText</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>pCursor</name><operator>-&gt;</operator><name>pTokenizer</name></name> <operator>=</operator> <name>pTokenizer</name></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><call><name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xNext</name></name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>,
                                               <argument><expr><operator>&amp;</operator><name>pToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nTokenBytes</name></expr></argument>,
                                               <argument><expr><operator>&amp;</operator><name>iStartOffset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iEndOffset</name></expr></argument>,
                                               <argument><expr><operator>&amp;</operator><name>iPosition</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <comment type="block">/* Positions can't be negative; we use -1 as a terminator internally. */</comment>
    <if_stmt><if>if<condition>( <expr><name>iPosition</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>fts1HashFind</name><argument_list>(<argument><expr><name>terms</name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>, <argument><expr><name>nTokenBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><name>NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>docListNew</name><argument_list>(<argument><expr><name>DL_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>docListAddDocid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fts1HashInsert</name><argument_list>(<argument><expr><name>terms</name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>, <argument><expr><name>nTokenBytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>iColumn</name><operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>docListAddPosOffset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iColumn</name></expr></argument>, <argument><expr><name>iPosition</name></expr></argument>, <argument><expr><name>iStartOffset</name></expr></argument>, <argument><expr><name>iEndOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

  <comment type="block">/* TODO(shess) Check return?  Should this be able to cause errors at
  ** this point?  Actually, same question about sqlite3_finalize(),
  ** though one could argue that failure there means that the data is
  ** not durable.  *ponder*
  */</comment>
  <expr_stmt><expr><call><name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Update the %_terms table to map the term [pTerm] to the given rowid. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>index_insert_term</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,
                             <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iIndexRow</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DocList</name></type> <name>doclist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iSegment</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>term_select</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>iSegment</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iIndexRow</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>docListInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>, <argument><expr><name>DL_DEFAULT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>docListUpdate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* TODO(shess) Consider length(doclist)&gt;CHUNK_MAX? */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>term_insert</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>iSegment</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>err</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>docListUpdate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>doclist</name><operator>.</operator><name>nData</name></name><operator>&lt;=</operator><name>CHUNK_MAX</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>term_update</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iIndexRow</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>err</name>;</goto>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Doclist doesn't fit, delete what's there, and accumulate
  ** forward.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>term_delete</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iIndexRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Try to insert the doclist into a higher segment bucket.  On
  ** failure, accumulate existing doclist with the doclist from that
  ** bucket, and put results in the next bucket.
  */</comment>
  <expr_stmt><expr><name>iSegment</name><operator>++</operator></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>(</operator><name>rc</name><operator>=</operator><call><name>term_insert</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iIndexRow</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>iSegment</name></expr></argument>,
                         <argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iSegmentRow</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DocList</name></type> <name>old</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc2</name></decl>;</decl_stmt>

    <comment type="block">/* Retain old error in case the term_insert() error was really an
    ** error rather than a bounced insert.
    */</comment>
    <expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>term_select</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>iSegment</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iSegmentRow</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc2</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>term_delete</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iSegmentRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Reusing lowest-number deleted row keeps the index smaller. */</comment>
    <if_stmt><if>if<condition>( <expr><name>iSegmentRow</name><operator>&lt;</operator><name>iIndexRow</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>iIndexRow</name> <operator>=</operator> <name>iSegmentRow</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* doclist contains the newer data, so accumulate it over old.
    ** Then steal accumulated data for doclist.
    */</comment>
    <expr_stmt><expr><call><name>docListAccumulate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>docListDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>doclist</name> <operator>=</operator> <name>old</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>iSegment</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

 <label><name>err</name>:</label>
  <expr_stmt><expr><call><name>docListDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add doclists for all terms in [pValues] to the hash table [terms]. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>insertTerms</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>fts1Hash</name> <modifier>*</modifier></type><name>terms</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iRowid</name></decl></parameter>,
                <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>pValues</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr> ;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zText</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>pValues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>buildTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>terms</name></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>, <argument><expr><name>zText</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add empty doclists for all terms in the given row's content to the hash
 * table [pTerms]. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>deleteTerms</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>fts1Hash</name> <modifier>*</modifier></type><name>pTerms</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pValues</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>content_select</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pValues</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>buildTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTerms</name></expr></argument>, <argument><expr><name>iRowid</name></expr></argument>, <argument><expr><name><name>pValues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>freeStringArray</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name></expr></argument>, <argument><expr><name>pValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Insert a row into the %_content table; set *piRowid to be the ID of the
 * new row.  Fill [pTerms] with new doclists for the %_term table. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>index_insert</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pRequestRowid</name></decl></parameter>,
                        <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>pValues</name></decl></parameter>,
                        <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>piRowid</name></decl></parameter>, <parameter><decl><type><name>fts1Hash</name> <modifier>*</modifier></type><name>pTerms</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>content_insert</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pRequestRowid</name></expr></argument>, <argument><expr><name>pValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* execute an SQL INSERT */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>piRowid</name> <operator>=</operator> <call><name>sqlite3_last_insert_rowid</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>insertTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTerms</name></expr></argument>, <argument><expr><operator>*</operator><name>piRowid</name></expr></argument>, <argument><expr><name>pValues</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Delete a row from the %_content table; fill [pTerms] with empty doclists
 * to be written to the %_term table. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>index_delete</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iRow</name></decl></parameter>, <parameter><decl><type><name>fts1Hash</name> <modifier>*</modifier></type><name>pTerms</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>deleteTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTerms</name></expr></argument>, <argument><expr><name>iRow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><call><name>content_delete</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iRow</name></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* execute an SQL DELETE */</comment>
</block_content>}</block></function>

<comment type="block">/* Update a row in the %_content table; fill [pTerms] with new doclists for the
 * %_term table. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>index_update</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iRow</name></decl></parameter>,
                        <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>pValues</name></decl></parameter>, <parameter><decl><type><name>fts1Hash</name> <modifier>*</modifier></type><name>pTerms</name></decl></parameter>)</parameter_list><block>{<block_content>
  <comment type="block">/* Generate an empty doclist for each term that previously appeared in this
   * row. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>deleteTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTerms</name></expr></argument>, <argument><expr><name>iRow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>content_update</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pValues</name></expr></argument>, <argument><expr><name>iRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* execute an SQL UPDATE */</comment>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Now add positions for terms which appear in the updated row. */</comment>
  <return>return <expr><call><name>insertTerms</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pTerms</name></expr></argument>, <argument><expr><name>iRow</name></expr></argument>, <argument><expr><name>pValues</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function implements the xUpdate callback; it is the top-level entry
 * point for inserting, deleting or updating a row in a full-text table. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextUpdate</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppArg</name></decl></parameter>,
                   <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator> <name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fts1Hash</name></type> <name>terms</name></decl>;</decl_stmt>   <comment type="block">/* maps term string -&gt; PosList */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fts1HashElem</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"FTS1 Update %p\n"</literal><operator>,</operator> <name>pVtab</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><call><name>fts1HashInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>terms</name></expr></argument>, <argument><expr><name>FTS1_HASH_STRING</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>index_delete</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>ppArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>terms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>ppArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* An update:
     * ppArg[0] = old rowid
     * ppArg[1] = new rowid
     * ppArg[2..2+v-&gt;nColumn-1] = values
     * ppArg[2+v-&gt;nColumn] = value for magic column (we ignore this)
     */</comment>
    <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>rowid</name> <init>= <expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>ppArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>ppArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SQLITE_INTEGER</name> <operator>||</operator>
      <call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>ppArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>rowid</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>  <comment type="block">/* we don't allow changing the rowid */</comment>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">2</literal><operator>+</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>index_update</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>rowid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ppArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>terms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* An insert:
     * ppArg[1] = requested rowid
     * ppArg[2..2+v-&gt;nColumn-1] = values
     * ppArg[2+v-&gt;nColumn] = value for magic column (we ignore this)
     */</comment>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">2</literal><operator>+</operator><name><name>v</name><operator>-&gt;</operator><name>nColumn</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>index_insert</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>ppArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ppArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pRowid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>terms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_OK</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Write updated doclists to disk. */</comment>
    <for>for<control>(<init><expr><name>e</name><operator>=</operator><call><name>fts1HashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name>terms</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>e</name><operator>=</operator><call><name>fts1HashNext</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
      <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>fts1HashData</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>index_insert_term</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>fts1HashKey</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>fts1HashKeysize</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* clean up */</comment>
  <for>for<control>(<init><expr><name>e</name><operator>=</operator><call><name>fts1HashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name>terms</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>e</name><operator>=</operator><call><name>fts1HashNext</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>fts1HashData</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>docListDelete</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>fts1HashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>terms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the snippet() function for FTS1
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>snippetFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_BLOB</name> <operator>||</operator>
      <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></sizeof></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"illegal first argument to html_snippet"</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStart</name> <init>= <expr><literal type="string">"&lt;b&gt;"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEnd</name> <init>= <expr><literal type="string">"&lt;/b&gt;"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zEllipsis</name> <init>= <expr><literal type="string">"&lt;b&gt;...&lt;/b&gt;"</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pCursor</name></expr></argument>, <argument><expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&gt;=</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>zStart</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&gt;=</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>zEnd</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&gt;=</operator><literal type="number">4</literal></expr> )</condition><block>{<block_content>
          <expr_stmt><expr><name>zEllipsis</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>snippetAllOffsets</name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>snippetText</name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>, <argument><expr><name>zStart</name></expr></argument>, <argument><expr><name>zEnd</name></expr></argument>, <argument><expr><name>zEllipsis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>zSnippet</name></name></expr></argument>,
                        <argument><expr><name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>nSnippet</name></name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Implementation of the offsets() function for FTS1
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>snippetOffsetsFunc</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>&lt;</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><name>SQLITE_BLOB</name> <operator>||</operator>
      <call><name>sqlite3_value_bytes</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>!=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></sizeof></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_result_error</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><literal type="string">"illegal first argument to offsets"</literal></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if><else>else<block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pCursor</name></expr></argument>, <argument><expr><call><name>sqlite3_value_blob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>snippetAllOffsets</name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>snippetOffsetText</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>,
                        <argument><expr><name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>zOffset</name></name></expr></argument>, <argument><expr><name><name>pCursor</name><operator>-&gt;</operator><name>snippet</name><operator>.</operator><name>nOffset</name></name></expr></argument>,
                        <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** This routine implements the xFindFunction method for the FTS1
** virtual table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextFindFunction</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><modifier>*</modifier><name>pxFunc</name>)<parameter_list>(<parameter><decl><type><name>sqlite3_context</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>sqlite3_value</name><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppArg</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <if_stmt><if>if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>,<argument><expr><literal type="string">"snippet"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pxFunc</name> <operator>=</operator> <name>snippetFunc</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if><if type="elseif">else if<condition>( <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>zName</name></expr></argument>,<argument><expr><literal type="string">"offsets"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pxFunc</name> <operator>=</operator> <name>snippetOffsetsFunc</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Rename an fts1 table.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextRename</name><parameter_list>(
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator><name>pVtab</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_NOMEM</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zSql</name> <init>= <expr><call><name>sqlite3_mprintf</name><argument_list>(
    <argument><expr><literal type="string">"ALTER TABLE %Q.'%q_content'  RENAME TO '%q_content';"</literal>
    <literal type="string">"ALTER TABLE %Q.'%q_term' RENAME TO '%q_term';"</literal></expr></argument>
    , <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>
    , <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zDb</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>zName</name></expr></argument>
  )</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>zSql</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>zSql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>zSql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_module</name></type> <name>fulltextModule</name> <init>= <expr><block>{
  <comment type="block">/* iVersion      */</comment> <expr><literal type="number">0</literal></expr>,
  <comment type="block">/* xCreate       */</comment> <expr><name>fulltextCreate</name></expr>,
  <comment type="block">/* xConnect      */</comment> <expr><name>fulltextConnect</name></expr>,
  <comment type="block">/* xBestIndex    */</comment> <expr><name>fulltextBestIndex</name></expr>,
  <comment type="block">/* xDisconnect   */</comment> <expr><name>fulltextDisconnect</name></expr>,
  <comment type="block">/* xDestroy      */</comment> <expr><name>fulltextDestroy</name></expr>,
  <comment type="block">/* xOpen         */</comment> <expr><name>fulltextOpen</name></expr>,
  <comment type="block">/* xClose        */</comment> <expr><name>fulltextClose</name></expr>,
  <comment type="block">/* xFilter       */</comment> <expr><name>fulltextFilter</name></expr>,
  <comment type="block">/* xNext         */</comment> <expr><name>fulltextNext</name></expr>,
  <comment type="block">/* xEof          */</comment> <expr><name>fulltextEof</name></expr>,
  <comment type="block">/* xColumn       */</comment> <expr><name>fulltextColumn</name></expr>,
  <comment type="block">/* xRowid        */</comment> <expr><name>fulltextRowid</name></expr>,
  <comment type="block">/* xUpdate       */</comment> <expr><name>fulltextUpdate</name></expr>,
  <comment type="block">/* xBegin        */</comment> <expr><literal type="number">0</literal></expr>, 
  <comment type="block">/* xSync         */</comment> <expr><literal type="number">0</literal></expr>,
  <comment type="block">/* xCommit       */</comment> <expr><literal type="number">0</literal></expr>,
  <comment type="block">/* xRollback     */</comment> <expr><literal type="number">0</literal></expr>,
  <comment type="block">/* xFindFunction */</comment> <expr><name>fulltextFindFunction</name></expr>,
  <comment type="block">/* xRename       */</comment> <expr><name>fulltextRename</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type> <name>sqlite3Fts1Init</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>sqlite3_overload_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"snippet"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_overload_function</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"offsets"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"fts1"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fulltextModule</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_CORE</name></expr></cpp:if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_fts1_init</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>)</parameter_list><block>{<block_content>
  <macro><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument>pApi</argument>)</argument_list></macro>
  <return>return <expr><call><name>sqlite3Fts1Init</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS1) */</comment>
</unit>
