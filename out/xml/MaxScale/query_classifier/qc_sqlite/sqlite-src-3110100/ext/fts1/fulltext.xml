<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/ext/fts1/fulltext.c"><comment type="block">/* The author disclaims copyright to this source code.
 *
 * This is an SQLite module implementing full-text search.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fulltext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ft_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tokenizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlite3ext.h"</cpp:file></cpp:include>
<function><type><name>SQLITE_EXTENSION_INIT1</name>

<comment type="block">/* utility functions */</comment>

<comment type="block">/* We encode variable-length integers in little-endian order using seven bits
 * per byte as follows:
**
** KEY:
**         A = 0xxxxxxx    7 bits of data and one flag bit
**         B = 1xxxxxxx    7 bits of data and one flag bit
**
**  7 bits - A
** 14 bits - BA
** 21 bits - BBA
** and so on.
*/</comment>

<comment type="block">/* We may need up to VARINT_MAX bytes to store an encoded 64-bit integer. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARINT_MAX</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<comment type="block">/* Write a 64-bit variable-length integer to memory starting at p[0].
 * The length of data written will be between 1 and VARINT_MAX bytes.
 * The number of bytes written is returned. */</comment>
<specifier>static</specifier> <name>int</name></type> <name>putVarint</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_uint64</name></type> <name>vu</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>
  <do>do<block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>vu</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>vu</name> <operator>&gt;&gt;=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
  </block_content>}</block>while<condition>( <expr><name>vu</name><operator>!=</operator><literal type="number">0</literal></expr> )</condition>;</do>
  <expr_stmt><expr><name><name>q</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>  <comment type="block">/* turn off high bit in final byte */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>q</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>&lt;=</operator> <name>VARINT_MAX</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>q</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Read a 64-bit variable-length integer from memory starting at p[0].
 * Return the number of bytes read, or 0 on error.
 * The value is stored in *v. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getVarint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_uint64</name></type> <name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>y</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><operator>(</operator><operator>*</operator><name>q</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>x</name> <operator>+=</operator> <name>y</name> <operator>*</operator> <operator>(</operator><operator>*</operator><name>q</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>y</name> <operator>&lt;&lt;=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>q</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>&gt;=</operator> <name>VARINT_MAX</name></expr> )</condition><block>{<block_content>  <comment type="block">/* bad data */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name>x</name> <operator>+=</operator> <name>y</name> <operator>*</operator> <operator>(</operator><operator>*</operator><name>q</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>(</operator><name>sqlite_int64</name><operator>)</operator> <name>x</name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>q</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>getVarint32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pi</name></decl></parameter>)</parameter_list><block>{<block_content>
 <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>i</name></decl>;</decl_stmt>
 <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>getVarint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
 <expr_stmt><expr><operator>*</operator><name>pi</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>i</name></expr>;</expr_stmt>
 <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>*</operator><name>pi</name><operator>==</operator><name>i</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
 <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*** Document lists ***
 *
 * A document list holds a sorted list of varint-encoded document IDs.
 *
 * A doclist with type DL_POSITIONS_OFFSETS is stored like this:
 *
 * array {
 *   varint docid;
 *   array {
 *     varint position;     (delta from previous position plus 1, or 0 for end)
 *     varint startOffset;  (delta from previous startOffset)
 *     varint endOffset;    (delta from startOffset)
 *   }
 * }
 *
 * Here, array { X } means zero or more occurrences of X, adjacent in memory.
 *
 * A doclist with type DL_POSITIONS is like the above, but holds only docids
 * and positions without offset information.
 *
 * A doclist with type DL_DOCIDS is like the above, but holds only docids
 * without positions or offset information.
 *
 * On disk, every document list has positions and offsets, so we don't bother
 * to serialize a doclist's type.
 * 
 * We don't yet delta-encode document IDs; doing so will probably be a
 * modest win.
 *
 * NOTE(shess) I've thought of a slightly (1%) better offset encoding.
 * After the first offset, estimate the next offset by using the
 * current token position and the previous token position and offset,
 * offset to handle some variance.  So the estimate would be
 * (iPosition*w-&gt;iStartOffset/w-&gt;iPosition-64), which is delta-encoded
 * as normal.  Offsets more than 64 chars from the estimate are
 * encoded as the delta to the previous start offset + 128.  An
 * additional tiny increment can be gained by using the end offset of
 * the previous token to make the estimate a tiny bit more precise.
*/</comment>

<typedef>typedef <type><enum>enum <name>DocListType</name> <block>{
  <decl><name>DL_DOCIDS</name></decl>,              <comment type="block">/* docids only */</comment>
  <decl><name>DL_POSITIONS</name></decl>,           <comment type="block">/* docids + positions */</comment>
  <decl><name>DL_POSITIONS_OFFSETS</name></decl>    <comment type="block">/* docids + positions + offsets */</comment>
}</block></enum></type> <name>DocListType</name>;</typedef>

<typedef>typedef <type><struct>struct <name>DocList</name> <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nData</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DocListType</name></type> <name>iType</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iLastPos</name></decl>;</decl_stmt>       <comment type="block">/* the last position written */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>iLastOffset</name></decl>;</decl_stmt>    <comment type="block">/* the last start offset written */</comment>
}</block></struct></type> <name>DocList</name>;</typedef>

<comment type="block">/* Initialize a new DocList to hold the given data. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListInit</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>DocListType</name></type> <name>iType</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pData</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nData</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <name>nData</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>nData</name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name>pData</name></expr></argument>, <argument><expr><name>nData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>iType</name></name> <operator>=</operator> <name>iType</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>iLastPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>iLastOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Create a new dynamically-allocated DocList. */</comment>
<function><type><specifier>static</specifier> <name>DocList</name> <modifier>*</modifier></type><name>docListNew</name><parameter_list>(<parameter><decl><type><name>DocListType</name></type> <name>iType</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><operator>(</operator><name>DocList</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DocList</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>docListInit</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>iType</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>d</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>docListDestroy</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">0x55</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>d</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>docListDelete</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>docListDestroy</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>docListEnd</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name> <operator>+</operator> <name><name>d</name><operator>-&gt;</operator><name>nData</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Append a varint to a DocList's data. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>appendVarint</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>i</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><name>VARINT_MAX</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>putVarint</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>nData</name></name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name> <operator>+</operator> <name><name>d</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>nData</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>docListAddDocid</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>appendVarint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>iLastPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Add a position to the last position list in a doclist. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListAddPos</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iPos</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>d</name><operator>-&gt;</operator><name>iType</name></name><operator>&gt;=</operator><name>DL_POSITIONS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>appendVarint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>iPos</name><operator>-</operator><name><name>d</name><operator>-&gt;</operator><name>iLastPos</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>iLastPos</name></name> <operator>=</operator> <name>iPos</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>docListAddPosOffset</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iPos</name></decl></parameter>,
                                <parameter><decl><type><name>int</name></type> <name>iStartOffset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iEndOffset</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>d</name><operator>-&gt;</operator><name>iType</name></name><operator>==</operator><name>DL_POSITIONS_OFFSETS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>docListAddPos</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>iPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>appendVarint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>iStartOffset</name><operator>-</operator><name><name>d</name><operator>-&gt;</operator><name>iLastOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>iLastOffset</name></name> <operator>=</operator> <name>iStartOffset</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>appendVarint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>iEndOffset</name><operator>-</operator><name>iStartOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Terminate the last position list in the given doclist. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>docListAddEndPos</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>appendVarint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>DocListReader</name> <block>{
  <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pDoclist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iLastPos</name></decl>;</decl_stmt>    <comment type="block">/* the last position read */</comment>
}</block></struct></type> <name>DocListReader</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>readerInit</name><parameter_list>(<parameter><decl><type><name>DocListReader</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pDoclist</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>pDoclist</name></name> <operator>=</operator> <name>pDoclist</name></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>pDoclist</name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name><name>pDoclist</name><operator>-&gt;</operator><name>pData</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>iLastPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>readerAtEnd</name><parameter_list>(<parameter><decl><type><name>DocListReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name> <operator>&gt;=</operator> <call><name>docListEnd</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>pDoclist</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Peek at the next docid without advancing the read pointer. */</comment>
<function><type><specifier>static</specifier> <name>sqlite_int64</name></type> <name>peekDocid</name><parameter_list>(<parameter><decl><type><name>DocListReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>ret</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>readerAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>getVarint</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Read the next docid. */</comment>
<function><type><specifier>static</specifier> <name>sqlite_int64</name></type> <name>readDocid</name><parameter_list>(<parameter><decl><type><name>DocListReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>ret</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>readerAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <call><name>getVarint</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iLastPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Read the next position from a position list.
 * Returns the position, or -1 at the end of the list. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>readPosition</name><parameter_list>(<parameter><decl><type><name>DocListReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iType</name> <init>= <expr><name><name>pReader</name><operator>-&gt;</operator><name>pDoclist</name><operator>-&gt;</operator><name>iType</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iType</name><operator>&gt;=</operator><name>DL_POSITIONS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><operator>!</operator><call><name>readerAtEnd</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iLastPos</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>iLastPos</name></name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>int</name><operator>)</operator> <name>i</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>iType</name><operator>&gt;=</operator><name>DL_POSITIONS_OFFSETS</name></expr> )</condition><block>{<block_content>
    <comment type="block">/* Skip over offsets, ignoring them for now. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>iStart</name></decl>, <decl><type ref="prev"/><name>iEnd</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <call><name>getVarint32</name><argument_list>(<argument><expr><name><name>pReader</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name><name>pReader</name><operator>-&gt;</operator><name>iLastPos</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Skip past the end of a position list. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>skipPositionList</name><parameter_list>(<parameter><decl><type><name>DocListReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <while>while<condition>( <expr><call><name>readPosition</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call><operator>!=</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content>
    <empty_stmt>;</empty_stmt></block_content></block></while>
</block_content>}</block></function>

<comment type="block">/* Skip over a docid, including its position list if the doclist has
 * positions. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>skipDocument</name><parameter_list>(<parameter><decl><type><name>DocListReader</name> <modifier>*</modifier></type><name>pReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>readDocid</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>pReader</name><operator>-&gt;</operator><name>pDoclist</name><operator>-&gt;</operator><name>iType</name></name> <operator>&gt;=</operator> <name>DL_POSITIONS</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>skipPositionList</name><argument_list>(<argument><expr><name>pReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sqlite_int64</name></type> <name>firstDocid</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DocListReader</name></type> <name>r</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>readDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Doclist multi-tool.  Pass pUpdate==NULL to delete the indicated docid;
 * otherwise pUpdate, which must contain only the single docid [iDocid], is
 * inserted (if not present) or updated (if already present). */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>docListUpdate</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl></parameter>, <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pUpdate</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>modified</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DocListReader</name></type> <name>reader</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>pUpdate</name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>d</name><operator>-&gt;</operator><name>iType</name></name><operator>==</operator><name><name>pUpdate</name><operator>-&gt;</operator><name>iType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iDocid</name><operator>==</operator><call><name>firstDocid</name><argument_list>(<argument><expr><name>pUpdate</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>!</operator><call><name>readerAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>peekDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call><operator>&lt;</operator><name>iDocid</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>skipDocument</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>reader</name><operator>.</operator><name>p</name></name></expr>;</expr_stmt>
  <comment type="block">/* Delete if there is a matching element. */</comment>
  <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>readerAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>iDocid</name><operator>==</operator><call><name>peekDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>skipDocument</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>reader</name><operator>.</operator><name>p</name></name></expr></argument>, <argument><expr><call><name>docListEnd</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>reader</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>nData</name></name> <operator>-=</operator> <operator>(</operator><name><name>reader</name><operator>.</operator><name>p</name></name> <operator>-</operator> <name>p</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>modified</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Insert if indicated. */</comment>
  <if_stmt><if>if<condition>( <expr><name>pUpdate</name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>iDoclist</name> <init>= <expr><name>p</name><operator>-</operator><name><name>d</name><operator>-&gt;</operator><name>pData</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>docListAddEndPos</name><argument_list>(<argument><expr><name>pUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>nData</name></name><operator>+</operator><name><name>pUpdate</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>pData</name></name> <operator>+</operator> <name>iDoclist</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><name><name>pUpdate</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>docListEnd</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pUpdate</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>pUpdate</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>nData</name></name> <operator>+=</operator> <name><name>pUpdate</name><operator>-&gt;</operator><name>nData</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>modified</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>modified</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Split the second half of doclist d into a separate doclist d2.  Returns 1
 * if successful, or 0 if d contains a single document and hence can't be
 * split. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>docListSplit</name><parameter_list>(<parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d2</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pSplitPoint</name> <init>= <expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name> <operator>+</operator> <name><name>d</name><operator>-&gt;</operator><name>nData</name></name> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DocListReader</name></type> <name>reader</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name><name>reader</name><operator>.</operator><name>p</name></name><operator>&lt;</operator><name>pSplitPoint</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>skipDocument</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><call><name>readerAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>docListInit</name><argument_list>(<argument><expr><name>d2</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>iType</name></name></expr></argument>, <argument><expr><name><name>reader</name><operator>.</operator><name>p</name></name></expr></argument>, <argument><expr><call><name>docListEnd</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>reader</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>nData</name></name> <operator>=</operator> <name><name>reader</name><operator>.</operator><name>p</name></name> <operator>-</operator> <name><name>d</name><operator>-&gt;</operator><name>pData</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* A DocListMerge computes the AND of an in-memory DocList [in] and a chunked
 * on-disk doclist, resulting in another in-memory DocList [out].  [in]
 * and [out] may or may not store position information according to the
 * caller's wishes.  The on-disk doclist always comes with positions.
 *
 * The caller must read each chunk of the on-disk doclist in succession and
 * pass it to mergeBlock().
 *
 * If [in] has positions, then the merge output contains only documents with
 * matching positions in the two input doclists.  If [in] does not have
 * positions, then the merge output contains all documents common to the two
 * input doclists.
 *
 * If [in] is NULL, then the on-disk doclist is copied to [out] directly.
 *
 * A merge is performed using an integer [iOffset] provided by the caller.
 * [iOffset] is subtracted from each position in the on-disk doclist for the
 * purpose of position comparison; this is helpful in implementing phrase
 * searches.
 *
 * A DocListMerge is not yet able to propagate offsets through query
 * processing; we should add that capability soon.
*/</comment>
<typedef>typedef <type><struct>struct <name>DocListMerge</name> <block>{
  <decl_stmt><decl><type><name>DocListReader</name></type> <name>in</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pOut</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iOffset</name></decl>;</decl_stmt>
}</block></struct></type> <name>DocListMerge</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mergeInit</name><parameter_list>(<parameter><decl><type><name>DocListMerge</name> <modifier>*</modifier></type><name>m</name></decl></parameter>,
                      <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iOffset</name></decl></parameter>, <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pOut</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>in</name></name></expr></argument>, <argument><expr><name>pIn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>pOut</name></name> <operator>=</operator> <name>pOut</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>iOffset</name></name> <operator>=</operator> <name>iOffset</name></expr>;</expr_stmt>

  <comment type="block">/* can't handle offsets yet */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>pIn</name><operator>==</operator><name>NULL</name> <operator>||</operator> <name><name>pIn</name><operator>-&gt;</operator><name>iType</name></name> <operator>&lt;=</operator> <name>DL_POSITIONS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pOut</name><operator>-&gt;</operator><name>iType</name></name> <operator>&lt;=</operator> <name>DL_POSITIONS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* A helper function for mergeBlock(), below.  Merge the position lists
 * pointed to by m-&gt;in and pBlockReader.
 * If the merge matches, write [iDocid] to m-&gt;pOut; if m-&gt;pOut
 * has positions then write all matching positions as well. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mergePosList</name><parameter_list>(<parameter><decl><type><name>DocListMerge</name> <modifier>*</modifier></type><name>m</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl></parameter>,
                  <parameter><decl><type><name>DocListReader</name> <modifier>*</modifier></type><name>pBlockReader</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>block_pos</name> <init>= <expr><call><name>readPosition</name><argument_list>(<argument><expr><name>pBlockReader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>in_pos</name> <init>= <expr><call><name>readPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>match</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <while>while<condition>( <expr><name>block_pos</name><operator>!=</operator><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>in_pos</name><operator>!=</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name>block_pos</name><operator>-</operator><name><name>m</name><operator>-&gt;</operator><name>iOffset</name></name><operator>==</operator><name>in_pos</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>!</operator><name>match</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>docListAddDocid</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>match</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>m</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>iType</name></name> <operator>&gt;=</operator> <name>DL_POSITIONS</name></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><call><name>docListAddPos</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>in_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>block_pos</name> <operator>=</operator> <call><name>readPosition</name><argument_list>(<argument><expr><name>pBlockReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>in_pos</name> <operator>=</operator> <call><name>readPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if<condition>( <expr><name>in_pos</name><operator>==</operator><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>block_pos</name><operator>!=</operator><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>block_pos</name><operator>-</operator><name><name>m</name><operator>-&gt;</operator><name>iOffset</name></name><operator>&lt;</operator><name>in_pos</name><operator>)</operator></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>block_pos</name> <operator>=</operator> <call><name>readPosition</name><argument_list>(<argument><expr><name>pBlockReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>in_pos</name> <operator>=</operator> <call><name>readPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if<condition>( <expr><name><name>m</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>iType</name></name> <operator>&gt;=</operator> <name>DL_POSITIONS</name> <operator>&amp;&amp;</operator> <name>match</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>docListAddEndPos</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Merge one block of an on-disk doclist into a DocListMerge. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mergeBlock</name><parameter_list>(<parameter><decl><type><name>DocListMerge</name> <modifier>*</modifier></type><name>m</name></decl></parameter>, <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pBlock</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>DocListReader</name></type> <name>blockReader</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name><name>pBlock</name><operator>-&gt;</operator><name>iType</name></name> <operator>&gt;=</operator> <name>DL_POSITIONS</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockReader</name></expr></argument>, <argument><expr><name>pBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><operator>!</operator><call><name>readerAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockReader</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iDocid</name> <init>= <expr><call><name>readDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockReader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>m</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>pDoclist</name></name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
      <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
        <if_stmt><if>if<condition>( <expr><call><name>readerAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* nothing more to merge */</comment>
        <if_stmt><if>if<condition>( <expr><call><name>peekDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call><operator>&gt;=</operator><name>iDocid</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>skipDocument</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if<condition>( <expr><call><name>peekDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call><operator>&gt;</operator><name>iDocid</name></expr> )</condition><block>{<block_content>  <comment type="block">/* [pIn] has no match with iDocid */</comment>
        <expr_stmt><expr><call><name>skipPositionList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip this docid in the block */</comment>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>readDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>m</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* We have a document match. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>m</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>pDoclist</name></name><operator>==</operator><name>NULL</name> <operator>||</operator> <name><name>m</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>pDoclist</name><operator>-&gt;</operator><name>iType</name></name> <operator>&lt;</operator> <name>DL_POSITIONS</name></expr> )</condition><block>{<block_content>
      <comment type="block">/* We don't need to do a poslist merge. */</comment>
      <expr_stmt><expr><call><name>docListAddDocid</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name><name>m</name><operator>-&gt;</operator><name>pOut</name><operator>-&gt;</operator><name>iType</name></name> <operator>&gt;=</operator> <name>DL_POSITIONS</name></expr> )</condition><block>{<block_content>
        <comment type="block">/* Copy all positions to the output doclist. */</comment>
        <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><call><name>readPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockReader</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if<condition>( <expr><name>pos</name><operator>==</operator><operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>docListAddPos</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>docListAddEndPos</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>pOut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>skipPositionList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>blockReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>mergePosList</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blockReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>string_dup_n</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>str</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  <return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Duplicate a string; the caller must free() the returned string.
 * (We don't use strdup() since it's not part of the standard C library and
 * may not be available everywhere.) */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>string_dup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><call><name>string_dup_n</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Format a string, replacing each occurrence of the % character with
 * zName.  This may be more convenient than sqlite_mprintf()
 * when one string is used repeatedly in a format string.
 * The caller must free() the returned string. */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>string_format</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>nName</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

  <comment type="block">/* first compute length needed */</comment>
  <for>for<control>(<init><expr><name>p</name> <operator>=</operator> <name>zFormat</name></expr> ;</init> <condition><expr><operator>*</operator><name>p</name></expr> ;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><ternary><condition><expr><operator>*</operator><name>p</name><operator>==</operator><literal type="char">'%'</literal></expr> ?</condition><then> <expr><name>nName</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* for null terminator */</comment>

  <expr_stmt><expr><name>r</name> <operator>=</operator> <name>result</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for<control>(<init><expr><name>p</name> <operator>=</operator> <name>zFormat</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>p</name><operator>==</operator><literal type="char">'%'</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>, <argument><expr><name>nName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name> <operator>+=</operator> <name>nName</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>r</name> <operator>==</operator> <name>result</name> <operator>+</operator> <name>len</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sql_exec</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCommand</name> <init>= <expr><call><name>string_format</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zCommand</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sql_prepare</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl></parameter>, <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zFormat</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zCommand</name> <init>= <expr><call><name>string_format</name><argument_list>(<argument><expr><name>zFormat</name></expr></argument>, <argument><expr><name>zName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>zCommand</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>ppStmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* end utility functions */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUERY_GENERIC</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUERY_FULLTEXT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNK_MAX</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum <name>fulltext_statement</name> <block>{
  <decl><name>CONTENT_INSERT_STMT</name></decl>,
  <decl><name>CONTENT_SELECT_STMT</name></decl>,
  <decl><name>CONTENT_DELETE_STMT</name></decl>,

  <decl><name>TERM_SELECT_STMT</name></decl>,
  <decl><name>TERM_CHUNK_SELECT_STMT</name></decl>,
  <decl><name>TERM_INSERT_STMT</name></decl>,
  <decl><name>TERM_UPDATE_STMT</name></decl>,
  <decl><name>TERM_DELETE_STMT</name></decl>,

  <decl><name>MAX_STMT</name></decl>                     <comment type="block">/* Always at end! */</comment>
}</block></enum></type> <name>fulltext_statement</name>;</typedef>

<comment type="block">/* These must exactly match the enum above. */</comment>
<comment type="block">/* TODO(adam): Is there some risk that a statement (in particular,
** pTermSelectStmt) will be used in two cursors at once, e.g.  if a
** query joins a virtual table to itself?  If so perhaps we should
** move some of these to the cursor object.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>fulltext_zStatement</name><index>[<expr><name>MAX_STMT</name></expr>]</index></name> <init>= <expr><block>{
  <comment type="block">/* CONTENT_INSERT */</comment> <expr><literal type="string">"insert into %_content (rowid, content) values (?, ?)"</literal></expr>,
  <comment type="block">/* CONTENT_SELECT */</comment> <expr><literal type="string">"select content from %_content where rowid = ?"</literal></expr>,
  <comment type="block">/* CONTENT_DELETE */</comment> <expr><literal type="string">"delete from %_content where rowid = ?"</literal></expr>,

  <comment type="block">/* TERM_SELECT */</comment>
  <expr><literal type="string">"select rowid, doclist from %_term where term = ? and first = ?"</literal></expr>,
  <comment type="block">/* TERM_CHUNK_SELECT */</comment>
  <expr><literal type="string">"select max(first) from %_term where term = ? and first &lt;= ?"</literal></expr>,
  <comment type="block">/* TERM_INSERT */</comment>
  <expr><literal type="string">"insert into %_term (term, first, doclist) values (?, ?, ?)"</literal></expr>,
  <comment type="block">/* TERM_UPDATE */</comment> <expr><literal type="string">"update %_term set doclist = ? where rowid = ?"</literal></expr>,
  <comment type="block">/* TERM_DELETE */</comment> <expr><literal type="string">"delete from %_term where rowid = ?"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>fulltext_vtab</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab</name></type> <name>base</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zName</name></decl>;</decl_stmt>               <comment type="block">/* virtual table name */</comment>
  <decl_stmt><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name></decl>;</decl_stmt>   <comment type="block">/* tokenizer for inserts and queries */</comment>

  <comment type="block">/* Precompiled statements which we keep as long as the table is
  ** open.
  */</comment>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name><name>pFulltextStatements</name><index>[<expr><name>MAX_STMT</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>fulltext_vtab</name>;</typedef>

<typedef>typedef <type><struct>struct <name>fulltext_cursor</name> <block>{
  <decl_stmt><decl><type><name>sqlite3_vtab_cursor</name></type> <name>base</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iCursorType</name></decl>;</decl_stmt>  <comment type="block">/* QUERY_GENERIC or QUERY_FULLTEXT */</comment>

  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pStmt</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>eof</name></decl>;</decl_stmt>

  <comment type="block">/* The following is used only when iCursorType == QUERY_FULLTEXT. */</comment>
  <decl_stmt><decl><type><name>DocListReader</name></type> <name>result</name></decl>;</decl_stmt>
}</block></struct></type> <name>fulltext_cursor</name>;</typedef>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>fulltext_vtab</name></name> <modifier>*</modifier></type><name>cursor_vtab</name><parameter_list>(<parameter><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list><block>{<block_content>
  <return>return <expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator> <name><name>c</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pVtab</name></name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>fulltextModule</name></decl>;</decl_stmt>   <comment type="block">/* forward declaration */</comment>

<comment type="block">/* Puts a freshly-prepared statement determined by iStmt in *ppStmt.
** If the indicated statement has never been prepared, it is prepared
** and cached, otherwise the cached version is reset.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sql_get_statement</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>fulltext_statement</name></type> <name>iStmt</name></decl></parameter>,
                             <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iStmt</name><operator>&lt;</operator><name>MAX_STMT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name><operator>==</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_prepare</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name></expr></argument>,
                         <argument><expr><name><name>fulltext_zStatement</name><index>[<expr><name>iStmt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppStmt</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Step the indicated statement, handling errors SQLITE_BUSY (by
** retrying) and SQLITE_SCHEMA (by re-preparing and transferring
** bindings to the new statement).
** TODO(adam): We should extend this function so that it can work with
** statements declared locally, not only globally cached statements.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sql_step_statement</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>fulltext_statement</name></type> <name>iStmt</name></decl></parameter>,
                              <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><operator>*</operator><name>ppStmt</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>iStmt</name><operator>&lt;</operator><name>MAX_STMT</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>s</name><operator>==</operator><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <while>while<condition>( <expr><operator>(</operator><name>rc</name><operator>=</operator><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator><operator>!=</operator><name>SQLITE_DONE</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pNewStmt</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_BUSY</name></expr> )</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ERROR</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_SCHEMA</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>   <comment type="block">/* Still in s */</comment>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pNewStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>ppStmt</name> <operator>=</operator> <name>pNewStmt</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_transfer_bindings</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>pNewStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name>pNewStmt</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>rc</name></expr>;</return>

 <label><name>err</name>:</label>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Like sql_step_statement(), but convert SQLITE_DONE to SQLITE_OK.
** Useful for statements like UPDATE, where we expect no results.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sql_single_step_statement</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
                                     <parameter><decl><type><name>fulltext_statement</name></type> <name>iStmt</name></decl></parameter>,
                                     <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_step_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iStmt</name></expr></argument>, <argument><expr><name>ppStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name>rc</name><operator>==</operator><name>SQLITE_DONE</name><operator>)</operator></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* insert into %_content (rowid, content) values ([rowid], [zContent]) */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>content_insert</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>rowid</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zContent</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nContent</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>CONTENT_INSERT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_value</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>zContent</name></expr></argument>, <argument><expr><name>nContent</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>sql_single_step_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>CONTENT_INSERT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* select content from %_content where rowid = [iRow]
 * The caller must delete the returned string. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>content_select</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iRow</name></decl></parameter>,
                          <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzContent</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>CONTENT_SELECT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_step_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>CONTENT_SELECT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>pzContent</name> <operator>=</operator> <call><name>string_dup</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We expect only one row.  We must execute another sqlite3_step()
   * to complete the iteration; otherwise the table will remain locked. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>pzContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* delete from %_content where rowid = [iRow ] */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>content_delete</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iRow</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>CONTENT_DELETE_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>sql_single_step_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>CONTENT_DELETE_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* select rowid, doclist from %_term where term = [zTerm] and first = [iFirst]
 * If found, returns SQLITE_OK; the caller must free the returned doclist.
 * If no rows found, returns SQLITE_ERROR. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>term_select</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,
                       <parameter><decl><type><name>sqlite_int64</name></type> <name>iFirst</name></decl></parameter>,
                       <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>rowid</name></decl></parameter>,
                       <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TERM_SELECT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>iFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_step_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TERM_SELECT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> ?</condition><then> <expr><name>SQLITE_ERROR</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><operator>*</operator><name>rowid</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>docListInit</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>DL_POSITIONS_OFFSETS</name></expr></argument>,
              <argument><expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We expect only one row.  We must execute another sqlite3_step()
   * to complete the iteration; otherwise the table will remain locked. */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> ?</condition><then> <expr><name>SQLITE_OK</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* select max(first) from %_term where term = [zTerm] and first &lt;= [iFirst]
 * If found, returns SQLITE_ROW and result in *piResult; if the query returns
 * NULL (meaning no row found) returns SQLITE_DONE.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>term_chunk_select</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,
                           <parameter><decl><type><name>sqlite_int64</name></type> <name>iFirst</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>piResult</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TERM_CHUNK_SELECT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>iFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_step_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TERM_CHUNK_SELECT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> ?</condition><then> <expr><name>SQLITE_ERROR</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

  <switch>switch<condition>( <expr><call><name>sqlite3_column_type</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <case>case <expr><name>SQLITE_NULL</name></expr>:</case>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_DONE</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>SQLITE_INTEGER</name></expr>:</case>
     <expr_stmt><expr><operator>*</operator><name>piResult</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <break>break;</break>
    <default>default:</default>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
  </block_content>}</block></switch>
  <comment type="block">/* We expect only one row.  We must execute another sqlite3_step()
   * to complete the iteration; otherwise the table will remain locked. */</comment>
  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* insert into %_term (term, first, doclist)
               values ([zTerm], [iFirst], [doclist]) */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>term_insert</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,
                       <parameter><decl><type><name>sqlite_int64</name></type> <name>iFirst</name></decl></parameter>, <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>doclist</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TERM_INSERT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>iFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_blob</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name><name>doclist</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>doclist</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>, <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>sql_single_step_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TERM_INSERT_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* update %_term set doclist = [doclist] where rowid = [rowid] */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>term_update</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>rowid</name></decl></parameter>,
                       <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>doclist</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TERM_UPDATE_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_blob</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>doclist</name><operator>-&gt;</operator><name>pData</name></name></expr></argument>, <argument><expr><name><name>doclist</name><operator>-&gt;</operator><name>nData</name></name></expr></argument>,
                         <argument><expr><name>SQLITE_STATIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>sql_single_step_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TERM_UPDATE_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>term_delete</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>rowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_get_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TERM_DELETE_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>sql_single_step_statement</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>TERM_DELETE_STMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fulltext_vtab_destroy</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>iStmt</name></decl>;</decl_stmt>

  <for>for<control>( <init><expr><name>iStmt</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>iStmt</name><operator>&lt;</operator><name>MAX_STMT</name></expr>;</condition> <incr><expr><name>iStmt</name><operator>++</operator></expr></incr> )</control><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name><index>[<expr><name>iStmt</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if<condition>( <expr><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xDestroy</name></name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>v</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Current interface:
** argv[0] - module name
** argv[1] - database name
** argv[2] - table name
** argv[3] - tokenizer name (optional, a sensible default is provided)
** argv[4..] - passed to tokenizer (optional based on tokenizer)
**/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextConnect</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVTab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_module</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>&gt;=</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fulltext_vtab</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* sqlite will initialize v-&gt;base */</comment>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <call><name>string_dup</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><name>argc</name><operator>==</operator><literal type="number">3</literal></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>get_simple_tokenizer_module</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* TODO(shess) For now, add new tokenizers as else if clauses. */</comment>
    <if_stmt><if>if<condition>( <expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"simple"</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>get_simple_tokenizer_module</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="string">"unrecognized tokenizer"</literal><operator>==</operator><name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* TODO(shess) Since tokenization impacts the index, the parameters
  ** to the tokenizer need to be identical when a persistent virtual
  ** table is re-created.  One solution would be a meta-table to track
  ** such information in the database.  Then we could verify that the
  ** information is identical on subsequent creates.
  */</comment>
  <comment type="block">/* TODO(shess) Why isn't argv already (const char **)? */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>m</name><operator>-&gt;</operator><name>xCreate</name></name><argument_list>(<argument><expr><name>argc</name><operator>-</operator><literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><name>argv</name><operator>+</operator><literal type="number">3</literal><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name></name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>

  <comment type="block">/* TODO: verify the existence of backing tables foo_content, foo_term */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_declare_vtab</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"create table x(content text)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>pFulltextStatements</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>ppVTab</name> <operator>=</operator> <operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextCreate</name><parameter_list>(
  <parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pAux</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>argv</name></decl></parameter>,
  <parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppVTab</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErr</name></decl></parameter>
)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>&gt;=</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The %_content table holds the text of each full-text item, with
  ** the rowid used as the docid.
  **
  ** The %_term table maps each term to a document list blob
  ** containing elements sorted by ascending docid, each element
  ** encoded as:
  **
  **   docid varint-encoded
  **   token count varint-encoded
  **   "count" token elements (poslist):
  **     position varint-encoded as delta from previous position
  **     start offset varint-encoded as delta from previous start offset
  **     end offset varint-encoded as delta from start offset
  **
  ** Additionally, doclist blobs can be chunked into multiple rows,
  ** using "first" to order the blobs.  "first" is simply the first
  ** docid in the blob.
  */</comment>
  <comment type="block">/*
  ** NOTE(shess) That last sentence is incorrect in the face of
  ** deletion, which can leave a doclist that doesn't contain the
  ** first from that row.  I _believe_ this does not matter to the
  ** operation of the system, but it might be reasonable to update
  ** appropriately in case this assumption becomes more important.
  */</comment>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
    <argument><expr><literal type="string">"create table %_content(content text);"</literal>
    <literal type="string">"create table %_term(term text, first integer, doclist blob);"</literal>
    <literal type="string">"create index %_index on %_term(term, first)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>fulltextConnect</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pAux</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ppVTab</name></expr></argument>, <argument><expr><name>pzErr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Decide how to handle an SQL query.
 * At the moment, MATCH queries can include implicit boolean ANDs; we
 * haven't implemented phrase searches or OR yet. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextBestIndex</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_index_info</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>nConstraint</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sqlite3_index_constraint</name></name> <modifier>*</modifier></type><name>pConstraint</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>pConstraint</name> <operator>=</operator> <operator>&amp;</operator><name><name>pInfo</name><operator>-&gt;</operator><name>aConstraint</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>pConstraint</name><operator>-&gt;</operator><name>iColumn</name></name><operator>==</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <name><name>pConstraint</name><operator>-&gt;</operator><name>op</name></name><operator>==</operator><name>SQLITE_INDEX_CONSTRAINT_MATCH</name> <operator>&amp;&amp;</operator>
        <name><name>pConstraint</name><operator>-&gt;</operator><name>usable</name></name></expr> )</condition><block>{<block_content>   <comment type="block">/* a full-text search */</comment>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>argvIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>aConstraintUsage</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>omit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>QUERY_FULLTEXT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>estimatedCost</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>   <comment type="block">/* an arbitrary value for now */</comment>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><name><name>pInfo</name><operator>-&gt;</operator><name>idxNum</name></name> <operator>=</operator> <name>QUERY_GENERIC</name></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextDisconnect</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <expr_stmt><expr><call><name>fulltext_vtab_destroy</name><argument_list>(<argument><expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator><name>pVTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextDestroy</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator><name>pVTab</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>sql_exec</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>,
                    <argument><expr><literal type="string">"drop table %_content; drop table %_term"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>fulltext_vtab_destroy</name><argument_list>(<argument><expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator><name>pVTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVTab</name></decl></parameter>, <parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <call><name>calloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fulltext_cursor</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* sqlite will initialize c-&gt;base */</comment>
  <expr_stmt><expr><operator>*</operator><name>ppCursor</name> <operator>=</operator> <operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name><name>c</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>pDoclist</name></name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>docListDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>pDoclist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextNext</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

  <switch>switch<condition>( <expr><name><name>c</name><operator>-&gt;</operator><name>iCursorType</name></name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>QUERY_GENERIC</name></expr>:</case>
      <comment type="block">/* TODO(shess) Handle SQLITE_SCHEMA AND SQLITE_BUSY. */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <switch>switch<condition>( <expr><name>rc</name></expr> )</condition><block>{<block_content>
        <case>case <expr><name>SQLITE_ROW</name></expr>:</case>
          <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <return>return <expr><name>SQLITE_OK</name></expr>;</return>
        <case>case <expr><name>SQLITE_DONE</name></expr>:</case>
          <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <return>return <expr><name>SQLITE_OK</name></expr>;</return>
        <default>default:</default>
          <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <return>return <expr><name>rc</name></expr>;</return>
      </block_content>}</block></switch>
    <case>case <expr><name>QUERY_FULLTEXT</name></expr>:</case>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

      <if_stmt><if>if<condition>( <expr><call><name>readerAtEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>iDocid</name> <operator>=</operator> <call><name>readDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <comment type="block">/* TODO(shess) Handle SQLITE_SCHEMA AND SQLITE_BUSY. */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>   <comment type="block">/* the case we expect */</comment>
        <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>SQLITE_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* an error occurred; abort */</comment>
      <return>return <expr><ternary><condition><expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> ?</condition><then> <expr><name>SQLITE_ERROR</name></expr> </then><else>: <expr><name>rc</name></expr></else></ternary></expr>;</return>
    <default>default:</default>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>  <comment type="block">/* not reached */</comment>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>term_select_doclist</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,
                               <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppStmt</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><operator>*</operator><name>ppStmt</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_reset</name><argument_list>(<argument><expr><operator>*</operator><name>ppStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_prepare</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><name>ppStmt</name></expr></argument>,
      <argument><expr><literal type="string">"select doclist from %_term where term = ? order by first"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><operator>*</operator><name>ppStmt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>sqlite3_step</name><argument_list>(<argument><expr><operator>*</operator><name>ppStmt</name></expr></argument>)</argument_list></call></expr>;</return>   <comment type="block">/* TODO(adamd): handle schema error */</comment>
</block_content>}</block></function>

<comment type="block">/* Read the posting list for [zTerm]; AND it with the doclist [in] to
 * produce the doclist [out], using the given offset [iOffset] for phrase
 * matching.
 * (*pSelect) is used to hold an SQLite statement used inside this function;
 * the caller should initialize *pSelect to NULL before the first call.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>query_merge</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>pSelect</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>,
                       <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pIn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iOffset</name></decl></parameter>, <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DocListMerge</name></type> <name>merge</name></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>pIn</name><operator>!=</operator><name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pIn</name><operator>-&gt;</operator><name>nData</name></name></expr> )</condition><block>{<block_content>
    <comment type="block">/* If [pIn] is already empty, there's no point in reading the
     * posting list to AND it in; return immediately. */</comment>
      <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>term_select_doclist</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>mergeInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merge</name></expr></argument>, <argument><expr><name>pIn</name></expr></argument>, <argument><expr><name>iOffset</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_ROW</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>DocList</name></type> <name>block</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>docListInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>block</name></expr></argument>, <argument><expr><name>DL_POSITIONS_OFFSETS</name></expr></argument>,
                <argument><expr><call><name>sqlite3_column_blob</name><argument_list>(<argument><expr><operator>*</operator><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>sqlite3_column_bytes</name><argument_list>(<argument><expr><operator>*</operator><name>pSelect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>mergeBlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merge</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>docListDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sqlite3_step</name><argument_list>(<argument><expr><operator>*</operator><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name> <operator>&amp;&amp;</operator> <name>rc</name><operator>!=</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>QueryTerm</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>is_phrase</name></decl>;</decl_stmt>    <comment type="block">/* true if this term begins a new phrase */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl>;</decl_stmt>
}</block></struct></type> <name>QueryTerm</name>;</typedef>

<comment type="block">/* A parsed query.
 *
 * As an example, parsing the query ["four score" years "new nation"] will
 * yield a Query with 5 terms:
 *   "four",   is_phrase = 1
 *   "score",  is_phrase = 0
 *   "years",  is_phrase = 1
 *   "new",    is_phrase = 1
 *   "nation", is_phrase = 0
 */</comment>
<typedef>typedef <type><struct>struct <name>Query</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>nTerms</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>QueryTerm</name> <modifier>*</modifier></type><name>pTerm</name></decl>;</decl_stmt>
}</block></struct></type> <name>Query</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>query_add</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>q</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_phrase</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>QueryTerm</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>++</operator><name><name>q</name><operator>-&gt;</operator><name>nTerms</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>pTerm</name></name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>pTerm</name></name></expr></argument>, <argument><expr><name><name>q</name><operator>-&gt;</operator><name>nTerms</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>pTerm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>t</name> <operator>=</operator> <operator>&amp;</operator><name><name>q</name><operator>-&gt;</operator><name>pTerm</name><index>[<expr><name><name>q</name><operator>-&gt;</operator><name>nTerms</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>is_phrase</name></name> <operator>=</operator> <name>is_phrase</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>zTerm</name></name> <operator>=</operator> <name>zTerm</name></expr>;</expr_stmt>
</block_content>}</block></function>
    
<function><type><specifier>static</specifier> <name>void</name></type> <name>query_free</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>q</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>q</name><operator>-&gt;</operator><name>nTerms</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>q</name><operator>-&gt;</operator><name>pTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zTerm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>q</name><operator>-&gt;</operator><name>pTerm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>tokenize_segment</name><parameter_list>(<parameter><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zQuery</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>in_phrase</name></decl></parameter>,
                            <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>pQuery</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_module</name> <modifier>*</modifier></type><name>pModule</name> <init>= <expr><name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>is_first</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name><name>pModule</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pTokenizer</name></expr></argument>, <argument><expr><name>zQuery</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCursor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>pCursor</name><operator>-&gt;</operator><name>pTokenizer</name></name> <operator>=</operator> <name>pTokenizer</name></expr>;</expr_stmt>

  <while>while<condition>( <expr><literal type="number">1</literal></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zToken</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nToken</name></decl>, <decl><type ref="prev"/><name>iStartOffset</name></decl>, <decl><type ref="prev"/><name>iEndOffset</name></decl>, <decl><type ref="prev"/><name>dummy_pos</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>pModule</name><operator>-&gt;</operator><name>xNext</name></name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>zToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nToken</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>iStartOffset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iEndOffset</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>dummy_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>query_add</name><argument_list>(<argument><expr><name>pQuery</name></expr></argument>, <argument><expr><operator>!</operator><name>in_phrase</name> <operator>||</operator> <name>is_first</name></expr></argument>, <argument><expr><call><name>string_dup_n</name><argument_list>(<argument><expr><name>zToken</name></expr></argument>, <argument><expr><name>nToken</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>is_first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></while>

  <return>return <expr><call><name><name>pModule</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parse a query string, yielding a Query object. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_query</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zQuery</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>pQuery</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zQuery1</name> <init>= <expr><call><name>string_dup</name><argument_list>(<argument><expr><name>zQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>in_phrase</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>zQuery1</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>nTerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pQuery</name><operator>-&gt;</operator><name>pTerm</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <while>while<condition>( <expr><operator>*</operator><name>s</name></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
    <while>while<condition>( <expr><operator>*</operator><name>t</name></expr> )</condition><block>{<block_content>
      <if_stmt><if>if<condition>( <expr><operator>*</operator><name>t</name><operator>==</operator><literal type="char">'"'</literal></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>++</operator><name>t</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if<condition>( <expr><operator>*</operator><name>s</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>tokenize_segment</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>in_phrase</name></expr></argument>, <argument><expr><name>pQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>in_phrase</name> <operator>=</operator> <operator>!</operator><name>in_phrase</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zQuery1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Perform a full-text query; return a list of documents in [pResult]. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltext_query</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zQuery</name></decl></parameter>,
                          <parameter><decl><type><name>DocList</name> <modifier>*</modifier><modifier>*</modifier></type><name>pResult</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Query</name></type> <name>q</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>phrase_start</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>pSelect</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>parse_query</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>zQuery</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>q</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Merge terms. */</comment>
  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>q</name><operator>.</operator><name>nTerms</name></name></expr> ;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block>{<block_content>
    <comment type="block">/* In each merge step, we need to generate positions whenever we're
     * processing a phrase which hasn't ended yet. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>need_positions</name> <init>= <expr><name>i</name><operator>&lt;</operator><name><name>q</name><operator>.</operator><name>nTerms</name></name><operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>q</name><operator>.</operator><name>pTerm</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>is_phrase</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><call><name>docListNew</name><argument_list>(<argument><expr><ternary><condition><expr><name>need_positions</name></expr> ?</condition><then> <expr><name>DL_POSITIONS</name></expr> </then><else>: <expr><name>DL_DOCIDS</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>( <expr><name><name>q</name><operator>.</operator><name>pTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_phrase</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>phrase_start</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>query_merge</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pSelect</name></expr></argument>, <argument><expr><name><name>q</name><operator>.</operator><name>pTerm</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>zTerm</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <name>phrase_start</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>( <expr><name>d</name><operator>!=</operator><name>NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><call><name>docListDelete</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>d</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name>pSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>query_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pResult</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextFilter</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>,
                          <parameter><decl><type><name>int</name></type> <name>idxNum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxStr</name></decl></parameter>,
                          <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>cursor_vtab</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zStatement</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>iCursorType</name></name> <operator>=</operator> <name>idxNum</name></expr>;</expr_stmt>
  <switch>switch<condition>( <expr><name>idxNum</name></expr> )</condition><block>{<block_content>
    <case>case <expr><name>QUERY_GENERIC</name></expr>:</case>
      <expr_stmt><expr><name>zStatement</name> <operator>=</operator> <literal type="string">"select rowid, content from %_content"</literal></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>QUERY_FULLTEXT</name></expr>:</case>   <comment type="block">/* full-text search */</comment>
    <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zQuery</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>pResult</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>argc</name><operator>==</operator><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fulltext_query</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>zQuery</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>readerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name>pResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zStatement</name> <operator>=</operator> <literal type="string">"select rowid, content from %_content where rowid = ?"</literal></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
      <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></switch>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>sql_prepare</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>zName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><name>zStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><call><name>fulltextNext</name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextEof</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>c</name><operator>-&gt;</operator><name>eof</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextColumn</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>,
                          <parameter><decl><type><name>sqlite3_context</name> <modifier>*</modifier></type><name>pContext</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idxCol</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>idxCol</name><operator>==</operator><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>sqlite3_column_text</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sqlite3_result_text</name><argument_list>(<argument><expr><name>pContext</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextRowid</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_cursor</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>fulltext_cursor</name> <operator>*</operator><operator>)</operator> <name>pCursor</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><operator>*</operator><name>pRowid</name> <operator>=</operator> <call><name>sqlite3_column_int64</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>pStmt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Build a hash table containing all terms in zText. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>build_terms</name><parameter_list>(<parameter><decl><type><name>Hash</name> <modifier>*</modifier></type><name>terms</name></decl></parameter>, <parameter><decl><type><name>sqlite3_tokenizer</name> <modifier>*</modifier></type><name>pTokenizer</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite3_tokenizer_cursor</name> <modifier>*</modifier></type><name>pCursor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pToken</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nTokenBytes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iStartOffset</name></decl>, <decl><type ref="prev"/><name>iEndOffset</name></decl>, <decl><type ref="prev"/><name>iPosition</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>pTokenizer</name></expr></argument>, <argument><expr><name>zText</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pCursor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>pCursor</name><operator>-&gt;</operator><name>pTokenizer</name></name> <operator>=</operator> <name>pTokenizer</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>HashInit</name><argument_list>(<argument><expr><name>terms</name></expr></argument>, <argument><expr><name>HASH_STRING</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>( <expr><name>SQLITE_OK</name><operator>==</operator><call><name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xNext</name></name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>,
                                               <argument><expr><operator>&amp;</operator><name>pToken</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nTokenBytes</name></expr></argument>,
                                               <argument><expr><operator>&amp;</operator><name>iStartOffset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iEndOffset</name></expr></argument>,
                                               <argument><expr><operator>&amp;</operator><name>iPosition</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <comment type="block">/* Positions can't be negative; we use -1 as a terminator internally. */</comment>
    <if_stmt><if>if<condition>( <expr><name>iPosition</name><operator>&lt;</operator><literal type="number">0</literal></expr> )</condition> <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_ERROR</name></expr>;</expr_stmt>  
      <goto>goto <name>err</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>HashFind</name><argument_list>(<argument><expr><name>terms</name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>, <argument><expr><name>nTokenBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>p</name><operator>==</operator><name>NULL</name></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>docListNew</name><argument_list>(<argument><expr><name>DL_POSITIONS_OFFSETS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>docListAddDocid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>HashInsert</name><argument_list>(<argument><expr><name>terms</name></expr></argument>, <argument><expr><name>pToken</name></expr></argument>, <argument><expr><name>nTokenBytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>docListAddPosOffset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>iPosition</name></expr></argument>, <argument><expr><name>iStartOffset</name></expr></argument>, <argument><expr><name>iEndOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

<label><name>err</name>:</label>
  <comment type="block">/* TODO(shess) Check return?  Should this be able to cause errors at
  ** this point?  Actually, same question about sqlite3_finalize(),
  ** though one could argue that failure there means that the data is
  ** not durable.  *ponder*
  */</comment>
  <expr_stmt><expr><call><name><name>pTokenizer</name><operator>-&gt;</operator><name>pModule</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name>pCursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* Update the %_terms table to map the term [zTerm] to the given rowid. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>index_insert_term</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,
                             <parameter><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl></parameter>, <parameter><decl><type><name>DocList</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iFirst</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iIndexRow</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DocList</name></type> <name>doclist</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>term_chunk_select</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iFirst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>==</operator><name>SQLITE_DONE</name></expr> )</condition><block>{<block_content>
    <expr_stmt><expr><call><name>docListInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>, <argument><expr><name>DL_POSITIONS_OFFSETS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><call><name>docListUpdate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>term_insert</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>docListDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>SQLITE_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* This word is in the index; add this document ID to its blob. */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>term_select</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>iFirst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iIndexRow</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>docListUpdate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <comment type="block">/* If the blob is too big, split it in half. */</comment>
    <if_stmt><if>if<condition>( <expr><name><name>doclist</name><operator>.</operator><name>nData</name></name><operator>&gt;</operator><name>CHUNK_MAX</name></expr> )</condition><block>{<block_content>
      <decl_stmt><decl><type><name>DocList</name></type> <name>half</name></decl>;</decl_stmt>
      <if_stmt><if>if<condition>( <expr><call><name>docListSplit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>half</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>term_insert</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><call><name>firstDocid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>half</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>half</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>docListDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>half</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>term_update</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iIndexRow</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>err</name>:</label>
  <expr_stmt><expr><call><name>docListDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Insert a row into the full-text index; set *piRowid to be the ID of the
 * new row. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>index_insert</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
                        <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier></type><name>pRequestRowid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zText</name></decl></parameter>,
                        <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>piRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>Hash</name></type> <name>terms</name></decl>;</decl_stmt>  <comment type="block">/* maps term string -&gt; PosList */</comment>
  <decl_stmt><decl><type><name>HashElem</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>content_insert</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pRequestRowid</name></expr></argument>, <argument><expr><name>zText</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>piRowid</name> <operator>=</operator> <call><name>sqlite3_last_insert_rowid</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if<condition>( <expr><operator>!</operator><name>zText</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_OK</name></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* nothing to index */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>build_terms</name><argument_list>(<argument><expr><operator>&amp;</operator><name>terms</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></argument>, <argument><expr><name>zText</name></expr></argument>, <argument><expr><operator>*</operator><name>piRowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <for>for<control>(<init><expr><name>e</name><operator>=</operator><call><name>HashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name>terms</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>e</name><operator>=</operator><call><name>HashNext</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>HashData</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>index_insert_term</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>HashKey</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>HashKeysize</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>piRowid</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <for>for<control>(<init><expr><name>e</name><operator>=</operator><call><name>HashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name>terms</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>e</name><operator>=</operator><call><name>HashNext</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>HashData</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>docListDelete</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>HashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>terms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>index_delete_term</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zTerm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTerm</name></decl></parameter>,
                             <parameter><decl><type><name>sqlite_int64</name></type> <name>iDocid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iFirst</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sqlite_int64</name></type> <name>iIndexRow</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DocList</name></type> <name>doclist</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>term_chunk_select</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iFirst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_ROW</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>SQLITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>term_select</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>zTerm</name></expr></argument>, <argument><expr><name>nTerm</name></expr></argument>, <argument><expr><name>iFirst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iIndexRow</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>docListUpdate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>, <argument><expr><name>iDocid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
    <if_stmt><if>if<condition>( <expr><name><name>doclist</name><operator>.</operator><name>nData</name></name><operator>&gt;</operator><literal type="number">0</literal></expr> )</condition><block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>term_update</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iIndexRow</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>  <comment type="block">/* empty posting list */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>term_delete</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iIndexRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>docListDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>doclist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Delete a row from the full-text index. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>index_delete</name><parameter_list>(<parameter><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>iRow</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zText</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Hash</name></type> <name>terms</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HashElem</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>content_select</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iRow</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zText</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>build_terms</name><argument_list>(<argument><expr><operator>&amp;</operator><name>terms</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>pTokenizer</name></name></expr></argument>, <argument><expr><name>zText</name></expr></argument>, <argument><expr><name>iRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zText</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <for>for<control>(<init><expr><name>e</name><operator>=</operator><call><name>HashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name>terms</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>e</name><operator>=</operator><call><name>HashNext</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>index_delete_term</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>HashKey</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>HashKeysize</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>iRow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>( <expr><name>rc</name><operator>!=</operator><name>SQLITE_OK</name></expr> )</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <for>for<control>(<init><expr><name>e</name><operator>=</operator><call><name>HashFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name>terms</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>e</name><operator>=</operator><call><name>HashNext</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></incr>)</control><block>{<block_content>
    <decl_stmt><decl><type><name>DocList</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>HashData</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>docListDelete</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>HashClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>terms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>content_delete</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>iRow</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fulltextUpdate</name><parameter_list>(<parameter><decl><type><name>sqlite3_vtab</name> <modifier>*</modifier></type><name>pVtab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nArg</name></decl></parameter>, <parameter><decl><type><name>sqlite3_value</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppArg</name></decl></parameter>,
                   <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>pRowid</name></decl></parameter>)</parameter_list><block>{<block_content>
  <decl_stmt><decl><type><name>fulltext_vtab</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>fulltext_vtab</name> <operator>*</operator><operator>)</operator> <name>pVtab</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if<condition>( <expr><name>nArg</name><operator>&lt;</operator><literal type="number">2</literal></expr> )</condition><block>{<block_content>
    <return>return <expr><call><name>index_delete</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>sqlite3_value_int64</name><argument_list>(<argument><expr><name><name>ppArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if<condition>( <expr><call><name>sqlite3_value_type</name><argument_list>(<argument><expr><name><name>ppArg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SQLITE_NULL</name></expr> )</condition><block>{<block_content>
    <return>return <expr><name>SQLITE_ERROR</name></expr>;</return>   <comment type="block">/* an update; not yet supported */</comment>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>nArg</name><operator>==</operator><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* ppArg[1] = rowid, ppArg[2] = content */</comment>
  <return>return <expr><call><name>index_insert</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>ppArg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                      <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>sqlite3_value_text</name><argument_list>(<argument><expr><name><name>ppArg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pRowid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>sqlite3_module</name></type> <name>fulltextModule</name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>,
  <expr><name>fulltextCreate</name></expr>,
  <expr><name>fulltextConnect</name></expr>,
  <expr><name>fulltextBestIndex</name></expr>,
  <expr><name>fulltextDisconnect</name></expr>,
  <expr><name>fulltextDestroy</name></expr>,
  <expr><name>fulltextOpen</name></expr>,
  <expr><name>fulltextClose</name></expr>,
  <expr><name>fulltextFilter</name></expr>,
  <expr><name>fulltextNext</name></expr>,
  <expr><name>fulltextEof</name></expr>,
  <expr><name>fulltextColumn</name></expr>,
  <expr><name>fulltextRowid</name></expr>,
  <expr><name>fulltextUpdate</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type> <name>fulltext_init</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list><block>{<block_content>
 <return>return <expr><call><name>sqlite3_create_module</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"fulltext"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fulltextModule</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SQLITE_CORE</name></expr></cpp:if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
<macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>sqlite3_fulltext_init</name><parameter_list>(<parameter><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pzErrMsg</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>sqlite3_api_routines</name> <modifier>*</modifier></type><name>pApi</name></decl></parameter>)</parameter_list><block>{<block_content>
 <macro><name>SQLITE_EXTENSION_INIT2</name><argument_list>(<argument>pApi</argument>)</argument_list></macro>
 <return>return <expr><call><name>fulltext_init</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
