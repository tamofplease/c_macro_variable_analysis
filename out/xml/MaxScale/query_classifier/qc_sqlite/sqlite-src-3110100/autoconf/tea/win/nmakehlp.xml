<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/query_classifier/qc_sqlite/sqlite-src-3110100/autoconf/tea/win/nmakehlp.c"><comment type="block">/*
 * ----------------------------------------------------------------------------
 * nmakehlp.c --
 *
 *	This is used to fix limitations within nmake and the environment.
 *
 * Copyright (c) 2002 by David Gravereaux.
 * Copyright (c) 2006 by Pat Thoyts
 *
 * See the file "license.terms" for information on usage and redistribution of
 * this file, and for a DISCLAIMER OF ALL WARRANTIES.
 * ----------------------------------------------------------------------------
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_CRT_SECURE_NO_DEPRECATE</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_SHLWAPI_GDI</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_SHLWAPI_STREAM</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_SHLWAPI_REG</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;shlwapi.h&gt;</cpp:file></cpp:include>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>comment</name> <name>(</name><name>lib</name><name>,</name> <cpp:literal>"user32.lib"</cpp:literal><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>comment</name> <name>(</name><name>lib</name><name>,</name> <cpp:literal>"kernel32.lib"</cpp:literal><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>comment</name> <name>(</name><name>lib</name><name>,</name> <cpp:literal>"shlwapi.lib"</cpp:literal><name>)</name></cpp:pragma>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
 * This library is required for x64 builds with _some_ versions of MSVC
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_IA64</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_M_AMD64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1400</literal> <operator>&amp;&amp;</operator> <name>_MSC_VER</name> <operator>&lt;</operator> <literal type="number">1500</literal></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>comment</name><name>(</name><name>lib</name><name>,</name> <cpp:literal>"bufferoverflowU"</cpp:literal><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ISO hack for dumb VC++ */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive>   <cpp:macro><name>snprintf</name></cpp:macro>	<cpp:value>_snprintf</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<comment type="block">/* protos */</comment>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>CheckForCompilerFeature</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>option</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>CheckForLinkerFeature</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>option</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>IsIn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>substring</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>SubstituteFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>substs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>QualifyPath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>GetVersionFromFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>match</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DWORD</name> <name>WINAPI</name></type> <name>ReadFromPipe</name><parameter_list>(<parameter><decl><type><name>LPVOID</name></type> <name>args</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* globals */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNK</name></cpp:macro>	<cpp:value>25</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATICBUFFERSIZE</name></cpp:macro>    <cpp:value>1000</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>HANDLE</name></type> <name>pipe</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>STATICBUFFERSIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>pipeinfo</name>;</typedef>

<decl_stmt><decl><type><name>pipeinfo</name></type> <name>Out</name> <init>= <expr><block>{<expr><name>INVALID_HANDLE_VALUE</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pipeinfo</name></type> <name>Err</name> <init>= <expr><block>{<expr><name>INVALID_HANDLE_VALUE</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<escape char="0x0c"/>
<comment type="block">/*
 * exitcodes: 0 == no, 1 == yes, 2 == error
 */</comment>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(
    <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,
    <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>msg</name><index>[<expr><literal type="number">300</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>dwWritten</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>chars</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Make sure children (cl.exe and link.exe) are kept quiet.
     */</comment>

    <expr_stmt><expr><call><name>SetErrorMode</name><argument_list>(<argument><expr><name>SEM_FAILCRITICALERRORS</name> <operator>|</operator> <name>SEM_NOOPENFILEERRORBOX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Make sure the compiler and linker aren't effected by the outside world.
     */</comment>

    <expr_stmt><expr><call><name>SetEnvironmentVariable</name><argument_list>(<argument><expr><literal type="string">"CL"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetEnvironmentVariable</name><argument_list>(<argument><expr><literal type="string">"LINK"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
	<switch>switch <condition>(<expr><operator>*</operator><operator>(</operator><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
	<case>case <expr><literal type="char">'c'</literal></expr>:</case>
	    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>chars</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
		        <argument><expr><literal type="string">"usage: %s -c &lt;compiler option&gt;\n"</literal>
			<literal type="string">"Tests for whether cl.exe supports an option\n"</literal>
			<literal type="string">"exitcodes: 0 == no, 1 == yes, 2 == error\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteFile</name><argument_list>(<argument><expr><call><name>GetStdHandle</name><argument_list>(<argument><expr><name>STD_ERROR_HANDLE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>,
			<argument><expr><operator>&amp;</operator><name>dwWritten</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">2</literal></expr>;</return>
	    </block_content>}</block></if></if_stmt>
	    <return>return <expr><call><name>CheckForCompilerFeature</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
	<case>case <expr><literal type="char">'l'</literal></expr>:</case>
	    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>chars</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
	       		<argument><expr><literal type="string">"usage: %s -l &lt;linker option&gt;\n"</literal>
			<literal type="string">"Tests for whether link.exe supports an option\n"</literal>
			<literal type="string">"exitcodes: 0 == no, 1 == yes, 2 == error\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteFile</name><argument_list>(<argument><expr><call><name>GetStdHandle</name><argument_list>(<argument><expr><name>STD_ERROR_HANDLE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>,
			<argument><expr><operator>&amp;</operator><name>dwWritten</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">2</literal></expr>;</return>
	    </block_content>}</block></if></if_stmt>
	    <return>return <expr><call><name>CheckForLinkerFeature</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
	<case>case <expr><literal type="char">'f'</literal></expr>:</case>
	    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>chars</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
			<argument><expr><literal type="string">"usage: %s -f &lt;string&gt; &lt;substring&gt;\n"</literal>
			<literal type="string">"Find a substring within another\n"</literal>
			<literal type="string">"exitcodes: 0 == no, 1 == yes, 2 == error\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteFile</name><argument_list>(<argument><expr><call><name>GetStdHandle</name><argument_list>(<argument><expr><name>STD_ERROR_HANDLE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>,
			<argument><expr><operator>&amp;</operator><name>dwWritten</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">2</literal></expr>;</return>
	    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * If the string is blank, there is no match.
		 */</comment>

		<return>return <expr><literal type="number">0</literal></expr>;</return>
	    </block_content>}</block></if> <else>else <block>{<block_content>
		<return>return <expr><call><name>IsIn</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
	    </block_content>}</block></else></if_stmt>
	<case>case <expr><literal type="char">'s'</literal></expr>:</case>
	    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>chars</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
			<argument><expr><literal type="string">"usage: %s -s &lt;substitutions file&gt; &lt;file&gt;\n"</literal>
			<literal type="string">"Perform a set of string map type substutitions on a file\n"</literal>
			<literal type="string">"exitcodes: 0\n"</literal></expr></argument>,
			<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteFile</name><argument_list>(<argument><expr><call><name>GetStdHandle</name><argument_list>(<argument><expr><name>STD_ERROR_HANDLE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>,
			<argument><expr><operator>&amp;</operator><name>dwWritten</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">2</literal></expr>;</return>
	    </block_content>}</block></if></if_stmt>
	    <return>return <expr><call><name>SubstituteFile</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
	<case>case <expr><literal type="char">'V'</literal></expr>:</case>
	    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>chars</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
		    <argument><expr><literal type="string">"usage: %s -V filename matchstring\n"</literal>
		    <literal type="string">"Extract a version from a file:\n"</literal>
		    <literal type="string">"eg: pkgIndex.tcl \"package ifneeded http\""</literal></expr></argument>,
		    <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteFile</name><argument_list>(<argument><expr><call><name>GetStdHandle</name><argument_list>(<argument><expr><name>STD_ERROR_HANDLE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>dwWritten</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	    </block_content>}</block></if></if_stmt>
	    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>GetVersionFromFile</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr><literal type="number">0</literal></expr>;</return>
	<case>case <expr><literal type="char">'Q'</literal></expr>:</case>
	    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>chars</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
		    <argument><expr><literal type="string">"usage: %s -Q path\n"</literal>
		    <literal type="string">"Emit the fully qualified path\n"</literal>
		    <literal type="string">"exitcodes: 0 == no, 1 == yes, 2 == error\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WriteFile</name><argument_list>(<argument><expr><call><name>GetStdHandle</name><argument_list>(<argument><expr><name>STD_ERROR_HANDLE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>dwWritten</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">2</literal></expr>;</return>
	    </block_content>}</block></if></if_stmt>
	    <return>return <expr><call><name>QualifyPath</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>chars</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
	    <argument><expr><literal type="string">"usage: %s -c|-f|-l|-Q|-s|-V ...\n"</literal>
	    <literal type="string">"This is a little helper app to equalize shell differences between WinNT and\n"</literal>
	    <literal type="string">"Win9x and get nmake.exe to accomplish its job.\n"</literal></expr></argument>,
	    <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WriteFile</name><argument_list>(<argument><expr><call><name>GetStdHandle</name><argument_list>(<argument><expr><name>STD_ERROR_HANDLE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dwWritten</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>
<escape char="0x0c"/>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CheckForCompilerFeature</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>option</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>STARTUPINFO</name></type> <name>si</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PROCESS_INFORMATION</name></type> <name>pi</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SECURITY_ATTRIBUTES</name></type> <name>sa</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>threadID</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>msg</name><index>[<expr><literal type="number">300</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOOL</name></type> <name>ok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HANDLE</name></type> <name>hProcess</name></decl>, <decl><type ref="prev"/><name>h</name></decl>, <decl><type ref="prev"/><name><name>pipeThreads</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>cmdline</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>hProcess</name> <operator>=</operator> <call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pi</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PROCESS_INFORMATION</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>STARTUPINFO</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>si</name><operator>.</operator><name>cb</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>STARTUPINFO</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>si</name><operator>.</operator><name>dwFlags</name></name>   <operator>=</operator> <name>STARTF_USESTDHANDLES</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>si</name><operator>.</operator><name>hStdInput</name></name> <operator>=</operator> <name>INVALID_HANDLE_VALUE</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SECURITY_ATTRIBUTES</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sa</name><operator>.</operator><name>nLength</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SECURITY_ATTRIBUTES</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sa</name><operator>.</operator><name>lpSecurityDescriptor</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sa</name><operator>.</operator><name>bInheritHandle</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Create a non-inheritible pipe.
     */</comment>

    <expr_stmt><expr><call><name>CreatePipe</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Out</name><operator>.</operator><name>pipe</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Dupe the write side, make it inheritible, and close the original.
     */</comment>

    <expr_stmt><expr><call><name>DuplicateHandle</name><argument_list>(<argument><expr><name>hProcess</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>hProcess</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>si</name><operator>.</operator><name>hStdOutput</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
	    <argument><expr><name>DUPLICATE_SAME_ACCESS</name> <operator>|</operator> <name>DUPLICATE_CLOSE_SOURCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Same as above, but for the error side.
     */</comment>

    <expr_stmt><expr><call><name>CreatePipe</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Err</name><operator>.</operator><name>pipe</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DuplicateHandle</name><argument_list>(<argument><expr><name>hProcess</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>hProcess</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>si</name><operator>.</operator><name>hStdError</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
	    <argument><expr><name>DUPLICATE_SAME_ACCESS</name> <operator>|</operator> <name>DUPLICATE_CLOSE_SOURCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Base command line.
     */</comment>

    <expr_stmt><expr><call><name>lstrcpy</name><argument_list>(<argument><expr><name>cmdline</name></expr></argument>, <argument><expr><literal type="string">"cl.exe -nologo -c -TC -Zs -X -Fp.\\_junk.pch "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Append our option for testing
     */</comment>

    <expr_stmt><expr><call><name>lstrcat</name><argument_list>(<argument><expr><name>cmdline</name></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Filename to compile, which exists, but is nothing and empty.
     */</comment>

    <expr_stmt><expr><call><name>lstrcat</name><argument_list>(<argument><expr><name>cmdline</name></expr></argument>, <argument><expr><literal type="string">" .\\nul"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>CreateProcess</name><argument_list>(
	    <argument><expr><name>NULL</name></expr></argument>,	    <comment type="block">/* Module name. */</comment>
	    <argument><expr><name>cmdline</name></expr></argument>,	    <comment type="block">/* Command line. */</comment>
	    <argument><expr><name>NULL</name></expr></argument>,	    <comment type="block">/* Process handle not inheritable. */</comment>
	    <argument><expr><name>NULL</name></expr></argument>,	    <comment type="block">/* Thread handle not inheritable. */</comment>
	    <argument><expr><name>TRUE</name></expr></argument>,	    <comment type="block">/* yes, inherit handles. */</comment>
	    <argument><expr><name>DETACHED_PROCESS</name></expr></argument>, <comment type="block">/* No console for you. */</comment>
	    <argument><expr><name>NULL</name></expr></argument>,	    <comment type="block">/* Use parent's environment block. */</comment>
	    <argument><expr><name>NULL</name></expr></argument>,	    <comment type="block">/* Use parent's starting directory. */</comment>
	    <argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,	    <comment type="block">/* Pointer to STARTUPINFO structure. */</comment>
	    <argument><expr><operator>&amp;</operator><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	    <comment type="block">/* Pointer to PROCESS_INFORMATION structure. */</comment>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>DWORD</name></type> <name>err</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>chars</name> <init>= <expr><call><name>snprintf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
		<argument><expr><literal type="string">"Tried to launch: \"%s\", but got error [%u]: "</literal></expr></argument>, <argument><expr><name>cmdline</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>FormatMessage</name><argument_list>(<argument><expr><name>FORMAT_MESSAGE_FROM_SYSTEM</name><operator>|</operator><name>FORMAT_MESSAGE_IGNORE_INSERTS</name><operator>|</operator>
		<name>FORMAT_MESSAGE_MAX_WIDTH_MASK</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>LPVOID</name><operator>)</operator><operator>&amp;</operator><name><name>msg</name><index>[<expr><name>chars</name></expr>]</index></name></expr></argument>,
		<argument><expr><operator>(</operator><literal type="number">300</literal><operator>-</operator><name>chars</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WriteFile</name><argument_list>(<argument><expr><call><name>GetStdHandle</name><argument_list>(<argument><expr><name>STD_ERROR_HANDLE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>lstrlen</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">2</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Close our references to the write handles that have now been inherited.
     */</comment>

    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>si</name><operator>.</operator><name>hStdOutput</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>si</name><operator>.</operator><name>hStdError</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>WaitForInputIdle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>, <argument><expr><literal type="number">5000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hThread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Start the pipe reader threads.
     */</comment>

    <expr_stmt><expr><name><name>pipeThreads</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CreateThread</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ReadFromPipe</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>threadID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pipeThreads</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CreateThread</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ReadFromPipe</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Err</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>threadID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Block waiting for the process to end.
     */</comment>

    <expr_stmt><expr><call><name>WaitForSingleObject</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Wait for our pipe to get done reading, should it be a little slow.
     */</comment>

    <expr_stmt><expr><call><name>WaitForMultipleObjects</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>pipeThreads</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pipeThreads</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pipeThreads</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Look for the commandline warning code in both streams.
     *  - in MSVC 6 &amp; 7 we get D4002, in MSVC 8 we get D9002.
     */</comment>

    <return>return <expr><operator>!</operator><operator>(</operator><call><name>strstr</name><argument_list>(<argument><expr><name><name>Out</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"D4002"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name>
             <operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>Err</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"D4002"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name>
             <operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>Out</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"D9002"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name>
             <operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>Err</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"D9002"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name>
             <operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>Out</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"D2021"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name>
             <operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>Err</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"D2021"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<escape char="0x0c"/>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CheckForLinkerFeature</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>option</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>STARTUPINFO</name></type> <name>si</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PROCESS_INFORMATION</name></type> <name>pi</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SECURITY_ATTRIBUTES</name></type> <name>sa</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>threadID</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>msg</name><index>[<expr><literal type="number">300</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOOL</name></type> <name>ok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HANDLE</name></type> <name>hProcess</name></decl>, <decl><type ref="prev"/><name>h</name></decl>, <decl><type ref="prev"/><name><name>pipeThreads</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>cmdline</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>hProcess</name> <operator>=</operator> <call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pi</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PROCESS_INFORMATION</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>STARTUPINFO</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>si</name><operator>.</operator><name>cb</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>STARTUPINFO</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>si</name><operator>.</operator><name>dwFlags</name></name>   <operator>=</operator> <name>STARTF_USESTDHANDLES</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>si</name><operator>.</operator><name>hStdInput</name></name> <operator>=</operator> <name>INVALID_HANDLE_VALUE</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SECURITY_ATTRIBUTES</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sa</name><operator>.</operator><name>nLength</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SECURITY_ATTRIBUTES</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sa</name><operator>.</operator><name>lpSecurityDescriptor</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sa</name><operator>.</operator><name>bInheritHandle</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Create a non-inheritible pipe.
     */</comment>

    <expr_stmt><expr><call><name>CreatePipe</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Out</name><operator>.</operator><name>pipe</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Dupe the write side, make it inheritible, and close the original.
     */</comment>

    <expr_stmt><expr><call><name>DuplicateHandle</name><argument_list>(<argument><expr><name>hProcess</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>hProcess</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>si</name><operator>.</operator><name>hStdOutput</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
	    <argument><expr><name>DUPLICATE_SAME_ACCESS</name> <operator>|</operator> <name>DUPLICATE_CLOSE_SOURCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Same as above, but for the error side.
     */</comment>

    <expr_stmt><expr><call><name>CreatePipe</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Err</name><operator>.</operator><name>pipe</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DuplicateHandle</name><argument_list>(<argument><expr><name>hProcess</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>hProcess</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>si</name><operator>.</operator><name>hStdError</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
	    <argument><expr><name>DUPLICATE_SAME_ACCESS</name> <operator>|</operator> <name>DUPLICATE_CLOSE_SOURCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Base command line.
     */</comment>

    <expr_stmt><expr><call><name>lstrcpy</name><argument_list>(<argument><expr><name>cmdline</name></expr></argument>, <argument><expr><literal type="string">"link.exe -nologo "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Append our option for testing.
     */</comment>

    <expr_stmt><expr><call><name>lstrcat</name><argument_list>(<argument><expr><name>cmdline</name></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>CreateProcess</name><argument_list>(
	    <argument><expr><name>NULL</name></expr></argument>,	    <comment type="block">/* Module name. */</comment>
	    <argument><expr><name>cmdline</name></expr></argument>,	    <comment type="block">/* Command line. */</comment>
	    <argument><expr><name>NULL</name></expr></argument>,	    <comment type="block">/* Process handle not inheritable. */</comment>
	    <argument><expr><name>NULL</name></expr></argument>,	    <comment type="block">/* Thread handle not inheritable. */</comment>
	    <argument><expr><name>TRUE</name></expr></argument>,	    <comment type="block">/* yes, inherit handles. */</comment>
	    <argument><expr><name>DETACHED_PROCESS</name></expr></argument>, <comment type="block">/* No console for you. */</comment>
	    <argument><expr><name>NULL</name></expr></argument>,	    <comment type="block">/* Use parent's environment block. */</comment>
	    <argument><expr><name>NULL</name></expr></argument>,	    <comment type="block">/* Use parent's starting directory. */</comment>
	    <argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,	    <comment type="block">/* Pointer to STARTUPINFO structure. */</comment>
	    <argument><expr><operator>&amp;</operator><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	    <comment type="block">/* Pointer to PROCESS_INFORMATION structure. */</comment>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition> <block>{<block_content>
	<decl_stmt><decl><type><name>DWORD</name></type> <name>err</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>chars</name> <init>= <expr><call><name>snprintf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
		<argument><expr><literal type="string">"Tried to launch: \"%s\", but got error [%u]: "</literal></expr></argument>, <argument><expr><name>cmdline</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>FormatMessage</name><argument_list>(<argument><expr><name>FORMAT_MESSAGE_FROM_SYSTEM</name><operator>|</operator><name>FORMAT_MESSAGE_IGNORE_INSERTS</name><operator>|</operator>
		<name>FORMAT_MESSAGE_MAX_WIDTH_MASK</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>LPVOID</name><operator>)</operator><operator>&amp;</operator><name><name>msg</name><index>[<expr><name>chars</name></expr>]</index></name></expr></argument>,
		<argument><expr><operator>(</operator><literal type="number">300</literal><operator>-</operator><name>chars</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WriteFile</name><argument_list>(<argument><expr><call><name>GetStdHandle</name><argument_list>(<argument><expr><name>STD_ERROR_HANDLE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>lstrlen</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">2</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Close our references to the write handles that have now been inherited.
     */</comment>

    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>si</name><operator>.</operator><name>hStdOutput</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>si</name><operator>.</operator><name>hStdError</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>WaitForInputIdle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>, <argument><expr><literal type="number">5000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hThread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Start the pipe reader threads.
     */</comment>

    <expr_stmt><expr><name><name>pipeThreads</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CreateThread</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ReadFromPipe</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Out</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>threadID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pipeThreads</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CreateThread</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ReadFromPipe</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Err</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>threadID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Block waiting for the process to end.
     */</comment>

    <expr_stmt><expr><call><name>WaitForSingleObject</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>hProcess</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Wait for our pipe to get done reading, should it be a little slow.
     */</comment>

    <expr_stmt><expr><call><name>WaitForMultipleObjects</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>pipeThreads</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pipeThreads</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pipeThreads</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Look for the commandline warning code in the stderr stream.
     */</comment>

    <return>return <expr><operator>!</operator><operator>(</operator><call><name>strstr</name><argument_list>(<argument><expr><name><name>Out</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"LNK1117"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
	    <call><name>strstr</name><argument_list>(<argument><expr><name><name>Err</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"LNK1117"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
	    <call><name>strstr</name><argument_list>(<argument><expr><name><name>Out</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"LNK4044"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
	    <call><name>strstr</name><argument_list>(<argument><expr><name><name>Err</name><operator>.</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"LNK4044"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<escape char="0x0c"/>
<function><type><specifier>static</specifier> <name>DWORD</name> <name>WINAPI</name></type>
<name>ReadFromPipe</name><parameter_list>(
    <parameter><decl><type><name>LPVOID</name></type> <name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>pipeinfo</name> <modifier>*</modifier></type><name>pi</name> <init>= <expr><operator>(</operator><name>pipeinfo</name> <operator>*</operator><operator>)</operator> <name>args</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lastBuf</name> <init>= <expr><name><name>pi</name><operator>-&gt;</operator><name>buffer</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>dwRead</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOOL</name></type> <name>ok</name></decl>;</decl_stmt>

  <label><name>again</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>lastBuf</name> <operator>-</operator> <name><name>pi</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name>CHUNK</name> <operator>&gt;</operator> <name>STATICBUFFERSIZE</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>DWORD</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>ReadFile</name><argument_list>(<argument><expr><name><name>pi</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>, <argument><expr><name>lastBuf</name></expr></argument>, <argument><expr><name>CHUNK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dwRead</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name> <operator>||</operator> <name>dwRead</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>pi</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>lastBuf</name> <operator>+=</operator> <name>dwRead</name></expr>;</expr_stmt>
    <goto>goto <name>again</name>;</goto>

    <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* makes the compiler happy */</comment>
</block_content>}</block></function>
<escape char="0x0c"/>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>IsIn</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>substring</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><call><name>strstr</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<escape char="0x0c"/>
<comment type="block">/*
 * GetVersionFromFile --
 * 	Looks for a match string in a file and then returns the version
 * 	following the match where a version is anything acceptable to
 * 	package provide or package ifneeded.
 */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetVersionFromFile</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>match</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cbBuffer</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>szBuffer</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>szResult</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"rt"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>fp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
	<comment type="block">/*
	 * Read data until we see our match string.
	 */</comment>

	<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>szBuffer</name></expr></argument>, <argument><expr><name>cbBuffer</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
	    <decl_stmt><decl><type><name>LPSTR</name></type> <name>p</name></decl>, <decl><type ref="prev"/><name>q</name></decl>;</decl_stmt>

	    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>szBuffer</name></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Skip to first digit.
		 */</comment>

		<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		    <expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * Find ending whitespace.
		 */</comment>

		<expr_stmt><expr><name>q</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>*</operator><name>q</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>isalnum</name><argument_list>(<argument><expr><operator>*</operator><name>q</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
		    <expr_stmt><expr><operator>++</operator><name>q</name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>szBuffer</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>q</name> <operator>-</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>szBuffer</name><index>[<expr><name>q</name><operator>-</operator><name>p</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>szResult</name> <operator>=</operator> <name>szBuffer</name></expr>;</expr_stmt>
		<break>break;</break>
	    </block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>szResult</name></expr>;</return>
</block_content>}</block></function>
<escape char="0x0c"/>
<comment type="block">/*
 * List helpers for the SubstituteFile function
 */</comment>

<typedef>typedef <type><struct>struct <name>list_item_t</name> <block>{
    <decl_stmt><decl><type><name><name>struct</name> <name>list_item_t</name></name> <modifier>*</modifier></type><name>nextPtr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>value</name></decl>;</decl_stmt>
}</block></struct></type> <name>list_item_t</name>;</typedef>

<comment type="block">/* insert a list item into the list (list may be null) */</comment>
<function><type><specifier>static</specifier> <name>list_item_t</name> <modifier>*</modifier></type>
<name>list_insert</name><parameter_list>(<parameter><decl><type><name>list_item_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>listPtrPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>list_item_t</name> <modifier>*</modifier></type><name>itemPtr</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>list_item_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>itemPtr</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>itemPtr</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>itemPtr</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>itemPtr</name><operator>-&gt;</operator><name>nextPtr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<while>while<condition>(<expr><operator>*</operator><name>listPtrPtr</name></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><name>listPtrPtr</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>listPtrPtr</name><operator>)</operator><operator>-&gt;</operator><name>nextPtr</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>listPtrPtr</name> <operator>=</operator> <name>itemPtr</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>itemPtr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>list_free</name><parameter_list>(<parameter><decl><type><name>list_item_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>listPtrPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>list_item_t</name> <modifier>*</modifier></type><name>tmpPtr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>listPtr</name> <init>= <expr><operator>*</operator><name>listPtrPtr</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>listPtr</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>tmpPtr</name> <operator>=</operator> <name>listPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>listPtr</name> <operator>=</operator> <name><name>listPtr</name><operator>-&gt;</operator><name>nextPtr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tmpPtr</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tmpPtr</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmpPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>
<escape char="0x0c"/>
<comment type="block">/*
 * SubstituteFile --
 *	As windows doesn't provide anything useful like sed and it's unreliable
 *	to use the tclsh you are building against (consider x-platform builds -
 *	eg compiling AMD64 target from IX86) we provide a simple substitution
 *	option here to handle autoconf style substitutions.
 *	The substitution file is whitespace and line delimited. The file should
 *	consist of lines matching the regular expression:
 *	  \s*\S+\s+\S*$
 *
 *	Usage is something like:
 *	  nmakehlp -S &lt;&lt; $** &gt; $@
 *        @PACKAGE_NAME@ $(PACKAGE_NAME)
 *        @PACKAGE_VERSION@ $(PACKAGE_VERSION)
 *        &lt;&lt;
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>SubstituteFile</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>substitutions</name></decl></parameter>,
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>cbBuffer</name> <init>= <expr><literal type="number">1024</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>szBuffer</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>szCopy</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>szResult</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>list_item_t</name> <modifier>*</modifier></type><name>substPtr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"rt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

	<comment type="block">/*
	 * Build a list of substutitions from the first filename
	 */</comment>

	<expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>substitutions</name></expr></argument>, <argument><expr><literal type="string">"rt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>sp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
	    <while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>szBuffer</name></expr></argument>, <argument><expr><name>cbBuffer</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ks</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ke</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>vs</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ve</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>ks</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>szBuffer</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>ks</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ks</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>ks</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>++</operator><name>ks</name></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><name>ke</name> <operator>=</operator> <name>ks</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>ke</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ke</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>ke</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>++</operator><name>ke</name></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><name>vs</name> <operator>=</operator> <name>ke</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>vs</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>vs</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>vs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>++</operator><name>vs</name></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><name>ve</name> <operator>=</operator> <name>vs</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>ve</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ve</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><operator>*</operator><name>ve</name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>||</operator> <operator>*</operator><name>ve</name> <operator>==</operator> <literal type="char">'\n'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>++</operator><name>ve</name></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><operator>*</operator><name>ke</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><operator>*</operator><name>ve</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>substPtr</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>ks</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>vs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </block_content>}</block></while>
	    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* debug: dump the list */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_DEBUG</name></cpp:ifdef>
	<block>{<block_content>
	    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>list_item_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	    <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>substPtr</name></expr>;</init> <condition><expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nextPtr</name></name></expr><operator>,</operator> <expr><operator>++</operator><name>n</name></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"% 3d '%s' =&gt; '%s'\n"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </block_content>}</block></for>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	
	<comment type="block">/*
	 * Run the substitutions over each line of the input
	 */</comment>
	
	<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>szBuffer</name></expr></argument>, <argument><expr><name>cbBuffer</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
	    <decl_stmt><decl><type><name>list_item_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	    <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>substPtr</name></expr>;</init> <condition><expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>nextPtr</name></name></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name>szBuffer</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>m</name></expr>)</condition> <block>{<block_content>
		    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>op</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
		    <expr_stmt><expr><name>cp</name> <operator>=</operator> <name>szCopy</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>szBuffer</name></expr>;</expr_stmt>
		    <while>while <condition>(<expr><name>op</name> <operator>!=</operator> <name>m</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>op</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		    <expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
		    <while>while <condition>(<expr><name>sp</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>sp</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>sp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		    <expr_stmt><expr><name>op</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <while>while <condition>(<expr><operator>*</operator><name>op</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>op</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		    <expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>szBuffer</name></expr></argument>, <argument><expr><name>szCopy</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>szCopy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	    </block_content>}</block></for>
	    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><name>szBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>substPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<escape char="0x0c"/>
<comment type="block">/*
 * QualifyPath --
 *
 *	This composes the current working directory with a provided path
 *	and returns the fully qualified and normalized path.
 *	Mostly needed to setup paths for testing.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>QualifyPath</name><parameter_list>(
    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>szPath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>szCwd</name><index>[<expr><name>MAX_PATH</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>szTmp</name><index>[<expr><name>MAX_PATH</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GetCurrentDirectory</name><argument_list>(<argument><expr><name>MAX_PATH</name></expr></argument>, <argument><expr><name>szCwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>szPath</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><call><name>PathCombine</name><argument_list>(<argument><expr><name>szTmp</name></expr></argument>, <argument><expr><name>szCwd</name></expr></argument>, <argument><expr><name>szPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PathCanonicalize</name><argument_list>(<argument><expr><name>szCwd</name></expr></argument>, <argument><expr><name>szTmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>szCwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Local variables:
 *   mode: c
 *   c-basic-offset: 4
 *   fill-column: 78
 *   indent-tabs-mode: t
 *   tab-width: 8
 * End:
 */</comment>
</unit>
