<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/pcre2/src/pcre2_study.c"><comment type="block" format="doxygen">/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/</comment>

<comment type="block">/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
     Original API code Copyright (c) 1997-2012 University of Cambridge
          New API code Copyright (c) 2016-2020 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/</comment>

<comment type="block">/* This module contains functions for scanning a compiled pattern and
collecting data (e.g. minimum matching length). */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_internal.h"</cpp:file></cpp:include>

<comment type="block">/* The maximum remembered capturing brackets minimum. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_CACHE_BACKREF</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>

<comment type="block">/* Set a bit in the starting code unit bit map. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_BIT</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>re-&gt;start_bitmap[(c)/8] |= (1u &lt;&lt; ((c)&amp;7))</cpp:value></cpp:define>

<comment type="block">/* Returns from set_start_bits() */</comment>

<enum>enum <block>{ <decl><name>SSB_FAIL</name></decl>, <decl><name>SSB_DONE</name></decl>, <decl><name>SSB_CONTINUE</name></decl>, <decl><name>SSB_UNKNOWN</name></decl>, <decl><name>SSB_TOODEEP</name></decl> }</block>;</enum>


<comment type="block" format="doxygen">/*************************************************
*   Find the minimum subject length for a group  *
*************************************************/</comment>

<comment type="block">/* Scan a parenthesized group and compute the minimum length of subject that
is needed to match it. This is a lower bound; it does not mean there is a
string of that length that matches. In UTF mode, the result is in characters
rather than code units. The field in a compiled pattern for storing the minimum
length is 16-bits long (on the grounds that anything longer than that is
pathological), so we give up when we reach that amount. This also means that
integer overflow for really crazy patterns cannot happen.

Backreference minimum lengths are cached to speed up multiple references. This
function is called only when the highest back reference in the pattern is less
than or equal to MAX_CACHE_BACKREF, which is one less than the size of the
caching vector. The zeroth element contains the number of the highest set
value.

Arguments:
  re              compiled pattern block
  code            pointer to start of group (the bracket)
  startcode       pointer to start of the whole pattern's code
  utf             UTF flag
  recurses        chain of recurse_check to catch mutual recursion
  countptr        pointer to call count (to catch over complexity)
  backref_cache   vector for caching back references.

This function is no longer called when the pattern contains (*ACCEPT); however,
the old code for returning -1 is retained, just in case.

Returns:   the minimum length
           -1 \C in UTF-8 mode
              or (*ACCEPT)
              or pattern too complicated
           -2 internal error (missing capturing bracket)
           -3 internal error (opcode not listed)
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>find_minlength</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pcre2_real_code</name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>code</name></decl></parameter>,
  <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>startcode</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>utf</name></decl></parameter>, <parameter><decl><type><name>recurse_check</name> <modifier>*</modifier></type><name>recurses</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>countptr</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>backref_cache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>branchlength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prev_cap_recno</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prev_cap_d</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prev_recurse_recno</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prev_recurse_d</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>once_fudge</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>had_recurse</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>dupcapused</name> <init>= <expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_DUPCAPUSED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>nextbranch</name> <init>= <expr><name>code</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><operator>(</operator><name>PCRE2_UCHAR</name> <operator>*</operator><operator>)</operator><name>code</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>recurse_check</name></type> <name>this_recurse</name></decl>;</decl_stmt>

<comment type="block">/* If this is a "could be empty" group, its minimum length is 0. */</comment>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>code</name> <operator>&gt;=</operator> <name>OP_SBRA</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>code</name> <operator>&lt;=</operator> <name>OP_SCOND</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* Skip over capturing bracket number */</comment>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_CBRA</name> <operator>||</operator> <operator>*</operator><name>code</name> <operator>==</operator> <name>OP_CBRAPOS</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* A large and/or complex regex can take too long to process. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>countptr</name><operator>)</operator><operator>++</operator> <operator>&gt;</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* Scan along the opcodes for this branch. If we get to the end of the branch,
check the length against that of the other branches. If the accumulated length
passes 16-bits, reset to that value and skip the rest of the branch. */</comment>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>d</name></decl>, <decl><type ref="prev"/><name>min</name></decl>, <decl><type ref="prev"/><name>recno</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>op</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cs</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>branchlength</name> <operator>&gt;=</operator> <name>UINT16_MAX</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>branchlength</name> <operator>=</operator> <name>UINT16_MAX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name> <operator>*</operator><operator>)</operator><name>nextbranch</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>op</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name>op</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>OP_COND</name></expr>:</case>
    <case>case <expr><name>OP_SCOND</name></expr>:</case>

    <comment type="block">/* If there is only one branch in a condition, the implied branch has zero
    length, so we don't add anything. This covers the DEFINE "condition"
    automatically. If there are two branches we can treat it the same as any
    other non-capturing subpattern. */</comment>

    <expr_stmt><expr><name>cs</name> <operator>=</operator> <name>cc</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cs</name> <operator>!=</operator> <name>OP_ALT</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>cc</name> <operator>=</operator> <name>cs</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if></if_stmt>
    <goto>goto <name>PROCESS_NON_CAPTURE</name>;</goto>

    <case>case <expr><name>OP_BRA</name></expr>:</case>
    <comment type="block">/* There's a special case of OP_BRA, when it is wrapped round a repeated
    OP_RECURSE. We'd like to process the latter at this level so that
    remembering the value works for repeated cases. So we do nothing, but
    set a fudge value to skip over the OP_KET after the recurse. */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>cc</name><index>[<expr><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_RECURSE</name> <operator>&amp;&amp;</operator> <name><name>cc</name><index>[<expr><literal type="number">2</literal><operator>*</operator><operator>(</operator><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name><operator>)</operator></expr>]</index></name> <operator>==</operator> <name>OP_KET</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>once_fudge</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if></if_stmt>
    <comment type="block">/* Fall through */</comment>

    <case>case <expr><name>OP_ONCE</name></expr>:</case>
    <case>case <expr><name>OP_SCRIPT_RUN</name></expr>:</case>
    <case>case <expr><name>OP_SBRA</name></expr>:</case>
    <case>case <expr><name>OP_BRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SBRAPOS</name></expr>:</case>
    <label><name>PROCESS_NON_CAPTURE</name>:</label>
    <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>find_minlength</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>startcode</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>recurses</name></expr></argument>, <argument><expr><name>countptr</name></expr></argument>,
      <argument><expr><name>backref_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>d</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>d</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>branchlength</name> <operator>+=</operator> <name>d</name></expr>;</expr_stmt>
    <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* To save time for repeated capturing subpatterns, we remember the
    length of the previous one. Unfortunately we can't do the same for
    the unnumbered ones above. Nor can we do this if (?| is present in the
    pattern because captures with the same number are not then identical. */</comment>

    <case>case <expr><name>OP_CBRA</name></expr>:</case>
    <case>case <expr><name>OP_SCBRA</name></expr>:</case>
    <case>case <expr><name>OP_CBRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SCBRAPOS</name></expr>:</case>
    <expr_stmt><expr><name>recno</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dupcapused</name> <operator>||</operator> <name>recno</name> <operator>!=</operator> <name>prev_cap_recno</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>prev_cap_recno</name> <operator>=</operator> <name>recno</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>prev_cap_d</name> <operator>=</operator> <call><name>find_minlength</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>startcode</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>recurses</name></expr></argument>, <argument><expr><name>countptr</name></expr></argument>,
        <argument><expr><name>backref_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>prev_cap_d</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>prev_cap_d</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>branchlength</name> <operator>+=</operator> <name>prev_cap_d</name></expr>;</expr_stmt>
    <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* ACCEPT makes things far too complicated; we have to give up. In fact,
    from 10.34 onwards, if a pattern contains (*ACCEPT), this function is not
    used. However, leave the code in place, just in case. */</comment>

    <case>case <expr><name>OP_ACCEPT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT_ACCEPT</name></expr>:</case>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

    <comment type="block">/* Reached end of a branch; if it's a ket it is the end of a nested
    call. If it's ALT it is an alternation in a nested call. If it is END it's
    the end of the outer call. All can be handled by the same code. If the
    length of any branch is zero, there is no need to scan any subsequent
    branches. */</comment>

    <case>case <expr><name>OP_ALT</name></expr>:</case>
    <case>case <expr><name>OP_KET</name></expr>:</case>
    <case>case <expr><name>OP_KETRMAX</name></expr>:</case>
    <case>case <expr><name>OP_KETRMIN</name></expr>:</case>
    <case>case <expr><name>OP_KETRPOS</name></expr>:</case>
    <case>case <expr><name>OP_END</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><operator>!</operator><name>had_recurse</name> <operator>&amp;&amp;</operator> <name>branchlength</name> <operator>&lt;</operator> <name>length</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>length</name> <operator>=</operator> <name>branchlength</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>op</name> <operator>!=</operator> <name>OP_ALT</name> <operator>||</operator> <name>length</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>length</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nextbranch</name> <operator>=</operator> <name>cc</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>branchlength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>had_recurse</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* Skip over assertive subpatterns */</comment>

    <case>case <expr><name>OP_ASSERT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT_NOT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NOT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT_NA</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NA</name></expr>:</case>
    <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
    <comment type="block">/* Fall through */</comment>

    <comment type="block">/* Skip over things that don't match chars */</comment>

    <case>case <expr><name>OP_REVERSE</name></expr>:</case>
    <case>case <expr><name>OP_CREF</name></expr>:</case>
    <case>case <expr><name>OP_DNCREF</name></expr>:</case>
    <case>case <expr><name>OP_RREF</name></expr>:</case>
    <case>case <expr><name>OP_DNRREF</name></expr>:</case>
    <case>case <expr><name>OP_FALSE</name></expr>:</case>
    <case>case <expr><name>OP_TRUE</name></expr>:</case>
    <case>case <expr><name>OP_CALLOUT</name></expr>:</case>
    <case>case <expr><name>OP_SOD</name></expr>:</case>
    <case>case <expr><name>OP_SOM</name></expr>:</case>
    <case>case <expr><name>OP_EOD</name></expr>:</case>
    <case>case <expr><name>OP_EODN</name></expr>:</case>
    <case>case <expr><name>OP_CIRC</name></expr>:</case>
    <case>case <expr><name>OP_CIRCM</name></expr>:</case>
    <case>case <expr><name>OP_DOLL</name></expr>:</case>
    <case>case <expr><name>OP_DOLLM</name></expr>:</case>
    <case>case <expr><name>OP_NOT_WORD_BOUNDARY</name></expr>:</case>
    <case>case <expr><name>OP_WORD_BOUNDARY</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>cc</name></expr>]</index></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CALLOUT_STR</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* Skip over a subpattern that has a {0} or {0,x} quantifier */</comment>

    <case>case <expr><name>OP_BRAZERO</name></expr>:</case>
    <case>case <expr><name>OP_BRAMINZERO</name></expr>:</case>
    <case>case <expr><name>OP_BRAPOSZERO</name></expr>:</case>
    <case>case <expr><name>OP_SKIPZERO</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>cc</name></expr>]</index></expr>;</expr_stmt>
    <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* Handle literal characters and + repetitions */</comment>

    <case>case <expr><name>OP_CHAR</name></expr>:</case>
    <case>case <expr><name>OP_CHARI</name></expr>:</case>
    <case>case <expr><name>OP_NOT</name></expr>:</case>
    <case>case <expr><name>OP_NOTI</name></expr>:</case>
    <case>case <expr><name>OP_PLUS</name></expr>:</case>
    <case>case <expr><name>OP_PLUSI</name></expr>:</case>
    <case>case <expr><name>OP_MINPLUS</name></expr>:</case>
    <case>case <expr><name>OP_MINPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_POSPLUS</name></expr>:</case>
    <case>case <expr><name>OP_POSPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPLUS</name></expr>:</case>
    <case>case <expr><name>OP_NOTPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINPLUS</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSPLUS</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSPLUSI</name></expr>:</case>
    <expr_stmt><expr><name>branchlength</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>

    <case>case <expr><name>OP_TYPEPLUS</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINPLUS</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSPLUS</name></expr>:</case>
    <expr_stmt><expr><name>branchlength</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <ternary><condition><expr><operator>(</operator><name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>OP_PROP</name> <operator>||</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* Handle exact repetitions. The count is already in characters, but we
    may need to skip over a multibyte character in UTF mode.  */</comment>

    <case>case <expr><name>OP_EXACT</name></expr>:</case>
    <case>case <expr><name>OP_EXACTI</name></expr>:</case>
    <case>case <expr><name>OP_NOTEXACT</name></expr>:</case>
    <case>case <expr><name>OP_NOTEXACTI</name></expr>:</case>
    <expr_stmt><expr><name>branchlength</name> <operator>+=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>

    <case>case <expr><name>OP_TYPEEXACT</name></expr>:</case>
    <expr_stmt><expr><name>branchlength</name> <operator>+=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <name>IMM2_SIZE</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>cc</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_PROP</name>
      <operator>||</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* Handle single-char non-literal matchers */</comment>

    <case>case <expr><name>OP_PROP</name></expr>:</case>
    <case>case <expr><name>OP_NOTPROP</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>

    <case>case <expr><name>OP_NOT_DIGIT</name></expr>:</case>
    <case>case <expr><name>OP_DIGIT</name></expr>:</case>
    <case>case <expr><name>OP_NOT_WHITESPACE</name></expr>:</case>
    <case>case <expr><name>OP_WHITESPACE</name></expr>:</case>
    <case>case <expr><name>OP_NOT_WORDCHAR</name></expr>:</case>
    <case>case <expr><name>OP_WORDCHAR</name></expr>:</case>
    <case>case <expr><name>OP_ANY</name></expr>:</case>
    <case>case <expr><name>OP_ALLANY</name></expr>:</case>
    <case>case <expr><name>OP_EXTUNI</name></expr>:</case>
    <case>case <expr><name>OP_HSPACE</name></expr>:</case>
    <case>case <expr><name>OP_NOT_HSPACE</name></expr>:</case>
    <case>case <expr><name>OP_VSPACE</name></expr>:</case>
    <case>case <expr><name>OP_NOT_VSPACE</name></expr>:</case>
    <expr_stmt><expr><name>branchlength</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* "Any newline" might match two characters, but it also might match just
    one. */</comment>

    <case>case <expr><name>OP_ANYNL</name></expr>:</case>
    <expr_stmt><expr><name>branchlength</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* The single-byte matcher means we can't proceed in UTF mode. (In
    non-UTF mode \C will actually be turned into OP_ALLANY, so won't ever
    appear, but leave the code, just in case.) */</comment>

    <case>case <expr><name>OP_ANYBYTE</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>branchlength</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* For repeated character types, we have to test for \p and \P, which have
    an extra two bytes of parameters. */</comment>

    <case>case <expr><name>OP_TYPESTAR</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINSTAR</name></expr>:</case>
    <case>case <expr><name>OP_TYPEQUERY</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINQUERY</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSQUERY</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>OP_PROP</name> <operator>||</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>op</name></expr>]</index></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_TYPEUPTO</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINUPTO</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSUPTO</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>cc</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_PROP</name>
      <operator>||</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>op</name></expr>]</index></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* Check a class for variable quantification */</comment>

    <case>case <expr><name>OP_CLASS</name></expr>:</case>
    <case>case <expr><name>OP_NCLASS</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>
    <case>case <expr><name>OP_XCLASS</name></expr>:</case>
    <comment type="block">/* The original code caused an unsigned overflow in 64 bit systems,
    so now we use a conditional statement. */</comment>
    <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>OP_XCLASS</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>OP_CLASS</name></expr>]</index></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>OP_CLASS</name></expr>]</index></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <switch>switch <condition>(<expr><operator>*</operator><name>cc</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>OP_CRPLUS</name></expr>:</case>
      <case>case <expr><name>OP_CRMINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_CRPOSPLUS</name></expr>:</case>
      <expr_stmt><expr><name>branchlength</name><operator>++</operator></expr>;</expr_stmt>
      <comment type="block">/* Fall through */</comment>

      <case>case <expr><name>OP_CRSTAR</name></expr>:</case>
      <case>case <expr><name>OP_CRMINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_CRQUERY</name></expr>:</case>
      <case>case <expr><name>OP_CRMINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_CRPOSSTAR</name></expr>:</case>
      <case>case <expr><name>OP_CRPOSQUERY</name></expr>:</case>
      <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_CRRANGE</name></expr>:</case>
      <case>case <expr><name>OP_CRMINRANGE</name></expr>:</case>
      <case>case <expr><name>OP_CRPOSRANGE</name></expr>:</case>
      <expr_stmt><expr><name>branchlength</name> <operator>+=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
      <break>break;</break>

      <default>default:</default>
      <expr_stmt><expr><name>branchlength</name><operator>++</operator></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></switch>
    <break>break;</break>

    <comment type="block">/* Backreferences and subroutine calls (OP_RECURSE) are treated in the same
    way: we find the minimum length for the subpattern. A recursion
    (backreference or subroutine) causes an a flag to be set that causes the
    length of this branch to be ignored. The logic is that a recursion can only
    make sense if there is another alternative that stops the recursing. That
    will provide the minimum length (when no recursion happens).

    If PCRE2_MATCH_UNSET_BACKREF is set, a backreference to an unset bracket
    matches an empty string (by default it causes a matching failure), so in
    that case we must set the minimum length to zero.

    For backreferenes, if duplicate numbers are present in the pattern we check
    for a reference to a duplicate. If it is, we don't know which version will
    be referenced, so we have to set the minimum length to zero. */</comment>

    <comment type="block">/* Duplicate named pattern back reference. */</comment>

    <case>case <expr><name>OP_DNREF</name></expr>:</case>
    <case>case <expr><name>OP_DNREFI</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dupcapused</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_MATCH_UNSET_BACKREF</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>slot</name> <init>=
        <expr><operator>(</operator><name>PCRE2_UCHAR</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>re</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pcre2_real_code</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>+</operator>
          <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>re</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>d</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt>

      <comment type="block">/* Scan all groups with the same name; find the shortest. */</comment>

      <while>while <condition>(<expr><name>count</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>dd</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>recno</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>recno</name> <operator>&lt;=</operator> <name><name>backref_cache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>backref_cache</name><index>[<expr><name>recno</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>dd</name> <operator>=</operator> <name><name>backref_cache</name><index>[<expr><name>recno</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
        <else>else
          <block>{<block_content>
          <expr_stmt><expr><name>ce</name> <operator>=</operator> <name>cs</name> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name> <operator>*</operator><operator>)</operator><call><call><name>PRIV</name><argument_list>(<argument><expr><name>find_bracket</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>startcode</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>recno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>cs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
          <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>ce</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>ce</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>

          <expr_stmt><expr><name>dd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dupcapused</name> <operator>||</operator>
              <operator>(</operator><name>PCRE2_UCHAR</name> <operator>*</operator><operator>)</operator><call><call><name>PRIV</name><argument_list>(<argument><expr><name>find_bracket</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>recno</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&gt;</operator> <name>cs</name> <operator>&amp;&amp;</operator> <name>cc</name> <operator>&lt;</operator> <name>ce</name></expr>)</condition>    <comment type="block">/* Simple recursion */</comment>
              <block>{<block_content>
              <expr_stmt><expr><name>had_recurse</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
              </block_content>}</block></if>
            <else>else
              <block>{<block_content>
              <decl_stmt><decl><type><name>recurse_check</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name>recurses</name></expr></init></decl>;</decl_stmt>
              <for>for <control>(<init><expr><name>r</name> <operator>=</operator> <name>recurses</name></expr>;</init> <condition><expr><name>r</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>r</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>group</name></name> <operator>==</operator> <name>cs</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
              <if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>           <comment type="block">/* Mutual recursion */</comment>
                <block>{<block_content>
                <expr_stmt><expr><name>had_recurse</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
                </block_content>}</block></if>
              <else>else
                <block>{<block_content>
                <expr_stmt><expr><name><name>this_recurse</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <name>recurses</name></expr>;</expr_stmt>  <comment type="block">/* No recursion */</comment>
                <expr_stmt><expr><name><name>this_recurse</name><operator>.</operator><name>group</name></name> <operator>=</operator> <name>cs</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>dd</name> <operator>=</operator> <call><name>find_minlength</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>, <argument><expr><name>startcode</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>this_recurse</name></expr></argument>,
                  <argument><expr><name>countptr</name></expr></argument>, <argument><expr><name>backref_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>dd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>dd</name></expr>;</return></block_content></block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

          <expr_stmt><expr><name><name>backref_cache</name><index>[<expr><name>recno</name></expr>]</index></name> <operator>=</operator> <name>dd</name></expr>;</expr_stmt>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>backref_cache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>recno</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>backref_cache</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
          <expr_stmt><expr><name><name>backref_cache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>recno</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>dd</name> <operator>&lt;</operator> <name>d</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>d</name> <operator>=</operator> <name>dd</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>d</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>    <comment type="block">/* No point looking at any more */</comment>
        <expr_stmt><expr><name>slot</name> <operator>+=</operator> <name><name>re</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>d</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>IMM2_SIZE</name></expr>;</expr_stmt>
    <goto>goto <name>REPEAT_BACK_REFERENCE</name>;</goto>

    <comment type="block">/* Single back reference by number. References by name are converted to by
    number when there is no duplication. */</comment>

    <case>case <expr><name>OP_REF</name></expr>:</case>
    <case>case <expr><name>OP_REFI</name></expr>:</case>
    <expr_stmt><expr><name>recno</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>recno</name> <operator>&lt;=</operator> <name><name>backref_cache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>backref_cache</name><index>[<expr><name>recno</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>backref_cache</name><index>[<expr><name>recno</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
    <else>else
      <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>d</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_MATCH_UNSET_BACKREF</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>ce</name> <operator>=</operator> <name>cs</name> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name> <operator>*</operator><operator>)</operator><call><call><name>PRIV</name><argument_list>(<argument><expr><name>find_bracket</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>startcode</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>recno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>cs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
        <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>ce</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>ce</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dupcapused</name> <operator>||</operator>
            <operator>(</operator><name>PCRE2_UCHAR</name> <operator>*</operator><operator>)</operator><call><call><name>PRIV</name><argument_list>(<argument><expr><name>find_bracket</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>recno</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&gt;</operator> <name>cs</name> <operator>&amp;&amp;</operator> <name>cc</name> <operator>&lt;</operator> <name>ce</name></expr>)</condition>    <comment type="block">/* Simple recursion */</comment>
            <block>{<block_content>
            <expr_stmt><expr><name>had_recurse</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
            </block_content>}</block></if>
          <else>else
            <block>{<block_content>
            <decl_stmt><decl><type><name>recurse_check</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name>recurses</name></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><expr><name>r</name> <operator>=</operator> <name>recurses</name></expr>;</init> <condition><expr><name>r</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>r</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control><block type="pseudo"><block_content> <if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>group</name></name> <operator>==</operator> <name>cs</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
            <if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>           <comment type="block">/* Mutual recursion */</comment>
              <block>{<block_content>
              <expr_stmt><expr><name>had_recurse</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
              </block_content>}</block></if>
            <else>else                     <comment type="block">/* No recursion */</comment>
              <block>{<block_content>
              <expr_stmt><expr><name><name>this_recurse</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <name>recurses</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>this_recurse</name><operator>.</operator><name>group</name></name> <operator>=</operator> <name>cs</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>find_minlength</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>, <argument><expr><name>startcode</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>this_recurse</name></expr></argument>, <argument><expr><name>countptr</name></expr></argument>,
                <argument><expr><name>backref_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if_stmt><if>if <condition>(<expr><name>d</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>d</name></expr>;</return></block_content></block></if></if_stmt>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name><name>backref_cache</name><index>[<expr><name>recno</name></expr>]</index></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>backref_cache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>recno</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>backref_cache</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
      <expr_stmt><expr><name><name>backref_cache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>recno</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>

    <comment type="block">/* Handle repeated back references */</comment>

    <label><name>REPEAT_BACK_REFERENCE</name>:</label>
    <switch>switch <condition>(<expr><operator>*</operator><name>cc</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>OP_CRSTAR</name></expr>:</case>
      <case>case <expr><name>OP_CRMINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_CRQUERY</name></expr>:</case>
      <case>case <expr><name>OP_CRMINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_CRPOSSTAR</name></expr>:</case>
      <case>case <expr><name>OP_CRPOSQUERY</name></expr>:</case>
      <expr_stmt><expr><name>min</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_CRPLUS</name></expr>:</case>
      <case>case <expr><name>OP_CRMINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_CRPOSPLUS</name></expr>:</case>
      <expr_stmt><expr><name>min</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_CRRANGE</name></expr>:</case>
      <case>case <expr><name>OP_CRMINRANGE</name></expr>:</case>
      <case>case <expr><name>OP_CRPOSRANGE</name></expr>:</case>
      <expr_stmt><expr><name>min</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
      <break>break;</break>

      <default>default:</default>
      <expr_stmt><expr><name>min</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></switch>

     <comment type="block">/* Take care not to overflow: (1) min and d are ints, so check that their
     product is not greater than INT_MAX. (2) branchlength is limited to
     UINT16_MAX (checked at the top of the loop). */</comment>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>INT_MAX</name><operator>/</operator><name>d</name><operator>)</operator> <operator>&lt;</operator> <name>min</name><operator>)</operator> <operator>||</operator> <name>UINT16_MAX</name> <operator>-</operator> <name>branchlength</name> <operator>&lt;</operator> <name>min</name><operator>*</operator><name>d</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>branchlength</name> <operator>=</operator> <name>UINT16_MAX</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>branchlength</name> <operator>+=</operator> <name>min</name> <operator>*</operator> <name>d</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <break>break;</break>

    <comment type="block">/* Recursion always refers to the first occurrence of a subpattern with a
    given number. Therefore, we can always make use of caching, even when the
    pattern contains multiple subpatterns with the same number. */</comment>

    <case>case <expr><name>OP_RECURSE</name></expr>:</case>
    <expr_stmt><expr><name>cs</name> <operator>=</operator> <name>ce</name> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name> <operator>*</operator><operator>)</operator><name>startcode</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>recno</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>recno</name> <operator>==</operator> <name>prev_recurse_recno</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>branchlength</name> <operator>+=</operator> <name>prev_recurse_d</name></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>ce</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>ce</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
      <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&gt;</operator> <name>cs</name> <operator>&amp;&amp;</operator> <name>cc</name> <operator>&lt;</operator> <name>ce</name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* Simple recursion */</comment>
        <expr_stmt><expr><name>had_recurse</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>
      <else>else
        <block>{<block_content>
        <decl_stmt><decl><type><name>recurse_check</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name>recurses</name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>r</name> <operator>=</operator> <name>recurses</name></expr>;</init> <condition><expr><name>r</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>r</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control><block type="pseudo"><block_content> <if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>group</name></name> <operator>==</operator> <name>cs</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
        <if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>          <comment type="block">/* Mutual recursion */</comment>
          <expr_stmt><expr><name>had_recurse</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>
        <else>else
          <block>{<block_content>
          <expr_stmt><expr><name><name>this_recurse</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <name>recurses</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>this_recurse</name><operator>.</operator><name>group</name></name> <operator>=</operator> <name>cs</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>prev_recurse_d</name> <operator>=</operator> <call><name>find_minlength</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>, <argument><expr><name>startcode</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>this_recurse</name></expr></argument>,
            <argument><expr><name>countptr</name></expr></argument>, <argument><expr><name>backref_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>prev_recurse_d</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>prev_recurse_d</name></expr>;</return></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>prev_recurse_recno</name> <operator>=</operator> <name>recno</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>branchlength</name> <operator>+=</operator> <name>prev_recurse_d</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <name>once_fudge</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>once_fudge</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* Anything else does not or need not match a character. We can get the
    item's length from the table, but for those that can match zero occurrences
    of a character, we must take special action for UTF-8 characters. As it
    happens, the "NOT" versions of these opcodes are used at present only for
    ASCII characters, so they could be omitted from this list. However, in
    future that may change, so we include them here so as not to leave a
    gotcha for a future maintainer. */</comment>

    <case>case <expr><name>OP_UPTO</name></expr>:</case>
    <case>case <expr><name>OP_UPTOI</name></expr>:</case>
    <case>case <expr><name>OP_NOTUPTO</name></expr>:</case>
    <case>case <expr><name>OP_NOTUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_MINUPTO</name></expr>:</case>
    <case>case <expr><name>OP_MINUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINUPTO</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_POSUPTO</name></expr>:</case>
    <case>case <expr><name>OP_POSUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSUPTO</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSUPTOI</name></expr>:</case>

    <case>case <expr><name>OP_STAR</name></expr>:</case>
    <case>case <expr><name>OP_STARI</name></expr>:</case>
    <case>case <expr><name>OP_NOTSTAR</name></expr>:</case>
    <case>case <expr><name>OP_NOTSTARI</name></expr>:</case>
    <case>case <expr><name>OP_MINSTAR</name></expr>:</case>
    <case>case <expr><name>OP_MINSTARI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINSTAR</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINSTARI</name></expr>:</case>
    <case>case <expr><name>OP_POSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_POSSTARI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSSTARI</name></expr>:</case>

    <case>case <expr><name>OP_QUERY</name></expr>:</case>
    <case>case <expr><name>OP_QUERYI</name></expr>:</case>
    <case>case <expr><name>OP_NOTQUERY</name></expr>:</case>
    <case>case <expr><name>OP_NOTQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_MINQUERY</name></expr>:</case>
    <case>case <expr><name>OP_MINQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINQUERY</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_POSQUERY</name></expr>:</case>
    <case>case <expr><name>OP_POSQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSQUERY</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSQUERYI</name></expr>:</case>

    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>op</name></expr>]</index></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>

    <comment type="block">/* Skip these, but we need to add in the name length. */</comment>

    <case>case <expr><name>OP_MARK</name></expr>:</case>
    <case>case <expr><name>OP_COMMIT_ARG</name></expr>:</case>
    <case>case <expr><name>OP_PRUNE_ARG</name></expr>:</case>
    <case>case <expr><name>OP_SKIP_ARG</name></expr>:</case>
    <case>case <expr><name>OP_THEN_ARG</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>op</name></expr>]</index> <operator>+</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* The remaining opcodes are just skipped over. */</comment>

    <case>case <expr><name>OP_CLOSE</name></expr>:</case>
    <case>case <expr><name>OP_COMMIT</name></expr>:</case>
    <case>case <expr><name>OP_FAIL</name></expr>:</case>
    <case>case <expr><name>OP_PRUNE</name></expr>:</case>
    <case>case <expr><name>OP_SET_SOM</name></expr>:</case>
    <case>case <expr><name>OP_SKIP</name></expr>:</case>
    <case>case <expr><name>OP_THEN</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>op</name></expr>]</index></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* This should not occur: we list all opcodes explicitly so that when
    new ones get added they are properly considered. */</comment>

    <default>default:</default>
    <return>return <expr><operator>-</operator><literal type="number">3</literal></expr>;</return>
    </block_content>}</block></switch>
  </block_content>}</block></for>
<comment type="block">/* Control never gets here */</comment>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*      Set a bit and maybe its alternate case    *
*************************************************/</comment>

<comment type="block">/* Given a character, set its first code unit's bit in the table, and also the
corresponding bit for the other version of a letter if we are caseless.

Arguments:
  re            points to the regex block
  p             points to the first code unit of the character
  caseless      TRUE if caseless
  utf           TRUE for UTF mode
  ucp           TRUE for UCP mode

Returns:        pointer after the character
*/</comment>

<function><type><specifier>static</specifier> <name>PCRE2_SPTR</name></type>
<name>set_table_bit</name><parameter_list>(<parameter><decl><type><name>pcre2_real_code</name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>caseless</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>utf</name></decl></parameter>,
  <parameter><decl><type><name>BOOL</name></type> <name>ucp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>p</name><operator>++</operator></expr></init></decl>;</decl_stmt>   <comment type="block">/* First code unit */</comment>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>utf</name></expr>;</expr_stmt>           <comment type="block">/* Stop compiler warnings when UTF not supported */</comment>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>ucp</name></expr>;</expr_stmt>

<comment type="block">/* In 16-bit and 32-bit modes, code units greater than 0xff set the bit for
0xff. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0xff</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<comment type="block">/* In UTF-8 or UTF-16 mode, pick up the remaining code units in order to find
the end of the character, even when caseless. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">0xc0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>GETUTF8INC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:elif>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0xfc00</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xd800</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>GETUTF16INC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

<comment type="block">/* If caseless, handle the other case of the character. */</comment>

<if_stmt><if>if <condition>(<expr><name>caseless</name></expr>)</condition>
  <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>||</operator> <name>ucp</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name><name>buff</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><call><name>PRIV</name><argument_list>(<argument><expr><name>ord2utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>buff</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* 16-bit or 32-bit mode */</comment>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0xff</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>

  <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

  <comment type="block">/* Not UTF or UCP */</comment>

  if <condition>(<expr><call><name>MAX_255</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>tables</name><index>[<expr><name>fcc_offset</name> <operator>+</operator> <name>c</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*     Set bits for a positive character type     *
*************************************************/</comment>

<comment type="block">/* This function sets starting bits for a character type. In UTF-8 mode, we can
only do a direct setting for bytes less than 128, as otherwise there can be
confusion with bytes in the middle of UTF-8 characters. In a "traditional"
environment, the tables will only recognize ASCII characters anyway, but in at
least one Windows environment, some higher bytes bits were set in the tables.
So we deal with that case by considering the UTF-8 encoding.

Arguments:
  re             the regex block
  cbit type      the type of character wanted
  table_limit    32 for non-UTF-8; 16 for UTF-8

Returns:         nothing
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_type_bits</name><parameter_list>(<parameter><decl><type><name>pcre2_real_code</name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cbit_type</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>table_limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>table_limit</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>start_bitmap</name><index>[<expr><name>c</name></expr>]</index></name> <operator>|=</operator> <name><name>re</name><operator>-&gt;</operator><name>tables</name><index>[<expr><name>c</name><operator>+</operator><name>cbits_offset</name><operator>+</operator><name>cbit_type</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>table_limit</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">128</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>tables</name><index>[<expr><name>cbits_offset</name> <operator>+</operator> <name>c</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name><name>buff</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><call><name>PRIV</name><argument_list>(<argument><expr><name>ord2utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>buff</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* UTF-8 */</comment>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*     Set bits for a negative character type     *
*************************************************/</comment>

<comment type="block">/* This function sets starting bits for a negative character type such as \D.
In UTF-8 mode, we can only do a direct setting for bytes less than 128, as
otherwise there can be confusion with bytes in the middle of UTF-8 characters.
Unlike in the positive case, where we can set appropriate starting bits for
specific high-valued UTF-8 characters, in this case we have to set the bits for
all high-valued characters. The lowest is 0xc2, but we overkill by starting at
0xc0 (192) for simplicity.

Arguments:
  re             the regex block
  cbit type      the type of character wanted
  table_limit    32 for non-UTF-8; 16 for UTF-8

Returns:         nothing
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_nottype_bits</name><parameter_list>(<parameter><decl><type><name>pcre2_real_code</name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cbit_type</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>table_limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>table_limit</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>start_bitmap</name><index>[<expr><name>c</name></expr>]</index></name> <operator>|=</operator> <operator>~</operator><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>tables</name><index>[<expr><name>c</name><operator>+</operator><name>cbits_offset</name><operator>+</operator><name>cbit_type</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>table_limit</name> <operator>!=</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content> <for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">24</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>start_bitmap</name><index>[<expr><name>c</name></expr>]</index></name> <operator>=</operator> <literal type="number">0xff</literal></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*      Create bitmap of starting code units      *
*************************************************/</comment>

<comment type="block">/* This function scans a compiled unanchored expression recursively and
attempts to build a bitmap of the set of possible starting code units whose
values are less than 256. In 16-bit and 32-bit mode, values above 255 all cause
the 255 bit to be set. When calling set[_not]_type_bits() in UTF-8 (sic) mode
we pass a value of 16 rather than 32 as the final argument. (See comments in
those functions for the reason.)

The SSB_CONTINUE return is useful for parenthesized groups in patterns such as
(a*)b where the group provides some optional starting code units but scanning
must continue at the outer level to find at least one mandatory code unit. At
the outermost level, this function fails unless the result is SSB_DONE.

We restrict recursion (for nested groups) to 1000 to avoid stack overflow
issues.

Arguments:
  re           points to the compiled regex block
  code         points to an expression
  utf          TRUE if in UTF mode
  ucp          TRUE if in UCP mode
  depthptr     pointer to recurse depth

Returns:       SSB_FAIL     =&gt; Failed to find any starting code units
               SSB_DONE     =&gt; Found mandatory starting code units
               SSB_CONTINUE =&gt; Found optional starting code units
               SSB_UNKNOWN  =&gt; Hit an unrecognized opcode
               SSB_TOODEEP  =&gt; Recursion is too deep
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_start_bits</name><parameter_list>(<parameter><decl><type><name>pcre2_real_code</name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>utf</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>ucp</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>depthptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yield</name> <init>= <expr><name>SSB_DONE</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>table_limit</name> <init>= <expr><ternary><condition><expr><name>utf</name></expr>?</condition><then> <expr><literal type="number">16</literal></expr></then><else>:<expr><literal type="number">32</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>int</name></type> <name>table_limit</name> <init>= <expr><literal type="number">32</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><operator>*</operator><name>depthptr</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>depthptr</name> <operator>&gt;</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>SSB_TOODEEP</name></expr>;</return></block_content></block></if></if_stmt>

<do>do
  <block>{<block_content>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>try_next</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>tcode</name> <init>= <expr><name>code</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_CBRA</name> <operator>||</operator> <operator>*</operator><name>code</name> <operator>==</operator> <name>OP_SCBRA</name> <operator>||</operator>
      <operator>*</operator><name>code</name> <operator>==</operator> <name>OP_CBRAPOS</name> <operator>||</operator> <operator>*</operator><name>code</name> <operator>==</operator> <name>OP_SCBRAPOS</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <while>while <condition>(<expr><name>try_next</name></expr>)</condition>    <comment type="block">/* Loop for items in this branch */</comment>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>classmap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>
    <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>xclassflags</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <switch>switch<condition>(<expr><operator>*</operator><name>tcode</name></expr>)</condition>
      <block>{<block_content>
      <comment type="block">/* If we reach something we don't understand, it means a new opcode has
      been created that hasn't been added to this function. Hopefully this
      problem will be discovered during testing. */</comment>

      <default>default:</default>
      <return>return <expr><name>SSB_UNKNOWN</name></expr>;</return>

      <comment type="block">/* Fail for a valid opcode that implies no starting bits. */</comment>

      <case>case <expr><name>OP_ACCEPT</name></expr>:</case>
      <case>case <expr><name>OP_ASSERT_ACCEPT</name></expr>:</case>
      <case>case <expr><name>OP_ALLANY</name></expr>:</case>
      <case>case <expr><name>OP_ANY</name></expr>:</case>
      <case>case <expr><name>OP_ANYBYTE</name></expr>:</case>
      <case>case <expr><name>OP_CIRCM</name></expr>:</case>
      <case>case <expr><name>OP_CLOSE</name></expr>:</case>
      <case>case <expr><name>OP_COMMIT</name></expr>:</case>
      <case>case <expr><name>OP_COMMIT_ARG</name></expr>:</case>
      <case>case <expr><name>OP_COND</name></expr>:</case>
      <case>case <expr><name>OP_CREF</name></expr>:</case>
      <case>case <expr><name>OP_FALSE</name></expr>:</case>
      <case>case <expr><name>OP_TRUE</name></expr>:</case>
      <case>case <expr><name>OP_DNCREF</name></expr>:</case>
      <case>case <expr><name>OP_DNREF</name></expr>:</case>
      <case>case <expr><name>OP_DNREFI</name></expr>:</case>
      <case>case <expr><name>OP_DNRREF</name></expr>:</case>
      <case>case <expr><name>OP_DOLL</name></expr>:</case>
      <case>case <expr><name>OP_DOLLM</name></expr>:</case>
      <case>case <expr><name>OP_END</name></expr>:</case>
      <case>case <expr><name>OP_EOD</name></expr>:</case>
      <case>case <expr><name>OP_EODN</name></expr>:</case>
      <case>case <expr><name>OP_EXTUNI</name></expr>:</case>
      <case>case <expr><name>OP_FAIL</name></expr>:</case>
      <case>case <expr><name>OP_MARK</name></expr>:</case>
      <case>case <expr><name>OP_NOT</name></expr>:</case>
      <case>case <expr><name>OP_NOTEXACT</name></expr>:</case>
      <case>case <expr><name>OP_NOTEXACTI</name></expr>:</case>
      <case>case <expr><name>OP_NOTI</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINPLUSI</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINQUERYI</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINSTARI</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINUPTO</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINUPTOI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPLUS</name></expr>:</case>
      <case>case <expr><name>OP_NOTPLUSI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSPLUS</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSPLUSI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSQUERY</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSQUERYI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSSTAR</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSSTARI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSUPTO</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSUPTOI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPROP</name></expr>:</case>
      <case>case <expr><name>OP_NOTQUERY</name></expr>:</case>
      <case>case <expr><name>OP_NOTQUERYI</name></expr>:</case>
      <case>case <expr><name>OP_NOTSTAR</name></expr>:</case>
      <case>case <expr><name>OP_NOTSTARI</name></expr>:</case>
      <case>case <expr><name>OP_NOTUPTO</name></expr>:</case>
      <case>case <expr><name>OP_NOTUPTOI</name></expr>:</case>
      <case>case <expr><name>OP_NOT_HSPACE</name></expr>:</case>
      <case>case <expr><name>OP_NOT_VSPACE</name></expr>:</case>
      <case>case <expr><name>OP_PRUNE</name></expr>:</case>
      <case>case <expr><name>OP_PRUNE_ARG</name></expr>:</case>
      <case>case <expr><name>OP_RECURSE</name></expr>:</case>
      <case>case <expr><name>OP_REF</name></expr>:</case>
      <case>case <expr><name>OP_REFI</name></expr>:</case>
      <case>case <expr><name>OP_REVERSE</name></expr>:</case>
      <case>case <expr><name>OP_RREF</name></expr>:</case>
      <case>case <expr><name>OP_SCOND</name></expr>:</case>
      <case>case <expr><name>OP_SET_SOM</name></expr>:</case>
      <case>case <expr><name>OP_SKIP</name></expr>:</case>
      <case>case <expr><name>OP_SKIP_ARG</name></expr>:</case>
      <case>case <expr><name>OP_SOD</name></expr>:</case>
      <case>case <expr><name>OP_SOM</name></expr>:</case>
      <case>case <expr><name>OP_THEN</name></expr>:</case>
      <case>case <expr><name>OP_THEN_ARG</name></expr>:</case>
      <return>return <expr><name>SSB_FAIL</name></expr>;</return>

      <comment type="block">/* OP_CIRC happens only at the start of an anchored branch (multiline ^
      uses OP_CIRCM). Skip over it. */</comment>

      <case>case <expr><name>OP_CIRC</name></expr>:</case>
      <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>OP_CIRC</name></expr>]</index></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/* A "real" property test implies no starting bits, but the fake property
      PT_CLIST identifies a list of characters. These lists are short, as they
      are used for characters with more than one "other case", so there is no
      point in recognizing them for OP_NOTPROP. */</comment>

      <case>case <expr><name>OP_PROP</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name><name>tcode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>PT_CLIST</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>SSB_FAIL</name></expr>;</return></block_content></block></if></if_stmt>
        <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_caseless_sets</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>tcode</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator><operator>)</operator> <operator>&lt;</operator> <name>NOTACHAR</name></expr>)</condition>
          <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
          <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
            <block>{<block_content>
            <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name><name>buff</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><call><name>PRIV</name><argument_list>(<argument><expr><name>ord2utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>buff</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0xff</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
          </block_content>}</block></while>
        </block_content>}</block>
      <expr_stmt><expr><name>try_next</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/* We can ignore word boundary tests. */</comment>

      <case>case <expr><name>OP_WORD_BOUNDARY</name></expr>:</case>
      <case>case <expr><name>OP_NOT_WORD_BOUNDARY</name></expr>:</case>
      <expr_stmt><expr><name>tcode</name><operator>++</operator></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/* If we hit a bracket or a positive lookahead assertion, recurse to set
      bits from within the subpattern. If it can't find anything, we have to
      give up. If it finds some mandatory character(s), we are done for this
      branch. Otherwise, carry on scanning after the subpattern. */</comment>

      <case>case <expr><name>OP_BRA</name></expr>:</case>
      <case>case <expr><name>OP_SBRA</name></expr>:</case>
      <case>case <expr><name>OP_CBRA</name></expr>:</case>
      <case>case <expr><name>OP_SCBRA</name></expr>:</case>
      <case>case <expr><name>OP_BRAPOS</name></expr>:</case>
      <case>case <expr><name>OP_SBRAPOS</name></expr>:</case>
      <case>case <expr><name>OP_CBRAPOS</name></expr>:</case>
      <case>case <expr><name>OP_SCBRAPOS</name></expr>:</case>
      <case>case <expr><name>OP_ONCE</name></expr>:</case>
      <case>case <expr><name>OP_SCRIPT_RUN</name></expr>:</case>
      <case>case <expr><name>OP_ASSERT</name></expr>:</case>
      <case>case <expr><name>OP_ASSERT_NA</name></expr>:</case>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>set_start_bits</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>tcode</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>ucp</name></expr></argument>, <argument><expr><name>depthptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>SSB_DONE</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>try_next</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
        </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>rc</name> <operator>==</operator> <name>SSB_CONTINUE</name></expr>)</condition>
        <block>{<block_content>
        <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>tcode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>tcode</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
        <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></else></if_stmt>   <comment type="block">/* FAIL, UNKNOWN, or TOODEEP */</comment>
      <break>break;</break>

      <comment type="block">/* If we hit ALT or KET, it means we haven't found anything mandatory in
      this branch, though we might have found something optional. For ALT, we
      continue with the next alternative, but we have to arrange that the final
      result from subpattern is SSB_CONTINUE rather than SSB_DONE. For KET,
      return SSB_CONTINUE: if this is the top level, that indicates failure,
      but after a nested subpattern, it causes scanning to continue. */</comment>

      <case>case <expr><name>OP_ALT</name></expr>:</case>
      <expr_stmt><expr><name>yield</name> <operator>=</operator> <name>SSB_CONTINUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>try_next</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_KET</name></expr>:</case>
      <case>case <expr><name>OP_KETRMAX</name></expr>:</case>
      <case>case <expr><name>OP_KETRMIN</name></expr>:</case>
      <case>case <expr><name>OP_KETRPOS</name></expr>:</case>
      <return>return <expr><name>SSB_CONTINUE</name></expr>;</return>

      <comment type="block">/* Skip over callout */</comment>

      <case>case <expr><name>OP_CALLOUT</name></expr>:</case>
      <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>OP_CALLOUT</name></expr>]</index></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_CALLOUT_STR</name></expr>:</case>
      <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>tcode</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/* Skip over lookbehind and negative lookahead assertions */</comment>

      <case>case <expr><name>OP_ASSERT_NOT</name></expr>:</case>
      <case>case <expr><name>OP_ASSERTBACK</name></expr>:</case>
      <case>case <expr><name>OP_ASSERTBACK_NOT</name></expr>:</case>
      <case>case <expr><name>OP_ASSERTBACK_NA</name></expr>:</case>
      <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>tcode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>tcode</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
      <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/* BRAZERO does the bracket, but carries on. */</comment>

      <case>case <expr><name>OP_BRAZERO</name></expr>:</case>
      <case>case <expr><name>OP_BRAMINZERO</name></expr>:</case>
      <case>case <expr><name>OP_BRAPOSZERO</name></expr>:</case>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>set_start_bits</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><operator>++</operator><name>tcode</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>ucp</name></expr></argument>, <argument><expr><name>depthptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>SSB_FAIL</name> <operator>||</operator> <name>rc</name> <operator>==</operator> <name>SSB_UNKNOWN</name> <operator>||</operator> <name>rc</name> <operator>==</operator> <name>SSB_TOODEEP</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
      <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>tcode</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>tcode</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
      <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/* SKIPZERO skips the bracket. */</comment>

      <case>case <expr><name>OP_SKIPZERO</name></expr>:</case>
      <expr_stmt><expr><name>tcode</name><operator>++</operator></expr>;</expr_stmt>
      <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>tcode</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>tcode</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
      <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/* Single-char * or ? sets the bit and tries the next item */</comment>

      <case>case <expr><name>OP_STAR</name></expr>:</case>
      <case>case <expr><name>OP_MINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_POSSTAR</name></expr>:</case>
      <case>case <expr><name>OP_QUERY</name></expr>:</case>
      <case>case <expr><name>OP_MINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_POSQUERY</name></expr>:</case>
      <expr_stmt><expr><name>tcode</name> <operator>=</operator> <call><name>set_table_bit</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>tcode</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>ucp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_STARI</name></expr>:</case>
      <case>case <expr><name>OP_MINSTARI</name></expr>:</case>
      <case>case <expr><name>OP_POSSTARI</name></expr>:</case>
      <case>case <expr><name>OP_QUERYI</name></expr>:</case>
      <case>case <expr><name>OP_MINQUERYI</name></expr>:</case>
      <case>case <expr><name>OP_POSQUERYI</name></expr>:</case>
      <expr_stmt><expr><name>tcode</name> <operator>=</operator> <call><name>set_table_bit</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>tcode</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>ucp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/* Single-char upto sets the bit and tries the next */</comment>

      <case>case <expr><name>OP_UPTO</name></expr>:</case>
      <case>case <expr><name>OP_MINUPTO</name></expr>:</case>
      <case>case <expr><name>OP_POSUPTO</name></expr>:</case>
      <expr_stmt><expr><name>tcode</name> <operator>=</operator> <call><name>set_table_bit</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>tcode</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>ucp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_UPTOI</name></expr>:</case>
      <case>case <expr><name>OP_MINUPTOI</name></expr>:</case>
      <case>case <expr><name>OP_POSUPTOI</name></expr>:</case>
      <expr_stmt><expr><name>tcode</name> <operator>=</operator> <call><name>set_table_bit</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>tcode</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>ucp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/* At least one single char sets the bit and stops */</comment>

      <case>case <expr><name>OP_EXACT</name></expr>:</case>
      <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through */</comment>
      <case>case <expr><name>OP_CHAR</name></expr>:</case>
      <case>case <expr><name>OP_PLUS</name></expr>:</case>
      <case>case <expr><name>OP_MINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_POSPLUS</name></expr>:</case>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>set_table_bit</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>tcode</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>ucp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>try_next</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_EXACTI</name></expr>:</case>
      <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through */</comment>
      <case>case <expr><name>OP_CHARI</name></expr>:</case>
      <case>case <expr><name>OP_PLUSI</name></expr>:</case>
      <case>case <expr><name>OP_MINPLUSI</name></expr>:</case>
      <case>case <expr><name>OP_POSPLUSI</name></expr>:</case>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>set_table_bit</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>tcode</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>ucp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>try_next</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/* Special spacing and line-terminating items. These recognize specific
      lists of characters. The difference between VSPACE and ANYNL is that the
      latter can match the two-character CRLF sequence, but that is not
      relevant for finding the first character, so their code here is
      identical. */</comment>

      <case>case <expr><name>OP_HSPACE</name></expr>:</case>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>CHAR_HT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>CHAR_SPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* For the 16-bit and 32-bit libraries (which can never be EBCDIC), set
      the bits for 0xA0 and for code units &gt;= 255, independently of UTF. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xA0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xFF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* For the 8-bit library in UTF-8 mode, set the bits for the first code
      units of horizontal space characters. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xC2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* For U+00A0 */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xE1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* For U+1680, U+180E */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xE2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* For U+2000 - U+200A, U+202F, U+205F */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xE3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* For U+3000 */</comment>
        </block_content>}</block></if>
      <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <comment type="block">/* For the 8-bit library not in UTF-8 mode, set the bit for 0xA0, unless
      the code is EBCDIC. */</comment>
        <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EBCDIC</name></cpp:ifndef>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xA0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* Not EBCDIC */</comment>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* 8-bit support */</comment>

      <expr_stmt><expr><name>try_next</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_ANYNL</name></expr>:</case>
      <case>case <expr><name>OP_VSPACE</name></expr>:</case>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>CHAR_LF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>CHAR_VT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>CHAR_FF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>CHAR_CR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* For the 16-bit and 32-bit libraries (which can never be EBCDIC), set
      the bits for NEL and for code units &gt;= 255, independently of UTF. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>CHAR_NEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xFF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* For the 8-bit library in UTF-8 mode, set the bits for the first code
      units of vertical space characters. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xC2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* For U+0085 (NEL) */</comment>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xE2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* For U+2028, U+2029 */</comment>
        </block_content>}</block></if>
      <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <comment type="block">/* For the 8-bit library not in UTF-8 mode, set the bit for NEL. */</comment>
        <block>{<block_content>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>CHAR_NEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* 8-bit support */</comment>

      <expr_stmt><expr><name>try_next</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/* Single character types set the bits and stop. Note that if PCRE2_UCP
      is set, we do not see these opcodes because \d etc are converted to
      properties. Therefore, these apply in the case when only characters less
      than 256 are recognized to match the types. */</comment>

      <case>case <expr><name>OP_NOT_DIGIT</name></expr>:</case>
      <expr_stmt><expr><call><name>set_nottype_bits</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>cbit_digit</name></expr></argument>, <argument><expr><name>table_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>try_next</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_DIGIT</name></expr>:</case>
      <expr_stmt><expr><call><name>set_type_bits</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>cbit_digit</name></expr></argument>, <argument><expr><name>table_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>try_next</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_NOT_WHITESPACE</name></expr>:</case>
      <expr_stmt><expr><call><name>set_nottype_bits</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>cbit_space</name></expr></argument>, <argument><expr><name>table_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>try_next</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_WHITESPACE</name></expr>:</case>
      <expr_stmt><expr><call><name>set_type_bits</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>cbit_space</name></expr></argument>, <argument><expr><name>table_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>try_next</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_NOT_WORDCHAR</name></expr>:</case>
      <expr_stmt><expr><call><name>set_nottype_bits</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>cbit_word</name></expr></argument>, <argument><expr><name>table_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>try_next</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_WORDCHAR</name></expr>:</case>
      <expr_stmt><expr><call><name>set_type_bits</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>cbit_word</name></expr></argument>, <argument><expr><name>table_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>try_next</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/* One or more character type fudges the pointer and restarts, knowing
      it will hit a single character type and stop there. */</comment>

      <case>case <expr><name>OP_TYPEPLUS</name></expr>:</case>
      <case>case <expr><name>OP_TYPEMINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_TYPEPOSPLUS</name></expr>:</case>
      <expr_stmt><expr><name>tcode</name><operator>++</operator></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_TYPEEXACT</name></expr>:</case>
      <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/* Zero or more repeats of character types set the bits and then
      try again. */</comment>

      <case>case <expr><name>OP_TYPEUPTO</name></expr>:</case>
      <case>case <expr><name>OP_TYPEMINUPTO</name></expr>:</case>
      <case>case <expr><name>OP_TYPEPOSUPTO</name></expr>:</case>
      <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>  <comment type="block">/* Fall through */</comment>

      <case>case <expr><name>OP_TYPESTAR</name></expr>:</case>
      <case>case <expr><name>OP_TYPEMINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_TYPEPOSSTAR</name></expr>:</case>
      <case>case <expr><name>OP_TYPEQUERY</name></expr>:</case>
      <case>case <expr><name>OP_TYPEMINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_TYPEPOSQUERY</name></expr>:</case>
      <switch>switch<condition>(<expr><name><name>tcode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
        <default>default:</default>
        <case>case <expr><name>OP_ANY</name></expr>:</case>
        <case>case <expr><name>OP_ALLANY</name></expr>:</case>
        <return>return <expr><name>SSB_FAIL</name></expr>;</return>

        <case>case <expr><name>OP_HSPACE</name></expr>:</case>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>CHAR_HT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>CHAR_SPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* For the 16-bit and 32-bit libraries (which can never be EBCDIC), set
        the bits for 0xA0 and for code units &gt;= 255, independently of UTF. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xA0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xFF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="block">/* For the 8-bit library in UTF-8 mode, set the bits for the first code
        units of horizontal space characters. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xC2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* For U+00A0 */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xE1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* For U+1680, U+180E */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xE2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* For U+2000 - U+200A, U+202F, U+205F */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xE3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* For U+3000 */</comment>
          </block_content>}</block></if>
        <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* For the 8-bit library not in UTF-8 mode, set the bit for 0xA0, unless
        the code is EBCDIC. */</comment>
          <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EBCDIC</name></cpp:ifndef>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xA0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* Not EBCDIC */</comment>
          </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* 8-bit support */</comment>
        <break>break;</break>

        <case>case <expr><name>OP_ANYNL</name></expr>:</case>
        <case>case <expr><name>OP_VSPACE</name></expr>:</case>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>CHAR_LF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>CHAR_VT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>CHAR_FF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>CHAR_CR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* For the 16-bit and 32-bit libraries (which can never be EBCDIC), set
        the bits for NEL and for code units &gt;= 255, independently of UTF. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>CHAR_NEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xFF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="block">/* For the 8-bit library in UTF-8 mode, set the bits for the first code
        units of vertical space characters. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xC2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* For U+0085 (NEL) */</comment>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xE2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* For U+2028, U+2029 */</comment>
          </block_content>}</block></if>
        <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* For the 8-bit library not in UTF-8 mode, set the bit for NEL. */</comment>
          <block>{<block_content>
          <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name>CHAR_NEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* 8-bit support */</comment>
        <break>break;</break>

        <case>case <expr><name>OP_NOT_DIGIT</name></expr>:</case>
        <expr_stmt><expr><call><name>set_nottype_bits</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>cbit_digit</name></expr></argument>, <argument><expr><name>table_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>OP_DIGIT</name></expr>:</case>
        <expr_stmt><expr><call><name>set_type_bits</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>cbit_digit</name></expr></argument>, <argument><expr><name>table_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>OP_NOT_WHITESPACE</name></expr>:</case>
        <expr_stmt><expr><call><name>set_nottype_bits</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>cbit_space</name></expr></argument>, <argument><expr><name>table_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>OP_WHITESPACE</name></expr>:</case>
        <expr_stmt><expr><call><name>set_type_bits</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>cbit_space</name></expr></argument>, <argument><expr><name>table_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>OP_NOT_WORDCHAR</name></expr>:</case>
        <expr_stmt><expr><call><name>set_nottype_bits</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>cbit_word</name></expr></argument>, <argument><expr><name>table_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>OP_WORDCHAR</name></expr>:</case>
        <expr_stmt><expr><call><name>set_type_bits</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>cbit_word</name></expr></argument>, <argument><expr><name>table_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
        </block_content>}</block></switch>

      <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/* Extended class: if there are any property checks, or if this is a
      negative XCLASS without a map, give up. If there are no property checks,
      there must be wide characters on the XCLASS list, because otherwise an
      XCLASS would not have been created. This means that code points &gt;= 255
      are potential starters. In the UTF-8 case we can scan them and set bits
      for the relevant leading bytes. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>
      <case>case <expr><name>OP_XCLASS</name></expr>:</case>
      <expr_stmt><expr><name>xclassflags</name> <operator>=</operator> <name><name>tcode</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>xclassflags</name> <operator>&amp;</operator> <name>XCL_HASPROP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
          <operator>(</operator><name>xclassflags</name> <operator>&amp;</operator> <operator>(</operator><name>XCL_MAP</name><operator>|</operator><name>XCL_NOT</name><operator>)</operator><operator>)</operator> <operator>==</operator> <name>XCL_NOT</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>SSB_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

      <comment type="block">/* We have a positive XCLASS or a negative one without a map. Set up the
      map pointer if there is one, and fall through. */</comment>

      <expr_stmt><expr><name>classmap</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>xclassflags</name> <operator>&amp;</operator> <name>XCL_MAP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name>NULL</name></expr> </then><else>:
        <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>tcode</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>

      <comment type="block">/* In UTF-8 mode, scan the character list and set bits for leading bytes,
      then jump to handle the map. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>xclassflags</name> <operator>&amp;</operator> <name>XCL_NOT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>b</name></decl>, <decl><type ref="prev"/><name>e</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>p</name> <init>= <expr><name>tcode</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>classmap</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr></then><else>:<expr><literal type="number">32</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>tcode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control><block type="pseudo"><block_content> <switch>switch <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>XCL_SINGLE</name></expr>:</case>
          <expr_stmt><expr><name>b</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
          <while>while <condition>(<expr><operator>(</operator><operator>*</operator><name>p</name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
          <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>start_bitmap</name><index>[<expr><name>b</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>b</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>XCL_RANGE</name></expr>:</case>
          <expr_stmt><expr><name>b</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
          <while>while <condition>(<expr><operator>(</operator><operator>*</operator><name>p</name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
          <expr_stmt><expr><name>e</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
          <while>while <condition>(<expr><operator>(</operator><operator>*</operator><name>p</name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
          <for>for <control>(<init>;</init> <condition><expr><name>b</name> <operator>&lt;=</operator> <name>e</name></expr>;</condition> <incr><expr><name>b</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>start_bitmap</name><index>[<expr><name>b</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>b</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
          <break>break;</break>

          <case>case <expr><name>XCL_END</name></expr>:</case>
          <goto>goto <name>HANDLE_CLASSMAP</name>;</goto>

          <default>default:</default>
          <return>return <expr><name>SSB_UNKNOWN</name></expr>;</return>   <comment type="block">/* Internal error, should not occur */</comment>
          </block_content>}</block></switch></block_content></block></for>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE &amp;&amp; PCRE2_CODE_UNIT_WIDTH == 8 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_WIDE_CHARS */</comment>

      <comment type="block">/* It seems that the fall through comment must be outside the #ifdef if
      it is to avoid the gcc compiler warning. */</comment>

      <comment type="block">/* Fall through */</comment>

      <comment type="block">/* Enter here for a negative non-XCLASS. In the 8-bit library, if we are
      in UTF mode, any byte with a value &gt;= 0xc4 is a potentially valid starter
      because it starts a character with a value &gt; 255. In 8-bit non-UTF mode,
      there is no difference between CLASS and NCLASS. In all other wide
      character modes, set the 0xFF bit to indicate code units &gt;= 255. */</comment>

      <case>case <expr><name>OP_NCLASS</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>start_bitmap</name><index>[<expr><literal type="number">24</literal></expr>]</index></name> <operator>|=</operator> <literal type="number">0xf0</literal></expr>;</expr_stmt>            <comment type="block">/* Bits for 0xc4 - 0xc8 */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>start_bitmap</name></name><operator>+</operator><literal type="number">25</literal></expr></argument>, <argument><expr><literal type="number">0xff</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* Bits for 0xc9 - 0xff */</comment>
        </block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:elif>
      <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><literal type="number">0xFF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>                             <comment type="block">/* For characters &gt;= 255 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <comment type="block">/* Fall through */</comment>

      <comment type="block">/* Enter here for a positive non-XCLASS. If we have fallen through from
      an XCLASS, classmap will already be set; just advance the code pointer.
      Otherwise, set up classmap for a a non-XCLASS and advance past it. */</comment>

      <case>case <expr><name>OP_CLASS</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tcode</name> <operator>==</operator> <name>OP_XCLASS</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>tcode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <else>else
        <block>{<block_content>
        <expr_stmt><expr><name>classmap</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>++</operator><name>tcode</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

      <comment type="block">/* When wide characters are supported, classmap may be NULL. In UTF-8
      (sic) mode, the bits in a class bit map correspond to character values,
      not to byte values. However, the bit map we are constructing is for byte
      values. So we have to do a conversion for characters whose code point is
      greater than 127. In fact, there are only two possible starting bytes for
      characters in the range 128 - 255. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_WIDE_CHARS</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
      <label><name>HANDLE_CLASSMAP</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if_stmt><if>if <condition>(<expr><name>classmap</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
        <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
          <block>{<block_content>
          <for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>start_bitmap</name><index>[<expr><name>c</name></expr>]</index></name> <operator>|=</operator> <name><name>classmap</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
          <for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">128</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>classmap</name><index>[<expr><name>c</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
              <block>{<block_content>
              <decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>|</operator> <literal type="number">0xc0</literal></expr></init></decl>;</decl_stmt>                 <comment type="block">/* Set bit for this starter */</comment>
              <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>start_bitmap</name><index>[<expr><name>d</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>d</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* and then skip on to the */</comment>
              <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>+</operator> <literal type="number">0x40</literal> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>               <comment type="block">/* next relevant character. */</comment>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
          </block_content>}</block></if>
        <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* In all modes except UTF-8, the two bit maps are compatible. */</comment>

          <block>{<block_content>
          <for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>start_bitmap</name><index>[<expr><name>c</name></expr>]</index></name> <operator>|=</operator> <name><name>classmap</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Act on what follows the class. For a zero minimum repeat, continue;
      otherwise stop processing. */</comment>

      <switch>switch <condition>(<expr><operator>*</operator><name>tcode</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>OP_CRSTAR</name></expr>:</case>
        <case>case <expr><name>OP_CRMINSTAR</name></expr>:</case>
        <case>case <expr><name>OP_CRQUERY</name></expr>:</case>
        <case>case <expr><name>OP_CRMINQUERY</name></expr>:</case>
        <case>case <expr><name>OP_CRPOSSTAR</name></expr>:</case>
        <case>case <expr><name>OP_CRPOSQUERY</name></expr>:</case>
        <expr_stmt><expr><name>tcode</name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>OP_CRRANGE</name></expr>:</case>
        <case>case <expr><name>OP_CRMINRANGE</name></expr>:</case>
        <case>case <expr><name>OP_CRPOSRANGE</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><call><name>GET2</name><argument_list>(<argument><expr><name>tcode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>tcode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt></block_content></block></if>
          <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>try_next</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <break>break;</break>

        <default>default:</default>
        <expr_stmt><expr><name>try_next</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
        <break>break;</break>
        </block_content>}</block></switch>
      <break>break;</break> <comment type="block">/* End of class handling case */</comment>
      </block_content>}</block></switch>      <comment type="block">/* End of switch for opcodes */</comment>
    </block_content>}</block></while>        <comment type="block">/* End of try_next loop */</comment>

  <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Advance to next branch */</comment>
  </block_content>}</block>
while <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>

<return>return <expr><name>yield</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*          Study a compiled expression           *
*************************************************/</comment>

<comment type="block">/* This function is handed a compiled expression that it must study to produce
information that will speed up the matching.

Argument:
  re       points to the compiled expression

Returns:   0 normally; non-zero should never normally occur
           1 unknown opcode in set_start_bits
           2 missing capturing bracket
           3 unknown opcode in find_minlength
*/</comment>

<function><type><name>int</name>
<name>PRIV</name></type>(<name>study</name>)<parameter_list>(<parameter><decl><type><name>pcre2_real_code</name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>ucp</name> <init>= <expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Find start of compiled code */</comment>

<expr_stmt><expr><name>code</name> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>re</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pcre2_real_code</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>+</operator>
  <name><name>re</name><operator>-&gt;</operator><name>name_entry_size</name></name> <operator>*</operator> <name><name>re</name><operator>-&gt;</operator><name>name_count</name></name></expr>;</expr_stmt>

<comment type="block">/* For a pattern that has a first code unit, or a multiline pattern that
matches only at "line start", there is no point in seeking a list of starting
code units. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_FIRSTSET</name><operator>|</operator><name>PCRE2_STARTLINE</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>set_start_bits</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>ucp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>depth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>SSB_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* If a list of starting code units was set up, scan the list to see if only
  one or two were listed. Having only one listed is rare because usually a
  single starting code unit will have been recognized and PCRE2_FIRSTSET set.
  If two are listed, see if they are caseless versions of the same character;
  if so we can replace the list with a caseless first code unit. This gives
  better performance and is plausibly worth doing for patterns such as [Ww]ord
  or (word|WORD). */</comment>

  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>SSB_DONE</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>a</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>b</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>re</name><operator>-&gt;</operator><name>start_bitmap</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>flags</name> <init>= <expr><name>PCRE2_FIRSTMAPSET</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name> <operator>+=</operator> <literal type="number">8</literal></expr></incr>)</control>
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint8_t</name></type> <name>x</name> <init>= <expr><operator>*</operator><name>p</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>x</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint8_t</name></type> <name>y</name> <init>= <expr><name>x</name> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><name>x</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>   <comment type="block">/* Least significant bit */</comment>
        <if_stmt><if>if <condition>(<expr><name>y</name> <operator>!=</operator> <name>x</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>DONE</name>;</goto></block_content></block></if></if_stmt>      <comment type="block">/* More than one bit set */</comment>

        <comment type="block">/* In the 16-bit and 32-bit libraries, the bit for 0xff means "0xff and
        all wide characters", so we cannot use it here. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">248</literal> <operator>&amp;&amp;</operator> <name>x</name> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>DONE</name>;</goto></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* Compute the character value */</comment>

        <expr_stmt><expr><name>c</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>x</name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><literal type="number">1</literal></expr>:</case>   <break>break;</break>
          <case>case <expr><literal type="number">2</literal></expr>:</case>   <expr_stmt><expr><name>c</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>  <case>case <expr><literal type="number">4</literal></expr>:</case>  <expr_stmt><expr><name>c</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>
          <case>case <expr><literal type="number">8</literal></expr>:</case>   <expr_stmt><expr><name>c</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt> <break>break;</break>  <case>case <expr><literal type="number">16</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <break>break;</break>
          <case>case <expr><literal type="number">32</literal></expr>:</case>  <expr_stmt><expr><name>c</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt> <break>break;</break>  <case>case <expr><literal type="number">64</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>+=</operator> <literal type="number">6</literal></expr>;</expr_stmt> <break>break;</break>
          <case>case <expr><literal type="number">128</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt> <break>break;</break>
          </block_content>}</block></switch>

        <comment type="block">/* c contains the code unit value, in the range 0-255. In 8-bit UTF
        mode, only values &lt; 128 can be used. In all the other cases, c is a
        character value. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
        <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>DONE</name>;</goto></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if <condition>(<expr><name>a</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>a</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if>   <comment type="block">/* First one found, save in a */</comment>
        <if type="elseif">else if <condition>(<expr><name>b</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>     <comment type="block">/* Second one found */</comment>
          <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><call><name>TABLE_GET</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>c</name></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>tables</name></name> <operator>+</operator> <name>fcc_offset</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
          <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>||</operator> <name>ucp</name></expr>)</condition>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>UCD_CASESET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>DONE</name>;</goto></block_content></block></if></if_stmt>     <comment type="block">/* Multiple case set */</comment>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

          <if_stmt><if>if <condition>(<expr><name>d</name> <operator>!=</operator> <name>a</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>DONE</name>;</goto></block_content></block></if></if_stmt>   <comment type="block">/* Not the other case of a */</comment>
          <expr_stmt><expr><name>b</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>                   <comment type="block">/* Save second in b */</comment>
          </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content> <goto>goto <name>DONE</name>;</goto></block_content></block></else></if_stmt>   <comment type="block">/* More than two characters found */</comment>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>

    <comment type="block">/* Replace the start code unit bits with a first code unit, but only if it
    is not the same as a required later code unit. This is because a search for
    a required code unit starts after an explicit first code unit, but at a
    code unit found from the bitmap. Patterns such as /a*a/ don't work
    if both the start unit and required unit are the same. */</comment>

    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <operator>(</operator>
        <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_LASTSET</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
          <operator>(</operator>
          <name><name>re</name><operator>-&gt;</operator><name>last_codeunit</name></name> <operator>!=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>a</name> <operator>&amp;&amp;</operator>
          <operator>(</operator><name>b</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>re</name><operator>-&gt;</operator><name>last_codeunit</name></name> <operator>!=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>b</name><operator>)</operator>
          <operator>)</operator>
        <operator>)</operator></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>first_codeunit</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>PCRE2_FIRSTSET</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>b</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>PCRE2_FIRSTCASELESS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

    <label><name>DONE</name>:</label>
    <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>flags</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Find the minimum length of subject string. If the pattern can match an empty
string, the minimum length is already known. If the pattern contains (*ACCEPT)
all bets are off, and we don't even try to find a minimum length. If there are
more back references than the size of the vector we are going to cache them in,
do nothing. A pattern that complicated will probably take a long time to
analyze and may in any case turn out to be too complicated. Note that back
reference minima are held as 16-bit numbers. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_MATCH_EMPTY</name><operator>|</operator><name>PCRE2_HASACCEPT</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
     <name><name>re</name><operator>-&gt;</operator><name>top_backref</name></name> <operator>&lt;=</operator> <name>MAX_CACHE_BACKREF</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>min</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name><name>backref_cache</name><index>[<expr><name>MAX_CACHE_BACKREF</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>backref_cache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* Highest one that is set */</comment>
  <expr_stmt><expr><name>min</name> <operator>=</operator> <call><name>find_minlength</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><name>backref_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch<condition>(<expr><name>min</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>  <comment type="block">/* \C in UTF mode or over-complex regex */</comment>
    <break>break;</break>    <comment type="block">/* Leave minlength unchanged (will be zero) */</comment>

    <case>case <expr><operator>-</operator><literal type="number">2</literal></expr>:</case>
    <return>return <expr><literal type="number">2</literal></expr>;</return> <comment type="block">/* missing capturing bracket */</comment>

    <case>case <expr><operator>-</operator><literal type="number">3</literal></expr>:</case>
    <return>return <expr><literal type="number">3</literal></expr>;</return> <comment type="block">/* unrecognized opcode */</comment>

    <default>default:</default>
    <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>minlength</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>min</name> <operator>&gt;</operator> <name>UINT16_MAX</name><operator>)</operator></expr>?</condition><then> <expr><name>UINT16_MAX</name></expr> </then><else>: <expr><name>min</name></expr></else></ternary></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* End of pcre2_study.c */</comment>
</unit>
