<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/pcre2/src/sljit/sljitNativeX86_32.c"><comment type="block">/*
 *    Stack-less Just-In-Time compiler
 *
 *    Copyright Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *   1. Redistributions of source code must retain the above copyright notice, this list of
 *      conditions and the following disclaimer.
 *
 *   2. Redistributions in binary form must reproduce the above copyright notice, this list
 *      of conditions and the following disclaimer in the documentation and/or other materials
 *      provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<comment type="block">/* x86 32-bit arch dependent functions. */</comment>

<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>emit_do_imm</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_u8</name></type> <name>opcode</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>imm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>inst</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>opcode</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sljit_unaligned_store_sw</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>imm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sljit_u8</name><modifier>*</modifier></type> <name>generate_far_jump_code</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl></parameter>, <parameter><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>code_ptr</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>executable_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>type</name> <init>= <expr><name><name>jump</name><operator>-&gt;</operator><name>flags</name></name> <operator>&gt;&gt;</operator> <name>TYPE_SHIFT</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>SLJIT_JUMP</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>code_ptr</name><operator>++</operator> <operator>=</operator> <name>JMP_i32</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>jump</name><operator>-&gt;</operator><name>addr</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>type</name> <operator>&gt;=</operator> <name>SLJIT_FAST_CALL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>code_ptr</name><operator>++</operator> <operator>=</operator> <name>CALL_i32</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>jump</name><operator>-&gt;</operator><name>addr</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>code_ptr</name><operator>++</operator> <operator>=</operator> <name>GROUP_0F</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>code_ptr</name><operator>++</operator> <operator>=</operator> <call><name>get_jump_code</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>jump</name><operator>-&gt;</operator><name>addr</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>jump</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JUMP_LABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>jump</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PATCH_MW</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>sljit_unaligned_store_sw</name><argument_list>(<argument><expr><name>code_ptr</name></expr></argument>, <argument><expr><name><name>jump</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>target</name></name> <operator>-</operator> <operator>(</operator><name><name>jump</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><name>sljit_uw</name><operator>)</operator><name>executable_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>code_ptr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

	<return>return <expr><name>code_ptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_enter</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>arg_types</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>scratches</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>saveds</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>fscratches</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>fsaveds</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>local_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>args</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>inst</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_emit_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>scratches</name></expr></argument>, <argument><expr><name>saveds</name></expr></argument>, <argument><expr><name>fscratches</name></expr></argument>, <argument><expr><name>fsaveds</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_emit_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>scratches</name></expr></argument>, <argument><expr><name>saveds</name></expr></argument>, <argument><expr><name>fscratches</name></expr></argument>, <argument><expr><name>fsaveds</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Emit ENDBR32 at function entry if needed.  */</comment>
	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_endbranch</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>get_arg_count</name><argument_list>(<argument><expr><name>arg_types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>

	<comment type="block">/* [esp+0] for saving temporaries and function calls. */</comment>
	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>stack_tmp_size</name></name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><operator>(</operator><name>defined</name> <name>SLJIT_X86_32_FASTCALL</name> <operator>&amp;&amp;</operator> <name>SLJIT_X86_32_FASTCALL</name><operator>)</operator></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>scratches</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>stack_tmp_size</name></name> <operator>=</operator> <literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>saveds_offset</name></name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>stack_tmp_size</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>scratches</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>saveds_offset</name></name> <operator>+=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>scratches</name> <operator>&gt;</operator> <operator>(</operator><literal type="number">3</literal> <operator>+</operator> <literal type="number">6</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">6</literal></expr> </then><else>: <expr><operator>(</operator><name>scratches</name> <operator>-</operator> <literal type="number">3</literal><operator>)</operator></expr></else></ternary><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>locals_offset</name></name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>saveds_offset</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>saveds</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>locals_offset</name></name> <operator>+=</operator> <operator>(</operator><name>saveds</name> <operator>-</operator> <literal type="number">3</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>SLJIT_F64_ALIGNMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>locals_offset</name></name> <operator>=</operator> <operator>(</operator><name><name>compiler</name><operator>-&gt;</operator><name>locals_offset</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_f64</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_f64</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>scratches</name> <operator>&gt;</operator> <literal type="number">9</literal></expr> ?</condition><then> <expr><operator>(</operator><name>scratches</name> <operator>-</operator> <literal type="number">9</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>saveds</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr> ?</condition><then> <expr><name>saveds</name></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>SLJIT_X86_32_FASTCALL</name> <operator>&amp;&amp;</operator> <name>SLJIT_X86_32_FASTCALL</name><operator>)</operator></expr></cpp:if>
	<expr_stmt><expr><name>size</name> <operator>+=</operator> <operator>(</operator><ternary><condition><expr><name>args</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>(</operator><name>args</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>args</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>size</name> <operator>+=</operator> <operator>(</operator><ternary><condition><expr><name>args</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>(</operator><literal type="number">2</literal> <operator>+</operator> <name>args</name> <operator>*</operator> <literal type="number">3</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PUSH_REG</name><argument_list>(<argument><expr><name><name>reg_map</name><index>[<expr><name>TMP_REG1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><operator>(</operator><name>defined</name> <name>SLJIT_X86_32_FASTCALL</name> <operator>&amp;&amp;</operator> <name>SLJIT_X86_32_FASTCALL</name><operator>)</operator></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>args</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>MOV_r_rm</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>MOD_REG</name> <operator>|</operator> <operator>(</operator><name><name>reg_map</name><index>[<expr><name>TMP_REG1</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x4</literal></expr> <comment type="block">/* esp */</comment>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><name>saveds</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>||</operator> <name>scratches</name> <operator>&gt;</operator> <literal type="number">9</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PUSH_REG</name><argument_list>(<argument><expr><name><name>reg_map</name><index>[<expr><name>SLJIT_S2</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>saveds</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>scratches</name> <operator>&gt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PUSH_REG</name><argument_list>(<argument><expr><name><name>reg_map</name><index>[<expr><name>SLJIT_S1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>saveds</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>scratches</name> <operator>&gt;</operator> <literal type="number">11</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PUSH_REG</name><argument_list>(<argument><expr><name><name>reg_map</name><index>[<expr><name>SLJIT_S0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>SLJIT_X86_32_FASTCALL</name> <operator>&amp;&amp;</operator> <name>SLJIT_X86_32_FASTCALL</name><operator>)</operator></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>args</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>MOV_r_rm</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>MOD_REG</name> <operator>|</operator> <operator>(</operator><name><name>reg_map</name><index>[<expr><name>SLJIT_S0</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <name><name>reg_map</name><index>[<expr><name>SLJIT_R2</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>inst</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>args</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>MOV_r_rm</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>MOD_REG</name> <operator>|</operator> <operator>(</operator><name><name>reg_map</name><index>[<expr><name>SLJIT_S1</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <name><name>reg_map</name><index>[<expr><name>SLJIT_R1</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>inst</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>args</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>MOV_r_rm</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>MOD_DISP8</name> <operator>|</operator> <operator>(</operator><name><name>reg_map</name><index>[<expr><name>SLJIT_S2</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x4</literal></expr> <comment type="block">/* esp */</comment>;</expr_stmt>
		<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x24</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><literal type="number">3</literal> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* saveds &gt;= 3 as well. */</comment>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name>args</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>MOV_r_rm</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>MOD_DISP8</name> <operator>|</operator> <operator>(</operator><name><name>reg_map</name><index>[<expr><name>SLJIT_S0</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <name><name>reg_map</name><index>[<expr><name>TMP_REG1</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>inst</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>args</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>MOV_r_rm</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>MOD_DISP8</name> <operator>|</operator> <operator>(</operator><name><name>reg_map</name><index>[<expr><name>SLJIT_S1</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <name><name>reg_map</name><index>[<expr><name>TMP_REG1</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>inst</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>args</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>MOV_r_rm</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>MOD_DISP8</name> <operator>|</operator> <operator>(</operator><name><name>reg_map</name><index>[<expr><name>SLJIT_S2</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <name><name>reg_map</name><index>[<expr><name>TMP_REG1</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>SLJIT_LOCALS_OFFSET</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<comment type="block">/* Ignore pushed registers and SLJIT_LOCALS_OFFSET when computing the aligned local size. */</comment>
	<expr_stmt><expr><name>saveds</name> <operator>=</operator> <operator>(</operator><literal type="number">2</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>scratches</name> <operator>&gt;</operator> <literal type="number">9</literal></expr> ?</condition><then> <expr><operator>(</operator><name>scratches</name> <operator>-</operator> <literal type="number">9</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>saveds</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr> ?</condition><then> <expr><name>saveds</name></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary><operator>)</operator><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_uw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>local_size</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SLJIT_LOCALS_OFFSET</name> <operator>+</operator> <name>saveds</name> <operator>+</operator> <name>local_size</name> <operator>+</operator> <literal type="number">15</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">15</literal><operator>)</operator> <operator>-</operator> <name>saveds</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>SLJIT_F64_ALIGNMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>local_size</name> <operator>=</operator> <name>SLJIT_LOCALS_OFFSET</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>local_size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_f64</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_f64</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>local_size</name> <operator>=</operator> <name>SLJIT_LOCALS_OFFSET</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>local_size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name> <operator>=</operator> <name>local_size</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN32</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>local_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>local_size</name> <operator>&lt;=</operator> <literal type="number">4</literal> <operator>*</operator> <literal type="number">4096</literal></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>local_size</name> <operator>&gt;</operator> <literal type="number">4096</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">4096</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>local_size</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>*</operator> <literal type="number">4096</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">4096</literal> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>local_size</name> <operator>&gt;</operator> <literal type="number">3</literal> <operator>*</operator> <literal type="number">4096</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">4096</literal> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else <block>{<block_content>
			<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>local_size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SLJIT_ASSERT</name> <argument_list>(<argument><expr><name><name>reg_map</name><index>[<expr><name>SLJIT_R0</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_R0</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">4096</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_non_cum_binary</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>BINARY_OPCODE</name><argument_list>(<argument><expr><name>SUB</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">4096</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_non_cum_binary</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>BINARY_OPCODE</name><argument_list>(<argument><expr><name>SUB</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>JNE_i8</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>sljit_s8</name><operator>)</operator> <operator>-</operator><literal type="number">16</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><name>local_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>local_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>SLJIT_F64_ALIGNMENT</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Some space might allocated during sljit_grow_stack() above on WIN32. */</comment>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_non_cum_binary</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>BINARY_OPCODE</name><argument_list>(<argument><expr><name>SUB</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>local_size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>_WIN32</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>defined</name> <name>SLJIT_X86_32_FASTCALL</name> <operator>&amp;&amp;</operator> <name>SLJIT_X86_32_FASTCALL</name><operator>)</operator></expr></cpp:if>
		<if_stmt><if>if <condition>(<expr><name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name> <operator>&gt;</operator> <literal type="number">1024</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_cum_binary</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>BINARY_OPCODE</name><argument_list>(<argument><expr><name>ADD</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>GROUP_BINARY_81</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>MOD_REG</name> <operator>|</operator> <name>AND</name> <operator>|</operator> <name><name>reg_map</name><index>[<expr><name>SLJIT_SP</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sljit_unaligned_store_sw</name><argument_list>(<argument><expr><name>inst</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>~</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_f64</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The real local size must be used. */</comment>
		<return>return <expr><call><name>emit_mov</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><call><name>emit_non_cum_binary</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>BINARY_OPCODE</name><argument_list>(<argument><expr><name>SUB</name></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_set_context</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>arg_types</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>scratches</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>saveds</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>fscratches</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>fsaveds</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>local_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_set_context</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>scratches</name></expr></argument>, <argument><expr><name>saveds</name></expr></argument>, <argument><expr><name>fscratches</name></expr></argument>, <argument><expr><name>fsaveds</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_set_context</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>scratches</name></expr></argument>, <argument><expr><name>saveds</name></expr></argument>, <argument><expr><name>fscratches</name></expr></argument>, <argument><expr><name>fsaveds</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>get_arg_count</name><argument_list>(<argument><expr><name>arg_types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* [esp+0] for saving temporaries and function calls. */</comment>
	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>stack_tmp_size</name></name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><operator>(</operator><name>defined</name> <name>SLJIT_X86_32_FASTCALL</name> <operator>&amp;&amp;</operator> <name>SLJIT_X86_32_FASTCALL</name><operator>)</operator></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>scratches</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>stack_tmp_size</name></name> <operator>=</operator> <literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>saveds_offset</name></name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>stack_tmp_size</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>scratches</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>saveds_offset</name></name> <operator>+=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>scratches</name> <operator>&gt;</operator> <operator>(</operator><literal type="number">3</literal> <operator>+</operator> <literal type="number">6</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">6</literal></expr> </then><else>: <expr><operator>(</operator><name>scratches</name> <operator>-</operator> <literal type="number">3</literal><operator>)</operator></expr></else></ternary><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>locals_offset</name></name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>saveds_offset</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>saveds</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>locals_offset</name></name> <operator>+=</operator> <operator>(</operator><name>saveds</name> <operator>-</operator> <literal type="number">3</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>SLJIT_F64_ALIGNMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>locals_offset</name></name> <operator>=</operator> <operator>(</operator><name><name>compiler</name><operator>-&gt;</operator><name>locals_offset</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_f64</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_f64</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>saveds</name> <operator>=</operator> <operator>(</operator><literal type="number">2</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>scratches</name> <operator>&gt;</operator> <literal type="number">9</literal></expr> ?</condition><then> <expr><operator>(</operator><name>scratches</name> <operator>-</operator> <literal type="number">9</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>saveds</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr> ?</condition><then> <expr><name>saveds</name></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary><operator>)</operator><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_uw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SLJIT_LOCALS_OFFSET</name> <operator>+</operator> <name>saveds</name> <operator>+</operator> <name>local_size</name> <operator>+</operator> <literal type="number">15</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">15</literal><operator>)</operator> <operator>-</operator> <name>saveds</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>SLJIT_F64_ALIGNMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name> <operator>=</operator> <name>SLJIT_LOCALS_OFFSET</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>local_size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_f64</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_f64</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name> <operator>=</operator> <name>SLJIT_LOCALS_OFFSET</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>local_size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_return</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>srcw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>inst</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_emit_return</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>compiler</name><operator>-&gt;</operator><name>args</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_mov_before_return</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name><name>compiler</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>SLJIT_F64_ALIGNMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<macro><name>EMIT_MOV</name><argument_list>(<argument>compiler</argument>, <argument>SLJIT_SP</argument>, <argument><literal type="number">0</literal></argument>, <argument>SLJIT_MEM1(SLJIT_SP)</argument>, <argument>compiler-&gt;local_size</argument>)</argument_list></macro></block_content></block>
	<if_stmt><else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_cum_binary</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>BINARY_OPCODE</name><argument_list>(<argument><expr><name>ADD</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_cum_binary</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>BINARY_OPCODE</name><argument_list>(<argument><expr><name>ADD</name></expr></argument>)</argument_list></call></expr></argument>,
		<argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">2</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>compiler</name><operator>-&gt;</operator><name>scratches</name></name> <operator>&gt;</operator> <literal type="number">9</literal></expr> ?</condition><then> <expr><operator>(</operator><name><name>compiler</name><operator>-&gt;</operator><name>scratches</name></name> <operator>-</operator> <literal type="number">9</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
		<operator>(</operator><ternary><condition><expr><name><name>compiler</name><operator>-&gt;</operator><name>saveds</name></name> <operator>&lt;=</operator> <literal type="number">3</literal></expr> ?</condition><then> <expr><name><name>compiler</name><operator>-&gt;</operator><name>saveds</name></name></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>SLJIT_X86_32_FASTCALL</name> <operator>&amp;&amp;</operator> <name>SLJIT_X86_32_FASTCALL</name><operator>)</operator></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name><name>compiler</name><operator>-&gt;</operator><name>args</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>compiler</name><operator>-&gt;</operator><name>saveds</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>compiler</name><operator>-&gt;</operator><name>scratches</name></name> <operator>&gt;</operator> <literal type="number">11</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>POP_REG</name><argument_list>(<argument><expr><name><name>reg_map</name><index>[<expr><name>SLJIT_S0</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>compiler</name><operator>-&gt;</operator><name>saveds</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>compiler</name><operator>-&gt;</operator><name>scratches</name></name> <operator>&gt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>POP_REG</name><argument_list>(<argument><expr><name><name>reg_map</name><index>[<expr><name>SLJIT_S1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>compiler</name><operator>-&gt;</operator><name>saveds</name></name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>||</operator> <name><name>compiler</name><operator>-&gt;</operator><name>scratches</name></name> <operator>&gt;</operator> <literal type="number">9</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>POP_REG</name><argument_list>(<argument><expr><name><name>reg_map</name><index>[<expr><name>SLJIT_S2</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>POP_REG</name><argument_list>(<argument><expr><name><name>reg_map</name><index>[<expr><name>TMP_REG1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>SLJIT_X86_32_FASTCALL</name> <operator>&amp;&amp;</operator> <name>SLJIT_X86_32_FASTCALL</name><operator>)</operator></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name><name>compiler</name><operator>-&gt;</operator><name>args</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RET_I16</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RET</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>RET</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------- */</comment>
<comment type="block">/*  Operators                                                            */</comment>
<comment type="block">/* --------------------------------------------------------------------- */</comment>

<comment type="block">/* Size contains the flags as well. */</comment>
<function><type><specifier>static</specifier> <name>sljit_u8</name><modifier>*</modifier></type> <name>emit_x86_instruction</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>size</name></decl></parameter>,
	<comment type="block">/* The register or immediate operand. */</comment>
	<parameter><decl><type><name>sljit_s32</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>imma</name></decl></parameter>,
	<comment type="block">/* The general operand (not immediate). */</comment>
	<parameter><decl><type><name>sljit_s32</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>immb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>inst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>buf_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>flags</name> <init>= <expr><name>size</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0xf</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>inst_size</name></decl>;</decl_stmt>

	<comment type="block">/* Both cannot be switched on. */</comment>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>EX86_BIN_INS</name> <operator>|</operator> <name>EX86_SHIFT_INS</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>EX86_BIN_INS</name> <operator>|</operator> <name>EX86_SHIFT_INS</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Size flags not allowed for typed instructions. */</comment>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>EX86_BIN_INS</name> <operator>|</operator> <name>EX86_SHIFT_INS</name><operator>)</operator><operator>)</operator> <operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>EX86_BYTE_ARG</name> <operator>|</operator> <name>EX86_HALF_ARG</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Both size flags cannot be switched on. */</comment>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>EX86_BYTE_ARG</name> <operator>|</operator> <name>EX86_HALF_ARG</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>EX86_BYTE_ARG</name> <operator>|</operator> <name>EX86_HALF_ARG</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* SSE2 and immediate is not possible. */</comment>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>a</name> <operator>&amp;</operator> <name>SLJIT_IMM</name><operator>)</operator> <operator>||</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_SSE2</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>EX86_PREF_F2</name> <operator>|</operator> <name>EX86_PREF_F3</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>EX86_PREF_F2</name> <operator>|</operator> <name>EX86_PREF_F3</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>EX86_PREF_F2</name> <operator>|</operator> <name>EX86_PREF_66</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>EX86_PREF_F2</name> <operator>|</operator> <name>EX86_PREF_66</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>EX86_PREF_F3</name> <operator>|</operator> <name>EX86_PREF_66</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>EX86_PREF_F3</name> <operator>|</operator> <name>EX86_PREF_66</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We don't support (%ebp). */</comment>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>b</name> <operator>&amp;</operator> <name>SLJIT_MEM</name><operator>)</operator> <operator>||</operator> <name>immb</name> <operator>||</operator> <name><name>reg_map</name><index>[<expr><name>b</name> <operator>&amp;</operator> <name>REG_MASK</name></expr>]</index></name> <operator>!=</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>&amp;=</operator> <literal type="number">0xf</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>inst_size</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>EX86_PREF_F2</name> <operator>|</operator> <name>EX86_PREF_F3</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>inst_size</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_PREF_66</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>inst_size</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Calculate size of b. */</comment>
	<expr_stmt><expr><name>inst_size</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* mod r/m byte. */</comment>
	<if_stmt><if>if <condition>(<expr><name>b</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>b</name> <operator>&amp;</operator> <name>REG_MASK</name><operator>)</operator> <operator>==</operator> <name>SLJIT_UNUSED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>inst_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>immb</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>b</name> <operator>&amp;</operator> <name>OFFS_REG_MASK</name><operator>)</operator></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Immediate operand. */</comment>
			<if_stmt><if>if <condition>(<expr><name>immb</name> <operator>&lt;=</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <name>immb</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>inst_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_s8</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>inst_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>b</name> <operator>&amp;</operator> <name>REG_MASK</name><operator>)</operator> <operator>==</operator> <name>SLJIT_SP</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>b</name> <operator>&amp;</operator> <name>OFFS_REG_MASK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>b</name> <operator>|=</operator> <call><name>TO_OFFS_REG</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>b</name> <operator>&amp;</operator> <name>OFFS_REG_MASK</name><operator>)</operator> <operator>!=</operator> <name>SLJIT_UNUSED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>inst_size</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* SIB byte. */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Calculate size of a. */</comment>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&amp;</operator> <name>SLJIT_IMM</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_BIN_INS</name></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>imma</name> <operator>&lt;=</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <name>imma</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">128</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>inst_size</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EX86_BYTE_ARG</name></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>inst_size</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_SHIFT_INS</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>imma</name> <operator>&amp;=</operator> <literal type="number">0x1f</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>imma</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>inst_size</name> <operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EX86_BYTE_ARG</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_BYTE_ARG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>inst_size</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_HALF_ARG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>inst_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>short</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>inst_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_SHIFT_INS</name><operator>)</operator> <operator>||</operator> <name>a</name> <operator>==</operator> <name>SLJIT_PREF_SHIFT_REG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>inst_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Encoding the byte. */</comment>
	<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><name>inst_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_PREF_F2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <literal type="number">0xf2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_PREF_F3</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <literal type="number">0xf3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_PREF_66</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <literal type="number">0x66</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>buf_ptr</name> <operator>=</operator> <name>inst</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>

	<comment type="block">/* Encode mod/rm byte. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_SHIFT_INS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_BIN_INS</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>a</name> <operator>&amp;</operator> <name>SLJIT_IMM</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>inst</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_BYTE_ARG</name><operator>)</operator></expr> ?</condition><then> <expr><name>GROUP_BINARY_83</name></expr> </then><else>: <expr><name>GROUP_BINARY_81</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&amp;</operator> <name>SLJIT_IMM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>buf_ptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_SSE2_OP1</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>buf_ptr</name> <operator>=</operator> <name><name>reg_map</name><index>[<expr><name>a</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>buf_ptr</name> <operator>=</operator> <name>a</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&amp;</operator> <name>SLJIT_IMM</name></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>imma</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>inst</name> <operator>=</operator> <name>GROUP_SHIFT_1</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>inst</name> <operator>=</operator> <name>GROUP_SHIFT_N</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>inst</name> <operator>=</operator> <name>GROUP_SHIFT_CL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>buf_ptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>b</name> <operator>&amp;</operator> <name>SLJIT_MEM</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>buf_ptr</name><operator>++</operator> <operator>|=</operator> <name>MOD_REG</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_SSE2_OP2</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name><name>reg_map</name><index>[<expr><name>b</name></expr>]</index></name></expr> </then><else>: <expr><name>b</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>b</name> <operator>&amp;</operator> <name>REG_MASK</name><operator>)</operator> <operator>!=</operator> <name>SLJIT_UNUSED</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>b</name> <operator>&amp;</operator> <name>OFFS_REG_MASK</name><operator>)</operator> <operator>==</operator> <name>SLJIT_UNUSED</name> <operator>||</operator> <operator>(</operator><name>b</name> <operator>&amp;</operator> <name>OFFS_REG_MASK</name><operator>)</operator> <operator>==</operator> <call><name>TO_OFFS_REG</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>immb</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>immb</name> <operator>&lt;=</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <name>immb</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>buf_ptr</name> <operator>|=</operator> <literal type="number">0x40</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>buf_ptr</name> <operator>|=</operator> <literal type="number">0x80</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>b</name> <operator>&amp;</operator> <name>OFFS_REG_MASK</name><operator>)</operator> <operator>==</operator> <name>SLJIT_UNUSED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>buf_ptr</name><operator>++</operator> <operator>|=</operator> <name><name>reg_map</name><index>[<expr><name>b</name> <operator>&amp;</operator> <name>REG_MASK</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<else>else <block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>buf_ptr</name><operator>++</operator> <operator>|=</operator> <literal type="number">0x04</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>buf_ptr</name><operator>++</operator> <operator>=</operator> <name><name>reg_map</name><index>[<expr><name>b</name> <operator>&amp;</operator> <name>REG_MASK</name></expr>]</index></name> <operator>|</operator> <operator>(</operator><name><name>reg_map</name><index>[<expr><call><name>OFFS_REG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>immb</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>immb</name> <operator>&lt;=</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <name>immb</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>buf_ptr</name><operator>++</operator> <operator>=</operator> <name>immb</name></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* 8 bit displacement. */</comment>
				<else>else <block>{<block_content>
					<expr_stmt><expr><call><name>sljit_unaligned_store_sw</name><argument_list>(<argument><expr><name>buf_ptr</name></expr></argument>, <argument><expr><name>immb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 32 bit displacement. */</comment>
					<expr_stmt><expr><name>buf_ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else <block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>buf_ptr</name><operator>++</operator> <operator>|=</operator> <literal type="number">0x04</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>buf_ptr</name><operator>++</operator> <operator>=</operator> <name><name>reg_map</name><index>[<expr><name>b</name> <operator>&amp;</operator> <name>REG_MASK</name></expr>]</index></name> <operator>|</operator> <operator>(</operator><name><name>reg_map</name><index>[<expr><call><name>OFFS_REG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>immb</name> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>buf_ptr</name><operator>++</operator> <operator>|=</operator> <literal type="number">0x05</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sljit_unaligned_store_sw</name><argument_list>(<argument><expr><name>buf_ptr</name></expr></argument>, <argument><expr><name>immb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 32 bit displacement. */</comment>
		<expr_stmt><expr><name>buf_ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&amp;</operator> <name>SLJIT_IMM</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_BYTE_ARG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>buf_ptr</name> <operator>=</operator> <name>imma</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_HALF_ARG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>sljit_unaligned_store_s16</name><argument_list>(<argument><expr><name>buf_ptr</name></expr></argument>, <argument><expr><name>imma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_SHIFT_INS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>sljit_unaligned_store_sw</name><argument_list>(<argument><expr><name>buf_ptr</name></expr></argument>, <argument><expr><name>imma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><ternary><condition><expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_SHIFT_INS</name><operator>)</operator></expr> ?</condition><then> <expr><name>inst</name></expr> </then><else>: <expr><operator>(</operator><name>inst</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------- */</comment>
<comment type="block">/*  Call / return instructions                                           */</comment>
<comment type="block">/* --------------------------------------------------------------------- */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>SLJIT_X86_32_FASTCALL</name> <operator>&amp;&amp;</operator> <name>SLJIT_X86_32_FASTCALL</name><operator>)</operator></expr></cpp:if>

<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>c_fast_call_get_stack_size</name><parameter_list>(<parameter><decl><type><name>sljit_s32</name></type> <name>arg_types</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name> <modifier>*</modifier></type><name>word_arg_count_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>stack_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>word_arg_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>arg_types</name> <operator>&gt;&gt;=</operator> <name>SLJIT_DEF_SHIFT</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>arg_types</name></expr>)</condition> <block>{<block_content>
		<switch>switch <condition>(<expr><name>arg_types</name> <operator>&amp;</operator> <name>SLJIT_DEF_MASK</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>SLJIT_ARG_TYPE_F32</name></expr>:</case>
			<expr_stmt><expr><name>stack_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_f32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_ARG_TYPE_F64</name></expr>:</case>
			<expr_stmt><expr><name>stack_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_f64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>word_arg_count</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>word_arg_count</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>stack_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></switch>

		<expr_stmt><expr><name>arg_types</name> <operator>&gt;&gt;=</operator> <name>SLJIT_DEF_SHIFT</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>word_arg_count_ptr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>word_arg_count_ptr</name> <operator>=</operator> <name>word_arg_count</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>stack_size</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>c_fast_call_with_args</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>arg_types</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>stack_size</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>word_arg_count</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>swap_args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>inst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>float_arg_count</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>stack_size</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator> <name>word_arg_count</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PUSH_REG</name><argument_list>(<argument><expr><name><name>reg_map</name><index>[<expr><name>SLJIT_R2</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>stack_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>word_arg_count</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>compiler</name><operator>-&gt;</operator><name>saveds_offset</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_non_cum_binary</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>BINARY_OPCODE</name><argument_list>(<argument><expr><name>SUB</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>stack_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>stack_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>arg_types</name> <operator>&gt;&gt;=</operator> <name>SLJIT_DEF_SHIFT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>word_arg_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>float_arg_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>arg_types</name></expr>)</condition> <block>{<block_content>
			<switch>switch <condition>(<expr><name>arg_types</name> <operator>&amp;</operator> <name>SLJIT_DEF_MASK</name></expr>)</condition> <block>{<block_content>
			<case>case <expr><name>SLJIT_ARG_TYPE_F32</name></expr>:</case>
				<expr_stmt><expr><name>float_arg_count</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_sse2_store</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stack_size</name></expr></argument>, <argument><expr><name>float_arg_count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>stack_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_f32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_ARG_TYPE_F64</name></expr>:</case>
				<expr_stmt><expr><name>float_arg_count</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_sse2_store</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stack_size</name></expr></argument>, <argument><expr><name>float_arg_count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>stack_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_f64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><name>word_arg_count</name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>word_arg_count</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stack_size</name></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>stack_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>word_arg_count</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stack_size</name></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>stack_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></switch>

			<expr_stmt><expr><name>arg_types</name> <operator>&gt;&gt;=</operator> <name>SLJIT_DEF_SHIFT</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>word_arg_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>swap_args</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>XCHG_EAX_r</name> <operator>|</operator> <name><name>reg_map</name><index>[<expr><name>SLJIT_R2</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else <block>{<block_content>
			<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>MOV_r_rm</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>MOD_REG</name> <operator>|</operator> <operator>(</operator><name><name>reg_map</name><index>[<expr><name>SLJIT_R2</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <name><name>reg_map</name><index>[<expr><name>SLJIT_R0</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>cdecl_call_get_stack_size</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>arg_types</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name> <modifier>*</modifier></type><name>word_arg_count_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>stack_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>word_arg_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>arg_types</name> <operator>&gt;&gt;=</operator> <name>SLJIT_DEF_SHIFT</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>arg_types</name></expr>)</condition> <block>{<block_content>
		<switch>switch <condition>(<expr><name>arg_types</name> <operator>&amp;</operator> <name>SLJIT_DEF_MASK</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>SLJIT_ARG_TYPE_F32</name></expr>:</case>
			<expr_stmt><expr><name>stack_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_f32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_ARG_TYPE_F64</name></expr>:</case>
			<expr_stmt><expr><name>stack_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_f64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>word_arg_count</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>stack_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></switch>

		<expr_stmt><expr><name>arg_types</name> <operator>&gt;&gt;=</operator> <name>SLJIT_DEF_SHIFT</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>word_arg_count_ptr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>word_arg_count_ptr</name> <operator>=</operator> <name>word_arg_count</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>stack_size</name> <operator>&lt;=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>stack_tmp_size</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<return>return <expr><operator>(</operator><operator>(</operator><name>stack_size</name> <operator>-</operator> <name><name>compiler</name><operator>-&gt;</operator><name>stack_tmp_size</name></name> <operator>+</operator> <literal type="number">15</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">15</literal><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><name>stack_size</name> <operator>-</operator> <name><name>compiler</name><operator>-&gt;</operator><name>stack_tmp_size</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>cdecl_call_with_args</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>arg_types</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>stack_size</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>word_arg_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>float_arg_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>word_arg_count</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>compiler</name><operator>-&gt;</operator><name>saveds_offset</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>stack_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_non_cum_binary</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>BINARY_OPCODE</name><argument_list>(<argument><expr><name>SUB</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>stack_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>stack_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>word_arg_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>arg_types</name> <operator>&gt;&gt;=</operator> <name>SLJIT_DEF_SHIFT</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>arg_types</name></expr>)</condition> <block>{<block_content>
		<switch>switch <condition>(<expr><name>arg_types</name> <operator>&amp;</operator> <name>SLJIT_DEF_MASK</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>SLJIT_ARG_TYPE_F32</name></expr>:</case>
			<expr_stmt><expr><name>float_arg_count</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_sse2_store</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stack_size</name></expr></argument>, <argument><expr><name>float_arg_count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>stack_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_f32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_ARG_TYPE_F64</name></expr>:</case>
			<expr_stmt><expr><name>float_arg_count</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_sse2_store</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stack_size</name></expr></argument>, <argument><expr><name>float_arg_count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>stack_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_f64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>word_arg_count</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stack_size</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>word_arg_count</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator></expr> ?</condition><then> <expr><name>TMP_REG1</name></expr> </then><else>: <expr><name>word_arg_count</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>stack_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></switch>

		<expr_stmt><expr><name>arg_types</name> <operator>&gt;&gt;=</operator> <name>SLJIT_DEF_SHIFT</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>post_call_with_args</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>arg_types</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>stack_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>inst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>single</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>stack_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_cum_binary</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>BINARY_OPCODE</name><argument_list>(<argument><expr><name>ADD</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>stack_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>arg_types</name> <operator>&amp;</operator> <name>SLJIT_DEF_MASK</name><operator>)</operator> <operator>&lt;</operator> <name>SLJIT_ARG_TYPE_F32</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>single</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>arg_types</name> <operator>&amp;</operator> <name>SLJIT_DEF_MASK</name><operator>)</operator> <operator>==</operator> <name>SLJIT_ARG_TYPE_F32</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>single</name></expr> ?</condition><then> <expr><name>FSTPS</name></expr> </then><else>: <expr><name>FSTPD</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><literal type="number">0x03</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x04</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><literal type="number">0x04</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <name><name>reg_map</name><index>[<expr><name>SLJIT_SP</name></expr>]</index></name></expr>;</expr_stmt>

	<return>return <expr><call><name>emit_sse2_load</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>single</name></expr></argument>, <argument><expr><name>SLJIT_FR0</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name><name>struct</name> <name>sljit_jump</name></name><modifier>*</modifier></type> <name>sljit_emit_call</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>type</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>arg_types</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>stack_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>word_arg_count</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR_PTR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_PTR</name><argument_list>(<argument><expr><call><name>check_sljit_emit_call</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>SLJIT_X86_32_FASTCALL</name> <operator>&amp;&amp;</operator> <name>SLJIT_X86_32_FASTCALL</name><operator>)</operator></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>type</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>==</operator> <name>SLJIT_CALL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>stack_size</name> <operator>=</operator> <call><name>c_fast_call_get_stack_size</name><argument_list>(<argument><expr><name>arg_types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_arg_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><call><name>c_fast_call_with_args</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>stack_size</name></expr></argument>, <argument><expr><name>word_arg_count</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>SLJIT_VERBOSE</name> <operator>&amp;&amp;</operator> <name>SLJIT_VERBOSE</name><operator>)</operator> \
		<operator>||</operator> <operator>(</operator><name>defined</name> <name>SLJIT_ARGUMENT_CHECKS</name> <operator>&amp;&amp;</operator> <name>SLJIT_ARGUMENT_CHECKS</name><operator>)</operator></expr></cpp:if>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>skip_checks</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>sljit_emit_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><name>jump</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><call><name>post_call_with_args</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>jump</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>stack_size</name> <operator>=</operator> <call><name>cdecl_call_get_stack_size</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_arg_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><call><name>cdecl_call_with_args</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>stack_size</name></expr></argument>, <argument><expr><name>word_arg_count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>SLJIT_VERBOSE</name> <operator>&amp;&amp;</operator> <name>SLJIT_VERBOSE</name><operator>)</operator> \
		<operator>||</operator> <operator>(</operator><name>defined</name> <name>SLJIT_ARGUMENT_CHECKS</name> <operator>&amp;&amp;</operator> <name>SLJIT_ARGUMENT_CHECKS</name><operator>)</operator></expr></cpp:if>
	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>skip_checks</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>sljit_emit_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><name>jump</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><call><name>post_call_with_args</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>stack_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>jump</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_icall</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>type</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>arg_types</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>srcw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>stack_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>word_arg_count</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>SLJIT_X86_32_FASTCALL</name> <operator>&amp;&amp;</operator> <name>SLJIT_X86_32_FASTCALL</name><operator>)</operator></expr></cpp:if>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>swap_args</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_emit_icall</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>SLJIT_X86_32_FASTCALL</name> <operator>&amp;&amp;</operator> <name>SLJIT_X86_32_FASTCALL</name><operator>)</operator></expr></cpp:if>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>reg_map</name><index>[<expr><name>SLJIT_R0</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>reg_map</name><index>[<expr><name>SLJIT_R2</name></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>SLJIT_R0</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>SLJIT_R2</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>type</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>==</operator> <name>SLJIT_CALL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>stack_size</name> <operator>=</operator> <call><name>c_fast_call_get_stack_size</name><argument_list>(<argument><expr><name>arg_types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_arg_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>swap_args</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>word_arg_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>src</name> <operator>&amp;</operator> <name>REG_MASK</name><operator>)</operator> <operator>==</operator> <name>SLJIT_R2</name> <operator>||</operator> <call><name>OFFS_REG</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SLJIT_R2</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>swap_args</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>src</name> <operator>&amp;</operator> <name>REG_MASK</name><operator>)</operator> <operator>|</operator> <literal type="number">0x2</literal><operator>)</operator> <operator>==</operator> <name>SLJIT_R2</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>src</name> <operator>^=</operator> <literal type="number">0x2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>OFFS_REG</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call> <operator>|</operator> <literal type="number">0x2</literal><operator>)</operator> <operator>==</operator> <name>SLJIT_R2</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>src</name> <operator>^=</operator> <call><name>TO_OFFS_REG</name><argument_list>(<argument><expr><literal type="number">0x2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>c_fast_call_with_args</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>stack_size</name></expr></argument>, <argument><expr><name>word_arg_count</name></expr></argument>, <argument><expr><name>swap_args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>saveds_offset</name></name> <operator>+=</operator> <name>stack_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>locals_offset</name></name> <operator>+=</operator> <name>stack_size</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>SLJIT_VERBOSE</name> <operator>&amp;&amp;</operator> <name>SLJIT_VERBOSE</name><operator>)</operator> \
		<operator>||</operator> <operator>(</operator><name>defined</name> <name>SLJIT_ARGUMENT_CHECKS</name> <operator>&amp;&amp;</operator> <name>SLJIT_ARGUMENT_CHECKS</name><operator>)</operator></expr></cpp:if>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>skip_checks</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>sljit_emit_ijump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>saveds_offset</name></name> <operator>-=</operator> <name>stack_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>locals_offset</name></name> <operator>-=</operator> <name>stack_size</name></expr>;</expr_stmt>

		<return>return <expr><call><name>post_call_with_args</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>stack_size</name> <operator>=</operator> <call><name>cdecl_call_get_stack_size</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>word_arg_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>cdecl_call_with_args</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>stack_size</name></expr></argument>, <argument><expr><name>word_arg_count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>saveds_offset</name></name> <operator>+=</operator> <name>stack_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>locals_offset</name></name> <operator>+=</operator> <name>stack_size</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>SLJIT_VERBOSE</name> <operator>&amp;&amp;</operator> <name>SLJIT_VERBOSE</name><operator>)</operator> \
		<operator>||</operator> <operator>(</operator><name>defined</name> <name>SLJIT_ARGUMENT_CHECKS</name> <operator>&amp;&amp;</operator> <name>SLJIT_ARGUMENT_CHECKS</name><operator>)</operator></expr></cpp:if>
	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>skip_checks</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>sljit_emit_ijump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>saveds_offset</name></name> <operator>-=</operator> <name>stack_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>locals_offset</name></name> <operator>-=</operator> <name>stack_size</name></expr>;</expr_stmt>

	<return>return <expr><call><name>post_call_with_args</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>stack_size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_fast_enter</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>dstw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>inst</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADJUST_LOCAL_OFFSET</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECK_EXTRA_REGS</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* For UNUSED dst. Uncommon, but possible. */</comment>
	<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>==</operator> <name>SLJIT_UNUSED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dst</name> <operator>=</operator> <name>TMP_REG1</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Unused dest is possible here. */</comment>
		<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POP_REG</name><argument_list>(<argument><expr><name><name>reg_map</name><index>[<expr><name>dst</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Memory. */</comment>
	<expr_stmt><expr><name>inst</name> <operator>=</operator> <call><name>emit_x86_instruction</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>POP_rm</name></expr>;</expr_stmt>
	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>emit_fast_return</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>srcw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>inst</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_EXTRA_REGS</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PUSH_REG</name><argument_list>(<argument><expr><name><name>reg_map</name><index>[<expr><name>src</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else <block>{<block_content>
		<expr_stmt><expr><name>inst</name> <operator>=</operator> <call><name>emit_x86_instruction</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>GROUP_FF</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>inst</name> <operator>|=</operator> <name>PUSH_rm</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>RET</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>skip_frames_before_return</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>saved_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>has_f64_aligment</name></decl>;</decl_stmt>

	<comment type="block">/* Don't adjust shadow stack if it isn't enabled.  */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cpu_has_shadow_stack</name> <argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>compiler</name><operator>-&gt;</operator><name>args</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<expr_stmt><expr><name>has_f64_aligment</name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>SLJIT_F64_ALIGNMENT</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>has_f64_aligment</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>saved_size</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>compiler</name><operator>-&gt;</operator><name>scratches</name></name> <operator>&gt;</operator> <literal type="number">9</literal></expr> ?</condition><then> <expr><operator>(</operator><name><name>compiler</name><operator>-&gt;</operator><name>scratches</name></name> <operator>-</operator> <literal type="number">9</literal><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>compiler</name><operator>-&gt;</operator><name>saveds</name></name> <operator>&lt;=</operator> <literal type="number">3</literal></expr> ?</condition><then> <expr><name><name>compiler</name><operator>-&gt;</operator><name>saveds</name></name></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary><operator>)</operator><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_uw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>has_f64_aligment</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* mov TMP_REG1, [esp + local_size].  */</comment>
		<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* mov TMP_REG1, [TMP_REG1+ saved_size].  */</comment>
		<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP_REG1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>saved_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Move return address to [esp]. */</comment>
		<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>+=</operator> <name>saved_size</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><call><name>adjust_shadow_stack</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
