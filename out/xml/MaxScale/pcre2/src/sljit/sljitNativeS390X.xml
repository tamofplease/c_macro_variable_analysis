<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/pcre2/src/sljit/sljitNativeS390X.c"><comment type="block">/*
 *    Stack-less Just-In-Time compiler
 *
 *    Copyright Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *   1. Redistributions of source code must retain the above copyright notice, this list of
 *      conditions and the following disclaimer.
 *
 *   2. Redistributions in binary form must reproduce the above copyright notice, this list
 *      of conditions and the following disclaimer in the documentation and/or other materials
 *      provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/auxv.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__ARCH__</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENABLE_STATIC_FACILITY_DETECTION</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENABLE_STATIC_FACILITY_DETECTION</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENABLE_DYNAMIC_FACILITY_DETECTION</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>sljit_get_platform_name</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><literal type="string">"s390x"</literal> <name>SLJIT_CPUINFO</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Instructions. */</comment>
<typedef>typedef <type><name>sljit_uw</name></type> <name>sljit_ins</name>;</typedef>

<comment type="block">/* Instruction tags (most significant halfword). */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_ins</name></type> <name>sljit_ins_const</name> <init>= <expr><operator>(</operator><name>sljit_ins</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">48</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sljit_u8</name></type> <name><name>reg_map</name><index>[<expr><name>SLJIT_NUMBER_OF_REGISTERS</name> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{
	<expr><literal type="number">14</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">9</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* there are also a[2-15] available, but they are slower to access and
 * their use is limited as mundaym explained:
 *   https://github.com/zherczeg/sljit/pull/91#discussion_r486895689
 */</comment>

<comment type="block">/* General Purpose Registers [0-15]. */</comment>
<typedef>typedef <type><name>sljit_uw</name></type> <name>sljit_gpr</name>;</typedef>

<comment type="block">/*
 * WARNING
 * the following code is non standard and should be improved for
 * consistency, but doesn't use SLJIT_NUMBER_OF_REGISTERS based
 * registers because r0 and r1 are the ABI recommended volatiles.
 * there is a gpr() function that maps sljit to physical register numbers
 * that should be used instead of the usual index into reg_map[] and
 * will be retired ASAP (TODO: carenas)
 */</comment>

<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_gpr</name></type> <name>r0</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* reg_map[SLJIT_NUMBER_OF_REGISTERS + 2]: 0 in address calculations; reserved */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_gpr</name></type> <name>r1</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* reg_map[SLJIT_NUMBER_OF_REGISTERS + 3]: reserved */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_gpr</name></type> <name>r2</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* reg_map[1]: 1st argument */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_gpr</name></type> <name>r3</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* reg_map[2]: 2nd argument */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_gpr</name></type> <name>r4</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* reg_map[3]: 3rd argument */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_gpr</name></type> <name>r5</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* reg_map[4]: 4th argument */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_gpr</name></type> <name>r6</name> <init>= <expr><literal type="number">6</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* reg_map[5]: 5th argument; 1st saved register */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_gpr</name></type> <name>r7</name> <init>= <expr><literal type="number">7</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* reg_map[6] */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_gpr</name></type> <name>r8</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* reg_map[7] */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_gpr</name></type> <name>r9</name> <init>= <expr><literal type="number">9</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* reg_map[8] */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_gpr</name></type> <name>r10</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* reg_map[9] */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_gpr</name></type> <name>r11</name> <init>= <expr><literal type="number">11</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* reg_map[10] */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_gpr</name></type> <name>r12</name> <init>= <expr><literal type="number">12</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* reg_map[11]: GOT */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_gpr</name></type> <name>r13</name> <init>= <expr><literal type="number">13</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* reg_map[12]: Literal Pool pointer */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_gpr</name></type> <name>r14</name> <init>= <expr><literal type="number">14</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* reg_map[0]: return address and flag register */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_gpr</name></type> <name>r15</name> <init>= <expr><literal type="number">15</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* reg_map[SLJIT_NUMBER_OF_REGISTERS + 1]: stack pointer */</comment>

<comment type="block">/* WARNING: r12 and r13 shouldn't be used as per ABI recommendation */</comment>
<comment type="block">/* TODO(carenas): r12 might conflict in PIC code, reserve? */</comment>
<comment type="block">/* TODO(carenas): r13 is usually pointed to "pool" per ABI, using a tmp
 *                like we do know might be faster though, reserve?
 */</comment>

<comment type="block">/* TODO(carenas): should be named TMP_REG[1-2] for consistency */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tmp0</name></cpp:macro>	<cpp:value>r0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tmp1</name></cpp:macro>	<cpp:value>r1</cpp:value></cpp:define>

<comment type="block">/* TODO(carenas): flags should move to a different register so that
 *                link register doesn't need to change
 */</comment>

<comment type="block">/* Link registers. The normal link register is r14, but since
   we use that for flags we need to use r0 instead to do fast
   calls so that flags are preserved. */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_gpr</name></type> <name>link_r</name> <init>= <expr><literal type="number">14</literal></expr></init></decl>;</decl_stmt>     <comment type="block">/* r14 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_gpr</name></type> <name>fast_link_r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* r0 */</comment>

<comment type="block">/* Flag register layout:

   0               32  33  34      36      64
   +---------------+---+---+-------+-------+
   |      ZERO     | 0 | 0 |  C C  |///////|
   +---------------+---+---+-------+-------+
*/</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_gpr</name></type> <name>flag_r</name> <init>= <expr><literal type="number">14</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* r14 */</comment>

<struct>struct <name>sljit_s390x_const</name> <block>{
	<decl_stmt><decl><type><name><name>struct</name> <name>sljit_const</name></name></type> <name>const_</name></decl>;</decl_stmt> <comment type="block">/* must be first */</comment>
	<decl_stmt><decl><type><name>sljit_sw</name></type> <name>init_value</name></decl>;</decl_stmt>       <comment type="block">/* required to build literal pool */</comment>
}</block>;</struct>

<comment type="block">/* Convert SLJIT register to hardware register. */</comment>
<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>sljit_gpr</name></type> <name>gpr</name><parameter_list>(<parameter><decl><type><name>sljit_s32</name></type> <name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>r</name> <operator>!=</operator> <name>SLJIT_UNUSED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>r</name> <operator>&lt;</operator> <operator>(</operator><name>sljit_s32</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>reg_map</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>reg_map</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>reg_map</name><index>[<expr><name>r</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Size of instruction in bytes. Tags must already be cleared. */</comment>
<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>sljit_uw</name></type> <name>sizeof_ins</name><parameter_list>(<parameter><decl><type><name>sljit_ins</name></type> <name>ins</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* keep faulting instructions */</comment>
	<if_stmt><if>if <condition>(<expr><name>ins</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		 <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ins</name> <operator>&amp;</operator> <literal type="number">0x00000000ffffL</literal><operator>)</operator> <operator>==</operator> <name>ins</name></expr>)</condition><block type="pseudo"><block_content>
		 <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ins</name> <operator>&amp;</operator> <literal type="number">0x0000ffffffffL</literal><operator>)</operator> <operator>==</operator> <name>ins</name></expr>)</condition><block type="pseudo"><block_content>
		 <return>return <expr><literal type="number">4</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ins</name> <operator>&amp;</operator> <literal type="number">0xffffffffffffL</literal><operator>)</operator> <operator>==</operator> <name>ins</name></expr>)</condition><block type="pseudo"><block_content>
		 <return>return <expr><literal type="number">6</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>sljit_uw</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>push_inst</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_ins</name></type> <name>ins</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_ins</name> <modifier>*</modifier></type><name>ibuf</name> <init>= <expr><operator>(</operator><name>sljit_ins</name> <operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_ins</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>ibuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>ibuf</name> <operator>=</operator> <name>ins</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>size</name></name><operator>++</operator></expr>;</expr_stmt>
	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>encode_inst</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>sljit_ins</name></type> <name>ins</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_u16</name> <modifier>*</modifier></type><name>ibuf</name> <init>= <expr><operator>(</operator><name>sljit_u16</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_uw</name></type> <name>size</name> <init>= <expr><call><name>sizeof_ins</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>size</name> <operator>&amp;</operator> <literal type="number">6</literal><operator>)</operator> <operator>==</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>size</name></expr>)</condition> <block>{<block_content>
	<case>case <expr><literal type="number">6</literal></expr>:</case>
		<expr_stmt><expr><operator>*</operator><name>ibuf</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>sljit_u16</name><operator>)</operator><operator>(</operator><name>ins</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* fallthrough */</comment>
	<case>case <expr><literal type="number">4</literal></expr>:</case>
		<expr_stmt><expr><operator>*</operator><name>ibuf</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>sljit_u16</name><operator>)</operator><operator>(</operator><name>ins</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* fallthrough */</comment>
	<case>case <expr><literal type="number">2</literal></expr>:</case>
		<expr_stmt><expr><operator>*</operator><name>ibuf</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>sljit_u16</name><operator>)</operator><operator>(</operator><name>ins</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>ibuf</name></expr>;</expr_stmt>
	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Map the given type to a 4-bit condition code mask. */</comment>
<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>sljit_u8</name></type> <name>get_cc</name><parameter_list>(<parameter><decl><type><name>sljit_s32</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_u8</name></type> <name>eq</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* equal {,to zero} */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_u8</name></type> <name>lt</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* less than {,zero} */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_u8</name></type> <name>gt</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* greater than {,zero} */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_u8</name></type> <name>ov</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* {overflow,NaN} */</comment>

	<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>SLJIT_EQUAL</name></expr>:</case>
	<case>case <expr><name>SLJIT_EQUAL_F64</name></expr>:</case>
		<return>return <expr><name>eq</name></expr>;</return>

	<case>case <expr><name>SLJIT_NOT_EQUAL</name></expr>:</case>
	<case>case <expr><name>SLJIT_NOT_EQUAL_F64</name></expr>:</case>
		<return>return <expr><operator>~</operator><name>eq</name></expr>;</return>

	<case>case <expr><name>SLJIT_LESS</name></expr>:</case>
	<case>case <expr><name>SLJIT_SIG_LESS</name></expr>:</case>
	<case>case <expr><name>SLJIT_LESS_F64</name></expr>:</case>
		<return>return <expr><name>lt</name></expr>;</return>

	<case>case <expr><name>SLJIT_LESS_EQUAL</name></expr>:</case>
	<case>case <expr><name>SLJIT_SIG_LESS_EQUAL</name></expr>:</case>
	<case>case <expr><name>SLJIT_LESS_EQUAL_F64</name></expr>:</case>
		<return>return <expr><operator>(</operator><name>lt</name> <operator>|</operator> <name>eq</name><operator>)</operator></expr>;</return>

	<case>case <expr><name>SLJIT_GREATER</name></expr>:</case>
	<case>case <expr><name>SLJIT_SIG_GREATER</name></expr>:</case>
	<case>case <expr><name>SLJIT_GREATER_F64</name></expr>:</case>
		<return>return <expr><name>gt</name></expr>;</return>

	<case>case <expr><name>SLJIT_GREATER_EQUAL</name></expr>:</case>
	<case>case <expr><name>SLJIT_SIG_GREATER_EQUAL</name></expr>:</case>
	<case>case <expr><name>SLJIT_GREATER_EQUAL_F64</name></expr>:</case>
		<return>return <expr><operator>(</operator><name>gt</name> <operator>|</operator> <name>eq</name><operator>)</operator></expr>;</return>

	<case>case <expr><name>SLJIT_OVERFLOW</name></expr>:</case>
	<case>case <expr><name>SLJIT_MUL_OVERFLOW</name></expr>:</case>
	<case>case <expr><name>SLJIT_UNORDERED_F64</name></expr>:</case>
		<return>return <expr><name>ov</name></expr>;</return>

	<case>case <expr><name>SLJIT_NOT_OVERFLOW</name></expr>:</case>
	<case>case <expr><name>SLJIT_MUL_NOT_OVERFLOW</name></expr>:</case>
	<case>case <expr><name>SLJIT_ORDERED_F64</name></expr>:</case>
		<return>return <expr><operator>~</operator><name>ov</name></expr>;</return>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>sljit_u8</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Facility to bit index mappings.
   Note: some facilities share the same bit index. */</comment>
<typedef>typedef <type><name>sljit_uw</name></type> <name>facility_bit</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORE_FACILITY_LIST_EXTENDED_FACILITY</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FAST_LONG_DISPLACEMENT_FACILITY</name></cpp:macro> <cpp:value>19</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTENDED_IMMEDIATE_FACILITY</name></cpp:macro> <cpp:value>21</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GENERAL_INSTRUCTION_EXTENSION_FACILITY</name></cpp:macro> <cpp:value>34</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISTINCT_OPERAND_FACILITY</name></cpp:macro> <cpp:value>45</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HIGH_WORD_FACILITY</name></cpp:macro> <cpp:value>45</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPULATION_COUNT_FACILITY</name></cpp:macro> <cpp:value>45</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD_STORE_ON_CONDITION_1_FACILITY</name></cpp:macro> <cpp:value>45</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MISCELLANEOUS_INSTRUCTION_EXTENSIONS_1_FACILITY</name></cpp:macro> <cpp:value>49</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD_STORE_ON_CONDITION_2_FACILITY</name></cpp:macro> <cpp:value>53</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MISCELLANEOUS_INSTRUCTION_EXTENSIONS_2_FACILITY</name></cpp:macro> <cpp:value>58</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VECTOR_FACILITY</name></cpp:macro> <cpp:value>129</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VECTOR_ENHANCEMENTS_1_FACILITY</name></cpp:macro> <cpp:value>135</cpp:value></cpp:define>

<comment type="block">/* Report whether a facility is known to be present due to the compiler
   settings. This function should always be compiled to a constant
   value given a constant argument. */</comment>
<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>int</name></type> <name>have_facility_static</name><parameter_list>(<parameter><decl><type><name>facility_bit</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ENABLE_STATIC_FACILITY_DETECTION</name></expr></cpp:if>
	<switch>switch <condition>(<expr><name>x</name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>FAST_LONG_DISPLACEMENT_FACILITY</name></expr>:</case>
		<return>return <expr><operator>(</operator><name>__ARCH__</name> <operator>&gt;=</operator>  <literal type="number">6</literal> <comment type="block">/* z990 */</comment><operator>)</operator></expr>;</return>
	<case>case <expr><name>EXTENDED_IMMEDIATE_FACILITY</name></expr>:</case>
	<case>case <expr><name>STORE_FACILITY_LIST_EXTENDED_FACILITY</name></expr>:</case>
		<return>return <expr><operator>(</operator><name>__ARCH__</name> <operator>&gt;=</operator>  <literal type="number">7</literal> <comment type="block">/* z9-109 */</comment><operator>)</operator></expr>;</return>
	<case>case <expr><name>GENERAL_INSTRUCTION_EXTENSION_FACILITY</name></expr>:</case>
		<return>return <expr><operator>(</operator><name>__ARCH__</name> <operator>&gt;=</operator>  <literal type="number">8</literal> <comment type="block">/* z10 */</comment><operator>)</operator></expr>;</return>
	<case>case <expr><name>DISTINCT_OPERAND_FACILITY</name></expr>:</case>
		<return>return <expr><operator>(</operator><name>__ARCH__</name> <operator>&gt;=</operator>  <literal type="number">9</literal> <comment type="block">/* z196 */</comment><operator>)</operator></expr>;</return>
	<case>case <expr><name>MISCELLANEOUS_INSTRUCTION_EXTENSIONS_1_FACILITY</name></expr>:</case>
		<return>return <expr><operator>(</operator><name>__ARCH__</name> <operator>&gt;=</operator> <literal type="number">10</literal> <comment type="block">/* zEC12 */</comment><operator>)</operator></expr>;</return>
	<case>case <expr><name>LOAD_STORE_ON_CONDITION_2_FACILITY</name></expr>:</case>
	<case>case <expr><name>VECTOR_FACILITY</name></expr>:</case>
		<return>return <expr><operator>(</operator><name>__ARCH__</name> <operator>&gt;=</operator> <literal type="number">11</literal> <comment type="block">/* z13 */</comment><operator>)</operator></expr>;</return>
	<case>case <expr><name>MISCELLANEOUS_INSTRUCTION_EXTENSIONS_2_FACILITY</name></expr>:</case>
	<case>case <expr><name>VECTOR_ENHANCEMENTS_1_FACILITY</name></expr>:</case>
		<return>return <expr><operator>(</operator><name>__ARCH__</name> <operator>&gt;=</operator> <literal type="number">12</literal> <comment type="block">/* z14 */</comment><operator>)</operator></expr>;</return>
	<default>default:</default>
		<expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>unsigned</name> <name>long</name></type> <name>get_hwcap</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>hwcap</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><operator>!</operator><name>hwcap</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>hwcap</name> <operator>=</operator> <call><name>getauxval</name><argument_list>(<argument><expr><name>AT_HWCAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>hwcap</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>hwcap</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>int</name></type> <name>have_stfle</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>have_facility_static</name><argument_list>(<argument><expr><name>STORE_FACILITY_LIST_EXTENDED_FACILITY</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><call><name>get_hwcap</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>HWCAP_S390_STFLE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Report whether the given facility is available. This function always
   performs a runtime check. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>have_facility_dynamic</name><parameter_list>(<parameter><decl><type><name>facility_bit</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ENABLE_DYNAMIC_FACILITY_DETECTION</name></expr></cpp:if>
	<struct><specifier>static</specifier> struct <block>{
		<decl_stmt><decl><type><name>sljit_uw</name></type> <name><name>bits</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	}</block> <decl><name>cpu_features</name></decl>;</struct>
	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>cpu_features</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_uw</name></type> <name>word_index</name> <init>= <expr><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_uw</name></type> <name>bit_index</name> <init>= <expr><operator>(</operator><operator>(</operator><literal type="number">1UL</literal> <operator>&lt;&lt;</operator> <literal type="number">63</literal><operator>)</operator> <operator>&gt;&gt;</operator> <operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">63</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>x</name> <operator>&lt;</operator> <name>size</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><operator>!</operator><call><name>have_stfle</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><name><name>cpu_features</name><operator>.</operator><name>bits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<asm>__asm__ <specifier>__volatile__</specifier> (
			"lgr   %%r0, %0;"
			"stfle 0(%1);"
			<comment type="block">/* outputs  */</comment>:
			<comment type="block">/* inputs   */</comment>: "d" ((size / 8) - 1), "a" (&amp;cpu_features)
			<comment type="block">/* clobbers */</comment>: "r0", "cc", "memory"
		);</asm>
		<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>cpu_features</name><operator>.</operator><name>bits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><operator>(</operator><name><name>cpu_features</name><operator>.</operator><name>bits</name><index>[<expr><name>word_index</name></expr>]</index></name> <operator>&amp;</operator> <name>bit_index</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_FACILITY</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>bit</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>static SLJIT_INLINE int name() \
{ \
	static int have = -1; \
	<comment type="block">/* Static check first. May allow the function to be optimized away. */</comment> \
	if (have_facility_static(bit)) \
		have = 1; \
	else if (SLJIT_UNLIKELY(have &lt; 0)) \
		have = have_facility_dynamic(bit) ? 1 : 0; \
\
	return have; \
}</cpp:value></cpp:define>

<macro><name>HAVE_FACILITY</name><argument_list>(<argument>have_eimm</argument>,    <argument>EXTENDED_IMMEDIATE_FACILITY</argument>)</argument_list></macro>
<macro><name>HAVE_FACILITY</name><argument_list>(<argument>have_ldisp</argument>,   <argument>FAST_LONG_DISPLACEMENT_FACILITY</argument>)</argument_list></macro>
<macro><name>HAVE_FACILITY</name><argument_list>(<argument>have_genext</argument>,  <argument>GENERAL_INSTRUCTION_EXTENSION_FACILITY</argument>)</argument_list></macro>
<macro><name>HAVE_FACILITY</name><argument_list>(<argument>have_lscond1</argument>, <argument>LOAD_STORE_ON_CONDITION_1_FACILITY</argument>)</argument_list></macro>
<macro><name>HAVE_FACILITY</name><argument_list>(<argument>have_lscond2</argument>, <argument>LOAD_STORE_ON_CONDITION_2_FACILITY</argument>)</argument_list></macro>
<macro><name>HAVE_FACILITY</name><argument_list>(<argument>have_misc2</argument>,   <argument>MISCELLANEOUS_INSTRUCTION_EXTENSIONS_2_FACILITY</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HAVE_FACILITY</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_u12</name><parameter_list>(<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(0 &lt;= (d) &amp;&amp; (d) &lt;= 0x00000fffL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_u32</name><parameter_list>(<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(0 &lt;= (d) &amp;&amp; (d) &lt;= 0xffffffffL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_SIGNED</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>bitlen</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((v) == (((v) &lt;&lt; (sizeof(v) * 8 - bitlen)) &gt;&gt; (sizeof(v) * 8 - bitlen)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_s16</name><parameter_list>(<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>CHECK_SIGNED((d), 16)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_s20</name><parameter_list>(<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>CHECK_SIGNED((d), 20)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_s32</name><parameter_list>(<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>CHECK_SIGNED((d), 32)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>sljit_uw</name></type> <name>disp_s20</name><parameter_list>(<parameter><decl><type><name>sljit_s32</name></type> <name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_uw</name></type> <name>dh</name> <init>= <expr><operator>(</operator><name>d</name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_uw</name></type> <name>dl</name> <init>= <expr><operator>(</operator><name>d</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xfff00</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><call><name>is_s20</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>dh</name> <operator>|</operator> <name>dl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* TODO(carenas): variadic macro is not strictly needed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_S390X_INSTRUCTION</name><parameter_list>(<parameter><type><name>op</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>static SLJIT_INLINE sljit_ins op(__VA_ARGS__)</cpp:value></cpp:define>

<comment type="block">/* RR form instructions. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_S390X_RR</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>pattern</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>SLJIT_S390X_INSTRUCTION(name, sljit_gpr dst, sljit_gpr src) \
{ \
	return (pattern) | ((dst &amp; 0xf) &lt;&lt; 4) | (src &amp; 0xf); \
}</cpp:value></cpp:define>

<comment type="block">/* ADD */</comment>
<macro><name>SLJIT_S390X_RR</name><argument_list>(<argument>ar</argument>,   <argument><literal type="number">0x1a00</literal></argument>)</argument_list></macro>

<comment type="block">/* ADD LOGICAL */</comment>
<macro><name>SLJIT_S390X_RR</name><argument_list>(<argument>alr</argument>,  <argument><literal type="number">0x1e00</literal></argument>)</argument_list></macro>

<comment type="block">/* AND */</comment>
<macro><name>SLJIT_S390X_RR</name><argument_list>(<argument>nr</argument>,   <argument><literal type="number">0x1400</literal></argument>)</argument_list></macro>

<comment type="block">/* BRANCH AND SAVE */</comment>
<macro><name>SLJIT_S390X_RR</name><argument_list>(<argument>basr</argument>, <argument><literal type="number">0x0d00</literal></argument>)</argument_list></macro>

<comment type="block">/* BRANCH ON CONDITION */</comment>
<macro><name>SLJIT_S390X_RR</name><argument_list>(<argument>bcr</argument>,  <argument><literal type="number">0x0700</literal></argument>)</argument_list></macro> <comment type="block">/* TODO(mundaym): type for mask? */</comment>

<comment type="block">/* COMPARE */</comment>
<macro><name>SLJIT_S390X_RR</name><argument_list>(<argument>cr</argument>,   <argument><literal type="number">0x1900</literal></argument>)</argument_list></macro>

<comment type="block">/* COMPARE LOGICAL */</comment>
<macro><name>SLJIT_S390X_RR</name><argument_list>(<argument>clr</argument>,  <argument><literal type="number">0x1500</literal></argument>)</argument_list></macro>

<comment type="block">/* DIVIDE */</comment>
<macro><name>SLJIT_S390X_RR</name><argument_list>(<argument>dr</argument>,   <argument><literal type="number">0x1d00</literal></argument>)</argument_list></macro>

<comment type="block">/* EXCLUSIVE OR */</comment>
<macro><name>SLJIT_S390X_RR</name><argument_list>(<argument>xr</argument>,   <argument><literal type="number">0x1700</literal></argument>)</argument_list></macro>

<comment type="block">/* LOAD */</comment>
<macro><name>SLJIT_S390X_RR</name><argument_list>(<argument>lr</argument>,   <argument><literal type="number">0x1800</literal></argument>)</argument_list></macro>

<comment type="block">/* LOAD COMPLEMENT */</comment>
<macro><name>SLJIT_S390X_RR</name><argument_list>(<argument>lcr</argument>,  <argument><literal type="number">0x1300</literal></argument>)</argument_list></macro>

<comment type="block">/* OR */</comment>
<macro><name>SLJIT_S390X_RR</name><argument_list>(<argument>or</argument>,   <argument><literal type="number">0x1600</literal></argument>)</argument_list></macro>

<comment type="block">/* SUBTRACT */</comment>
<macro><name>SLJIT_S390X_RR</name><argument_list>(<argument>sr</argument>,   <argument><literal type="number">0x1b00</literal></argument>)</argument_list></macro>

<comment type="block">/* SUBTRACT LOGICAL */</comment>
<macro><name>SLJIT_S390X_RR</name><argument_list>(<argument>slr</argument>,  <argument><literal type="number">0x1f00</literal></argument>)</argument_list></macro>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SLJIT_S390X_RR</name></cpp:undef>

<comment type="block">/* RRE form instructions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_S390X_RRE</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>pattern</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>SLJIT_S390X_INSTRUCTION(name, sljit_gpr dst, sljit_gpr src) \
{ \
	return (pattern) | ((dst &amp; 0xf) &lt;&lt; 4) | (src &amp; 0xf); \
}</cpp:value></cpp:define>

<comment type="block">/* ADD */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>agr</argument>,   <argument><literal type="number">0xb9080000</literal></argument>)</argument_list></macro>

<comment type="block">/* ADD LOGICAL */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>algr</argument>,  <argument><literal type="number">0xb90a0000</literal></argument>)</argument_list></macro>

<comment type="block">/* ADD LOGICAL WITH CARRY */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>alcr</argument>,  <argument><literal type="number">0xb9980000</literal></argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>alcgr</argument>, <argument><literal type="number">0xb9880000</literal></argument>)</argument_list></macro>

<comment type="block">/* AND */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>ngr</argument>,   <argument><literal type="number">0xb9800000</literal></argument>)</argument_list></macro>

<comment type="block">/* COMPARE */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>cgr</argument>,   <argument><literal type="number">0xb9200000</literal></argument>)</argument_list></macro>

<comment type="block">/* COMPARE LOGICAL */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>clgr</argument>,  <argument><literal type="number">0xb9210000</literal></argument>)</argument_list></macro>

<comment type="block">/* DIVIDE LOGICAL */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>dlr</argument>,   <argument><literal type="number">0xb9970000</literal></argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>dlgr</argument>,  <argument><literal type="number">0xb9870000</literal></argument>)</argument_list></macro>

<comment type="block">/* DIVIDE SINGLE */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>dsgr</argument>,  <argument><literal type="number">0xb90d0000</literal></argument>)</argument_list></macro>

<comment type="block">/* EXCLUSIVE OR */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>xgr</argument>,   <argument><literal type="number">0xb9820000</literal></argument>)</argument_list></macro>

<comment type="block">/* LOAD */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>lgr</argument>,   <argument><literal type="number">0xb9040000</literal></argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>lgfr</argument>,  <argument><literal type="number">0xb9140000</literal></argument>)</argument_list></macro>

<comment type="block">/* LOAD BYTE */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>lbr</argument>,   <argument><literal type="number">0xb9260000</literal></argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>lgbr</argument>,  <argument><literal type="number">0xb9060000</literal></argument>)</argument_list></macro>

<comment type="block">/* LOAD COMPLEMENT */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>lcgr</argument>,  <argument><literal type="number">0xb9030000</literal></argument>)</argument_list></macro>

<comment type="block">/* LOAD HALFWORD */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>lhr</argument>,   <argument><literal type="number">0xb9270000</literal></argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>lghr</argument>,  <argument><literal type="number">0xb9070000</literal></argument>)</argument_list></macro>

<comment type="block">/* LOAD LOGICAL */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>llgfr</argument>, <argument><literal type="number">0xb9160000</literal></argument>)</argument_list></macro>

<comment type="block">/* LOAD LOGICAL CHARACTER */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>llcr</argument>,  <argument><literal type="number">0xb9940000</literal></argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>llgcr</argument>, <argument><literal type="number">0xb9840000</literal></argument>)</argument_list></macro>

<comment type="block">/* LOAD LOGICAL HALFWORD */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>llhr</argument>,  <argument><literal type="number">0xb9950000</literal></argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>llghr</argument>, <argument><literal type="number">0xb9850000</literal></argument>)</argument_list></macro>

<comment type="block">/* MULTIPLY LOGICAL */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>mlgr</argument>,  <argument><literal type="number">0xb9860000</literal></argument>)</argument_list></macro>

<comment type="block">/* MULTIPLY SINGLE */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>msr</argument>,   <argument><literal type="number">0xb2520000</literal></argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>msgr</argument>,  <argument><literal type="number">0xb90c0000</literal></argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>msgfr</argument>, <argument><literal type="number">0xb91c0000</literal></argument>)</argument_list></macro>

<comment type="block">/* OR */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>ogr</argument>,   <argument><literal type="number">0xb9810000</literal></argument>)</argument_list></macro>

<comment type="block">/* SUBTRACT */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>sgr</argument>,   <argument><literal type="number">0xb9090000</literal></argument>)</argument_list></macro>

<comment type="block">/* SUBTRACT LOGICAL */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>slgr</argument>,  <argument><literal type="number">0xb90b0000</literal></argument>)</argument_list></macro>

<comment type="block">/* SUBTRACT LOGICAL WITH BORROW */</comment>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>slbr</argument>,  <argument><literal type="number">0xb9990000</literal></argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RRE</name><argument_list>(<argument>slbgr</argument>, <argument><literal type="number">0xb9890000</literal></argument>)</argument_list></macro>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SLJIT_S390X_RRE</name></cpp:undef>

<comment type="block">/* RI-a form instructions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_S390X_RIA</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>pattern</name></type></parameter>, <parameter><type><name>imm_type</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>SLJIT_S390X_INSTRUCTION(name, sljit_gpr reg, imm_type imm) \
{ \
	return (pattern) | ((reg &amp; 0xf) &lt;&lt; 20) | (imm &amp; 0xffff); \
}</cpp:value></cpp:define>

<comment type="block">/* ADD HALFWORD IMMEDIATE */</comment>
<macro><name>SLJIT_S390X_RIA</name><argument_list>(<argument>ahi</argument>,   <argument><literal type="number">0xa70a0000</literal></argument>, <argument>sljit_s16</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RIA</name><argument_list>(<argument>aghi</argument>,  <argument><literal type="number">0xa70b0000</literal></argument>, <argument>sljit_s16</argument>)</argument_list></macro>

<comment type="block">/* COMPARE HALFWORD IMMEDIATE */</comment>
<macro><name>SLJIT_S390X_RIA</name><argument_list>(<argument>chi</argument>,   <argument><literal type="number">0xa70e0000</literal></argument>, <argument>sljit_s16</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RIA</name><argument_list>(<argument>cghi</argument>,  <argument><literal type="number">0xa70f0000</literal></argument>, <argument>sljit_s16</argument>)</argument_list></macro>

<comment type="block">/* LOAD HALFWORD IMMEDIATE */</comment>
<macro><name>SLJIT_S390X_RIA</name><argument_list>(<argument>lhi</argument>,   <argument><literal type="number">0xa7080000</literal></argument>, <argument>sljit_s16</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RIA</name><argument_list>(<argument>lghi</argument>,  <argument><literal type="number">0xa7090000</literal></argument>, <argument>sljit_s16</argument>)</argument_list></macro>

<comment type="block">/* LOAD LOGICAL IMMEDIATE */</comment>
<macro><name>SLJIT_S390X_RIA</name><argument_list>(<argument>llihh</argument>, <argument><literal type="number">0xa50c0000</literal></argument>, <argument>sljit_u16</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RIA</name><argument_list>(<argument>llihl</argument>, <argument><literal type="number">0xa50d0000</literal></argument>, <argument>sljit_u16</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RIA</name><argument_list>(<argument>llilh</argument>, <argument><literal type="number">0xa50e0000</literal></argument>, <argument>sljit_u16</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RIA</name><argument_list>(<argument>llill</argument>, <argument><literal type="number">0xa50f0000</literal></argument>, <argument>sljit_u16</argument>)</argument_list></macro>

<comment type="block">/* MULTIPLY HALFWORD IMMEDIATE */</comment>
<macro><name>SLJIT_S390X_RIA</name><argument_list>(<argument>mhi</argument>,   <argument><literal type="number">0xa70c0000</literal></argument>, <argument>sljit_s16</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RIA</name><argument_list>(<argument>mghi</argument>,  <argument><literal type="number">0xa70d0000</literal></argument>, <argument>sljit_s16</argument>)</argument_list></macro>

<comment type="block">/* OR IMMEDIATE */</comment>
<macro><name>SLJIT_S390X_RIA</name><argument_list>(<argument>oilh</argument>,  <argument><literal type="number">0xa50a0000</literal></argument>, <argument>sljit_u16</argument>)</argument_list></macro>

<comment type="block">/* TEST UNDER MASK */</comment>
<macro><name>SLJIT_S390X_RIA</name><argument_list>(<argument>tmlh</argument>,  <argument><literal type="number">0xa7000000</literal></argument>, <argument>sljit_u16</argument>)</argument_list></macro>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SLJIT_S390X_RIA</name></cpp:undef>

<comment type="block">/* RIL-a form instructions (requires extended immediate facility) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_S390X_RILA</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>pattern</name></type></parameter>, <parameter><type><name>imm_type</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>SLJIT_S390X_INSTRUCTION(name, sljit_gpr reg, imm_type imm) \
{ \
	SLJIT_ASSERT(have_eimm()); \
	return (pattern) | ((sljit_ins)(reg &amp; 0xf) &lt;&lt; 36) | (imm &amp; 0xffffffff); \
}</cpp:value></cpp:define>

<comment type="block">/* ADD IMMEDIATE */</comment>
<macro><name>SLJIT_S390X_RILA</name><argument_list>(<argument>afi</argument>,   <argument><literal type="number">0xc20900000000</literal></argument>, <argument>sljit_s32</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RILA</name><argument_list>(<argument>agfi</argument>,  <argument><literal type="number">0xc20800000000</literal></argument>, <argument>sljit_s32</argument>)</argument_list></macro>

<comment type="block">/* ADD IMMEDIATE HIGH */</comment>
<macro><name>SLJIT_S390X_RILA</name><argument_list>(<argument>aih</argument>,   <argument><literal type="number">0xcc0800000000</literal></argument>, <argument>sljit_s32</argument>)</argument_list></macro> <comment type="block">/* TODO(mundaym): high-word facility? */</comment>

<comment type="block">/* ADD LOGICAL IMMEDIATE */</comment>
<macro><name>SLJIT_S390X_RILA</name><argument_list>(<argument>alfi</argument>,  <argument><literal type="number">0xc20b00000000</literal></argument>, <argument>sljit_u32</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RILA</name><argument_list>(<argument>algfi</argument>, <argument><literal type="number">0xc20a00000000</literal></argument>, <argument>sljit_u32</argument>)</argument_list></macro>

<comment type="block">/* AND IMMEDIATE */</comment>
<macro><name>SLJIT_S390X_RILA</name><argument_list>(<argument>nihf</argument>,  <argument><literal type="number">0xc00a00000000</literal></argument>, <argument>sljit_u32</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RILA</name><argument_list>(<argument>nilf</argument>,  <argument><literal type="number">0xc00b00000000</literal></argument>, <argument>sljit_u32</argument>)</argument_list></macro>

<comment type="block">/* COMPARE IMMEDIATE */</comment>
<macro><name>SLJIT_S390X_RILA</name><argument_list>(<argument>cfi</argument>,   <argument><literal type="number">0xc20d00000000</literal></argument>, <argument>sljit_s32</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RILA</name><argument_list>(<argument>cgfi</argument>,  <argument><literal type="number">0xc20c00000000</literal></argument>, <argument>sljit_s32</argument>)</argument_list></macro>

<comment type="block">/* COMPARE IMMEDIATE HIGH */</comment>
<macro><name>SLJIT_S390X_RILA</name><argument_list>(<argument>cih</argument>,   <argument><literal type="number">0xcc0d00000000</literal></argument>, <argument>sljit_s32</argument>)</argument_list></macro> <comment type="block">/* TODO(mundaym): high-word facility? */</comment>

<comment type="block">/* COMPARE LOGICAL IMMEDIATE */</comment>
<macro><name>SLJIT_S390X_RILA</name><argument_list>(<argument>clfi</argument>,  <argument><literal type="number">0xc20f00000000</literal></argument>, <argument>sljit_u32</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RILA</name><argument_list>(<argument>clgfi</argument>, <argument><literal type="number">0xc20e00000000</literal></argument>, <argument>sljit_u32</argument>)</argument_list></macro>

<comment type="block">/* EXCLUSIVE OR IMMEDIATE */</comment>
<macro><name>SLJIT_S390X_RILA</name><argument_list>(<argument>xilf</argument>,  <argument><literal type="number">0xc00700000000</literal></argument>, <argument>sljit_u32</argument>)</argument_list></macro>

<comment type="block">/* INSERT IMMEDIATE */</comment>
<macro><name>SLJIT_S390X_RILA</name><argument_list>(<argument>iihf</argument>,  <argument><literal type="number">0xc00800000000</literal></argument>, <argument>sljit_u32</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RILA</name><argument_list>(<argument>iilf</argument>,  <argument><literal type="number">0xc00900000000</literal></argument>, <argument>sljit_u32</argument>)</argument_list></macro>

<comment type="block">/* LOAD IMMEDIATE */</comment>
<macro><name>SLJIT_S390X_RILA</name><argument_list>(<argument>lgfi</argument>,  <argument><literal type="number">0xc00100000000</literal></argument>, <argument>sljit_s32</argument>)</argument_list></macro>

<comment type="block">/* LOAD LOGICAL IMMEDIATE */</comment>
<macro><name>SLJIT_S390X_RILA</name><argument_list>(<argument>llihf</argument>, <argument><literal type="number">0xc00e00000000</literal></argument>, <argument>sljit_u32</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RILA</name><argument_list>(<argument>llilf</argument>, <argument><literal type="number">0xc00f00000000</literal></argument>, <argument>sljit_u32</argument>)</argument_list></macro>

<comment type="block">/* OR IMMEDIATE */</comment>
<macro><name>SLJIT_S390X_RILA</name><argument_list>(<argument>oilf</argument>,  <argument><literal type="number">0xc00d00000000</literal></argument>, <argument>sljit_u32</argument>)</argument_list></macro>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SLJIT_S390X_RILA</name></cpp:undef>

<comment type="block">/* RX-a form instructions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_S390X_RXA</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>pattern</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>SLJIT_S390X_INSTRUCTION(name, sljit_gpr r, sljit_u16 d, sljit_gpr x, sljit_gpr b) \
{ \
	sljit_ins ri, xi, bi, di; \
\
	SLJIT_ASSERT((d &amp; 0xfff) == d); \
	ri = (sljit_ins)(r &amp; 0xf) &lt;&lt; 20; \
	xi = (sljit_ins)(x &amp; 0xf) &lt;&lt; 16; \
	bi = (sljit_ins)(b &amp; 0xf) &lt;&lt; 12; \
	di = (sljit_ins)(d &amp; 0xfff); \
\
	return (pattern) | ri | xi | bi | di; \
}</cpp:value></cpp:define>

<comment type="block">/* ADD */</comment>
<macro><name>SLJIT_S390X_RXA</name><argument_list>(<argument>a</argument>,   <argument><literal type="number">0x5a000000</literal></argument>)</argument_list></macro>

<comment type="block">/* ADD LOGICAL */</comment>
<macro><name>SLJIT_S390X_RXA</name><argument_list>(<argument>al</argument>,  <argument><literal type="number">0x5e000000</literal></argument>)</argument_list></macro>

<comment type="block">/* AND */</comment>
<macro><name>SLJIT_S390X_RXA</name><argument_list>(<argument>n</argument>,   <argument><literal type="number">0x54000000</literal></argument>)</argument_list></macro>

<comment type="block">/* EXCLUSIVE OR */</comment>
<macro><name>SLJIT_S390X_RXA</name><argument_list>(<argument>x</argument>,   <argument><literal type="number">0x57000000</literal></argument>)</argument_list></macro>

<comment type="block">/* LOAD */</comment>
<macro><name>SLJIT_S390X_RXA</name><argument_list>(<argument>l</argument>,   <argument><literal type="number">0x58000000</literal></argument>)</argument_list></macro>

<comment type="block">/* LOAD ADDRESS */</comment>
<macro><name>SLJIT_S390X_RXA</name><argument_list>(<argument>la</argument>,  <argument><literal type="number">0x41000000</literal></argument>)</argument_list></macro>

<comment type="block">/* LOAD HALFWORD */</comment>
<macro><name>SLJIT_S390X_RXA</name><argument_list>(<argument>lh</argument>,  <argument><literal type="number">0x48000000</literal></argument>)</argument_list></macro>

<comment type="block">/* MULTIPLY SINGLE */</comment>
<macro><name>SLJIT_S390X_RXA</name><argument_list>(<argument>ms</argument>,  <argument><literal type="number">0x71000000</literal></argument>)</argument_list></macro>

<comment type="block">/* OR */</comment>
<macro><name>SLJIT_S390X_RXA</name><argument_list>(<argument>o</argument>,   <argument><literal type="number">0x56000000</literal></argument>)</argument_list></macro>

<comment type="block">/* STORE */</comment>
<macro><name>SLJIT_S390X_RXA</name><argument_list>(<argument>st</argument>,  <argument><literal type="number">0x50000000</literal></argument>)</argument_list></macro>

<comment type="block">/* STORE CHARACTER */</comment>
<macro><name>SLJIT_S390X_RXA</name><argument_list>(<argument>stc</argument>, <argument><literal type="number">0x42000000</literal></argument>)</argument_list></macro>

<comment type="block">/* STORE HALFWORD */</comment>
<macro><name>SLJIT_S390X_RXA</name><argument_list>(<argument>sth</argument>, <argument><literal type="number">0x40000000</literal></argument>)</argument_list></macro>

<comment type="block">/* SUBTRACT */</comment>
<macro><name>SLJIT_S390X_RXA</name><argument_list>(<argument>s</argument>,   <argument><literal type="number">0x5b000000</literal></argument>)</argument_list></macro>

<comment type="block">/* SUBTRACT LOGICAL */</comment>
<macro><name>SLJIT_S390X_RXA</name><argument_list>(<argument>sl</argument>,  <argument><literal type="number">0x5f000000</literal></argument>)</argument_list></macro>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SLJIT_S390X_RXA</name></cpp:undef>

<comment type="block">/* RXY-a instructions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_S390X_RXYA</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>pattern</name></type></parameter>, <parameter><type><name>cond</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>SLJIT_S390X_INSTRUCTION(name, sljit_gpr r, sljit_s32 d, sljit_gpr x, sljit_gpr b) \
{ \
	sljit_ins ri, xi, bi, di; \
\
	SLJIT_ASSERT(cond); \
	ri = (sljit_ins)(r &amp; 0xf) &lt;&lt; 36; \
	xi = (sljit_ins)(x &amp; 0xf) &lt;&lt; 32; \
	bi = (sljit_ins)(b &amp; 0xf) &lt;&lt; 28; \
	di = (sljit_ins)disp_s20(d) &lt;&lt; 8; \
\
	return (pattern) | ri | xi | bi | di; \
}</cpp:value></cpp:define>

<comment type="block">/* ADD */</comment>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>ay</argument>,    <argument><literal type="number">0xe3000000005a</literal></argument>, <argument>have_ldisp()</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>ag</argument>,    <argument><literal type="number">0xe30000000008</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* ADD LOGICAL */</comment>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>aly</argument>,   <argument><literal type="number">0xe3000000005e</literal></argument>, <argument>have_ldisp()</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>alg</argument>,   <argument><literal type="number">0xe3000000000a</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* ADD LOGICAL WITH CARRY */</comment>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>alc</argument>,   <argument><literal type="number">0xe30000000098</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>alcg</argument>,  <argument><literal type="number">0xe30000000088</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* AND */</comment>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>ny</argument>,    <argument><literal type="number">0xe30000000054</literal></argument>, <argument>have_ldisp()</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>ng</argument>,    <argument><literal type="number">0xe30000000080</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* EXCLUSIVE OR */</comment>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>xy</argument>,    <argument><literal type="number">0xe30000000057</literal></argument>, <argument>have_ldisp()</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>xg</argument>,    <argument><literal type="number">0xe30000000082</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* LOAD */</comment>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>ly</argument>,    <argument><literal type="number">0xe30000000058</literal></argument>, <argument>have_ldisp()</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>lg</argument>,    <argument><literal type="number">0xe30000000004</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>lgf</argument>,   <argument><literal type="number">0xe30000000014</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* LOAD BYTE */</comment>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>lb</argument>,    <argument><literal type="number">0xe30000000076</literal></argument>, <argument>have_ldisp()</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>lgb</argument>,   <argument><literal type="number">0xe30000000077</literal></argument>, <argument>have_ldisp()</argument>)</argument_list></macro>

<comment type="block">/* LOAD HALFWORD */</comment>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>lhy</argument>,   <argument><literal type="number">0xe30000000078</literal></argument>, <argument>have_ldisp()</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>lgh</argument>,   <argument><literal type="number">0xe30000000015</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* LOAD LOGICAL */</comment>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>llgf</argument>,  <argument><literal type="number">0xe30000000016</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* LOAD LOGICAL CHARACTER */</comment>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>llc</argument>,   <argument><literal type="number">0xe30000000094</literal></argument>, <argument>have_eimm()</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>llgc</argument>,  <argument><literal type="number">0xe30000000090</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* LOAD LOGICAL HALFWORD */</comment>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>llh</argument>,   <argument><literal type="number">0xe30000000095</literal></argument>, <argument>have_eimm()</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>llgh</argument>,  <argument><literal type="number">0xe30000000091</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* MULTIPLY SINGLE */</comment>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>msy</argument>,   <argument><literal type="number">0xe30000000051</literal></argument>, <argument>have_ldisp()</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>msg</argument>,   <argument><literal type="number">0xe3000000000c</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* OR */</comment>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>oy</argument>,    <argument><literal type="number">0xe30000000056</literal></argument>, <argument>have_ldisp()</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>og</argument>,    <argument><literal type="number">0xe30000000081</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* STORE */</comment>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>sty</argument>,   <argument><literal type="number">0xe30000000050</literal></argument>, <argument>have_ldisp()</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>stg</argument>,   <argument><literal type="number">0xe30000000024</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* STORE CHARACTER */</comment>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>stcy</argument>,  <argument><literal type="number">0xe30000000072</literal></argument>, <argument>have_ldisp()</argument>)</argument_list></macro>

<comment type="block">/* STORE HALFWORD */</comment>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>sthy</argument>,  <argument><literal type="number">0xe30000000070</literal></argument>, <argument>have_ldisp()</argument>)</argument_list></macro>

<comment type="block">/* SUBTRACT */</comment>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>sy</argument>,    <argument><literal type="number">0xe3000000005b</literal></argument>, <argument>have_ldisp()</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>sg</argument>,    <argument><literal type="number">0xe30000000009</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* SUBTRACT LOGICAL */</comment>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>sly</argument>,   <argument><literal type="number">0xe3000000005f</literal></argument>, <argument>have_ldisp()</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>slg</argument>,   <argument><literal type="number">0xe3000000000b</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* SUBTRACT LOGICAL WITH BORROW */</comment>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>slb</argument>,   <argument><literal type="number">0xe30000000099</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RXYA</name><argument_list>(<argument>slbg</argument>,  <argument><literal type="number">0xe30000000089</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SLJIT_S390X_RXYA</name></cpp:undef>

<comment type="block">/* RS-a instructions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_S390X_RSA</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>pattern</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>SLJIT_S390X_INSTRUCTION(name, sljit_gpr reg, sljit_sw d, sljit_gpr b) \
{ \
	sljit_ins r1 = (sljit_ins)(reg &amp; 0xf) &lt;&lt; 20; \
	sljit_ins b2 = (sljit_ins)(b &amp; 0xf) &lt;&lt; 12; \
	sljit_ins d2 = (sljit_ins)(d &amp; 0xfff); \
	return (pattern) | r1 | b2 | d2; \
}</cpp:value></cpp:define>

<comment type="block">/* SHIFT LEFT SINGLE LOGICAL */</comment>
<macro><name>SLJIT_S390X_RSA</name><argument_list>(<argument>sll</argument>, <argument><literal type="number">0x89000000</literal></argument>)</argument_list></macro>

<comment type="block">/* SHIFT RIGHT SINGLE */</comment>
<macro><name>SLJIT_S390X_RSA</name><argument_list>(<argument>sra</argument>, <argument><literal type="number">0x8a000000</literal></argument>)</argument_list></macro>

<comment type="block">/* SHIFT RIGHT SINGLE LOGICAL */</comment>
<macro><name>SLJIT_S390X_RSA</name><argument_list>(<argument>srl</argument>, <argument><literal type="number">0x88000000</literal></argument>)</argument_list></macro>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SLJIT_S390X_RSA</name></cpp:undef>

<comment type="block">/* RSY-a instructions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_S390X_RSYA</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>pattern</name></type></parameter>, <parameter><type><name>cond</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>SLJIT_S390X_INSTRUCTION(name, sljit_gpr dst, sljit_gpr src, sljit_sw d, sljit_gpr b) \
{ \
	sljit_ins r1, r3, b2, d2; \
\
	SLJIT_ASSERT(cond); \
	r1 = (sljit_ins)(dst &amp; 0xf) &lt;&lt; 36; \
	r3 = (sljit_ins)(src &amp; 0xf) &lt;&lt; 32; \
	b2 = (sljit_ins)(b &amp; 0xf) &lt;&lt; 28; \
	d2 = (sljit_ins)disp_s20(d) &lt;&lt; 8; \
\
	return (pattern) | r1 | r3 | b2 | d2; \
}</cpp:value></cpp:define>

<comment type="block">/* LOAD MULTIPLE */</comment>
<macro><name>SLJIT_S390X_RSYA</name><argument_list>(<argument>lmg</argument>,   <argument><literal type="number">0xeb0000000004</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* SHIFT LEFT LOGICAL */</comment>
<macro><name>SLJIT_S390X_RSYA</name><argument_list>(<argument>sllg</argument>,  <argument><literal type="number">0xeb000000000d</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* SHIFT RIGHT SINGLE */</comment>
<macro><name>SLJIT_S390X_RSYA</name><argument_list>(<argument>srag</argument>,  <argument><literal type="number">0xeb000000000a</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* SHIFT RIGHT SINGLE LOGICAL */</comment>
<macro><name>SLJIT_S390X_RSYA</name><argument_list>(<argument>srlg</argument>,  <argument><literal type="number">0xeb000000000c</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* STORE MULTIPLE */</comment>
<macro><name>SLJIT_S390X_RSYA</name><argument_list>(<argument>stmg</argument>,  <argument><literal type="number">0xeb0000000024</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SLJIT_S390X_RSYA</name></cpp:undef>

<comment type="block">/* RIE-f instructions (require general-instructions-extension facility) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_S390X_RIEF</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>pattern</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>SLJIT_S390X_INSTRUCTION(name, sljit_gpr dst, sljit_gpr src, sljit_u8 start, sljit_u8 end, sljit_u8 rot) \
{ \
	sljit_ins r1, r2, i3, i4, i5; \
\
	SLJIT_ASSERT(have_genext()); \
	r1 = (sljit_ins)(dst &amp; 0xf) &lt;&lt; 36; \
	r2 = (sljit_ins)(src &amp; 0xf) &lt;&lt; 32; \
	i3 = (sljit_ins)start &lt;&lt; 24; \
	i4 = (sljit_ins)end &lt;&lt; 16; \
	i5 = (sljit_ins)rot &lt;&lt; 8; \
\
	return (pattern) | r1 | r2 | i3 | i4 | i5; \
}</cpp:value></cpp:define>

<comment type="block">/* ROTATE THEN AND SELECTED BITS */</comment>
<comment type="block">/* SLJIT_S390X_RIEF(rnsbg,  0xec0000000054) */</comment>

<comment type="block">/* ROTATE THEN EXCLUSIVE OR SELECTED BITS */</comment>
<comment type="block">/* SLJIT_S390X_RIEF(rxsbg,  0xec0000000057) */</comment>

<comment type="block">/* ROTATE THEN OR SELECTED BITS */</comment>
<macro><name>SLJIT_S390X_RIEF</name><argument_list>(<argument>rosbg</argument>,  <argument><literal type="number">0xec0000000056</literal></argument>)</argument_list></macro>

<comment type="block">/* ROTATE THEN INSERT SELECTED BITS */</comment>
<comment type="block">/* SLJIT_S390X_RIEF(risbg,  0xec0000000055) */</comment>
<comment type="block">/* SLJIT_S390X_RIEF(risbgn, 0xec0000000059) */</comment>

<comment type="block">/* ROTATE THEN INSERT SELECTED BITS HIGH */</comment>
<macro><name>SLJIT_S390X_RIEF</name><argument_list>(<argument>risbhg</argument>, <argument><literal type="number">0xec000000005d</literal></argument>)</argument_list></macro>

<comment type="block">/* ROTATE THEN INSERT SELECTED BITS LOW */</comment>
<comment type="block">/* SLJIT_S390X_RIEF(risblg, 0xec0000000051) */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SLJIT_S390X_RIEF</name></cpp:undef>

<comment type="block">/* RRF-a instructions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_S390X_RRFA</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>pattern</name></type></parameter>, <parameter><type><name>cond</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>SLJIT_S390X_INSTRUCTION(name, sljit_gpr dst, sljit_gpr src1, sljit_gpr src2) \
{ \
	sljit_ins r1, r2, r3; \
\
	SLJIT_ASSERT(cond); \
	r1 = (sljit_ins)(dst &amp; 0xf) &lt;&lt; 4; \
	r2 = (sljit_ins)(src1 &amp; 0xf); \
	r3 = (sljit_ins)(src2 &amp; 0xf) &lt;&lt; 12; \
\
	return (pattern) | r3 | r1 | r2; \
}</cpp:value></cpp:define>

<comment type="block">/* MULTIPLY */</comment>
<macro><name>SLJIT_S390X_RRFA</name><argument_list>(<argument>msrkc</argument>,  <argument><literal type="number">0xb9fd0000</literal></argument>, <argument>have_misc2()</argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RRFA</name><argument_list>(<argument>msgrkc</argument>, <argument><literal type="number">0xb9ed0000</literal></argument>, <argument>have_misc2()</argument>)</argument_list></macro>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SLJIT_S390X_RRFA</name></cpp:undef>

<comment type="block">/* RRF-c instructions (require load/store-on-condition 1 facility) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_S390X_RRFC</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>pattern</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>SLJIT_S390X_INSTRUCTION(name, sljit_gpr dst, sljit_gpr src, sljit_uw mask) \
{ \
	sljit_ins r1, r2, m3; \
\
	SLJIT_ASSERT(have_lscond1()); \
	r1 = (sljit_ins)(dst &amp; 0xf) &lt;&lt; 4; \
	r2 = (sljit_ins)(src &amp; 0xf); \
	m3 = (sljit_ins)(mask &amp; 0xf) &lt;&lt; 12; \
\
	return (pattern) | m3 | r1 | r2; \
}</cpp:value></cpp:define>

<comment type="block">/* LOAD HALFWORD IMMEDIATE ON CONDITION */</comment>
<macro><name>SLJIT_S390X_RRFC</name><argument_list>(<argument>locr</argument>,  <argument><literal type="number">0xb9f20000</literal></argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RRFC</name><argument_list>(<argument>locgr</argument>, <argument><literal type="number">0xb9e20000</literal></argument>)</argument_list></macro>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SLJIT_S390X_RRFC</name></cpp:undef>

<comment type="block">/* RIE-g instructions (require load/store-on-condition 2 facility) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_S390X_RIEG</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>pattern</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>SLJIT_S390X_INSTRUCTION(name, sljit_gpr reg, sljit_sw imm, sljit_uw mask) \
{ \
	sljit_ins r1, m3, i2; \
\
	SLJIT_ASSERT(have_lscond2()); \
	r1 = (sljit_ins)(reg &amp; 0xf) &lt;&lt; 36; \
	m3 = (sljit_ins)(mask &amp; 0xf) &lt;&lt; 32; \
	i2 = (sljit_ins)(imm &amp; 0xffffL) &lt;&lt; 16; \
\
	return (pattern) | r1 | m3 | i2; \
}</cpp:value></cpp:define>

<comment type="block">/* LOAD HALFWORD IMMEDIATE ON CONDITION */</comment>
<macro><name>SLJIT_S390X_RIEG</name><argument_list>(<argument>lochi</argument>,  <argument><literal type="number">0xec0000000042</literal></argument>)</argument_list></macro>
<macro><name>SLJIT_S390X_RIEG</name><argument_list>(<argument>locghi</argument>, <argument><literal type="number">0xec0000000046</literal></argument>)</argument_list></macro>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SLJIT_S390X_RIEG</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_S390X_RILB</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>pattern</name></type></parameter>, <parameter><type><name>cond</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>SLJIT_S390X_INSTRUCTION(name, sljit_gpr reg, sljit_sw ri) \
{ \
	sljit_ins r1, ri2; \
\
	SLJIT_ASSERT(cond); \
	r1 = (sljit_ins)(reg &amp; 0xf) &lt;&lt; 36; \
	ri2 = (sljit_ins)(ri &amp; 0xffffffff); \
\
	return (pattern) | r1 | ri2; \
}</cpp:value></cpp:define>

<comment type="block">/* BRANCH RELATIVE AND SAVE LONG */</comment>
<macro><name>SLJIT_S390X_RILB</name><argument_list>(<argument>brasl</argument>, <argument><literal type="number">0xc00500000000</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* LOAD ADDRESS RELATIVE LONG */</comment>
<macro><name>SLJIT_S390X_RILB</name><argument_list>(<argument>larl</argument>,  <argument><literal type="number">0xc00000000000</literal></argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro>

<comment type="block">/* LOAD RELATIVE LONG */</comment>
<macro><name>SLJIT_S390X_RILB</name><argument_list>(<argument>lgrl</argument>,  <argument><literal type="number">0xc40800000000</literal></argument>, <argument>have_genext()</argument>)</argument_list></macro>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SLJIT_S390X_RILB</name></cpp:undef>

<macro><name>SLJIT_S390X_INSTRUCTION</name><argument_list>(<argument>br</argument>, <argument>sljit_gpr target</argument>)</argument_list></macro>
<block>{<block_content>
	<return>return <expr><literal type="number">0x07f0</literal> <operator>|</operator> <name>target</name></expr>;</return>
</block_content>}</block>

<macro><name>SLJIT_S390X_INSTRUCTION</name><argument_list>(<argument>brcl</argument>, <argument>sljit_uw mask</argument>, <argument>sljit_sw target</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_ins</name></type> <name>m1</name> <init>= <expr><operator>(</operator><name>sljit_ins</name><operator>)</operator><operator>(</operator><name>mask</name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">36</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_ins</name></type> <name>ri2</name> <init>= <expr><operator>(</operator><name>sljit_ins</name><operator>)</operator><name>target</name> <operator>&amp;</operator> <literal type="number">0xffffffff</literal></expr></init></decl>;</decl_stmt>
	<return>return <expr><literal type="number">0xc00400000000L</literal> <operator>|</operator> <name>m1</name> <operator>|</operator> <name>ri2</name></expr>;</return>
</block_content>}</block>

<macro><name>SLJIT_S390X_INSTRUCTION</name><argument_list>(<argument>flogr</argument>, <argument>sljit_gpr dst</argument>, <argument>sljit_gpr src</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_ins</name></type> <name>r1</name> <init>= <expr><operator>(</operator><operator>(</operator><name>sljit_ins</name><operator>)</operator><name>dst</name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_ins</name></type> <name>r2</name> <init>= <expr><operator>(</operator><operator>(</operator><name>sljit_ins</name><operator>)</operator><name>src</name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><call><name>have_eimm</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0xb9830000</literal> <operator>|</operator> <name>r1</name> <operator>|</operator> <name>r2</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* INSERT PROGRAM MASK */</comment>
<macro><name>SLJIT_S390X_INSTRUCTION</name><argument_list>(<argument>ipm</argument>, <argument>sljit_gpr dst</argument>)</argument_list></macro>
<block>{<block_content>
	<return>return <expr><literal type="number">0xb2220000</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>sljit_ins</name><operator>)</operator><operator>(</operator><name>dst</name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr>;</return>
</block_content>}</block>

<comment type="block">/* ROTATE THEN INSERT SELECTED BITS HIGH (ZERO) */</comment>
<macro><name>SLJIT_S390X_INSTRUCTION</name><argument_list>(<argument>risbhgz</argument>, <argument>sljit_gpr dst</argument>, <argument>sljit_gpr src</argument>, <argument>sljit_u8 start</argument>, <argument>sljit_u8 end</argument>, <argument>sljit_u8 rot</argument>)</argument_list></macro>
<block>{<block_content>
	<return>return <expr><call><name>risbhg</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><literal type="number">0x8</literal> <operator>|</operator> <name>end</name></expr></argument>, <argument><expr><name>rot</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SLJIT_S390X_INSTRUCTION</name></cpp:undef>

<comment type="block">/* load condition code as needed to match type */</comment>
<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>push_load_cc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>type</name> <operator>&amp;=</operator> <operator>~</operator><name>SLJIT_I32_OP</name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>SLJIT_ZERO</name></expr>:</case>
	<case>case <expr><name>SLJIT_NOT_ZERO</name></expr>:</case>
		<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>cih</name><argument_list>(<argument><expr><name>flag_r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<break>break;</break>
	<default>default:</default>
		<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>tmlh</name><argument_list>(<argument><expr><name>flag_r</name></expr></argument>, <argument><expr><literal type="number">0x3000</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>push_store_zero_flag</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>sljit_gpr</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* insert low 32-bits into high 32-bits of flag register */</comment>
	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>risbhgz</name><argument_list>(<argument><expr><name>flag_r</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">31</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<comment type="block">/* OR high 32-bits with high 32-bits of flag register */</comment>
		<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>rosbg</name><argument_list>(<argument><expr><name>flag_r</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">31</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* load 64-bit immediate into register without clobbering flags */</comment>
<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>push_load_imm_inst</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_gpr</name></type> <name>target</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* 4 byte instructions */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>is_s16</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lghi</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_s16</name><operator>)</operator><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sljit_uw</name><operator>)</operator><name>v</name> <operator>==</operator> <operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">0x000000000000ffffU</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>llill</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_u16</name><operator>)</operator><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sljit_uw</name><operator>)</operator><name>v</name> <operator>==</operator> <operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">0x00000000ffff0000U</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>llilh</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_u16</name><operator>)</operator><operator>(</operator><name>v</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sljit_uw</name><operator>)</operator><name>v</name> <operator>==</operator> <operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">0x0000ffff00000000U</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>llihl</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_u16</name><operator>)</operator><operator>(</operator><name>v</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sljit_uw</name><operator>)</operator><name>v</name> <operator>==</operator> <operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">0xffff000000000000U</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>llihh</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_u16</name><operator>)</operator><operator>(</operator><name>v</name> <operator>&gt;&gt;</operator> <literal type="number">48</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* 6 byte instructions (requires extended immediate facility) */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>have_eimm</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>is_s32</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lgfi</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_s32</name><operator>)</operator><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sljit_uw</name><operator>)</operator><name>v</name> <operator>==</operator> <operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">0x00000000ffffffffU</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>llilf</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_u32</name><operator>)</operator><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sljit_uw</name><operator>)</operator><name>v</name> <operator>==</operator> <operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">0xffffffff00000000U</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>llihf</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_u32</name><operator>)</operator><operator>(</operator><name>v</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>llilf</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_u32</name><operator>)</operator><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>iihf</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_u32</name><operator>)</operator><operator>(</operator><name>v</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* TODO(mundaym): instruction sequences that don't use extended immediates */</comment>
	<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>addr</name> <block>{
	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_sw</name></type>  <name>offset</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* transform memory operand into D(X,B) form with a signed 20-bit offset */</comment>
<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>make_addr_bxy</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>,
	<parameter><decl><type><name><name>struct</name> <name>addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>mem</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>off</name></decl></parameter>,
	<parameter><decl><type><name>sljit_gpr</name></type> <name>tmp</name></decl></parameter> <comment type="block">/* clobbered, must not be r0 */</comment>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>base</name> <init>= <expr><name>r0</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>index</name> <init>= <expr><name>r0</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>tmp</name> <operator>!=</operator> <name>r0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>mem</name> <operator>&amp;</operator> <name>REG_MASK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>gpr</name><argument_list>(<argument><expr><name>mem</name> <operator>&amp;</operator> <name>REG_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>mem</name> <operator>&amp;</operator> <name>OFFS_REG_MASK</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>gpr</name><argument_list>(<argument><expr><call><name>OFFS_REG</name><argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>off</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<comment type="block">/* shift and put the result into tmp */</comment>
			<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>off</name> <operator>&amp;&amp;</operator> <name>off</name> <operator>&lt;</operator> <literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>sllg</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>index</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* clear offset */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>is_s20</name><argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_load_imm_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* clear offset */</comment>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>addr</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>addr</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>addr</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* transform memory operand into D(X,B) form with an unsigned 12-bit offset */</comment>
<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>make_addr_bx</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>,
	<parameter><decl><type><name><name>struct</name> <name>addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>mem</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>off</name></decl></parameter>,
	<parameter><decl><type><name>sljit_gpr</name></type> <name>tmp</name></decl></parameter> <comment type="block">/* clobbered, must not be r0 */</comment>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>base</name> <init>= <expr><name>r0</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>index</name> <init>= <expr><name>r0</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>tmp</name> <operator>!=</operator> <name>r0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>mem</name> <operator>&amp;</operator> <name>REG_MASK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>gpr</name><argument_list>(<argument><expr><name>mem</name> <operator>&amp;</operator> <name>REG_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>mem</name> <operator>&amp;</operator> <name>OFFS_REG_MASK</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>gpr</name><argument_list>(<argument><expr><call><name>OFFS_REG</name><argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>off</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<comment type="block">/* shift and put the result into tmp */</comment>
			<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>off</name> <operator>&amp;&amp;</operator> <name>off</name> <operator>&lt;</operator> <literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>sllg</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>index</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* clear offset */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>is_u12</name><argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_load_imm_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* clear offset */</comment>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>addr</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>addr</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>addr</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EVAL</name><parameter_list>(<parameter><type><name>op</name></type></parameter>, <parameter><type><name>r</name></type></parameter>, <parameter><type><name>addr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>op(r, addr.offset, addr.index, addr.base)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WHEN</name><parameter_list>(<parameter><type><name>cond</name></type></parameter>, <parameter><type><name>r</name></type></parameter>, <parameter><type><name>i1</name></type></parameter>, <parameter><type><name>i2</name></type></parameter>, <parameter><type><name>addr</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(cond) ? EVAL(i1, r, addr) : EVAL(i2, r, addr)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>load_word</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_gpr</name></type> <name>dst</name></decl></parameter>,
		<parameter><decl><type><name>sljit_s32</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>srcw</name></decl></parameter>,
		<parameter><decl><type><name>sljit_gpr</name></type> <name>tmp</name></decl></parameter> <comment type="block">/* clobbered */</comment>, <parameter><decl><type><name>sljit_s32</name></type> <name>is_32bit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>addr</name></name></type> <name>addr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_ins</name></type> <name>ins</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>src</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>have_ldisp</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><name>is_32bit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>make_addr_bxy</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>make_addr_bx</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_32bit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>WHEN</name><argument_list>(<argument><expr><call><name>is_u12</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>ly</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>lg</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>store_word</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_gpr</name></type> <name>src</name></decl></parameter>,
		<parameter><decl><type><name>sljit_s32</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>dstw</name></decl></parameter>,
		<parameter><decl><type><name>sljit_gpr</name></type> <name>tmp</name></decl></parameter> <comment type="block">/* clobbered */</comment>, <parameter><decl><type><name>sljit_s32</name></type> <name>is_32bit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>addr</name></name></type> <name>addr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_ins</name></type> <name>ins</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>dst</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>have_ldisp</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><name>is_32bit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>make_addr_bxy</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>make_addr_bx</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_32bit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>WHEN</name><argument_list>(<argument><expr><call><name>is_u12</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>sty</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>stg</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>WHEN</name></cpp:undef>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>void</name><modifier>*</modifier></type> <name>sljit_generate_code</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sljit_s390x_const</name></name> <modifier>*</modifier></type><name>const_</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sljit_put_label</name></name> <modifier>*</modifier></type><name>put_label</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_sw</name></type> <name>executable_offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_uw</name></type> <name>ins_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* instructions */</comment>
	<decl_stmt><decl><type><name>sljit_uw</name></type> <name>pool_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* literal pool */</comment>
	<decl_stmt><decl><type><name>sljit_uw</name></type> <name>pad_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_uw</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sljit_memory_fragment</name></name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>code</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>code_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_uw</name> <modifier>*</modifier></type><name>pool</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pool_ptr</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>sljit_uw</name></type> <name>source</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_sw</name></type> <name>offset</name></decl>;</decl_stmt> <comment type="block">/* TODO(carenas): only need 32 bit */</comment>

	<expr_stmt><expr><call><name>CHECK_ERROR_PTR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_PTR</name><argument_list>(<argument><expr><call><name>check_sljit_generate_code</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>reverse_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* branch handling */</comment>
	<expr_stmt><expr><name>label</name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>labels</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>jump</name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>jumps</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>put_label</name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>put_labels</name></name></expr>;</expr_stmt>

	<comment type="block">/* TODO(carenas): compiler-&gt;executable_size could be calculated
         *                before to avoid the following loop (except for
         *                pool_size)
         */</comment>
	<comment type="block">/* calculate the size of the code */</comment>
	<for>for <control>(<init><expr><name>buf</name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>buf</name></name></expr>;</init> <condition><expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>buf</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>sljit_uw</name></type> <name>len</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>used_size</name></name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_ins</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sljit_ins</name> <modifier>*</modifier></type><name>ibuf</name> <init>= <expr><operator>(</operator><name>sljit_ins</name> <operator>*</operator><operator>)</operator><name><name>buf</name><operator>-&gt;</operator><name>memory</name></name></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr><operator>,</operator> <expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>sljit_ins</name></type> <name>ins</name> <init>= <expr><name><name>ibuf</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* TODO(carenas): instruction tag vs size/addr == j
			 * using instruction tags for const is creative
			 * but unlike all other architectures, and is not
			 * done consistently for all other objects.
			 * This might need reviewing later.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ins</name> <operator>&amp;</operator> <name>sljit_ins_const</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>pool_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pool</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<expr_stmt><expr><name>ins</name> <operator>&amp;=</operator> <operator>~</operator><name>sljit_ins_const</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>label</name> <operator>&amp;&amp;</operator> <name><name>label</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <name>j</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name><name>label</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>ins_size</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>label</name> <operator>=</operator> <name><name>label</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>jump</name> <operator>&amp;&amp;</operator> <name><name>jump</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>j</name></expr>)</condition> <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>jump</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SLJIT_REWRITABLE_JUMP</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>jump</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JUMP_ADDR</name><operator>)</operator></expr>)</condition> <block>{<block_content>
					<comment type="block">/* encoded: */</comment>
					<comment type="block">/*   brasl %r14, &lt;rel_addr&gt; (or brcl &lt;mask&gt;, &lt;rel_addr&gt;) */</comment>
					<comment type="block">/* replace with: */</comment>
					<comment type="block">/*   lgrl %r1, &lt;pool_addr&gt; */</comment>
					<comment type="block">/*   bras %r14, %r1 (or bcr &lt;mask&gt;, %r1) */</comment>
					<expr_stmt><expr><name>pool_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pool</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
					<expr_stmt><expr><name>ins_size</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>jump</name> <operator>=</operator> <name><name>jump</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>put_label</name> <operator>&amp;&amp;</operator> <name><name>put_label</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>j</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>pool_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pool</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<expr_stmt><expr><name>put_label</name> <operator>=</operator> <name><name>put_label</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>ins_size</name> <operator>+=</operator> <call><name>sizeof_ins</name><argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<comment type="block">/* emit trailing label */</comment>
	<if_stmt><if>if <condition>(<expr><name>label</name> <operator>&amp;&amp;</operator> <name><name>label</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <name>j</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>label</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>ins_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>label</name> <operator>=</operator> <name><name>label</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name>put_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* pad code size to 8 bytes so is accessible with half word offsets */</comment>
	<comment type="block">/* the literal pool needs to be doubleword aligned */</comment>
	<expr_stmt><expr><name>pad_size</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ins_size</name> <operator>+</operator> <literal type="number">7UL</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">7UL</literal><operator>)</operator> <operator>-</operator> <name>ins_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>pad_size</name> <operator>&lt;</operator> <literal type="number">8UL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* allocate target buffer */</comment>
	<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>SLJIT_MALLOC_EXEC</name><argument_list>(<argument><expr><name>ins_size</name> <operator>+</operator> <name>pad_size</name> <operator>+</operator> <name>pool_size</name></expr></argument>,
					<argument><expr><name><name>compiler</name><operator>-&gt;</operator><name>exec_allocator_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PTR_FAIL_WITH_EXEC_IF</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>code_ptr</name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>executable_offset</name> <operator>=</operator> <call><name>SLJIT_EXEC_OFFSET</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* TODO(carenas): pool is optional, and the ABI recommends it to
         *                be created before the function code, instead of
         *                globally; if generated code is too big could
         *                need offsets bigger than 32bit words and asser()
         */</comment>
	<expr_stmt><expr><name>pool</name> <operator>=</operator> <operator>(</operator><name>sljit_uw</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>sljit_uw</name><operator>)</operator><name>code</name> <operator>+</operator> <name>ins_size</name> <operator>+</operator> <name>pad_size</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>pool_ptr</name> <operator>=</operator> <name>pool</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>const_</name> <operator>=</operator> <operator>(</operator>struct <name>sljit_s390x_const</name> <operator>*</operator><operator>)</operator><name><name>compiler</name><operator>-&gt;</operator><name>consts</name></name></expr>;</expr_stmt>

	<comment type="block">/* update label addresses */</comment>
	<expr_stmt><expr><name>label</name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>labels</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>label</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>label</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <operator>(</operator><name>sljit_uw</name><operator>)</operator><call><name>SLJIT_ADD_EXEC_OFFSET</name><argument_list>(
			<argument><expr><operator>(</operator><name>sljit_uw</name><operator>)</operator><name>code_ptr</name> <operator>+</operator> <name><name>label</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>executable_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>label</name> <operator>=</operator> <name><name>label</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* reset jumps */</comment>
	<expr_stmt><expr><name>jump</name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>jumps</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>put_label</name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>put_labels</name></name></expr>;</expr_stmt>

	<comment type="block">/* emit the code */</comment>
	<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>buf</name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>buf</name></name></expr>;</init> <condition><expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>buf</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>sljit_uw</name></type> <name>len</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>used_size</name></name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_ins</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sljit_ins</name> <modifier>*</modifier></type><name>ibuf</name> <init>= <expr><operator>(</operator><name>sljit_ins</name> <operator>*</operator><operator>)</operator><name><name>buf</name><operator>-&gt;</operator><name>memory</name></name></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr><operator>,</operator> <expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>sljit_ins</name></type> <name>ins</name> <init>= <expr><name><name>ibuf</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>ins</name> <operator>&amp;</operator> <name>sljit_ins_const</name></expr>)</condition> <block>{<block_content>
				<comment type="block">/* clear the const tag */</comment>
				<expr_stmt><expr><name>ins</name> <operator>&amp;=</operator> <operator>~</operator><name>sljit_ins_const</name></expr>;</expr_stmt>

				<comment type="block">/* update instruction with relative address of constant */</comment>
				<expr_stmt><expr><name>source</name> <operator>=</operator> <operator>(</operator><name>sljit_uw</name><operator>)</operator><name>code_ptr</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>sljit_uw</name><operator>)</operator><name>pool_ptr</name> <operator>-</operator> <name>source</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>offset</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>offset</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* halfword (not byte) offset */</comment>
				<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><call><name>is_s32</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ins</name> <operator>|=</operator> <operator>(</operator><name>sljit_ins</name><operator>)</operator><name>offset</name> <operator>&amp;</operator> <literal type="number">0xffffffff</literal></expr>;</expr_stmt>

				<comment type="block">/* update address */</comment>
				<expr_stmt><expr><name><name>const_</name><operator>-&gt;</operator><name>const_</name><operator>.</operator><name>addr</name></name> <operator>=</operator> <operator>(</operator><name>sljit_uw</name><operator>)</operator><name>pool_ptr</name></expr>;</expr_stmt>

				<comment type="block">/* store initial value into pool and update pool address */</comment>
				<expr_stmt><expr><operator>*</operator><operator>(</operator><name>pool_ptr</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name><name>const_</name><operator>-&gt;</operator><name>init_value</name></name></expr>;</expr_stmt>

				<comment type="block">/* move to next constant */</comment>
				<expr_stmt><expr><name>const_</name> <operator>=</operator> <operator>(</operator>struct <name>sljit_s390x_const</name> <operator>*</operator><operator>)</operator><name><name>const_</name><operator>-&gt;</operator><name>const_</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>jump</name> <operator>&amp;&amp;</operator> <name><name>jump</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>j</name></expr>)</condition> <block>{<block_content>
				<decl_stmt><decl><type><name>sljit_sw</name></type> <name>target</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>jump</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JUMP_LABEL</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>jump</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>label</name><operator>-&gt;</operator><name>addr</name></name></expr> </then><else>: <expr><name><name>jump</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>target</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>jump</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SLJIT_REWRITABLE_JUMP</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>jump</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JUMP_ADDR</name><operator>)</operator></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name><name>jump</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <operator>(</operator><name>sljit_uw</name><operator>)</operator><name>pool_ptr</name></expr>;</expr_stmt>

					<comment type="block">/* load address into tmp1 */</comment>
					<expr_stmt><expr><name>source</name> <operator>=</operator> <operator>(</operator><name>sljit_uw</name><operator>)</operator><call><name>SLJIT_ADD_EXEC_OFFSET</name><argument_list>(<argument><expr><name>code_ptr</name></expr></argument>, <argument><expr><name>executable_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>sljit_uw</name><operator>)</operator><call><name>SLJIT_ADD_EXEC_OFFSET</name><argument_list>(<argument><expr><name>pool_ptr</name></expr></argument>, <argument><expr><name>executable_offset</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>source</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>offset</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>offset</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><call><name>is_s32</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>encode_inst</name><argument_list>(<argument><expr><operator>&amp;</operator><name>code_ptr</name></expr></argument>,
						<argument><expr><call><name>lgrl</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>offset</name> <operator>&amp;</operator> <literal type="number">0xffffffff</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* store jump target into pool and update pool address */</comment>
					<expr_stmt><expr><operator>*</operator><operator>(</operator><name>pool_ptr</name><operator>++</operator><operator>)</operator> <operator>=</operator> <name>target</name></expr>;</expr_stmt>

					<comment type="block">/* branch to tmp1 */</comment>
					<decl_stmt><decl><type><name>sljit_ins</name></type> <name>op</name> <init>= <expr><operator>(</operator><name>ins</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xf</literal></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>sljit_ins</name></type> <name>arg</name> <init>= <expr><operator>(</operator><name>ins</name> <operator>&gt;&gt;</operator> <literal type="number">36</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xf</literal></expr></init></decl>;</decl_stmt>
					<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
					<case>case <expr><literal type="number">4</literal></expr>:</case> <comment type="block">/* brcl -&gt; bcr */</comment>
						<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>bcr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="number">5</literal></expr>:</case> <comment type="block">/* brasl -&gt; basr */</comment>
						<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>basr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></switch>
				</block_content>}</block></if>
				<else>else <block>{<block_content>
					<expr_stmt><expr><name><name>jump</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <operator>(</operator><name>sljit_uw</name><operator>)</operator><name>code_ptr</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>source</name> <operator>=</operator> <operator>(</operator><name>sljit_uw</name><operator>)</operator><call><name>SLJIT_ADD_EXEC_OFFSET</name><argument_list>(<argument><expr><name>code_ptr</name></expr></argument>, <argument><expr><name>executable_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>target</name> <operator>-</operator> <name>source</name></expr>;</expr_stmt>

					<comment type="block">/* offset must be halfword aligned */</comment>
					<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>offset</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>offset</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><call><name>is_s32</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* TODO(mundaym): handle arbitrary offsets */</comment>

					<comment type="block">/* patch jump target */</comment>
					<expr_stmt><expr><name>ins</name> <operator>|=</operator> <operator>(</operator><name>sljit_ins</name><operator>)</operator><name>offset</name> <operator>&amp;</operator> <literal type="number">0xffffffff</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name>jump</name> <operator>=</operator> <name><name>jump</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>put_label</name> <operator>&amp;&amp;</operator> <name><name>put_label</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>j</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>source</name> <operator>=</operator> <operator>(</operator><name>sljit_uw</name><operator>)</operator><call><name>SLJIT_ADD_EXEC_OFFSET</name><argument_list>(<argument><expr><name>code_ptr</name></expr></argument>, <argument><expr><name>executable_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>put_label</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>put_label</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <operator>(</operator><name>sljit_uw</name><operator>)</operator><name>code_ptr</name></expr>;</expr_stmt>

				<comment type="block">/* store target into pool */</comment>
				<expr_stmt><expr><operator>*</operator><name>pool_ptr</name> <operator>=</operator> <name><name>put_label</name><operator>-&gt;</operator><name>label</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>sljit_uw</name><operator>)</operator><call><name>SLJIT_ADD_EXEC_OFFSET</name><argument_list>(<argument><expr><name>pool_ptr</name></expr></argument>, <argument><expr><name>executable_offset</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>source</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>pool_ptr</name><operator>++</operator></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>offset</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>offset</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><call><name>is_s32</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ins</name> <operator>|=</operator> <operator>(</operator><name>sljit_ins</name><operator>)</operator><name>offset</name> <operator>&amp;</operator> <literal type="number">0xffffffff</literal></expr>;</expr_stmt>

				<expr_stmt><expr><name>put_label</name> <operator>=</operator> <name><name>put_label</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>encode_inst</name><argument_list>(<argument><expr><operator>&amp;</operator><name>code_ptr</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>sljit_u8</name> <operator>*</operator><operator>)</operator><name>code</name> <operator>+</operator> <name>ins_size</name> <operator>==</operator> <name>code_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>sljit_u8</name> <operator>*</operator><operator>)</operator><name>pool</name> <operator>+</operator> <name>pool_size</name> <operator>==</operator> <operator>(</operator><name>sljit_u8</name> <operator>*</operator><operator>)</operator><name>pool_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <name>SLJIT_ERR_COMPILED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>executable_offset</name></name> <operator>=</operator> <name>executable_offset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>executable_size</name></name> <operator>=</operator> <name>ins_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>SLJIT_ADD_EXEC_OFFSET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>executable_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>code_ptr</name> <operator>=</operator> <call><name>SLJIT_ADD_EXEC_OFFSET</name><argument_list>(<argument><expr><name>code_ptr</name></expr></argument>, <argument><expr><name>executable_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SLJIT_CACHE_FLUSH</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>code_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SLJIT_UPDATE_WX_FLAGS</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>code_ptr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_has_cpu_feature</name><parameter_list>(<parameter><decl><type><name>sljit_s32</name></type> <name>feature_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* TODO(mundaym): implement all */</comment>
	<switch>switch <condition>(<expr><name>feature_type</name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>SLJIT_HAS_CLZ</name></expr>:</case>
		<return>return <expr><ternary><condition><expr><call><name>have_eimm</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return> <comment type="block">/* FLOGR instruction */</comment>
	<case>case <expr><name>SLJIT_HAS_CMOV</name></expr>:</case>
		<return>return <expr><ternary><condition><expr><call><name>have_lscond1</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
	<case>case <expr><name>SLJIT_HAS_FPU</name></expr>:</case>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------- */</comment>
<comment type="block">/*  Entry, exit                                                          */</comment>
<comment type="block">/* --------------------------------------------------------------------- */</comment>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_enter</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>arg_types</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>scratches</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>saveds</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>fscratches</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>fsaveds</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>local_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>args</name> <init>= <expr><call><name>get_arg_count</name><argument_list>(<argument><expr><name>arg_types</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_sw</name></type> <name>frame_size</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_emit_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>scratches</name></expr></argument>, <argument><expr><name>saveds</name></expr></argument>, <argument><expr><name>fscratches</name></expr></argument>, <argument><expr><name>fsaveds</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_emit_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>scratches</name></expr></argument>, <argument><expr><name>saveds</name></expr></argument>, <argument><expr><name>fscratches</name></expr></argument>, <argument><expr><name>fsaveds</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* saved registers go in callee allocated save area */</comment>
	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name> <operator>=</operator> <operator>(</operator><name>local_size</name> <operator>+</operator> <literal type="number">0xf</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">0xf</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>frame_size</name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name> <operator>+</operator> <name>SLJIT_S390X_DEFAULT_STACK_FRAME_SIZE</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>stmg</name><argument_list>(<argument><expr><name>r6</name></expr></argument>, <argument><expr><name>r15</name></expr></argument>, <argument><expr><name>r6</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>r15</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* save registers TODO(MGM): optimize */</comment>
	<if_stmt><if>if <condition>(<expr><name>frame_size</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>is_s16</name><argument_list>(<argument><expr><operator>-</operator><name>frame_size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>aghi</name><argument_list>(<argument><expr><name>r15</name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><operator>(</operator><name>sljit_s16</name><operator>)</operator><name>frame_size</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>is_s32</name><argument_list>(<argument><expr><operator>-</operator><name>frame_size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>agfi</name><argument_list>(<argument><expr><name>r15</name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><operator>(</operator><name>sljit_s32</name><operator>)</operator><name>frame_size</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else <block>{<block_content>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_load_imm_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><operator>-</operator><name>frame_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>la</name><argument_list>(<argument><expr><name>r15</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>r15</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>args</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lgr</name><argument_list>(<argument><expr><call><name>gpr</name><argument_list>(<argument><expr><name>SLJIT_S0</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>gpr</name><argument_list>(<argument><expr><name>SLJIT_R0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>args</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lgr</name><argument_list>(<argument><expr><call><name>gpr</name><argument_list>(<argument><expr><name>SLJIT_S1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>gpr</name><argument_list>(<argument><expr><name>SLJIT_R1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>args</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lgr</name><argument_list>(<argument><expr><call><name>gpr</name><argument_list>(<argument><expr><name>SLJIT_S2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>gpr</name><argument_list>(<argument><expr><name>SLJIT_R2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>args</name> <operator>&lt;</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_set_context</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>arg_types</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>scratches</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>saveds</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>fscratches</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>fsaveds</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>local_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_set_context</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>scratches</name></expr></argument>, <argument><expr><name>saveds</name></expr></argument>, <argument><expr><name>fscratches</name></expr></argument>, <argument><expr><name>fsaveds</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_set_context</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>scratches</name></expr></argument>, <argument><expr><name>saveds</name></expr></argument>, <argument><expr><name>fscratches</name></expr></argument>, <argument><expr><name>fsaveds</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* TODO(mundaym): stack space for saved floating point registers */</comment>
	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name> <operator>=</operator> <operator>(</operator><name>local_size</name> <operator>+</operator> <literal type="number">0xf</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">0xf</literal></expr>;</expr_stmt>
	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_return</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>srcw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_sw</name></type> <name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>end</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_emit_return</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_mov_before_return</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name> <operator>+</operator> <name>SLJIT_S390X_DEFAULT_STACK_FRAME_SIZE</name> <operator>+</operator> <operator>(</operator><name>r6</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_s20</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_load_imm_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name> <operator>+</operator> <name>SLJIT_S390X_DEFAULT_STACK_FRAME_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>la</name><argument_list>(<argument><expr><name>r15</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>r15</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <name>r6</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>end</name> <operator>=</operator> <name>r14</name></expr>;</expr_stmt> <comment type="block">/* r15 has been restored already */</comment>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>end</name> <operator>=</operator> <name>r15</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lmg</name><argument_list>(<argument><expr><name>r6</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>r15</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* restore registers TODO(MGM): optimize */</comment>
	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>br</name><argument_list>(<argument><expr><name>r14</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* return */</comment>

	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------- */</comment>
<comment type="block">/*  Operators                                                            */</comment>
<comment type="block">/* --------------------------------------------------------------------- */</comment>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_op0</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>arg0</name> <init>= <expr><call><name>gpr</name><argument_list>(<argument><expr><name>SLJIT_R0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>arg1</name> <init>= <expr><call><name>gpr</name><argument_list>(<argument><expr><name>SLJIT_R1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_emit_op0</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name><operator>)</operator></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>SLJIT_BREAKPOINT</name></expr>:</case>
		<comment type="block">/* TODO(mundaym): insert real breakpoint? */</comment>
	<case>case <expr><name>SLJIT_NOP</name></expr>:</case>
		<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">0x0700</literal></expr></argument> <comment type="block">/* 2-byte nop */</comment>)</argument_list></call></expr>;</return>
	<case>case <expr><name>SLJIT_LMUL_UW</name></expr>:</case>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>mlgr</name><argument_list>(<argument><expr><name>arg0</name></expr></argument>, <argument><expr><name>arg0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>SLJIT_LMUL_SW</name></expr>:</case>
		<comment type="block">/* signed multiplication from: */</comment>
		<comment type="block">/* Hacker's Delight, Second Edition: Chapter 8-3. */</comment>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>srag</name><argument_list>(<argument><expr><name>tmp0</name></expr></argument>, <argument><expr><name>arg0</name></expr></argument>, <argument><expr><literal type="number">63</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>srag</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">63</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>ngr</name><argument_list>(<argument><expr><name>tmp0</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>ngr</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>arg0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* unsigned multiplication */</comment>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>mlgr</name><argument_list>(<argument><expr><name>arg0</name></expr></argument>, <argument><expr><name>arg0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>sgr</name><argument_list>(<argument><expr><name>arg0</name></expr></argument>, <argument><expr><name>tmp0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>sgr</name><argument_list>(<argument><expr><name>arg0</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>SLJIT_DIV_U32</name></expr>:</case>
	<case>case <expr><name>SLJIT_DIVMOD_U32</name></expr>:</case>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lhi</name><argument_list>(<argument><expr><name>tmp0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lr</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>arg0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>dlr</name><argument_list>(<argument><expr><name>tmp0</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lr</name><argument_list>(<argument><expr><name>arg0</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* quotient */</comment>
		<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>SLJIT_DIVMOD_U32</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lr</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>tmp0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* remainder */</comment>

		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
	<case>case <expr><name>SLJIT_DIV_S32</name></expr>:</case>
	<case>case <expr><name>SLJIT_DIVMOD_S32</name></expr>:</case>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lhi</name><argument_list>(<argument><expr><name>tmp0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lr</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>arg0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>dr</name><argument_list>(<argument><expr><name>tmp0</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lr</name><argument_list>(<argument><expr><name>arg0</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* quotient */</comment>
		<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>SLJIT_DIVMOD_S32</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lr</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>tmp0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* remainder */</comment>

		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
	<case>case <expr><name>SLJIT_DIV_UW</name></expr>:</case>
	<case>case <expr><name>SLJIT_DIVMOD_UW</name></expr>:</case>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lghi</name><argument_list>(<argument><expr><name>tmp0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lgr</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>arg0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>dlgr</name><argument_list>(<argument><expr><name>tmp0</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lgr</name><argument_list>(<argument><expr><name>arg0</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* quotient */</comment>
		<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>SLJIT_DIVMOD_UW</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lgr</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>tmp0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* remainder */</comment>

		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
	<case>case <expr><name>SLJIT_DIV_SW</name></expr>:</case>
	<case>case <expr><name>SLJIT_DIVMOD_SW</name></expr>:</case>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lgr</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>arg0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>dsgr</name><argument_list>(<argument><expr><name>tmp0</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lgr</name><argument_list>(<argument><expr><name>arg0</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* quotient */</comment>
		<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>SLJIT_DIVMOD_SW</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lgr</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>tmp0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* remainder */</comment>

		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
	<case>case <expr><name>SLJIT_ENDBR</name></expr>:</case>
		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
	<case>case <expr><name>SLJIT_SKIP_FRAMES_BEFORE_RETURN</name></expr>:</case>
		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
	<default>default:</default>
		<expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<comment type="block">/* swap result registers */</comment>
	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lgr</name><argument_list>(<argument><expr><name>tmp0</name></expr></argument>, <argument><expr><name>arg0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lgr</name><argument_list>(<argument><expr><name>arg0</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lgr</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>tmp0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* LEVAL will be defined later with different parameters as needed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WHEN2</name><parameter_list>(<parameter><type><name>cond</name></type></parameter>, <parameter><type><name>i1</name></type></parameter>, <parameter><type><name>i2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(cond) ? LEVAL(i1) : LEVAL(i2)</cpp:value></cpp:define>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_op1</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>op</name></decl></parameter>,
        <parameter><decl><type><name>sljit_s32</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>dstw</name></decl></parameter>,
        <parameter><decl><type><name>sljit_s32</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>srcw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_ins</name></type> <name>ins</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>addr</name></name></type> <name>mem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>dst_r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>src_r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>opcode</name> <init>= <expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_emit_op1</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADJUST_LOCAL_OFFSET</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADJUST_LOCAL_OFFSET</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dst</name> <operator>==</operator> <name>SLJIT_UNUSED</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>HAS_FLAGS</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/* TODO(carenas): implement prefetch? */</comment>
		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>&gt;=</operator> <name>SLJIT_MOV</name> <operator>&amp;&amp;</operator> <name>opcode</name> <operator>&lt;=</operator> <name>SLJIT_MOV_P</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* LOAD REGISTER */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>dst_r</name> <operator>=</operator> <call><name>gpr</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>src_r</name> <operator>=</operator> <call><name>gpr</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><name>opcode</name> <operator>|</operator> <operator>(</operator><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
			<comment type="block">/* 32-bit */</comment>
			<case>case <expr><name>SLJIT_MOV32_U8</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>llcr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV32_S8</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>lbr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV32_U16</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>llhr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV32_S16</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>lhr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV32</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>lr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<comment type="block">/* 64-bit */</comment>
			<case>case <expr><name>SLJIT_MOV_U8</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>llgcr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV_S8</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>lgbr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV_U16</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>llghr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV_S16</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>lghr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV_U32</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>llgfr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV_S32</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>lgfr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV</name></expr>:</case>
			<case>case <expr><name>SLJIT_MOV_P</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>lgr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>HAS_FLAGS</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<comment type="block">/* only handle zero flag */</comment>
				<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>op</name> <operator>&amp;</operator> <name>VARIABLE_FLAG_MASK</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>push_store_zero_flag</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>dst_r</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* LOAD IMMEDIATE */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>src</name> <operator>&amp;</operator> <name>SLJIT_IMM</name><operator>)</operator></expr>)</condition> <block>{<block_content>
			<switch>switch <condition>(<expr><name>opcode</name></expr>)</condition> <block>{<block_content>
			<case>case <expr><name>SLJIT_MOV_U8</name></expr>:</case>
				<expr_stmt><expr><name>srcw</name> <operator>=</operator> <operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><operator>(</operator><name>sljit_u8</name><operator>)</operator><operator>(</operator><name>srcw</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV_S8</name></expr>:</case>
				<expr_stmt><expr><name>srcw</name> <operator>=</operator> <operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><operator>(</operator><name>sljit_s8</name><operator>)</operator><operator>(</operator><name>srcw</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV_U16</name></expr>:</case>
				<expr_stmt><expr><name>srcw</name> <operator>=</operator> <operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><operator>(</operator><name>sljit_u16</name><operator>)</operator><operator>(</operator><name>srcw</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV_S16</name></expr>:</case>
				<expr_stmt><expr><name>srcw</name> <operator>=</operator> <operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><operator>(</operator><name>sljit_s16</name><operator>)</operator><operator>(</operator><name>srcw</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV_U32</name></expr>:</case>
				<expr_stmt><expr><name>srcw</name> <operator>=</operator> <operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><operator>(</operator><name>sljit_u32</name><operator>)</operator><operator>(</operator><name>srcw</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV_S32</name></expr>:</case>
				<expr_stmt><expr><name>srcw</name> <operator>=</operator> <operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><operator>(</operator><name>sljit_s32</name><operator>)</operator><operator>(</operator><name>srcw</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></switch>
			<return>return <expr><call><name>push_load_imm_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>gpr</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* LOAD */</comment>
		<comment type="block">/* TODO(carenas): avoid reg being defined later */</comment>
		<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEVAL</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>EVAL(i, reg, mem)</cpp:value></cpp:define>
		<if_stmt><if>if <condition>(<expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>src</name> <operator>&amp;</operator> <name>SLJIT_MEM</name><operator>)</operator></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>reg</name> <init>= <expr><call><name>gpr</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>make_addr_bxy</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* TODO(carenas): convert all calls below to LEVAL */</comment>
			<switch>switch <condition>(<expr><name>opcode</name> <operator>|</operator> <operator>(</operator><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
			<case>case <expr><name>SLJIT_MOV32_U8</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>llc</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV32_S8</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>lb</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV32_U16</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>llh</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV32_S16</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>WHEN2</name><argument_list>(<argument><expr><call><name>is_u12</name><argument_list>(<argument><expr><name><name>mem</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lh</name></expr></argument>, <argument><expr><name>lhy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV32</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>WHEN2</name><argument_list>(<argument><expr><call><name>is_u12</name><argument_list>(<argument><expr><name><name>mem</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>ly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV_U8</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>llgc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV_S8</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>lgb</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV_U16</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>llgh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV_S16</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>lgh</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV_U32</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>llgf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV_S32</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>lgf</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SLJIT_MOV_P</name></expr>:</case>
			<case>case <expr><name>SLJIT_MOV</name></expr>:</case>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>lg</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>mem</name><operator>.</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>HAS_FLAGS</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<comment type="block">/* only handle zero flag */</comment>
				<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>op</name> <operator>&amp;</operator> <name>VARIABLE_FLAG_MASK</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>push_store_zero_flag</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* STORE and STORE IMMEDIATE */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dst</name> <operator>&amp;</operator> <name>SLJIT_MEM</name><operator>)</operator>
			<operator>&amp;&amp;</operator> <operator>(</operator><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>src</name> <operator>&amp;</operator> <name>SLJIT_IMM</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>reg</name> <init>= <expr><ternary><condition><expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>gpr</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>tmp0</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;</operator> <name>SLJIT_IMM</name></expr>)</condition> <block>{<block_content>
				<comment type="block">/* TODO(mundaym): MOVE IMMEDIATE? */</comment>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_load_imm_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<decl_stmt><decl><type><name><name>struct</name> <name>addr</name></name></type> <name>mem</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>make_addr_bxy</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><name>opcode</name></expr>)</condition> <block>{<block_content>
			<case>case <expr><name>SLJIT_MOV_U8</name></expr>:</case>
			<case>case <expr><name>SLJIT_MOV_S8</name></expr>:</case>
				<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
					<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><call><name>is_u12</name><argument_list>(<argument><expr><name><name>mem</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stc</name></expr></argument>, <argument><expr><name>stcy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
			<case>case <expr><name>SLJIT_MOV_U16</name></expr>:</case>
			<case>case <expr><name>SLJIT_MOV_S16</name></expr>:</case>
				<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
					<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><call><name>is_u12</name><argument_list>(<argument><expr><name><name>mem</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sth</name></expr></argument>, <argument><expr><name>sthy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
			<case>case <expr><name>SLJIT_MOV_U32</name></expr>:</case>
			<case>case <expr><name>SLJIT_MOV_S32</name></expr>:</case>
				<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
					<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><call><name>is_u12</name><argument_list>(<argument><expr><name><name>mem</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>st</name></expr></argument>, <argument><expr><name>sty</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
			<case>case <expr><name>SLJIT_MOV_P</name></expr>:</case>
			<case>case <expr><name>SLJIT_MOV</name></expr>:</case>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>LEVAL</name><argument_list>(<argument><expr><name>stg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>HAS_FLAGS</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
					<comment type="block">/* only handle zero flag */</comment>
					<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>op</name> <operator>&amp;</operator> <name>VARIABLE_FLAG_MASK</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><call><name>push_store_zero_flag</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
			<default>default:</default>
				<expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
		<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEVAL</name></cpp:undef>
		<comment type="block">/* MOVE CHARACTERS */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dst</name> <operator>&amp;</operator> <name>SLJIT_MEM</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>src</name> <operator>&amp;</operator> <name>SLJIT_MEM</name><operator>)</operator></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>addr</name></name></type> <name>mem</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>make_addr_bxy</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><name>opcode</name></expr>)</condition> <block>{<block_content>
			<case>case <expr><name>SLJIT_MOV_U8</name></expr>:</case>
			<case>case <expr><name>SLJIT_MOV_S8</name></expr>:</case>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
					<argument><expr><call><name>EVAL</name><argument_list>(<argument><expr><name>llgc</name></expr></argument>, <argument><expr><name>tmp0</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>make_addr_bxy</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
					<argument><expr><call><name>EVAL</name><argument_list>(<argument><expr><name>stcy</name></expr></argument>, <argument><expr><name>tmp0</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
			<case>case <expr><name>SLJIT_MOV_U16</name></expr>:</case>
			<case>case <expr><name>SLJIT_MOV_S16</name></expr>:</case>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
					<argument><expr><call><name>EVAL</name><argument_list>(<argument><expr><name>llgh</name></expr></argument>, <argument><expr><name>tmp0</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>make_addr_bxy</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
					<argument><expr><call><name>EVAL</name><argument_list>(<argument><expr><name>sthy</name></expr></argument>, <argument><expr><name>tmp0</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
			<case>case <expr><name>SLJIT_MOV_U32</name></expr>:</case>
			<case>case <expr><name>SLJIT_MOV_S32</name></expr>:</case>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
					<argument><expr><call><name>EVAL</name><argument_list>(<argument><expr><name>ly</name></expr></argument>, <argument><expr><name>tmp0</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>make_addr_bxy</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
					<argument><expr><call><name>EVAL</name><argument_list>(<argument><expr><name>sty</name></expr></argument>, <argument><expr><name>tmp0</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
			<case>case <expr><name>SLJIT_MOV_P</name></expr>:</case>
			<case>case <expr><name>SLJIT_MOV</name></expr>:</case>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
					<argument><expr><call><name>EVAL</name><argument_list>(<argument><expr><name>lg</name></expr></argument>, <argument><expr><name>tmp0</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>make_addr_bxy</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
					<argument><expr><call><name>EVAL</name><argument_list>(<argument><expr><name>stg</name></expr></argument>, <argument><expr><name>tmp0</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>HAS_FLAGS</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
					<comment type="block">/* only handle zero flag */</comment>
					<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>op</name> <operator>&amp;</operator> <name>VARIABLE_FLAG_MASK</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><call><name>push_store_zero_flag</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>tmp0</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
			<default>default:</default>
				<expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>src</name> <operator>&amp;</operator> <name>SLJIT_IMM</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* no immediates */</comment>

	<expr_stmt><expr><name>dst_r</name> <operator>=</operator> <ternary><condition><expr><call><name>SLOW_IS_REG</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>gpr</name><argument_list>(<argument><expr><name>REG_MASK</name> <operator>&amp;</operator> <name>dst</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>tmp0</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>src_r</name> <operator>=</operator> <ternary><condition><expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>gpr</name><argument_list>(<argument><expr><name>REG_MASK</name> <operator>&amp;</operator> <name>src</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>tmp0</name></expr></else></ternary></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>load_word</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>src</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* TODO(mundaym): optimize loads and stores */</comment>
	<switch>switch <condition>(<expr><name>opcode</name> <operator>|</operator> <operator>(</operator><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>SLJIT_NOT</name></expr>:</case>
		<comment type="block">/* emulate ~x with x^-1 */</comment>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_load_imm_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>src_r</name> <operator>!=</operator> <name>dst_r</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lgr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>xgr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>SLJIT_NOT32</name></expr>:</case>
		<comment type="block">/* emulate ~x with x^-1 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>have_eimm</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>xilf</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else <block>{<block_content>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_load_imm_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>src_r</name> <operator>!=</operator> <name>dst_r</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>xr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<break>break;</break>
	<case>case <expr><name>SLJIT_NEG</name></expr>:</case>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lcgr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>SLJIT_NEG32</name></expr>:</case>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lcr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>SLJIT_CLZ</name></expr>:</case>
		<if_stmt><if>if <condition>(<expr><call><name>have_eimm</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>flogr</name><argument_list>(<argument><expr><name>tmp0</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* clobbers tmp1 */</comment>
			<if_stmt><if>if <condition>(<expr><name>dst_r</name> <operator>!=</operator> <name>tmp0</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lgr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>tmp0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* TODO(mundaym): no eimm (?) */</comment>
		</block_content>}</block></else></if_stmt>
		<break>break;</break>
	<case>case <expr><name>SLJIT_CLZ32</name></expr>:</case>
		<if_stmt><if>if <condition>(<expr><call><name>have_eimm</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>sllg</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>iilf</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>, <argument><expr><literal type="number">0xffffffff</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>flogr</name><argument_list>(<argument><expr><name>tmp0</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* clobbers tmp1 */</comment>
			<if_stmt><if>if <condition>(<expr><name>dst_r</name> <operator>!=</operator> <name>tmp0</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>tmp0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* TODO(mundaym): no eimm (?) */</comment>
		</block_content>}</block></else></if_stmt>
		<break>break;</break>
	<default>default:</default>
		<expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/* write condition code to emulated flag register */</comment>
	<if_stmt><if>if <condition>(<expr><name>op</name> <operator>&amp;</operator> <name>VARIABLE_FLAG_MASK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>ipm</name><argument_list>(<argument><expr><name>flag_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* write zero flag to emulated flag register */</comment>
	<if_stmt><if>if <condition>(<expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_SET_Z</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_store_zero_flag</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>dst_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* TODO(carenas): doesn't need FAIL_IF */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dst</name> <operator>!=</operator> <name>SLJIT_UNUSED</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>dst</name> <operator>&amp;</operator> <name>SLJIT_MEM</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>store_word</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>int</name></type> <name>is_commutative</name><parameter_list>(<parameter><decl><type><name>sljit_s32</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>SLJIT_ADD</name></expr>:</case>
	<case>case <expr><name>SLJIT_ADDC</name></expr>:</case>
	<case>case <expr><name>SLJIT_MUL</name></expr>:</case>
	<case>case <expr><name>SLJIT_AND</name></expr>:</case>
	<case>case <expr><name>SLJIT_OR</name></expr>:</case>
	<case>case <expr><name>SLJIT_XOR</name></expr>:</case>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>int</name></type> <name>is_shift</name><parameter_list>(<parameter><decl><type><name>sljit_s32</name></type> <name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>v</name> <init>= <expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name>v</name> <operator>==</operator> <name>SLJIT_SHL</name> <operator>||</operator> <name>v</name> <operator>==</operator> <name>SLJIT_ASHR</name> <operator>||</operator> <name>v</name> <operator>==</operator> <name>SLJIT_LSHR</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>int</name></type> <name>sets_signed_flag</name><parameter_list>(<parameter><decl><type><name>sljit_s32</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>GET_FLAG_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>SLJIT_OVERFLOW</name></expr>:</case>
	<case>case <expr><name>SLJIT_NOT_OVERFLOW</name></expr>:</case>
	<case>case <expr><name>SLJIT_SIG_LESS</name></expr>:</case>
	<case>case <expr><name>SLJIT_SIG_LESS_EQUAL</name></expr>:</case>
	<case>case <expr><name>SLJIT_SIG_GREATER</name></expr>:</case>
	<case>case <expr><name>SLJIT_SIG_GREATER_EQUAL</name></expr>:</case>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Report whether we have an instruction for:
     op dst src imm
   where dst and src are separate registers. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>have_op_3_imm</name><parameter_list>(<parameter><decl><type><name>sljit_s32</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>imm</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return> <comment type="block">/* TODO(mundaym): implement */</comment>
</block_content>}</block></function>

<comment type="block">/* Report whether we have an instruction for:
     op reg imm
  where reg is both a source and the destination. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>have_op_2_imm</name><parameter_list>(<parameter><decl><type><name>sljit_s32</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>imm</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<switch>switch <condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>SLJIT_ADD32</name></expr>:</case>
	<case>case <expr><name>SLJIT_ADD</name></expr>:</case>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HAS_FLAGS</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>sets_signed_flag</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><ternary><condition><expr><call><name>have_eimm</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>is_s32</name><argument_list>(<argument><expr><name>imm</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>is_s16</name><argument_list>(<argument><expr><name>imm</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

		<return>return <expr><call><name>have_eimm</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_u32</name><argument_list>(<argument><expr><name>imm</name></expr></argument>)</argument_list></call></expr>;</return>
	<case>case <expr><name>SLJIT_MUL32</name></expr>:</case>
	<case>case <expr><name>SLJIT_MUL</name></expr>:</case>
		<comment type="block">/* TODO(mundaym): general extension check */</comment>
		<comment type="block">/* for ms{,g}fi */</comment>
		<if_stmt><if>if <condition>(<expr><name>op</name> <operator>&amp;</operator> <name>VARIABLE_FLAG_MASK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

		<return>return <expr><call><name>have_genext</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_s16</name><argument_list>(<argument><expr><name>imm</name></expr></argument>)</argument_list></call></expr>;</return>
	<case>case <expr><name>SLJIT_OR32</name></expr>:</case>
	<case>case <expr><name>SLJIT_XOR32</name></expr>:</case>
	<case>case <expr><name>SLJIT_AND32</name></expr>:</case>
		<comment type="block">/* only use if have extended immediate facility */</comment>
		<comment type="block">/* this ensures flags are set correctly */</comment>
		<return>return <expr><call><name>have_eimm</name><argument_list>()</argument_list></call></expr>;</return>
	<case>case <expr><name>SLJIT_AND</name></expr>:</case>
	<case>case <expr><name>SLJIT_OR</name></expr>:</case>
	<case>case <expr><name>SLJIT_XOR</name></expr>:</case>
		<comment type="block">/* TODO(mundaym): make this more flexible */</comment>
		<comment type="block">/* avoid using immediate variations, flags */</comment>
		<comment type="block">/* won't be set correctly */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	<case>case <expr><name>SLJIT_ADDC32</name></expr>:</case>
	<case>case <expr><name>SLJIT_ADDC</name></expr>:</case>
		<comment type="block">/* no ADD LOGICAL WITH CARRY IMMEDIATE */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	<case>case <expr><name>SLJIT_SUB</name></expr>:</case>
	<case>case <expr><name>SLJIT_SUB32</name></expr>:</case>
	<case>case <expr><name>SLJIT_SUBC</name></expr>:</case>
	<case>case <expr><name>SLJIT_SUBC32</name></expr>:</case>
		<comment type="block">/* no SUBTRACT IMMEDIATE */</comment>
		<comment type="block">/* TODO(mundaym): SUBTRACT LOGICAL IMMEDIATE */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_op2</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>op</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>dstw</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>src1</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>src1w</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>src2</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>src2w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_emit_op2</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><name>src1</name></expr></argument>, <argument><expr><name>src1w</name></expr></argument>, <argument><expr><name>src2</name></expr></argument>, <argument><expr><name>src2w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADJUST_LOCAL_OFFSET</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADJUST_LOCAL_OFFSET</name><argument_list>(<argument><expr><name>src1</name></expr></argument>, <argument><expr><name>src1w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADJUST_LOCAL_OFFSET</name><argument_list>(<argument><expr><name>src2</name></expr></argument>, <argument><expr><name>src2w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>==</operator> <name>SLJIT_UNUSED</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>HAS_FLAGS</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>dst_r</name> <init>= <expr><ternary><condition><expr><call><name>SLOW_IS_REG</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>gpr</name><argument_list>(<argument><expr><name>dst</name> <operator>&amp;</operator> <name>REG_MASK</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>tmp0</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>is_commutative</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SWAP_ARGS</name></cpp:macro> \
		<cpp:value>do {                         \
			sljit_s32 t = src1;  \
			sljit_sw tw = src1w; \
			src1 = src2;         \
			src1w = src2w;       \
			src2 = t;            \
			src2w = tw;          \
		} while(0);</cpp:value></cpp:define>

		<comment type="block">/* prefer immediate in src2 */</comment>
		<if_stmt><if>if <condition>(<expr><name>src1</name> <operator>&amp;</operator> <name>SLJIT_IMM</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>SWAP_ARGS</name></expr></expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* prefer to have src1 use same register as dst */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>src2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>gpr</name><argument_list>(<argument><expr><name>src2</name> <operator>&amp;</operator> <name>REG_MASK</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>dst_r</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>SWAP_ARGS</name></expr></expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* prefer memory argument in src2 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>src2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>src1</name> <operator>&amp;</operator> <name>SLJIT_MEM</name><operator>)</operator></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>SWAP_ARGS</name></expr></expr_stmt>
		</block_content>}</block></if></if_stmt>
		<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SWAP_ARGS</name></cpp:undef>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* src1 must be in a register */</comment>
	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>src1_r</name> <init>= <expr><ternary><condition><expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>src1</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>gpr</name><argument_list>(<argument><expr><name>src1</name> <operator>&amp;</operator> <name>REG_MASK</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>tmp0</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>src1</name> <operator>&amp;</operator> <name>SLJIT_IMM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_load_imm_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>src1_r</name></expr></argument>, <argument><expr><name>src1w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>src1</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>load_word</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>src1_r</name></expr></argument>, <argument><expr><name>src1</name></expr></argument>, <argument><expr><name>src1w</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* emit comparison before subtract */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SLJIT_SUB</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>op</name> <operator>&amp;</operator> <name>VARIABLE_FLAG_MASK</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>sljit_sw</name></type> <name>cmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><call><name>GET_FLAG_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>SLJIT_LESS</name></expr>:</case>
		<case>case <expr><name>SLJIT_LESS_EQUAL</name></expr>:</case>
		<case>case <expr><name>SLJIT_GREATER</name></expr>:</case>
		<case>case <expr><name>SLJIT_GREATER_EQUAL</name></expr>:</case>
			<expr_stmt><expr><name>cmp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* unsigned */</comment>
			<break>break;</break>
		<case>case <expr><name>SLJIT_EQUAL</name></expr>:</case>
		<case>case <expr><name>SLJIT_SIG_LESS</name></expr>:</case>
		<case>case <expr><name>SLJIT_SIG_LESS_EQUAL</name></expr>:</case>
		<case>case <expr><name>SLJIT_SIG_GREATER</name></expr>:</case>
		<case>case <expr><name>SLJIT_SIG_GREATER_EQUAL</name></expr>:</case>
			<expr_stmt><expr><name>cmp</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* signed */</comment>
			<break>break;</break>
		</block_content>}</block></switch>
		<if_stmt><if>if <condition>(<expr><name>cmp</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* clear flags - no need to generate now */</comment>
			<expr_stmt><expr><name>op</name> <operator>&amp;=</operator> <operator>~</operator><name>VARIABLE_FLAG_MASK</name></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>src2_r</name> <init>= <expr><ternary><condition><expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>src2</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>gpr</name><argument_list>(<argument><expr><name>src2</name> <operator>&amp;</operator> <name>REG_MASK</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>tmp1</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>src2</name> <operator>&amp;</operator> <name>SLJIT_IMM</name></expr>)</condition> <block>{<block_content>
				<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEVAL</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>i(src1_r, src2w)</cpp:value></cpp:define>
				<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>is_u32</name><argument_list>(<argument><expr><name>src2w</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
					<comment type="block">/* unsigned */</comment>
					<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
					<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>, <argument><expr><name>clfi</name></expr></argument>, <argument><expr><name>clgfi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>is_s16</name><argument_list>(<argument><expr><name>src2w</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
					<comment type="block">/* signed */</comment>
					<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
					<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>, <argument><expr><name>chi</name></expr></argument>, <argument><expr><name>cghi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>is_s32</name><argument_list>(<argument><expr><name>src2w</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
					<comment type="block">/* signed */</comment>
					<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
					<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>, <argument><expr><name>cfi</name></expr></argument>, <argument><expr><name>cgfi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEVAL</name></cpp:undef>
				<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEVAL</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>i(src1_r, src2_r)</cpp:value></cpp:define>
				<else>else <block>{<block_content>
					<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_load_imm_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>src2_r</name></expr></argument>, <argument><expr><name>src2w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
						<comment type="block">/* unsigned */</comment>
						<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
						<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>, <argument><expr><name>clr</name></expr></argument>, <argument><expr><name>clgr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
						<comment type="block">/* signed */</comment>
						<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
						<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>, <argument><expr><name>cgr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>src2</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr>)</condition> <block>{<block_content>
					<comment type="block">/* TODO(mundaym): comparisons with memory */</comment>
					<comment type="block">/* load src2 into register */</comment>
					<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>load_word</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>src2_r</name></expr></argument>, <argument><expr><name>src2</name></expr></argument>, <argument><expr><name>src2w</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
					<comment type="block">/* unsigned */</comment>
					<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
						<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>, <argument><expr><name>clr</name></expr></argument>, <argument><expr><name>clgr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
					<comment type="block">/* signed */</comment>
					<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
						<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>, <argument><expr><name>cgr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEVAL</name></cpp:undef>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>ipm</name><argument_list>(<argument><expr><name>flag_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HAS_FLAGS</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>dst</name> <operator>==</operator> <name>SLJIT_UNUSED</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* need to specify signed or logical operation */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>signed_flags</name> <init>= <expr><call><name>sets_signed_flag</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>is_shift</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/* handle shifts first, they have more constraints than other operations */</comment>
		<decl_stmt><decl><type><name>sljit_sw</name></type> <name>d</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>b</name> <init>= <expr><ternary><condition><expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>src2</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>gpr</name><argument_list>(<argument><expr><name>src2</name> <operator>&amp;</operator> <name>REG_MASK</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>r0</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>src2</name> <operator>&amp;</operator> <name>SLJIT_IMM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>d</name> <operator>=</operator> <name>src2w</name> <operator>&amp;</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">31</literal></expr> </then><else>: <expr><literal type="number">63</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>src2</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* shift amount (b) cannot be in r0 (i.e. tmp0) */</comment>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>load_word</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>src2</name></expr></argument>, <argument><expr><name>src2w</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>b</name> <operator>=</operator> <name>tmp1</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* src1 and dst share the same register in the base 32-bit ISA */</comment>
		<comment type="block">/* TODO(mundaym): not needed when distinct-operand facility is available */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>workaround_alias</name> <init>= <expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name> <operator>&amp;&amp;</operator> <name>src1_r</name> <operator>!=</operator> <name>dst_r</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>workaround_alias</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* put src1 into tmp0 so we can overwrite it */</comment>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lr</name><argument_list>(<argument><expr><name>tmp0</name></expr></argument>, <argument><expr><name>src1_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>src1_r</name> <operator>=</operator> <name>tmp0</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<switch>switch <condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>SLJIT_SHL</name></expr>:</case>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>sllg</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src1_r</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_SHL32</name></expr>:</case>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>sll</name><argument_list>(<argument><expr><name>src1_r</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_LSHR</name></expr>:</case>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>srlg</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src1_r</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_LSHR32</name></expr>:</case>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>srl</name><argument_list>(<argument><expr><name>src1_r</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_ASHR</name></expr>:</case>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>srag</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src1_r</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_ASHR32</name></expr>:</case>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>sra</name><argument_list>(<argument><expr><name>src1_r</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
		<if_stmt><if>if <condition>(<expr><name>workaround_alias</name> <operator>&amp;&amp;</operator> <name>dst_r</name> <operator>!=</operator> <name>src1_r</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src1_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SLJIT_MUL</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>HAS_FLAGS</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/* multiply instructions do not generally set flags so we need to manually */</comment>
		<comment type="block">/* detect overflow conditions */</comment>
		<comment type="block">/* TODO(mundaym): 64-bit overflow */</comment>
		<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><call><name>GET_FLAG_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SLJIT_MUL_OVERFLOW</name> <operator>||</operator>
		             <call><name>GET_FLAG_TYPE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SLJIT_MUL_NOT_OVERFLOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>src2_r</name> <init>= <expr><ternary><condition><expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>src2</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>gpr</name><argument_list>(<argument><expr><name>src2</name> <operator>&amp;</operator> <name>REG_MASK</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>tmp1</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>src2</name> <operator>&amp;</operator> <name>SLJIT_IMM</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* load src2 into register */</comment>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_load_imm_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>src2_r</name></expr></argument>, <argument><expr><name>src2w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>src2</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* load src2 into register */</comment>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>load_word</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>src2_r</name></expr></argument>, <argument><expr><name>src2</name></expr></argument>, <argument><expr><name>src2w</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>have_misc2</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
			<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEVAL</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>i(dst_r, src1_r, src2_r)</cpp:value></cpp:define>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
				<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>, <argument><expr><name>msrkc</name></expr></argument>, <argument><expr><name>msgrkc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEVAL</name></cpp:undef>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>op</name> <operator>&amp;=</operator> <operator>~</operator><name>VARIABLE_FLAG_MASK</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lgfr</name><argument_list>(<argument><expr><name>tmp0</name></expr></argument>, <argument><expr><name>src1_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>msgfr</name><argument_list>(<argument><expr><name>tmp0</name></expr></argument>, <argument><expr><name>src2_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>dst_r</name> <operator>!=</operator> <name>tmp0</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>tmp0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>aih</name><argument_list>(<argument><expr><name>tmp0</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>nihf</name><argument_list>(<argument><expr><name>tmp0</name></expr></argument>, <argument><expr><operator>~</operator><literal type="number">1U</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>ipm</name><argument_list>(<argument><expr><name>flag_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>oilh</name><argument_list>(<argument><expr><name>flag_r</name></expr></argument>, <argument><expr><literal type="number">0x2000</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>SLJIT_ERR_UNSUPPORTED</name></expr>;</return></block_content></block></else></if_stmt>

	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SLJIT_SUB</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>op</name> <operator>&amp;</operator> <name>SLJIT_SET_Z</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>signed_flags</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* subtract logical instructions do not set the right flags unfortunately */</comment>
		<comment type="block">/* instead, negate src2 and issue an add logical */</comment>
		<comment type="block">/* TODO(mundaym): distinct operand facility where needed */</comment>
		<if_stmt><if>if <condition>(<expr><name>src1_r</name> <operator>!=</operator> <name>dst_r</name> <operator>&amp;&amp;</operator> <name>src1_r</name> <operator>!=</operator> <name>tmp0</name></expr>)</condition> <block>{<block_content>
			<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEVAL</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>i(tmp0, src1_r)</cpp:value></cpp:define>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
				<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>lgr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>src1_r</name> <operator>=</operator> <name>tmp0</name></expr>;</expr_stmt>
			<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEVAL</name></cpp:undef>
		</block_content>}</block></if></if_stmt>
		<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>src2_r</name> <init>= <expr><ternary><condition><expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>src2</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>gpr</name><argument_list>(<argument><expr><name>src2</name> <operator>&amp;</operator> <name>REG_MASK</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>tmp1</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>src2</name> <operator>&amp;</operator> <name>SLJIT_IMM</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* load src2 into register */</comment>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_load_imm_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>src2_r</name></expr></argument>, <argument><expr><name>src2w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>src2</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* load src2 into register */</comment>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>load_word</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>src2_r</name></expr></argument>, <argument><expr><name>src2</name></expr></argument>, <argument><expr><name>src2w</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lcr</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>src2_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>alr</name><argument_list>(<argument><expr><name>src1_r</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>src1_r</name> <operator>!=</operator> <name>dst_r</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src1_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else <block>{<block_content>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lcgr</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>src2_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>algr</name><argument_list>(<argument><expr><name>src1_r</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>src1_r</name> <operator>!=</operator> <name>dst_r</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lgr</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src1_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>src2</name> <operator>&amp;</operator> <name>SLJIT_IMM</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>src1_r</name> <operator>==</operator> <name>dst_r</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>have_op_2_imm</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>src2w</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<switch>switch <condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEVAL</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>i(dst_r, src2w)</cpp:value></cpp:define>
		<case>case <expr><name>SLJIT_ADD</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HAS_FLAGS</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>signed_flags</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
					<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><call><name>is_s16</name><argument_list>(<argument><expr><name>src2w</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>aghi</name></expr></argument>, <argument><expr><name>agfi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>LEVAL</name><argument_list>(<argument><expr><name>algfi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>
		<case>case <expr><name>SLJIT_ADD32</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HAS_FLAGS</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>signed_flags</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
					<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><call><name>is_s16</name><argument_list>(<argument><expr><name>src2w</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ahi</name></expr></argument>, <argument><expr><name>afi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>LEVAL</name><argument_list>(<argument><expr><name>alfi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<break>break;</break>
		<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEVAL</name></cpp:undef> <comment type="block">/* TODO(carenas): move down and refactor? */</comment>
		<case>case <expr><name>SLJIT_MUL</name></expr>:</case>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>mhi</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src2w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_MUL32</name></expr>:</case>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>mghi</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src2w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_OR32</name></expr>:</case>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>oilf</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src2w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_XOR32</name></expr>:</case>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>xilf</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src2w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_AND32</name></expr>:</case>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>nilf</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>src2w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>src2</name> <operator>&amp;</operator> <name>SLJIT_IMM</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>have_op_3_imm</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>src2w</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* TODO(mundaym): implement */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>src2</name> <operator>&amp;</operator> <name>SLJIT_MEM</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>dst_r</name> <operator>==</operator> <name>src1_r</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<comment type="block">/* most 32-bit instructions can only handle 12-bit immediate offsets */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>need_u12</name> <init>= <expr><operator>!</operator><call><name>have_ldisp</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SLJIT_ADDC</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SLJIT_SUBC</name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>addr</name></name></type> <name>mem</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>need_u12</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>make_addr_bx</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem</name></expr></argument>, <argument><expr><name>src2</name></expr></argument>, <argument><expr><name>src2w</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>make_addr_bxy</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mem</name></expr></argument>, <argument><expr><name>src2</name></expr></argument>, <argument><expr><name>src2w</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>can_u12</name> <init>= <expr><ternary><condition><expr><call><name>is_u12</name><argument_list>(<argument><expr><name><name>mem</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>sljit_ins</name></type> <name>ins</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<comment type="block">/* 64-bit ops */</comment>
		<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEVAL</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>EVAL(i, dst_r, mem)</cpp:value></cpp:define>
		<case>case <expr><name>SLJIT_ADD</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>WHEN2</name><argument_list>(<argument><expr><name>signed_flags</name></expr></argument>, <argument><expr><name>ag</name></expr></argument>, <argument><expr><name>alg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_SUB</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>WHEN2</name><argument_list>(<argument><expr><name>signed_flags</name></expr></argument>, <argument><expr><name>sg</name></expr></argument>, <argument><expr><name>slg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_ADDC</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>alcg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_SUBC</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>slbg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_MUL</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_OR</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>og</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_XOR</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>xg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_AND</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>ng</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<comment type="block">/* 32-bit ops */</comment>
		<case>case <expr><name>SLJIT_ADD32</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>signed_flags</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>WHEN2</name><argument_list>(<argument><expr><name>can_u12</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>ay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>WHEN2</name><argument_list>(<argument><expr><name>can_u12</name></expr></argument>, <argument><expr><name>al</name></expr></argument>, <argument><expr><name>aly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_SUB32</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>signed_flags</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>WHEN2</name><argument_list>(<argument><expr><name>can_u12</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>sy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>WHEN2</name><argument_list>(<argument><expr><name>can_u12</name></expr></argument>, <argument><expr><name>sl</name></expr></argument>, <argument><expr><name>sly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_ADDC32</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>alc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_SUBC32</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>slb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_MUL32</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>WHEN2</name><argument_list>(<argument><expr><name>can_u12</name></expr></argument>, <argument><expr><name>ms</name></expr></argument>, <argument><expr><name>msy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_OR32</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>WHEN2</name><argument_list>(<argument><expr><name>can_u12</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>oy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_XOR32</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>WHEN2</name><argument_list>(<argument><expr><name>can_u12</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>xy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_AND32</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>WHEN2</name><argument_list>(<argument><expr><name>can_u12</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>ny</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEVAL</name></cpp:undef>
		<default>default:</default>
			<expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else <block>{<block_content>
		<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>src2_r</name> <init>= <expr><ternary><condition><expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>src2</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>gpr</name><argument_list>(<argument><expr><name>src2</name> <operator>&amp;</operator> <name>REG_MASK</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>tmp1</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>src2</name> <operator>&amp;</operator> <name>SLJIT_IMM</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* load src2 into register */</comment>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_load_imm_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>src2_r</name></expr></argument>, <argument><expr><name>src2w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>src2</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* load src2 into register */</comment>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>load_word</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>src2_r</name></expr></argument>, <argument><expr><name>src2</name></expr></argument>, <argument><expr><name>src2w</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* TODO(mundaym): distinct operand facility where needed */</comment>
		<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEVAL</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>i(tmp0, src1_r)</cpp:value></cpp:define>
		<if_stmt><if>if <condition>(<expr><name>src1_r</name> <operator>!=</operator> <name>dst_r</name> <operator>&amp;&amp;</operator> <name>src1_r</name> <operator>!=</operator> <name>tmp0</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
				<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>lgr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>src1_r</name> <operator>=</operator> <name>tmp0</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEVAL</name></cpp:undef>
		<decl_stmt><decl><type><name>sljit_ins</name></type> <name>ins</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>|</operator> <operator>(</operator><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEVAL</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>i(src1_r, src2_r)</cpp:value></cpp:define>
		<comment type="block">/* 64-bit ops */</comment>
		<case>case <expr><name>SLJIT_ADD</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>WHEN2</name><argument_list>(<argument><expr><name>signed_flags</name></expr></argument>, <argument><expr><name>agr</name></expr></argument>, <argument><expr><name>algr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_SUB</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>WHEN2</name><argument_list>(<argument><expr><name>signed_flags</name></expr></argument>, <argument><expr><name>sgr</name></expr></argument>, <argument><expr><name>slgr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_ADDC</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>alcgr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_SUBC</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>slbgr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_MUL</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>msgr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_AND</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>ngr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_OR</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>ogr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_XOR</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>xgr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<comment type="block">/* 32-bit ops */</comment>
		<case>case <expr><name>SLJIT_ADD32</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>WHEN2</name><argument_list>(<argument><expr><name>signed_flags</name></expr></argument>, <argument><expr><name>ar</name></expr></argument>, <argument><expr><name>alr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_SUB32</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>WHEN2</name><argument_list>(<argument><expr><name>signed_flags</name></expr></argument>, <argument><expr><name>sr</name></expr></argument>, <argument><expr><name>slr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_ADDC32</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>alcr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_SUBC32</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>slbr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_MUL32</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>msr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_AND32</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_OR32</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>or</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_XOR32</name></expr>:</case>
			<expr_stmt><expr><name>ins</name> <operator>=</operator> <call><name>LEVAL</name><argument_list>(<argument><expr><name>xr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEVAL</name></cpp:undef>
		<default>default:</default>
			<expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEVAL</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>i(dst_r, src1_r)</cpp:value></cpp:define>
		<if_stmt><if>if <condition>(<expr><name>src1_r</name> <operator>!=</operator> <name>dst_r</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
				<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>lgr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEVAL</name></cpp:undef>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* write condition code to emulated flag register */</comment>
	<if_stmt><if>if <condition>(<expr><name>op</name> <operator>&amp;</operator> <name>VARIABLE_FLAG_MASK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>ipm</name><argument_list>(<argument><expr><name>flag_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* write zero flag to emulated flag register */</comment>
	<if_stmt><if>if <condition>(<expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_SET_Z</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_store_zero_flag</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>dst_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* finally write the result to memory if required */</comment>
	<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>dst_r</name> <operator>!=</operator> <name>tmp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* TODO(carenas): s/FAIL_IF/ return */</comment>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>store_word</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_op_src</name><parameter_list>(
	<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>srcw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>src_r</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_emit_op_src</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADJUST_LOCAL_OFFSET</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>SLJIT_FAST_RETURN</name></expr>:</case>
		<expr_stmt><expr><name>src_r</name> <operator>=</operator> <ternary><condition><expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>gpr</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>tmp1</name></expr></else></ternary></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>load_word</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>br</name><argument_list>(<argument><expr><name>src_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	<case>case <expr><name>SLJIT_SKIP_FRAMES_BEFORE_FAST_RETURN</name></expr>:</case>
		<comment type="block">/* TODO(carenas): implement? */</comment>
		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
	<case>case <expr><name>SLJIT_PREFETCH_L1</name></expr>:</case>
	<case>case <expr><name>SLJIT_PREFETCH_L2</name></expr>:</case>
	<case>case <expr><name>SLJIT_PREFETCH_L3</name></expr>:</case>
	<case>case <expr><name>SLJIT_PREFETCH_ONCE</name></expr>:</case>
		<comment type="block">/* TODO(carenas): implement */</comment>
		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
	<default>default:</default>
                <comment type="block">/* TODO(carenas): probably should not success by default */</comment>
		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
	</block_content>}</block></switch>

	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_get_register_index</name><parameter_list>(<parameter><decl><type><name>sljit_s32</name></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CHECK_REG_INDEX</name><argument_list>(<argument><expr><call><name>check_sljit_get_register_index</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>gpr</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_get_float_register_index</name><parameter_list>(<parameter><decl><type><name>sljit_s32</name></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CHECK_REG_INDEX</name><argument_list>(<argument><expr><call><name>check_sljit_get_float_register_index</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_op_custom</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>,
	<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>instruction</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_ins</name></type> <name>ins</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_emit_op_custom</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>instruction</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>sljit_u8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ins</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ins</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>size</name></expr></argument>, <argument><expr><name>instruction</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>ins</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------- */</comment>
<comment type="block">/*  Floating point operators                                             */</comment>
<comment type="block">/* --------------------------------------------------------------------- */</comment>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_fop1</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>op</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>dstw</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>srcw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_fop2</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>op</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>dstw</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>src1</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>src1w</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>src2</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>src2w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------- */</comment>
<comment type="block">/*  Other instructions                                                   */</comment>
<comment type="block">/* --------------------------------------------------------------------- */</comment>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_fast_enter</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>dstw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADJUST_LOCAL_OFFSET</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lgr</name><argument_list>(<argument><expr><call><name>gpr</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fast_link_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* memory */</comment>
	<return>return <expr><call><name>store_word</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>fast_link_r</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------- */</comment>
<comment type="block">/*  Conditional instructions                                             */</comment>
<comment type="block">/* --------------------------------------------------------------------- */</comment>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name><name>struct</name> <name>sljit_label</name></name><modifier>*</modifier></type> <name>sljit_emit_label</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR_PTR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_PTR</name><argument_list>(<argument><expr><call><name>check_sljit_emit_label</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>compiler</name><operator>-&gt;</operator><name>last_label</name></name> <operator>&amp;&amp;</operator> <name><name>compiler</name><operator>-&gt;</operator><name>last_label</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <name><name>compiler</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>compiler</name><operator>-&gt;</operator><name>last_label</name></name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>label</name> <operator>=</operator> <operator>(</operator>struct <name>sljit_label</name><operator>*</operator><operator>)</operator><call><name>ensure_abuf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sljit_label</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_label</name><argument_list>(<argument><expr><name>label</name></expr></argument>, <argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>label</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name><name>struct</name> <name>sljit_jump</name></name><modifier>*</modifier></type> <name>sljit_emit_jump</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_u8</name></type> <name>mask</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>type</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>&lt;</operator> <name>SLJIT_JUMP</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>get_cc</name><argument_list>(<argument><expr><name>type</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0xf</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR_PTR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_PTR</name><argument_list>(<argument><expr><call><name>check_sljit_emit_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* reload condition code */</comment>
	<if_stmt><if>if <condition>(<expr><name>mask</name> <operator>!=</operator> <literal type="number">0xf</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><call><name>push_load_cc</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* record jump */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name> <init>= <expr><operator>(</operator>struct <name>sljit_jump</name> <operator>*</operator><operator>)</operator>
		<call><name>ensure_abuf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sljit_jump</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_jump</name><argument_list>(<argument><expr><name>jump</name></expr></argument>, <argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name> <operator>&amp;</operator> <name>SLJIT_REWRITABLE_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jump</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

	<comment type="block">/* emit jump instruction */</comment>
	<expr_stmt><expr><name>type</name> <operator>&amp;=</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&gt;=</operator> <name>SLJIT_FAST_CALL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>brasl</name><argument_list>(<argument><expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>SLJIT_FAST_CALL</name></expr> ?</condition><then> <expr><name>fast_link_r</name></expr> </then><else>: <expr><name>link_r</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>brcl</name><argument_list>(<argument><expr><name>mask</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>jump</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name><name>struct</name> <name>sljit_jump</name></name><modifier>*</modifier></type> <name>sljit_emit_call</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>type</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>arg_types</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CHECK_ERROR_PTR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_PTR</name><argument_list>(<argument><expr><call><name>check_sljit_emit_call</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>SLJIT_VERBOSE</name> <operator>&amp;&amp;</operator> <name>SLJIT_VERBOSE</name><operator>)</operator> \
		<operator>||</operator> <operator>(</operator><name>defined</name> <name>SLJIT_ARGUMENT_CHECKS</name> <operator>&amp;&amp;</operator> <name>SLJIT_ARGUMENT_CHECKS</name><operator>)</operator></expr></cpp:if>
	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>skip_checks</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><call><name>sljit_emit_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_ijump</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>srcw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>src_r</name> <init>= <expr><ternary><condition><expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>gpr</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>tmp1</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_emit_ijump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADJUST_LOCAL_OFFSET</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;</operator> <name>SLJIT_IMM</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>srcw</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* target address must be even */</comment>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_load_imm_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>src</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>load_word</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* 64-bit */</comment>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* emit jump instruction */</comment>
	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&gt;=</operator> <name>SLJIT_FAST_CALL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>basr</name><argument_list>(<argument><expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>SLJIT_FAST_CALL</name></expr> ?</condition><then> <expr><name>fast_link_r</name></expr> </then><else>: <expr><name>link_r</name></expr></else></ternary></expr></argument>, <argument><expr><name>src_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>br</name><argument_list>(<argument><expr><name>src_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_icall</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>type</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>arg_types</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>srcw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_emit_icall</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>SLJIT_VERBOSE</name> <operator>&amp;&amp;</operator> <name>SLJIT_VERBOSE</name><operator>)</operator> \
		<operator>||</operator> <operator>(</operator><name>defined</name> <name>SLJIT_ARGUMENT_CHECKS</name> <operator>&amp;&amp;</operator> <name>SLJIT_ARGUMENT_CHECKS</name><operator>)</operator></expr></cpp:if>
	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>skip_checks</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><call><name>sljit_emit_ijump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_op_flags</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>op</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>dstw</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_u8</name></type> <name>mask</name> <init>= <expr><call><name>get_cc</name><argument_list>(<argument><expr><name>type</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_emit_op_flags</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>dst_r</name> <init>= <expr><ternary><condition><expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>gpr</name><argument_list>(<argument><expr><name>dst</name> <operator>&amp;</operator> <name>REG_MASK</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>tmp0</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>loc_r</name> <init>= <expr><name>tmp1</name></expr></init></decl>;</decl_stmt>
	<switch>switch <condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>SLJIT_AND</name></expr>:</case>
	<case>case <expr><name>SLJIT_OR</name></expr>:</case>
	<case>case <expr><name>SLJIT_XOR</name></expr>:</case>
		<comment type="block">/* dst is also source operand */</comment>
		<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>load_word</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<break>break;</break>
	<case>case <expr><name>SLJIT_MOV</name></expr>:</case>
	<case>case <expr><operator>(</operator><name>SLJIT_MOV32</name> <operator>&amp;</operator> <operator>~</operator><name>SLJIT_I32_OP</name><operator>)</operator></expr>:</case>
		<comment type="block">/* can write straight into destination */</comment>
		<expr_stmt><expr><name>loc_r</name> <operator>=</operator> <name>dst_r</name></expr>;</expr_stmt>
		<break>break;</break>
	<default>default:</default>
		<expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>mask</name> <operator>!=</operator> <literal type="number">0xf</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_load_cc</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* TODO(mundaym): fold into cmov helper function? */</comment>
	<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEVAL</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>i(loc_r, 1, mask)</cpp:value></cpp:define>
	<if_stmt><if>if <condition>(<expr><call><name>have_lscond2</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_load_imm_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>loc_r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
			<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>, <argument><expr><name>lochi</name></expr></argument>, <argument><expr><name>locghi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/* TODO(mundaym): no load/store-on-condition 2 facility (ipm? branch-and-set?) */</comment>
		<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEVAL</name></cpp:undef>

	<comment type="block">/* apply bitwise op and set condition codes */</comment>
	<switch>switch <condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEVAL</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>i(dst_r, loc_r)</cpp:value></cpp:define>
	<case>case <expr><name>SLJIT_AND</name></expr>:</case>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
			<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>, <argument><expr><name>ngr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>SLJIT_OR</name></expr>:</case>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
			<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>, <argument><expr><name>or</name></expr></argument>, <argument><expr><name>ogr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<case>case <expr><name>SLJIT_XOR</name></expr>:</case>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
			<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>, <argument><expr><name>xr</name></expr></argument>, <argument><expr><name>xgr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEVAL</name></cpp:undef>
	</block_content>}</block></switch>

	<comment type="block">/* set zero flag if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_SET_Z</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_store_zero_flag</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>dst_r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* store result to memory if required */</comment>
	<comment type="block">/* TODO(carenas): s/FAIL_IF/ return */</comment>
	<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>store_word</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>op</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_cmov</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>type</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>dst_reg</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>srcw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_u8</name></type> <name>mask</name> <init>= <expr><call><name>get_cc</name><argument_list>(<argument><expr><name>type</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>dst_r</name> <init>= <expr><call><name>gpr</name><argument_list>(<argument><expr><name>dst_reg</name> <operator>&amp;</operator> <operator>~</operator><name>SLJIT_I32_OP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>src_r</name> <init>= <expr><ternary><condition><expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>gpr</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>tmp0</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_emit_cmov</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>dst_reg</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>mask</name> <operator>!=</operator> <literal type="number">0xf</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_load_cc</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;</operator> <name>SLJIT_IMM</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* TODO(mundaym): fast path with lscond2 */</comment>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>push_load_imm_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>src_r</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEVAL</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>i(dst_r, src_r, mask)</cpp:value></cpp:define>
	<if_stmt><if>if <condition>(<expr><call><name>have_lscond1</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
			<argument><expr><call><name>WHEN2</name><argument_list>(<argument><expr><name>dst_reg</name> <operator>&amp;</operator> <name>SLJIT_I32_OP</name></expr></argument>, <argument><expr><name>locr</name></expr></argument>, <argument><expr><name>locgr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEVAL</name></cpp:undef>

	<comment type="block">/* TODO(mundaym): implement */</comment>
	<return>return <expr><name>SLJIT_ERR_UNSUPPORTED</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------- */</comment>
<comment type="block">/*  Other instructions                                                   */</comment>
<comment type="block">/* --------------------------------------------------------------------- */</comment>

<comment type="block">/* On s390x we build a literal pool to hold constants. This has two main
   advantages:

     1. we only need one instruction in the instruction stream (LGRL)
     2. we can store 64 bit addresses and use 32 bit offsets

   To retrofit the extra information needed to build the literal pool we
   add a new sljit_s390x_const struct that contains the initial value but
   can still be cast to a sljit_const. */</comment>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name><name>struct</name> <name>sljit_const</name></name><modifier>*</modifier></type> <name>sljit_emit_const</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>dstw</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>init_value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>sljit_s390x_const</name></name> <modifier>*</modifier></type><name>const_</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>dst_r</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR_PTR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_PTR</name><argument_list>(<argument><expr><call><name>check_sljit_emit_const</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><name>init_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>const_</name> <operator>=</operator> <operator>(</operator>struct <name>sljit_s390x_const</name><operator>*</operator><operator>)</operator><call><name>ensure_abuf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>,
					<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sljit_s390x_const</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>const_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_const</name><argument_list>(<argument><expr><operator>(</operator>struct <name>sljit_const</name><operator>*</operator><operator>)</operator><name>const_</name></expr></argument>, <argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>const_</name><operator>-&gt;</operator><name>init_value</name></name> <operator>=</operator> <name>init_value</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>dst_r</name> <operator>=</operator> <ternary><condition><expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>gpr</name><argument_list>(<argument><expr><name>dst</name> <operator>&amp;</operator> <name>REG_MASK</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>tmp0</name></expr></else></ternary></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>have_genext</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>sljit_ins_const</name> <operator>|</operator> <call><name>lgrl</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else <block>{<block_content>
		<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>sljit_ins_const</name> <operator>|</operator> <call><name>larl</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lg</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>r0</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><call><name>store_word</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> <comment type="block">/* always 64-bit */</comment>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator>struct <name>sljit_const</name><operator>*</operator><operator>)</operator><name>const_</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>void</name></type> <name>sljit_set_jump_addr</name><parameter_list>(<parameter><decl><type><name>sljit_uw</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>sljit_uw</name></type> <name>new_target</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>executable_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Update the constant pool. */</comment>
	<decl_stmt><decl><type><name>sljit_uw</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><operator>(</operator><name>sljit_uw</name> <operator>*</operator><operator>)</operator><name>addr</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SLJIT_UNUSED_ARG</name><argument_list>(<argument><expr><name>executable_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SLJIT_UPDATE_WX_FLAGS</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>new_target</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SLJIT_UPDATE_WX_FLAGS</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SLJIT_CACHE_FLUSH</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>void</name></type> <name>sljit_set_const</name><parameter_list>(<parameter><decl><type><name>sljit_uw</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>new_constant</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>executable_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>sljit_set_jump_addr</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>new_constant</name></expr></argument>, <argument><expr><name>executable_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name><name>struct</name> <name>sljit_put_label</name></name> <modifier>*</modifier></type><name>sljit_emit_put_label</name><parameter_list>(
	<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>dstw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>sljit_put_label</name></name> <modifier>*</modifier></type><name>put_label</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_gpr</name></type> <name>dst_r</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR_PTR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_PTR</name><argument_list>(<argument><expr><call><name>check_sljit_emit_put_label</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADJUST_LOCAL_OFFSET</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>put_label</name> <operator>=</operator> <operator>(</operator>struct <name>sljit_put_label</name><operator>*</operator><operator>)</operator><call><name>ensure_abuf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sljit_put_label</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>put_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_put_label</name><argument_list>(<argument><expr><name>put_label</name></expr></argument>, <argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>dst_r</name> <operator>=</operator> <ternary><condition><expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>gpr</name><argument_list>(<argument><expr><name>dst</name> <operator>&amp;</operator> <name>REG_MASK</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>tmp0</name></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>have_genext</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lgrl</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else <block>{<block_content>
		<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>larl</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><call><name>push_inst</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>lg</name><argument_list>(<argument><expr><name>dst_r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>r0</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><call><name>store_word</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>dst_r</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>put_label</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* TODO(carenas): EVAL probably should move up or be refactored */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>WHEN2</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>EVAL</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>tmp1</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>tmp0</name></cpp:undef>

<comment type="block">/* TODO(carenas): undef other macros that spill like is_u12? */</comment>
</unit>
