<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/pcre2/src/sljit/sljitNativeX86_64.c"><comment type="block">/*
 *    Stack-less Just-In-Time compiler
 *
 *    Copyright Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *   1. Redistributions of source code must retain the above copyright notice, this list of
 *      conditions and the following disclaimer.
 *
 *   2. Redistributions in binary form must reproduce the above copyright notice, this list
 *      of conditions and the following disclaimer in the documentation and/or other materials
 *      provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */</comment>

<comment type="block">/* x86 64-bit arch dependent functions. */</comment>

<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>emit_load_imm64</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>imm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>inst</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>REX_W</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>reg_map</name><index>[<expr><name>reg</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="number">7</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>REX_B</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>MOV_r_i32</name> <operator>+</operator> <operator>(</operator><name><name>reg_map</name><index>[<expr><name>reg</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sljit_unaligned_store_sw</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>imm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sljit_u8</name><modifier>*</modifier></type> <name>generate_far_jump_code</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl></parameter>, <parameter><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>code_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>type</name> <init>= <expr><name><name>jump</name><operator>-&gt;</operator><name>flags</name></name> <operator>&gt;&gt;</operator> <name>TYPE_SHIFT</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>short_addr</name> <init>= <expr><operator>!</operator><operator>(</operator><name><name>jump</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SLJIT_REWRITABLE_JUMP</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>jump</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JUMP_LABEL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>jump</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>target</name></name> <operator>&lt;=</operator> <literal type="number">0xffffffff</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="block">/* The relative jump below specialized for this case. */</comment>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>reg_map</name><index>[<expr><name>TMP_REG2</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&lt;</operator> <name>SLJIT_JUMP</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Invert type. */</comment>
		<expr_stmt><expr><operator>*</operator><name>code_ptr</name><operator>++</operator> <operator>=</operator> <call><name>get_jump_code</name><argument_list>(<argument><expr><name>type</name> <operator>^</operator> <literal type="number">0x1</literal></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">0x10</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>code_ptr</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><name>short_addr</name></expr> ?</condition><then> <expr><operator>(</operator><literal type="number">6</literal> <operator>+</operator> <literal type="number">3</literal><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><literal type="number">10</literal> <operator>+</operator> <literal type="number">3</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>code_ptr</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><name>short_addr</name></expr> ?</condition><then> <expr><name>REX_B</name></expr> </then><else>: <expr><operator>(</operator><name>REX_W</name> <operator>|</operator> <name>REX_B</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>code_ptr</name><operator>++</operator> <operator>=</operator> <name>MOV_r_i32</name> <operator>|</operator> <name><name>reg_lmap</name><index>[<expr><name>TMP_REG2</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jump</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <operator>(</operator><name>sljit_uw</name><operator>)</operator><name>code_ptr</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>jump</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>JUMP_LABEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>jump</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PATCH_MD</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>short_addr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>sljit_unaligned_store_s32</name><argument_list>(<argument><expr><name>code_ptr</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_s32</name><operator>)</operator><name><name>jump</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>sljit_unaligned_store_sw</name><argument_list>(<argument><expr><name>code_ptr</name></expr></argument>, <argument><expr><name><name>jump</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>code_ptr</name> <operator>+=</operator> <ternary><condition><expr><name>short_addr</name></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_s32</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>code_ptr</name><operator>++</operator> <operator>=</operator> <name>REX_B</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>code_ptr</name><operator>++</operator> <operator>=</operator> <name>GROUP_FF</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>code_ptr</name><operator>++</operator> <operator>=</operator> <name>MOD_REG</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>type</name> <operator>&gt;=</operator> <name>SLJIT_FAST_CALL</name></expr> ?</condition><then> <expr><name>CALL_rm</name></expr> </then><else>: <expr><name>JMP_rm</name></expr></else></ternary><operator>)</operator> <operator>|</operator> <name><name>reg_lmap</name><index>[<expr><name>TMP_REG2</name></expr>]</index></name></expr>;</expr_stmt>

	<return>return <expr><name>code_ptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sljit_u8</name><modifier>*</modifier></type> <name>generate_put_label_code</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_put_label</name></name> <modifier>*</modifier></type><name>put_label</name></decl></parameter>, <parameter><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>code_ptr</name></decl></parameter>, <parameter><decl><type><name>sljit_uw</name></type> <name>max_label</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>max_label</name> <operator>&gt;</operator> <name>HALFWORD_MAX</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>put_label</name><operator>-&gt;</operator><name>addr</name></name> <operator>-=</operator> <name><name>put_label</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>put_label</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>PATCH_MD</name></expr>;</expr_stmt>
		<return>return <expr><name>code_ptr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>put_label</name><operator>-&gt;</operator><name>flags</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Destination is register. */</comment>
		<expr_stmt><expr><name>code_ptr</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><name><name>put_label</name><operator>-&gt;</operator><name>addr</name></name> <operator>-</operator> <literal type="number">2</literal> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_uw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name><name>code_ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xf8</literal><operator>)</operator> <operator>==</operator> <name>REX_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name><name>code_ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xf8</literal><operator>)</operator> <operator>==</operator> <name>MOV_r_i32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>code_ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x07</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>code_ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>)</operator><operator>(</operator><name><name>code_ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0x08</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>code_ptr</name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_s32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else <block>{<block_content>
			<expr_stmt><expr><name><name>code_ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>code_ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>code_ptr</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_s32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>put_label</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <operator>(</operator><name>sljit_uw</name><operator>)</operator><name>code_ptr</name></expr>;</expr_stmt>
		<return>return <expr><name>code_ptr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>code_ptr</name> <operator>-=</operator> <name><name>put_label</name><operator>-&gt;</operator><name>flags</name></name> <operator>+</operator> <operator>(</operator><literal type="number">2</literal> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_uw</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SLJIT_MEMMOVE</name><argument_list>(<argument><expr><name>code_ptr</name></expr></argument>, <argument><expr><name>code_ptr</name> <operator>+</operator> <operator>(</operator><literal type="number">2</literal> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_uw</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>, <argument><expr><name><name>put_label</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name><name>code_ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xf8</literal><operator>)</operator> <operator>==</operator> <name>REX_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>code_ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xf8</literal><operator>)</operator> <operator>==</operator> <name>MOV_r_i32</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>code_ptr</name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_uw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name><name>code_ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xf8</literal><operator>)</operator> <operator>==</operator> <name>REX_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>code_ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>MOV_rm_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>code_ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>)</operator><operator>(</operator><name><name>code_ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0x4</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>code_ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>MOV_rm_i32</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>code_ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>)</operator><operator>(</operator><name><name>code_ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><literal type="number">0x7</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>code_ptr</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>put_label</name><operator>-&gt;</operator><name>addr</name></name> <operator>-</operator> <operator>(</operator><literal type="number">2</literal> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_uw</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_s32</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>put_label</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <operator>(</operator><name>sljit_uw</name><operator>)</operator><name>code_ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>put_label</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>code_ptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_enter</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>arg_types</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>scratches</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>saveds</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>fscratches</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>fsaveds</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>local_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>args</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>saved_register_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>inst</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_emit_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>scratches</name></expr></argument>, <argument><expr><name>saveds</name></expr></argument>, <argument><expr><name>fscratches</name></expr></argument>, <argument><expr><name>fsaveds</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_emit_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>scratches</name></expr></argument>, <argument><expr><name>saveds</name></expr></argument>, <argument><expr><name>fscratches</name></expr></argument>, <argument><expr><name>fsaveds</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Emit ENDBR64 at function entry if needed.  */</comment>
	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_endbranch</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>mode32</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN64</name></cpp:ifdef>
	<comment type="block">/* Two/four register slots for parameters plus space for xmm6 register if needed. */</comment>
	<if_stmt><if>if <condition>(<expr><name>fscratches</name> <operator>&gt;=</operator> <literal type="number">6</literal> <operator>||</operator> <name>fsaveds</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>locals_offset</name></name> <operator>=</operator> <literal type="number">6</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>locals_offset</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>scratches</name> <operator>&gt;</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Including the return address saved by the call instruction. */</comment>
	<expr_stmt><expr><name>saved_register_size</name> <operator>=</operator> <call><name>GET_SAVED_REGISTERS_SIZE</name><argument_list>(<argument><expr><name>scratches</name></expr></argument>, <argument><expr><name>saveds</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <ternary><condition><expr><name>saveds</name> <operator>&lt;</operator> <name>SLJIT_NUMBER_OF_SAVED_REGISTERS</name></expr> ?</condition><then> <expr><operator>(</operator><name>SLJIT_S0</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>saveds</name><operator>)</operator></expr> </then><else>: <expr><name>SLJIT_FIRST_SAVED_REG</name></expr></else></ternary></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>SLJIT_S0</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <name>tmp</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <ternary><condition><expr><name><name>reg_map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">8</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>reg_map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>REX_B</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PUSH_REG</name><argument_list>(<argument><expr><name><name>reg_lmap</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>scratches</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <name>SLJIT_FIRST_SAVED_REG</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <ternary><condition><expr><name><name>reg_map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">8</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>reg_map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>REX_B</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>PUSH_REG</name><argument_list>(<argument><expr><name><name>reg_lmap</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>get_arg_count</name><argument_list>(<argument><expr><name>arg_types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>args</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <name>args</name> <operator>*</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN64</name></cpp:ifndef>
		<if_stmt><if>if <condition>(<expr><name>args</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>REX_W</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>MOV_r_rm</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>MOD_REG</name> <operator>|</operator> <operator>(</operator><name><name>reg_map</name><index>[<expr><name>SLJIT_S0</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x7</literal></expr> <comment type="block">/* rdi */</comment>;</expr_stmt>
			<expr_stmt><expr><name>inst</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>args</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>REX_W</name> <operator>|</operator> <name>REX_R</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>MOV_r_rm</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>MOD_REG</name> <operator>|</operator> <operator>(</operator><name><name>reg_lmap</name><index>[<expr><name>SLJIT_S1</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x6</literal></expr> <comment type="block">/* rsi */</comment>;</expr_stmt>
			<expr_stmt><expr><name>inst</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>args</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>REX_W</name> <operator>|</operator> <name>REX_R</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>MOV_r_rm</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>MOD_REG</name> <operator>|</operator> <operator>(</operator><name><name>reg_lmap</name><index>[<expr><name>SLJIT_S2</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x2</literal></expr> <comment type="block">/* rdx */</comment>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<if_stmt><if>if <condition>(<expr><name>args</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>REX_W</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>MOV_r_rm</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>MOD_REG</name> <operator>|</operator> <operator>(</operator><name><name>reg_map</name><index>[<expr><name>SLJIT_S0</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x1</literal></expr> <comment type="block">/* rcx */</comment>;</expr_stmt>
			<expr_stmt><expr><name>inst</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>args</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>REX_W</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>MOV_r_rm</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>MOD_REG</name> <operator>|</operator> <operator>(</operator><name><name>reg_map</name><index>[<expr><name>SLJIT_S1</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x2</literal></expr> <comment type="block">/* rdx */</comment>;</expr_stmt>
			<expr_stmt><expr><name>inst</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>args</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>REX_W</name> <operator>|</operator> <name>REX_B</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>MOV_r_rm</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>MOD_REG</name> <operator>|</operator> <operator>(</operator><name><name>reg_map</name><index>[<expr><name>SLJIT_S2</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x0</literal></expr> <comment type="block">/* r8 */</comment>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>local_size</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>local_size</name> <operator>+</operator> <name>SLJIT_LOCALS_OFFSET</name> <operator>+</operator> <name>saved_register_size</name> <operator>+</operator> <literal type="number">15</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">15</literal><operator>)</operator> <operator>-</operator> <name>saved_register_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name> <operator>=</operator> <name>local_size</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN64</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>local_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>local_size</name> <operator>&lt;=</operator> <literal type="number">4</literal> <operator>*</operator> <literal type="number">4096</literal></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>local_size</name> <operator>&gt;</operator> <literal type="number">4096</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">4096</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>local_size</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>*</operator> <literal type="number">4096</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">4096</literal> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>local_size</name> <operator>&gt;</operator> <literal type="number">3</literal> <operator>*</operator> <literal type="number">4096</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">4096</literal> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else <block>{<block_content>
			<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>local_size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SLJIT_ASSERT</name> <argument_list>(<argument><expr><name><name>reg_map</name><index>[<expr><name>SLJIT_R0</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_R0</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">4096</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_non_cum_binary</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>BINARY_OPCODE</name><argument_list>(<argument><expr><name>SUB</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">4096</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_non_cum_binary</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>BINARY_OPCODE</name><argument_list>(<argument><expr><name>SUB</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>JNE_i8</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inst</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>sljit_s8</name><operator>)</operator> <operator>-</operator><literal type="number">19</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><name>local_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>local_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_non_cum_binary</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>BINARY_OPCODE</name><argument_list>(<argument><expr><name>SUB</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN64</name></cpp:ifdef>
	<comment type="block">/* Save xmm6 register: movaps [rsp + 0x20], xmm6 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fscratches</name> <operator>&gt;=</operator> <literal type="number">6</literal> <operator>||</operator> <name>fsaveds</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>GROUP_0F</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sljit_unaligned_store_s32</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><literal type="number">0x20247429</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_set_context</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>arg_types</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>scratches</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>saveds</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>fscratches</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>fsaveds</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>local_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>saved_register_size</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_set_context</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>scratches</name></expr></argument>, <argument><expr><name>saveds</name></expr></argument>, <argument><expr><name>fscratches</name></expr></argument>, <argument><expr><name>fsaveds</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_set_context</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>scratches</name></expr></argument>, <argument><expr><name>saveds</name></expr></argument>, <argument><expr><name>fscratches</name></expr></argument>, <argument><expr><name>fsaveds</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN64</name></cpp:ifdef>
	<comment type="block">/* Two/four register slots for parameters plus space for xmm6 register if needed. */</comment>
	<if_stmt><if>if <condition>(<expr><name>fscratches</name> <operator>&gt;=</operator> <literal type="number">6</literal> <operator>||</operator> <name>fsaveds</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>locals_offset</name></name> <operator>=</operator> <literal type="number">6</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>locals_offset</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>scratches</name> <operator>&gt;</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Including the return address saved by the call instruction. */</comment>
	<expr_stmt><expr><name>saved_register_size</name> <operator>=</operator> <call><name>GET_SAVED_REGISTERS_SIZE</name><argument_list>(<argument><expr><name>scratches</name></expr></argument>, <argument><expr><name>saveds</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>local_size</name> <operator>+</operator> <name>SLJIT_LOCALS_OFFSET</name> <operator>+</operator> <name>saved_register_size</name> <operator>+</operator> <literal type="number">15</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">15</literal><operator>)</operator> <operator>-</operator> <name>saved_register_size</name></expr>;</expr_stmt>
	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_return</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>srcw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>inst</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_emit_return</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_mov_before_return</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_WIN64</name></cpp:ifdef>
	<comment type="block">/* Restore xmm6 register: movaps xmm6, [rsp + 0x20] */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>compiler</name><operator>-&gt;</operator><name>fscratches</name></name> <operator>&gt;=</operator> <literal type="number">6</literal> <operator>||</operator> <name><name>compiler</name><operator>-&gt;</operator><name>fsaveds</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>GROUP_0F</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sljit_unaligned_store_s32</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><literal type="number">0x20247428</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name> <operator>&lt;=</operator> <literal type="number">127</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>REX_W</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>GROUP_BINARY_83</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>MOD_REG</name> <operator>|</operator> <name>ADD</name> <operator>|</operator> <literal type="number">4</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>inst</name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else <block>{<block_content>
			<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>REX_W</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>GROUP_BINARY_81</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>MOD_REG</name> <operator>|</operator> <name>ADD</name> <operator>|</operator> <literal type="number">4</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sljit_unaligned_store_s32</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>scratches</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>SLJIT_FIRST_SAVED_REG</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>tmp</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <ternary><condition><expr><name><name>reg_map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">8</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>reg_map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>REX_B</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>POP_REG</name><argument_list>(<argument><expr><name><name>reg_lmap</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <ternary><condition><expr><name><name>compiler</name><operator>-&gt;</operator><name>saveds</name></name> <operator>&lt;</operator> <name>SLJIT_NUMBER_OF_SAVED_REGISTERS</name></expr> ?</condition><then> <expr><operator>(</operator><name>SLJIT_S0</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name><name>compiler</name><operator>-&gt;</operator><name>saveds</name></name><operator>)</operator></expr> </then><else>: <expr><name>SLJIT_FIRST_SAVED_REG</name></expr></else></ternary></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>tmp</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>SLJIT_S0</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <ternary><condition><expr><name><name>reg_map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">8</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>reg_map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>REX_B</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>POP_REG</name><argument_list>(<argument><expr><name><name>reg_lmap</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RET</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------- */</comment>
<comment type="block">/*  Operators                                                            */</comment>
<comment type="block">/* --------------------------------------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>emit_do_imm32</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_u8</name></type> <name>rex</name></decl></parameter>, <parameter><decl><type><name>sljit_u8</name></type> <name>opcode</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>imm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>inst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>length</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>rex</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_s32</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rex</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>rex</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>opcode</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sljit_unaligned_store_s32</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>imm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sljit_u8</name><modifier>*</modifier></type> <name>emit_x86_instruction</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>size</name></decl></parameter>,
	<comment type="block">/* The register or immediate operand. */</comment>
	<parameter><decl><type><name>sljit_s32</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>imma</name></decl></parameter>,
	<comment type="block">/* The general operand (not immediate). */</comment>
	<parameter><decl><type><name>sljit_s32</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>immb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>inst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>buf_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_u8</name></type> <name>rex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>flags</name> <init>= <expr><name>size</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0xf</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>inst_size</name></decl>;</decl_stmt>

	<comment type="block">/* The immediate operand must be 32 bit. */</comment>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>a</name> <operator>&amp;</operator> <name>SLJIT_IMM</name><operator>)</operator> <operator>||</operator> <name><name>compiler</name><operator>-&gt;</operator><name>mode32</name></name> <operator>||</operator> <call><name>IS_HALFWORD</name><argument_list>(<argument><expr><name>imma</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Both cannot be switched on. */</comment>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>EX86_BIN_INS</name> <operator>|</operator> <name>EX86_SHIFT_INS</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>EX86_BIN_INS</name> <operator>|</operator> <name>EX86_SHIFT_INS</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Size flags not allowed for typed instructions. */</comment>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>EX86_BIN_INS</name> <operator>|</operator> <name>EX86_SHIFT_INS</name><operator>)</operator><operator>)</operator> <operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>EX86_BYTE_ARG</name> <operator>|</operator> <name>EX86_HALF_ARG</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Both size flags cannot be switched on. */</comment>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>EX86_BYTE_ARG</name> <operator>|</operator> <name>EX86_HALF_ARG</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>EX86_BYTE_ARG</name> <operator>|</operator> <name>EX86_HALF_ARG</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* SSE2 and immediate is not possible. */</comment>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>a</name> <operator>&amp;</operator> <name>SLJIT_IMM</name><operator>)</operator> <operator>||</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_SSE2</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>EX86_PREF_F2</name> <operator>|</operator> <name>EX86_PREF_F3</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>EX86_PREF_F2</name> <operator>|</operator> <name>EX86_PREF_F3</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>EX86_PREF_F2</name> <operator>|</operator> <name>EX86_PREF_66</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>EX86_PREF_F2</name> <operator>|</operator> <name>EX86_PREF_66</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>EX86_PREF_F3</name> <operator>|</operator> <name>EX86_PREF_66</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>EX86_PREF_F3</name> <operator>|</operator> <name>EX86_PREF_66</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>&amp;=</operator> <literal type="number">0xf</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>inst_size</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>compiler</name><operator>-&gt;</operator><name>mode32</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_NO_REXW</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rex</name> <operator>|=</operator> <name>REX_W</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_REX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rex</name> <operator>|=</operator> <name>REX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>EX86_PREF_F2</name> <operator>|</operator> <name>EX86_PREF_F3</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>inst_size</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_PREF_66</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>inst_size</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Calculate size of b. */</comment>
	<expr_stmt><expr><name>inst_size</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* mod r/m byte. */</comment>
	<if_stmt><if>if <condition>(<expr><name>b</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>b</name> <operator>&amp;</operator> <name>OFFS_REG_MASK</name><operator>)</operator></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>NOT_HALFWORD</name><argument_list>(<argument><expr><name>immb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_load_imm64</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG2</name></expr></argument>, <argument><expr><name>immb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>immb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>b</name> <operator>&amp;</operator> <name>REG_MASK</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>b</name> <operator>|=</operator> <call><name>TO_OFFS_REG</name><argument_list>(<argument><expr><name>TMP_REG2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>b</name> <operator>|=</operator> <name>TMP_REG2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>reg_lmap</name><index>[<expr><name>b</name> <operator>&amp;</operator> <name>REG_MASK</name></expr>]</index></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>b</name> <operator>|=</operator> <call><name>TO_OFFS_REG</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>b</name> <operator>&amp;</operator> <name>REG_MASK</name><operator>)</operator> <operator>==</operator> <name>SLJIT_UNUSED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>inst_size</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_s32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* SIB byte required to avoid RIP based addressing. */</comment>
		<else>else <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>reg_map</name><index>[<expr><name>b</name> <operator>&amp;</operator> <name>REG_MASK</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rex</name> <operator>|=</operator> <name>REX_B</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>immb</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><operator>(</operator><name>b</name> <operator>&amp;</operator> <name>OFFS_REG_MASK</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>b</name> <operator>&amp;</operator> <name>OFFS_REG_MASK</name><operator>)</operator> <operator>==</operator> <call><name>TO_OFFS_REG</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
				<comment type="block">/* Immediate operand. */</comment>
				<if_stmt><if>if <condition>(<expr><name>immb</name> <operator>&lt;=</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <name>immb</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>inst_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_s8</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>inst_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_s32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>reg_lmap</name><index>[<expr><name>b</name> <operator>&amp;</operator> <name>REG_MASK</name></expr>]</index></name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>inst_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_s8</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>b</name> <operator>&amp;</operator> <name>OFFS_REG_MASK</name><operator>)</operator> <operator>!=</operator> <name>SLJIT_UNUSED</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>inst_size</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* SIB byte. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>reg_map</name><index>[<expr><call><name>OFFS_REG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rex</name> <operator>|=</operator> <name>REX_X</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_SSE2_OP2</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>reg_map</name><index>[<expr><name>b</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rex</name> <operator>|=</operator> <name>REX_B</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>freg_map</name><index>[<expr><name>b</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rex</name> <operator>|=</operator> <name>REX_B</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&amp;</operator> <name>SLJIT_IMM</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_BIN_INS</name></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>imma</name> <operator>&lt;=</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <name>imma</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">128</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>inst_size</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EX86_BYTE_ARG</name></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>inst_size</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_SHIFT_INS</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>imma</name> <operator>&amp;=</operator> <ternary><condition><expr><name><name>compiler</name><operator>-&gt;</operator><name>mode32</name></name></expr> ?</condition><then> <expr><literal type="number">0x1f</literal></expr> </then><else>: <expr><literal type="number">0x3f</literal></expr></else></ternary></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>imma</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>inst_size</name> <operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EX86_BYTE_ARG</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_BYTE_ARG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>inst_size</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_HALF_ARG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>inst_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>short</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>inst_size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_s32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else <block>{<block_content>
		<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_SHIFT_INS</name><operator>)</operator> <operator>||</operator> <name>a</name> <operator>==</operator> <name>SLJIT_PREF_SHIFT_REG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* reg_map[SLJIT_PREF_SHIFT_REG] is less than 8. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_SSE2_OP1</name><operator>)</operator></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>reg_map</name><index>[<expr><name>a</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rex</name> <operator>|=</operator> <name>REX_R</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>freg_map</name><index>[<expr><name>a</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rex</name> <operator>|=</operator> <name>REX_R</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rex</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>inst_size</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>inst_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Encoding the byte. */</comment>
	<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><name>inst_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_PREF_F2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <literal type="number">0xf2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_PREF_F3</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <literal type="number">0xf3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_PREF_66</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <literal type="number">0x66</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>rex</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>rex</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>buf_ptr</name> <operator>=</operator> <name>inst</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>

	<comment type="block">/* Encode mod/rm byte. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_SHIFT_INS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_BIN_INS</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>a</name> <operator>&amp;</operator> <name>SLJIT_IMM</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>inst</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_BYTE_ARG</name><operator>)</operator></expr> ?</condition><then> <expr><name>GROUP_BINARY_83</name></expr> </then><else>: <expr><name>GROUP_BINARY_81</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&amp;</operator> <name>SLJIT_IMM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>buf_ptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_SSE2_OP1</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>buf_ptr</name> <operator>=</operator> <name><name>reg_lmap</name><index>[<expr><name>a</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>buf_ptr</name> <operator>=</operator> <name><name>freg_lmap</name><index>[<expr><name>a</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&amp;</operator> <name>SLJIT_IMM</name></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>imma</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>inst</name> <operator>=</operator> <name>GROUP_SHIFT_1</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>inst</name> <operator>=</operator> <name>GROUP_SHIFT_N</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>inst</name> <operator>=</operator> <name>GROUP_SHIFT_CL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>buf_ptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>b</name> <operator>&amp;</operator> <name>SLJIT_MEM</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>buf_ptr</name><operator>++</operator> <operator>|=</operator> <name>MOD_REG</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_SSE2_OP2</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><name><name>reg_lmap</name><index>[<expr><name>b</name></expr>]</index></name></expr> </then><else>: <expr><name><name>freg_lmap</name><index>[<expr><name>b</name></expr>]</index></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>b</name> <operator>&amp;</operator> <name>REG_MASK</name><operator>)</operator> <operator>!=</operator> <name>SLJIT_UNUSED</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>b</name> <operator>&amp;</operator> <name>OFFS_REG_MASK</name><operator>)</operator> <operator>==</operator> <name>SLJIT_UNUSED</name> <operator>||</operator> <operator>(</operator><name>b</name> <operator>&amp;</operator> <name>OFFS_REG_MASK</name><operator>)</operator> <operator>==</operator> <call><name>TO_OFFS_REG</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>immb</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>reg_lmap</name><index>[<expr><name>b</name> <operator>&amp;</operator> <name>REG_MASK</name></expr>]</index></name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>immb</name> <operator>&lt;=</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <name>immb</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>buf_ptr</name> <operator>|=</operator> <literal type="number">0x40</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>buf_ptr</name> <operator>|=</operator> <literal type="number">0x80</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>b</name> <operator>&amp;</operator> <name>OFFS_REG_MASK</name><operator>)</operator> <operator>==</operator> <name>SLJIT_UNUSED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>buf_ptr</name><operator>++</operator> <operator>|=</operator> <name><name>reg_lmap</name><index>[<expr><name>b</name> <operator>&amp;</operator> <name>REG_MASK</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<else>else <block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>buf_ptr</name><operator>++</operator> <operator>|=</operator> <literal type="number">0x04</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>buf_ptr</name><operator>++</operator> <operator>=</operator> <name><name>reg_lmap</name><index>[<expr><name>b</name> <operator>&amp;</operator> <name>REG_MASK</name></expr>]</index></name> <operator>|</operator> <operator>(</operator><name><name>reg_lmap</name><index>[<expr><call><name>OFFS_REG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>immb</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>reg_lmap</name><index>[<expr><name>b</name> <operator>&amp;</operator> <name>REG_MASK</name></expr>]</index></name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>immb</name> <operator>&lt;=</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <name>immb</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>buf_ptr</name><operator>++</operator> <operator>=</operator> <name>immb</name></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* 8 bit displacement. */</comment>
				<else>else <block>{<block_content>
					<expr_stmt><expr><call><name>sljit_unaligned_store_s32</name><argument_list>(<argument><expr><name>buf_ptr</name></expr></argument>, <argument><expr><name>immb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 32 bit displacement. */</comment>
					<expr_stmt><expr><name>buf_ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_s32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>reg_lmap</name><index>[<expr><name>b</name> <operator>&amp;</operator> <name>REG_MASK</name></expr>]</index></name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>buf_ptr</name> <operator>|=</operator> <literal type="number">0x40</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>buf_ptr</name><operator>++</operator> <operator>|=</operator> <literal type="number">0x04</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>buf_ptr</name><operator>++</operator> <operator>=</operator> <name><name>reg_lmap</name><index>[<expr><name>b</name> <operator>&amp;</operator> <name>REG_MASK</name></expr>]</index></name> <operator>|</operator> <operator>(</operator><name><name>reg_lmap</name><index>[<expr><call><name>OFFS_REG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>immb</name> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>reg_lmap</name><index>[<expr><name>b</name> <operator>&amp;</operator> <name>REG_MASK</name></expr>]</index></name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>buf_ptr</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>buf_ptr</name><operator>++</operator> <operator>|=</operator> <literal type="number">0x04</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>buf_ptr</name><operator>++</operator> <operator>=</operator> <literal type="number">0x25</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sljit_unaligned_store_s32</name><argument_list>(<argument><expr><name>buf_ptr</name></expr></argument>, <argument><expr><name>immb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 32 bit displacement. */</comment>
		<expr_stmt><expr><name>buf_ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_s32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&amp;</operator> <name>SLJIT_IMM</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_BYTE_ARG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>buf_ptr</name> <operator>=</operator> <name>imma</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EX86_HALF_ARG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>sljit_unaligned_store_s16</name><argument_list>(<argument><expr><name>buf_ptr</name></expr></argument>, <argument><expr><name>imma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_SHIFT_INS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>sljit_unaligned_store_s32</name><argument_list>(<argument><expr><name>buf_ptr</name></expr></argument>, <argument><expr><name>imma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><ternary><condition><expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>EX86_SHIFT_INS</name><operator>)</operator></expr> ?</condition><then> <expr><name>inst</name></expr> </then><else>: <expr><operator>(</operator><name>inst</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------- */</comment>
<comment type="block">/*  Call / return instructions                                           */</comment>
<comment type="block">/* --------------------------------------------------------------------- */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN64</name></cpp:ifndef>

<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>call_with_args</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>arg_types</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name> <modifier>*</modifier></type><name>src_ptr</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>srcw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>src</name> <init>= <expr><ternary><condition><expr><name>src_ptr</name></expr> ?</condition><then> <expr><operator>(</operator><operator>*</operator><name>src_ptr</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>word_arg_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>reg_map</name><index>[<expr><name>SLJIT_R1</name></expr>]</index></name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <name><name>reg_map</name><index>[<expr><name>SLJIT_R3</name></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>reg_map</name><index>[<expr><name>TMP_REG1</name></expr>]</index></name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>mode32</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Remove return value. */</comment>
	<expr_stmt><expr><name>arg_types</name> <operator>&gt;&gt;=</operator> <name>SLJIT_DEF_SHIFT</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>arg_types</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>arg_types</name> <operator>&amp;</operator> <name>SLJIT_DEF_MASK</name><operator>)</operator> <operator>&lt;</operator> <name>SLJIT_ARG_TYPE_F32</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>word_arg_count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>arg_types</name> <operator>&gt;&gt;=</operator> <name>SLJIT_DEF_SHIFT</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>word_arg_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ADJUST_LOCAL_OFFSET</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>src_ptr</name> <operator>=</operator> <name>TMP_REG2</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>src</name> <operator>==</operator> <name>SLJIT_R2</name> <operator>&amp;&amp;</operator> <name>word_arg_count</name> <operator>&gt;=</operator> <name>SLJIT_R2</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>src_ptr</name> <operator>=</operator> <name>TMP_REG1</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>word_arg_count</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><call><name>emit_mov</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>call_with_args</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>arg_types</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name> <modifier>*</modifier></type><name>src_ptr</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>srcw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>src</name> <init>= <expr><ternary><condition><expr><name>src_ptr</name></expr> ?</condition><then> <expr><operator>(</operator><operator>*</operator><name>src_ptr</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>arg_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>word_arg_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>float_arg_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>types</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>data_trandfer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>sljit_u8</name></type> <name><name>word_arg_regs</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><name>SLJIT_R3</name></expr>, <expr><name>SLJIT_R1</name></expr>, <expr><name>SLJIT_R2</name></expr>, <expr><name>TMP_REG1</name></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>reg_map</name><index>[<expr><name>SLJIT_R3</name></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>reg_map</name><index>[<expr><name>SLJIT_R1</name></expr>]</index></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>reg_map</name><index>[<expr><name>SLJIT_R2</name></expr>]</index></name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name><name>reg_map</name><index>[<expr><name>TMP_REG1</name></expr>]</index></name> <operator>==</operator> <literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>mode32</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>arg_types</name> <operator>&gt;&gt;=</operator> <name>SLJIT_DEF_SHIFT</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>arg_types</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>types</name> <operator>=</operator> <operator>(</operator><name>types</name> <operator>&lt;&lt;</operator> <name>SLJIT_DEF_SHIFT</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>arg_types</name> <operator>&amp;</operator> <name>SLJIT_DEF_MASK</name><operator>)</operator></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>arg_types</name> <operator>&amp;</operator> <name>SLJIT_DEF_MASK</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>SLJIT_ARG_TYPE_F32</name></expr>:</case>
		<case>case <expr><name>SLJIT_ARG_TYPE_F64</name></expr>:</case>
			<expr_stmt><expr><name>arg_count</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>float_arg_count</name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>arg_count</name> <operator>!=</operator> <name>float_arg_count</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>data_trandfer</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>arg_count</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>word_arg_count</name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>arg_count</name> <operator>!=</operator> <name>word_arg_count</name> <operator>||</operator> <name>arg_count</name> <operator>!=</operator> <name><name>word_arg_regs</name><index>[<expr><name>arg_count</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>data_trandfer</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>src</name> <operator>==</operator> <name><name>word_arg_regs</name><index>[<expr><name>arg_count</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>src_ptr</name> <operator>=</operator> <name>TMP_REG2</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></switch>

		<expr_stmt><expr><name>arg_types</name> <operator>&gt;&gt;=</operator> <name>SLJIT_DEF_SHIFT</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>data_trandfer</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ADJUST_LOCAL_OFFSET</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP_REG2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>src_ptr</name> <operator>=</operator> <name>TMP_REG2</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name>types</name></expr>)</condition> <block>{<block_content>
		<switch>switch <condition>(<expr><name>types</name> <operator>&amp;</operator> <name>SLJIT_DEF_MASK</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>SLJIT_ARG_TYPE_F32</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>arg_count</name> <operator>!=</operator> <name>float_arg_count</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_sse2_load</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>arg_count</name></expr></argument>, <argument><expr><name>float_arg_count</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>arg_count</name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>float_arg_count</name><operator>--</operator></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SLJIT_ARG_TYPE_F64</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>arg_count</name> <operator>!=</operator> <name>float_arg_count</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_sse2_load</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>arg_count</name></expr></argument>, <argument><expr><name>float_arg_count</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>arg_count</name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>float_arg_count</name><operator>--</operator></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<if_stmt><if>if <condition>(<expr><name>arg_count</name> <operator>!=</operator> <name>word_arg_count</name> <operator>||</operator> <name>arg_count</name> <operator>!=</operator> <name><name>word_arg_regs</name><index>[<expr><name>arg_count</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>EMIT_MOV</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name><name>word_arg_regs</name><index>[<expr><name>arg_count</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>word_arg_count</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>arg_count</name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>word_arg_count</name><operator>--</operator></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></switch>

		<expr_stmt><expr><name>types</name> <operator>&gt;&gt;=</operator> <name>SLJIT_DEF_SHIFT</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name><name>struct</name> <name>sljit_jump</name></name><modifier>*</modifier></type> <name>sljit_emit_call</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>type</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>arg_types</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CHECK_ERROR_PTR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_PTR</name><argument_list>(<argument><expr><call><name>check_sljit_emit_call</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PTR_FAIL_IF</name><argument_list>(<argument><expr><call><name>call_with_args</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>SLJIT_VERBOSE</name> <operator>&amp;&amp;</operator> <name>SLJIT_VERBOSE</name><operator>)</operator> \
		<operator>||</operator> <operator>(</operator><name>defined</name> <name>SLJIT_ARGUMENT_CHECKS</name> <operator>&amp;&amp;</operator> <name>SLJIT_ARGUMENT_CHECKS</name><operator>)</operator></expr></cpp:if>
	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>skip_checks</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><call><name>sljit_emit_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_icall</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>type</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>arg_types</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>srcw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_emit_icall</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>call_with_args</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>arg_types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>SLJIT_VERBOSE</name> <operator>&amp;&amp;</operator> <name>SLJIT_VERBOSE</name><operator>)</operator> \
		<operator>||</operator> <operator>(</operator><name>defined</name> <name>SLJIT_ARGUMENT_CHECKS</name> <operator>&amp;&amp;</operator> <name>SLJIT_ARGUMENT_CHECKS</name><operator>)</operator></expr></cpp:if>
	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>skip_checks</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><call><name>sljit_emit_ijump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SLJIT_API_FUNC_ATTRIBUTE</name> <name>sljit_s32</name></type> <name>sljit_emit_fast_enter</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>dstw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>inst</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_ERROR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>check_sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ADJUST_LOCAL_OFFSET</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* For UNUSED dst. Uncommon, but possible. */</comment>
	<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>==</operator> <name>SLJIT_UNUSED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dst</name> <operator>=</operator> <name>TMP_REG1</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>reg_map</name><index>[<expr><name>dst</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>POP_REG</name><argument_list>(<argument><expr><name><name>reg_lmap</name><index>[<expr><name>dst</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>REX_B</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POP_REG</name><argument_list>(<argument><expr><name><name>reg_lmap</name><index>[<expr><name>dst</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* REX_W is not necessary (src is not immediate). */</comment>
	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>mode32</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>inst</name> <operator>=</operator> <call><name>emit_x86_instruction</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>POP_rm</name></expr>;</expr_stmt>
	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>emit_fast_return</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>srcw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>inst</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>reg_map</name><index>[<expr><name>src</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PUSH_REG</name><argument_list>(<argument><expr><name><name>reg_lmap</name><index>[<expr><name>src</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else <block>{<block_content>
			<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>REX_B</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PUSH_REG</name><argument_list>(<argument><expr><name><name>reg_lmap</name><index>[<expr><name>src</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else <block>{<block_content>
		<comment type="block">/* REX_W is not necessary (src is not immediate). */</comment>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>mode32</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>inst</name> <operator>=</operator> <call><name>emit_x86_instruction</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>GROUP_FF</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>inst</name> <operator>|=</operator> <name>PUSH_rm</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><call><name>ensure_buf</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>INC_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>RET</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------- */</comment>
<comment type="block">/*  Extend input                                                         */</comment>
<comment type="block">/* --------------------------------------------------------------------- */</comment>

<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>emit_mov_int</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>sign</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>dstw</name></decl></parameter>,
	<parameter><decl><type><name>sljit_s32</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>srcw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_u8</name><modifier>*</modifier></type> <name>inst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>dst_r</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>mode32</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>==</operator> <name>SLJIT_UNUSED</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>src</name> <operator>&amp;</operator> <name>SLJIT_MEM</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* Empty instruction. */</comment>

	<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;</operator> <name>SLJIT_IMM</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>sign</name> <operator>||</operator> <operator>(</operator><operator>(</operator><name>sljit_uw</name><operator>)</operator><name>srcw</name> <operator>&lt;=</operator> <literal type="number">0x7fffffff</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>inst</name> <operator>=</operator> <call><name>emit_x86_instruction</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><name>sljit_s32</name><operator>)</operator><name>srcw</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>inst</name> <operator>=</operator> <name>MOV_rm_i32</name></expr>;</expr_stmt>
				<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><call><name>emit_load_imm64</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>mode32</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>inst</name> <operator>=</operator> <call><name>emit_x86_instruction</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><name>sljit_s32</name><operator>)</operator><name>srcw</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>inst</name> <operator>=</operator> <name>MOV_rm_i32</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>mode32</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>dst_r</name> <operator>=</operator> <ternary><condition><expr><call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>dst</name></expr> </then><else>: <expr><name>TMP_REG1</name></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dst</name> <operator>&amp;</operator> <name>SLJIT_MEM</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>FAST_IS_REG</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dst_r</name> <operator>=</operator> <name>src</name></expr>;</expr_stmt></block_content></block></if>
	<else>else <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>sign</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>inst</name> <operator>=</operator> <call><name>emit_x86_instruction</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>dst_r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>inst</name><operator>++</operator> <operator>=</operator> <name>MOVSXD_r_rm</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>mode32</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><call><name>emit_mov</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>dst_r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>mode32</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>&amp;</operator> <name>SLJIT_MEM</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>mode32</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>inst</name> <operator>=</operator> <call><name>emit_x86_instruction</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>dst_r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FAIL_IF</name><argument_list>(<argument><expr><operator>!</operator><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>inst</name> <operator>=</operator> <name>MOV_rm_r</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>compiler</name><operator>-&gt;</operator><name>mode32</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sljit_s32</name></type> <name>skip_frames_before_return</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sljit_s32</name></type> <name>tmp</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>

	<comment type="block">/* Don't adjust shadow stack if it isn't enabled.  */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cpu_has_shadow_stack</name> <argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SLJIT_SUCCESS</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>local_size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>compiler</name><operator>-&gt;</operator><name>scratches</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>&gt;=</operator> <name>SLJIT_FIRST_SAVED_REG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>+=</operator> <operator>(</operator><name>tmp</name> <operator>-</operator> <name>SLJIT_FIRST_SAVED_REG</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_uw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <ternary><condition><expr><name><name>compiler</name><operator>-&gt;</operator><name>saveds</name></name> <operator>&lt;</operator> <name>SLJIT_NUMBER_OF_SAVED_REGISTERS</name></expr> ?</condition><then> <expr><operator>(</operator><name>SLJIT_S0</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name><name>compiler</name><operator>-&gt;</operator><name>saveds</name></name><operator>)</operator></expr> </then><else>: <expr><name>SLJIT_FIRST_SAVED_REG</name></expr></else></ternary></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>SLJIT_S0</name> <operator>&gt;=</operator> <name>tmp</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>+=</operator> <operator>(</operator><name>SLJIT_S0</name> <operator>-</operator> <name>tmp</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_uw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>adjust_shadow_stack</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
