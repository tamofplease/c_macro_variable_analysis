<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/pcre2/src/pcre2_jit_compile.c"><comment type="block" format="doxygen">/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/</comment>

<comment type="block">/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
                    This module by Zoltan Herczeg
     Original API code Copyright (c) 1997-2012 University of Cambridge
          New API code Copyright (c) 2016-2019 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_internal.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_JIT</name></cpp:ifdef>

<comment type="block">/* All-in-one: Since we use the JIT compiler only from here,
we just include it. This way we don't need to touch the build
system files. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_CONFIG_AUTO</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_CONFIG_STATIC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_VERBOSE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PCRE2_DEBUG</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_DEBUG</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_DEBUG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_MALLOC</name><parameter_list>(<parameter><type><name>size</name></type></parameter>, <parameter><type><name>allocator_data</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_jit_malloc(size, allocator_data)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLJIT_FREE</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>allocator_data</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_jit_free(ptr, allocator_data)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type> <name>pcre2_jit_malloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>allocator_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcre2_memctl</name> <modifier>*</modifier></type><name>allocator</name> <init>= <expr><operator>(</operator><operator>(</operator><name>pcre2_memctl</name><operator>*</operator><operator>)</operator><name>allocator_data</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>allocator</name><operator>-&gt;</operator><name>malloc</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>allocator</name><operator>-&gt;</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>pcre2_jit_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>allocator_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcre2_memctl</name> <modifier>*</modifier></type><name>allocator</name> <init>= <expr><operator>(</operator><operator>(</operator><name>pcre2_memctl</name><operator>*</operator><operator>)</operator><name>allocator_data</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>allocator</name><operator>-&gt;</operator><name>free</name></name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>allocator</name><operator>-&gt;</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sljit/sljitLir.c"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SLJIT_CONFIG_UNSUPPORTED</name> <operator>&amp;&amp;</operator> <name>SLJIT_CONFIG_UNSUPPORTED</name></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> Unsupported architecture</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Defines for debugging purposes. */</comment>

<comment type="block">/* 1 - Use unoptimized capturing brackets.
   2 - Enable capture_last_ptr (includes option 1). */</comment>
<comment type="block">/* #define DEBUG_FORCE_UNOPTIMIZED_CBRAS 2 */</comment>

<comment type="block">/* 1 - Always have a control head. */</comment>
<comment type="block">/* #define DEBUG_FORCE_CONTROL_HEAD 1 */</comment>

<comment type="block">/* Allocate memory for the regex stack on the real machine stack.
Fast, but limited size. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MACHINE_STACK_SIZE</name></cpp:macro> <cpp:value>32768</cpp:value></cpp:define>

<comment type="block">/* Growth rate for stack allocated by the OS. Should be the multiply
of page size. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACK_GROWTH_RATE</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>

<comment type="block">/* Enable to check that the allocation could destroy temporaries. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SLJIT_DEBUG</name> <operator>&amp;&amp;</operator> <name>SLJIT_DEBUG</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DESTROY_REGISTERS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
Short summary about the backtracking mechanism empolyed by the jit code generator:

The code generator follows the recursive nature of the PERL compatible regular
expressions. The basic blocks of regular expressions are condition checkers
whose execute different commands depending on the result of the condition check.
The relationship between the operators can be horizontal (concatenation) and
vertical (sub-expression) (See struct backtrack_common for more details).

  'ab' - 'a' and 'b' regexps are concatenated
  'a+' - 'a' is the sub-expression of the '+' operator

The condition checkers are boolean (true/false) checkers. Machine code is generated
for the checker itself and for the actions depending on the result of the checker.
The 'true' case is called as the matching path (expected path), and the other is called as
the 'backtrack' path. Branch instructions are expesive for all CPUs, so we avoid taken
branches on the matching path.

 Greedy star operator (*) :
   Matching path: match happens.
   Backtrack path: match failed.
 Non-greedy star operator (*?) :
   Matching path: no need to perform a match.
   Backtrack path: match is required.

The following example shows how the code generated for a capturing bracket
with two alternatives. Let A, B, C, D are arbirary regular expressions, and
we have the following regular expression:

   A(B|C)D

The generated code will be the following:

 A matching path
 '(' matching path (pushing arguments to the stack)
 B matching path
 ')' matching path (pushing arguments to the stack)
 D matching path
 return with successful match

 D backtrack path
 ')' backtrack path (If we arrived from "C" jump to the backtrack of "C")
 B backtrack path
 C expected path
 jump to D matching path
 C backtrack path
 A backtrack path

 Notice, that the order of backtrack code paths are the opposite of the fast
 code paths. In this way the topmost value on the stack is always belong
 to the current backtrack code path. The backtrack path must check
 whether there is a next alternative. If so, it needs to jump back to
 the matching path eventually. Otherwise it needs to clear out its own stack
 frame and continue the execution on the backtrack code paths.
*/</comment>

<comment type="block">/*
Saved stack frames:

Atomic blocks and asserts require reloading the values of private data
when the backtrack mechanism performed. Because of OP_RECURSE, the data
are not necessarly known in compile time, thus we need a dynamic restore
mechanism.

The stack frames are stored in a chain list, and have the following format:
([ capturing bracket offset ][ start value ][ end value ])+ ... [ 0 ] [ previous head ]

Thus we can restore the private data to a particular point in the stack.
*/</comment>

<typedef>typedef <type><struct>struct <name>jit_arguments</name> <block>{
  <comment type="block">/* Pointers first. */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_stack</name></name> <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>str</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>begin</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>end</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>pcre2_match_data</name> <modifier>*</modifier></type><name>match_data</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>startchar_ptr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>mark_ptr</name></decl>;</decl_stmt>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>callout</name>)<parameter_list>(<parameter><decl><type><name>pcre2_callout_block</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>callout_data</name></decl>;</decl_stmt>
  <comment type="block">/* Everything else after. */</comment>
  <decl_stmt><decl><type><name>sljit_uw</name></type> <name>offset_limit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sljit_u32</name></type> <name>limit_match</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sljit_u32</name></type> <name>oveccount</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sljit_u32</name></type> <name>options</name></decl>;</decl_stmt>
}</block></struct></type> <name>jit_arguments</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JIT_NUMBER_OF_COMPILE_MODES</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>executable_functions</name> <block>{
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name><name>executable_funcs</name><index>[<expr><name>JIT_NUMBER_OF_COMPILE_MODES</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name><name>read_only_data_heads</name><index>[<expr><name>JIT_NUMBER_OF_COMPILE_MODES</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sljit_uw</name></type> <name><name>executable_sizes</name><index>[<expr><name>JIT_NUMBER_OF_COMPILE_MODES</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sljit_u32</name></type> <name>top_bracket</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sljit_u32</name></type> <name>limit_match</name></decl>;</decl_stmt>
}</block></struct></type> <name>executable_functions</name>;</typedef>

<typedef>typedef <type><struct>struct <name>jump_list</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>jump_list</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
}</block></struct></type> <name>jump_list</name>;</typedef>

<typedef>typedef <type><struct>struct <name>stub_list</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>quit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>stub_list</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
}</block></struct></type> <name>stub_list</name>;</typedef>

<enum>enum <name>frame_types</name> <block>{
  <decl><name>no_frame</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
  <decl><name>no_stack</name> <init>= <expr><operator>-</operator><literal type="number">2</literal></expr></init></decl>
}</block>;</enum>

<enum>enum <name>control_types</name> <block>{
  <decl><name>type_mark</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
  <decl><name>type_then_trap</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>
}</block>;</enum>

<enum>enum  <name>early_fail_types</name> <block>{
  <decl><name>type_skip</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
  <decl><name>type_fail</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
  <decl><name>type_fail_range</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>
}</block>;</enum>

<typedef>typedef <function_decl><type><name>int</name></type> (<name>SLJIT_FUNC</name> <modifier>*</modifier><name>jit_function</name>)<parameter_list>(<parameter><decl><type><name>jit_arguments</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* The following structure is the key data type for the recursive
code generator. It is allocated by compile_matchingpath, and contains
the arguments for compile_backtrackingpath. Must be the first member
of its descendants. */</comment>
<typedef>typedef <type><struct>struct <name>backtrack_common</name> <block>{
  <comment type="block">/* Concatenation stack. */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>backtrack_common</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>nextbacktracks</name></decl>;</decl_stmt>
  <comment type="block">/* Internal stack (for component operators). */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>backtrack_common</name></name> <modifier>*</modifier></type><name>top</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>topbacktracks</name></decl>;</decl_stmt>
  <comment type="block">/* Opcode pointer. */</comment>
  <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl>;</decl_stmt>
}</block></struct></type> <name>backtrack_common</name>;</typedef>

<typedef>typedef <type><struct>struct <name>assert_backtrack</name> <block>{
  <decl_stmt><decl><type><name>backtrack_common</name></type> <name>common</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>condfailed</name></decl>;</decl_stmt>
  <comment type="block">/* Less than 0 if a frame is not needed. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>framesize</name></decl>;</decl_stmt>
  <comment type="block">/* Points to our private memory word on the stack. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>private_data_ptr</name></decl>;</decl_stmt>
  <comment type="block">/* For iterators. */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>matchingpath</name></decl>;</decl_stmt>
}</block></struct></type> <name>assert_backtrack</name>;</typedef>

<typedef>typedef <type><struct>struct <name>bracket_backtrack</name> <block>{
  <decl_stmt><decl><type><name>backtrack_common</name></type> <name>common</name></decl>;</decl_stmt>
  <comment type="block">/* Where to coninue if an alternative is successfully matched. */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>alternative_matchingpath</name></decl>;</decl_stmt>
  <comment type="block">/* For rmin and rmax iterators. */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>recursive_matchingpath</name></decl>;</decl_stmt>
  <comment type="block">/* For greedy ? operator. */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>zero_matchingpath</name></decl>;</decl_stmt>
  <comment type="block">/* Contains the branches of a failed condition. */</comment>
  <union>union <block>{
    <comment type="block">/* Both for OP_COND, OP_SCOND. */</comment>
    <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>condfailed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>assert_backtrack</name> <modifier>*</modifier></type><name>assert</name></decl>;</decl_stmt>
    <comment type="block">/* For OP_ONCE. Less than 0 if not needed. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>framesize</name></decl>;</decl_stmt>
    <comment type="block">/* For brackets with &gt;3 alternatives. */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>sljit_put_label</name></name> <modifier>*</modifier></type><name>matching_put_label</name></decl>;</decl_stmt>
  }</block> <decl><name>u</name></decl>;</union>
  <comment type="block">/* Points to our private memory word on the stack. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>private_data_ptr</name></decl>;</decl_stmt>
}</block></struct></type> <name>bracket_backtrack</name>;</typedef>

<typedef>typedef <type><struct>struct <name>bracketpos_backtrack</name> <block>{
  <decl_stmt><decl><type><name>backtrack_common</name></type> <name>common</name></decl>;</decl_stmt>
  <comment type="block">/* Points to our private memory word on the stack. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>private_data_ptr</name></decl>;</decl_stmt>
  <comment type="block">/* Reverting stack is needed. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>framesize</name></decl>;</decl_stmt>
  <comment type="block">/* Allocated stack size. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>stacksize</name></decl>;</decl_stmt>
}</block></struct></type> <name>bracketpos_backtrack</name>;</typedef>

<typedef>typedef <type><struct>struct <name>braminzero_backtrack</name> <block>{
  <decl_stmt><decl><type><name>backtrack_common</name></type> <name>common</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>matchingpath</name></decl>;</decl_stmt>
}</block></struct></type> <name>braminzero_backtrack</name>;</typedef>

<typedef>typedef <type><struct>struct <name>char_iterator_backtrack</name> <block>{
  <decl_stmt><decl><type><name>backtrack_common</name></type> <name>common</name></decl>;</decl_stmt>
  <comment type="block">/* Next iteration. */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>matchingpath</name></decl>;</decl_stmt>
  <union>union <block>{
    <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>backtracks</name></decl>;</decl_stmt>
    <struct>struct <block>{
      <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>othercasebit</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>chr</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BOOL</name></type> <name>enabled</name></decl>;</decl_stmt>
    }</block> <decl><name>charpos</name></decl>;</struct>
  }</block> <decl><name>u</name></decl>;</union>
}</block></struct></type> <name>char_iterator_backtrack</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ref_iterator_backtrack</name> <block>{
  <decl_stmt><decl><type><name>backtrack_common</name></type> <name>common</name></decl>;</decl_stmt>
  <comment type="block">/* Next iteration. */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>matchingpath</name></decl>;</decl_stmt>
}</block></struct></type> <name>ref_iterator_backtrack</name>;</typedef>

<typedef>typedef <type><struct>struct <name>recurse_entry</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>recurse_entry</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
  <comment type="block">/* Contains the function entry label. */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>entry_label</name></decl>;</decl_stmt>
  <comment type="block">/* Contains the function entry label. */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>backtrack_label</name></decl>;</decl_stmt>
  <comment type="block">/* Collects the entry calls until the function is not created. */</comment>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>entry_calls</name></decl>;</decl_stmt>
  <comment type="block">/* Collects the backtrack calls until the function is not created. */</comment>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>backtrack_calls</name></decl>;</decl_stmt>
  <comment type="block">/* Points to the starting opcode. */</comment>
  <decl_stmt><decl><type><name>sljit_sw</name></type> <name>start</name></decl>;</decl_stmt>
}</block></struct></type> <name>recurse_entry</name>;</typedef>

<typedef>typedef <type><struct>struct <name>recurse_backtrack</name> <block>{
  <decl_stmt><decl><type><name>backtrack_common</name></type> <name>common</name></decl>;</decl_stmt>
  <comment type="block">/* Return to the matching path. */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>matchingpath</name></decl>;</decl_stmt>
  <comment type="block">/* Recursive pattern. */</comment>
  <decl_stmt><decl><type><name>recurse_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
  <comment type="block">/* Pattern is inlined. */</comment>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>inlined_pattern</name></decl>;</decl_stmt>
}</block></struct></type> <name>recurse_backtrack</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP_THEN_TRAP</name></cpp:macro> <cpp:value>OP_TABLE_LENGTH</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>then_trap_backtrack</name> <block>{
  <decl_stmt><decl><type><name>backtrack_common</name></type> <name>common</name></decl>;</decl_stmt>
  <comment type="block">/* If then_trap is not NULL, this structure contains the real
  then_trap for the backtracking path. */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>then_trap_backtrack</name></name> <modifier>*</modifier></type><name>then_trap</name></decl>;</decl_stmt>
  <comment type="block">/* Points to the starting opcode. */</comment>
  <decl_stmt><decl><type><name>sljit_sw</name></type> <name>start</name></decl>;</decl_stmt>
  <comment type="block">/* Exit point for the then opcodes of this alternative. */</comment>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>quit</name></decl>;</decl_stmt>
  <comment type="block">/* Frame size of the current alternative. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>framesize</name></decl>;</decl_stmt>
}</block></struct></type> <name>then_trap_backtrack</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_N_CHARS</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_DIFF_CHARS</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>fast_forward_char_data</name> <block>{
  <comment type="block">/* Number of characters in the chars array, 255 for any character. */</comment>
  <decl_stmt><decl><type><name>sljit_u8</name></type> <name>count</name></decl>;</decl_stmt>
  <comment type="block">/* Number of last UTF-8 characters in the chars array. */</comment>
  <decl_stmt><decl><type><name>sljit_u8</name></type> <name>last_count</name></decl>;</decl_stmt>
  <comment type="block">/* Available characters in the current position. */</comment>
  <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name><name>chars</name><index>[<expr><name>MAX_DIFF_CHARS</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>fast_forward_char_data</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_CLASS_RANGE_SIZE</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_CLASS_CHARS_SIZE</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>compiler_common</name> <block>{
  <comment type="block">/* The sljit ceneric compiler. */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl>;</decl_stmt>
  <comment type="block">/* Compiled regular expression. */</comment>
  <decl_stmt><decl><type><name>pcre2_real_code</name> <modifier>*</modifier></type><name>re</name></decl>;</decl_stmt>
  <comment type="block">/* First byte code. */</comment>
  <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>start</name></decl>;</decl_stmt>
  <comment type="block">/* Maps private data offset to each opcode. */</comment>
  <decl_stmt><decl><type><name>sljit_s32</name> <modifier>*</modifier></type><name>private_data_ptrs</name></decl>;</decl_stmt>
  <comment type="block">/* Chain list of read-only data ptrs. */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>read_only_data_head</name></decl>;</decl_stmt>
  <comment type="block">/* Tells whether the capturing bracket is optimized. */</comment>
  <decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>optimized_cbracket</name></decl>;</decl_stmt>
  <comment type="block">/* Tells whether the starting offset is a target of then. */</comment>
  <decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>then_offsets</name></decl>;</decl_stmt>
  <comment type="block">/* Current position where a THEN must jump. */</comment>
  <decl_stmt><decl><type><name>then_trap_backtrack</name> <modifier>*</modifier></type><name>then_trap</name></decl>;</decl_stmt>
  <comment type="block">/* Starting offset of private data for capturing brackets. */</comment>
  <decl_stmt><decl><type><name>sljit_s32</name></type> <name>cbra_ptr</name></decl>;</decl_stmt>
  <comment type="block">/* Output vector starting point. Must be divisible by 2. */</comment>
  <decl_stmt><decl><type><name>sljit_s32</name></type> <name>ovector_start</name></decl>;</decl_stmt>
  <comment type="block">/* Points to the starting character of the current match. */</comment>
  <decl_stmt><decl><type><name>sljit_s32</name></type> <name>start_ptr</name></decl>;</decl_stmt>
  <comment type="block">/* Last known position of the requested byte. */</comment>
  <decl_stmt><decl><type><name>sljit_s32</name></type> <name>req_char_ptr</name></decl>;</decl_stmt>
  <comment type="block">/* Head of the last recursion. */</comment>
  <decl_stmt><decl><type><name>sljit_s32</name></type> <name>recursive_head_ptr</name></decl>;</decl_stmt>
  <comment type="block">/* First inspected character for partial matching.
     (Needed for avoiding zero length partial matches.) */</comment>
  <decl_stmt><decl><type><name>sljit_s32</name></type> <name>start_used_ptr</name></decl>;</decl_stmt>
  <comment type="block">/* Starting pointer for partial soft matches. */</comment>
  <decl_stmt><decl><type><name>sljit_s32</name></type> <name>hit_start</name></decl>;</decl_stmt>
  <comment type="block">/* Pointer of the match end position. */</comment>
  <decl_stmt><decl><type><name>sljit_s32</name></type> <name>match_end_ptr</name></decl>;</decl_stmt>
  <comment type="block">/* Points to the marked string. */</comment>
  <decl_stmt><decl><type><name>sljit_s32</name></type> <name>mark_ptr</name></decl>;</decl_stmt>
  <comment type="block">/* Recursive control verb management chain. */</comment>
  <decl_stmt><decl><type><name>sljit_s32</name></type> <name>control_head_ptr</name></decl>;</decl_stmt>
  <comment type="block">/* Points to the last matched capture block index. */</comment>
  <decl_stmt><decl><type><name>sljit_s32</name></type> <name>capture_last_ptr</name></decl>;</decl_stmt>
  <comment type="block">/* Fast forward skipping byte code pointer. */</comment>
  <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>fast_forward_bc_ptr</name></decl>;</decl_stmt>
  <comment type="block">/* Locals used by fast fail optimization. */</comment>
  <decl_stmt><decl><type><name>sljit_s32</name></type> <name>early_fail_start_ptr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sljit_s32</name></type> <name>early_fail_end_ptr</name></decl>;</decl_stmt>

  <comment type="block">/* Flipped and lower case tables. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>sljit_u8</name> <modifier>*</modifier></type><name>fcc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sljit_sw</name></type> <name>lcc</name></decl>;</decl_stmt>
  <comment type="block">/* Mode can be PCRE2_JIT_COMPLETE and others. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>;</decl_stmt>
  <comment type="block">/* TRUE, when empty match is accepted for partial matching. */</comment>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>allow_empty_partial</name></decl>;</decl_stmt>
  <comment type="block">/* TRUE, when minlength is greater than 0. */</comment>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>might_be_empty</name></decl>;</decl_stmt>
  <comment type="block">/* \K is found in the pattern. */</comment>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>has_set_som</name></decl>;</decl_stmt>
  <comment type="block">/* (*SKIP:arg) is found in the pattern. */</comment>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>has_skip_arg</name></decl>;</decl_stmt>
  <comment type="block">/* (*THEN) is found in the pattern. */</comment>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>has_then</name></decl>;</decl_stmt>
  <comment type="block">/* (*SKIP) or (*SKIP:arg) is found in lookbehind assertion. */</comment>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>has_skip_in_assert_back</name></decl>;</decl_stmt>
  <comment type="block">/* Quit is redirected by recurse, negative assertion, or positive assertion in conditional block. */</comment>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>local_quit_available</name></decl>;</decl_stmt>
  <comment type="block">/* Currently in a positive assertion. */</comment>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>in_positive_assertion</name></decl>;</decl_stmt>
  <comment type="block">/* Newline control. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nltype</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sljit_u32</name></type> <name>nlmax</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sljit_u32</name></type> <name>nlmin</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>newline</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bsr_nltype</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sljit_u32</name></type> <name>bsr_nlmax</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sljit_u32</name></type> <name>bsr_nlmin</name></decl>;</decl_stmt>
  <comment type="block">/* Dollar endonly. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>endonly</name></decl>;</decl_stmt>
  <comment type="block">/* Tables. */</comment>
  <decl_stmt><decl><type><name>sljit_sw</name></type> <name>ctypes</name></decl>;</decl_stmt>
  <comment type="block">/* Named capturing brackets. */</comment>
  <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>name_table</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sljit_sw</name></type> <name>name_count</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sljit_sw</name></type> <name>name_entry_size</name></decl>;</decl_stmt>

  <comment type="block">/* Labels and jump lists. */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>partialmatchlabel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>quit_label</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>abort_label</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>accept_label</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>ff_newline_shortcut</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>stub_list</name> <modifier>*</modifier></type><name>stubs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>recurse_entry</name> <modifier>*</modifier></type><name>entries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>recurse_entry</name> <modifier>*</modifier></type><name>currententry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>partialmatch</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>quit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>positive_assertion_quit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>abort</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>failed_match</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>accept</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>calllimit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>stackalloc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>revertframes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>wordboundary</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>anynewline</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>hspace</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>vspace</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>casefulcmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>caselesscmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>reset_match</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>unset_backref</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>alt_circumflex</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>invalid_utf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>ucp</name></decl>;</decl_stmt>
  <comment type="block">/* Points to saving area for iref. */</comment>
  <decl_stmt><decl><type><name>sljit_s32</name></type> <name>iref_ptr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>getucd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>getucdtype</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>utfreadchar</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>utfreadtype8</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>utfpeakcharback</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:if>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>utfreadchar_invalid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>utfreadnewline_invalid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>utfmoveback_invalid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>utfpeakcharback_invalid</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
}</block></struct></type> <name>compiler_common</name>;</typedef>

<comment type="block">/* For byte_sequence_compare. */</comment>

<typedef>typedef <type><struct>struct <name>compare_context</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>sourcereg</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SLJIT_UNALIGNED</name> <operator>&amp;&amp;</operator> <name>SLJIT_UNALIGNED</name></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>ucharptr</name></decl>;</decl_stmt>
  <union>union <block>{
    <decl_stmt><decl><type><name>sljit_s32</name></type> <name>asint</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sljit_u16</name></type> <name>asushort</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <decl_stmt><decl><type><name>sljit_u8</name></type> <name>asbyte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sljit_u8</name></type> <name><name>asuchars</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:elif>
    <decl_stmt><decl><type><name>sljit_u16</name></type> <name><name>asuchars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:elif>
    <decl_stmt><decl><type><name>sljit_u32</name></type> <name><name>asuchars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block> <decl><name>c</name></decl>;</union>
  <union>union <block>{
    <decl_stmt><decl><type><name>sljit_s32</name></type> <name>asint</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sljit_u16</name></type> <name>asushort</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <decl_stmt><decl><type><name>sljit_u8</name></type> <name>asbyte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sljit_u8</name></type> <name><name>asuchars</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:elif>
    <decl_stmt><decl><type><name>sljit_u16</name></type> <name><name>asuchars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:elif>
    <decl_stmt><decl><type><name>sljit_u32</name></type> <name><name>asuchars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block> <decl><name>oc</name></decl>;</union>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>compare_context</name>;</typedef>

<comment type="block">/* Undefine sljit macros. */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CMP</name></cpp:undef>

<comment type="block">/* Used for accessing the elements of the stack. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACK</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>((i) * (int)sizeof(sljit_sw))</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SLJIT_PREF_SHIFT_REG</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SLJIT_PREF_SHIFT_REG</name> <operator>==</operator> <name>SLJIT_R2</name></expr></cpp:if>
<comment type="block">/* Nothing. */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SLJIT_PREF_SHIFT_REG</name> <operator>==</operator> <name>SLJIT_R3</name></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHIFT_REG_IS_R3</name></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"Unsupported shift register"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TMP1</name></cpp:macro>          <cpp:value>SLJIT_R0</cpp:value></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHIFT_REG_IS_R3</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TMP2</name></cpp:macro>          <cpp:value>SLJIT_R3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TMP3</name></cpp:macro>          <cpp:value>SLJIT_R2</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TMP2</name></cpp:macro>          <cpp:value>SLJIT_R2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TMP3</name></cpp:macro>          <cpp:value>SLJIT_R3</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_PTR</name></cpp:macro>       <cpp:value>SLJIT_R1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_END</name></cpp:macro>       <cpp:value>SLJIT_S0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACK_TOP</name></cpp:macro>     <cpp:value>SLJIT_S1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACK_LIMIT</name></cpp:macro>   <cpp:value>SLJIT_S2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COUNT_MATCH</name></cpp:macro>   <cpp:value>SLJIT_S3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARGUMENTS</name></cpp:macro>     <cpp:value>SLJIT_S4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETURN_ADDR</name></cpp:macro>   <cpp:value>SLJIT_R4</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>SLJIT_CONFIG_X86_32</name> <operator>&amp;&amp;</operator> <name>SLJIT_CONFIG_X86_32</name><operator>)</operator></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAS_VIRTUAL_REGISTERS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAS_VIRTUAL_REGISTERS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Local space layout. */</comment>
<comment type="block">/* These two locals can be used by the current opcode. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCALS0</name></cpp:macro>          <cpp:value>(0 * sizeof(sljit_sw))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCALS1</name></cpp:macro>          <cpp:value>(1 * sizeof(sljit_sw))</cpp:value></cpp:define>
<comment type="block">/* Two local variables for possessive quantifiers (char1 cannot use them). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POSSESSIVE0</name></cpp:macro>      <cpp:value>(2 * sizeof(sljit_sw))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POSSESSIVE1</name></cpp:macro>      <cpp:value>(3 * sizeof(sljit_sw))</cpp:value></cpp:define>
<comment type="block">/* Max limit of recursions. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIMIT_MATCH</name></cpp:macro>      <cpp:value>(4 * sizeof(sljit_sw))</cpp:value></cpp:define>
<comment type="block">/* The output vector is stored on the stack, and contains pointers
to characters. The vector data is divided into two groups: the first
group contains the start / end character pointers, and the second is
the start pointers when the end of the capturing group has not yet reached. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OVECTOR_START</name></cpp:macro>    <cpp:value>(common-&gt;ovector_start)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OVECTOR</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(OVECTOR_START + (i) * (sljit_sw)sizeof(sljit_sw))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OVECTOR_PRIV</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(common-&gt;cbra_ptr + (i) * (sljit_sw)sizeof(sljit_sw))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRIVATE_DATA</name><parameter_list>(<parameter><type><name>cc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(common-&gt;private_data_ptrs[(cc) - common-&gt;start])</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MOV_UCHAR</name></cpp:macro>  <cpp:value>SLJIT_MOV_U8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IN_UCHARS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MOV_UCHAR</name></cpp:macro>  <cpp:value>SLJIT_MOV_U16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UCHAR_SHIFT</name></cpp:macro> <cpp:value>(1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IN_UCHARS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) * 2)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MOV_UCHAR</name></cpp:macro>  <cpp:value>SLJIT_MOV_U32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UCHAR_SHIFT</name></cpp:macro> <cpp:value>(2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IN_UCHARS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) * 4)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> Unsupported compiling mode</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Shortcuts. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_COMPILER</name></cpp:macro> \
  <cpp:value>struct sljit_compiler *compiler = common-&gt;compiler</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP1</name><parameter_list>(<parameter><type><name>op</name></type></parameter>, <parameter><type><name>dst</name></type></parameter>, <parameter><type><name>dstw</name></type></parameter>, <parameter><type><name>src</name></type></parameter>, <parameter><type><name>srcw</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>sljit_emit_op1(compiler, (op), (dst), (dstw), (src), (srcw))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP2</name><parameter_list>(<parameter><type><name>op</name></type></parameter>, <parameter><type><name>dst</name></type></parameter>, <parameter><type><name>dstw</name></type></parameter>, <parameter><type><name>src1</name></type></parameter>, <parameter><type><name>src1w</name></type></parameter>, <parameter><type><name>src2</name></type></parameter>, <parameter><type><name>src2w</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>sljit_emit_op2(compiler, (op), (dst), (dstw), (src1), (src1w), (src2), (src2w))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP_SRC</name><parameter_list>(<parameter><type><name>op</name></type></parameter>, <parameter><type><name>src</name></type></parameter>, <parameter><type><name>srcw</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>sljit_emit_op_src(compiler, (op), (src), (srcw))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LABEL</name><parameter_list>()</parameter_list></cpp:macro> \
  <cpp:value>sljit_emit_label(compiler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JUMP</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>sljit_emit_jump(compiler, (type))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JUMPTO</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>label</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>sljit_set_label(sljit_emit_jump(compiler, (type)), (label))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JUMPHERE</name><parameter_list>(<parameter><type><name>jump</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>sljit_set_label((jump), sljit_emit_label(compiler))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_LABEL</name><parameter_list>(<parameter><type><name>jump</name></type></parameter>, <parameter><type><name>label</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>sljit_set_label((jump), (label))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMP</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>src1</name></type></parameter>, <parameter><type><name>src1w</name></type></parameter>, <parameter><type><name>src2</name></type></parameter>, <parameter><type><name>src2w</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>sljit_emit_cmp(compiler, (type), (src1), (src1w), (src2), (src2w))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMPTO</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>src1</name></type></parameter>, <parameter><type><name>src1w</name></type></parameter>, <parameter><type><name>src2</name></type></parameter>, <parameter><type><name>src2w</name></type></parameter>, <parameter><type><name>label</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>sljit_set_label(sljit_emit_cmp(compiler, (type), (src1), (src1w), (src2), (src2w)), (label))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP_FLAGS</name><parameter_list>(<parameter><type><name>op</name></type></parameter>, <parameter><type><name>dst</name></type></parameter>, <parameter><type><name>dstw</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>sljit_emit_op_flags(compiler, (op), (dst), (dstw), (type))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMOV</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>dst_reg</name></type></parameter>, <parameter><type><name>src</name></type></parameter>, <parameter><type><name>srcw</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>sljit_emit_cmov(compiler, (type), (dst_reg), (src), (srcw))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_LOCAL_BASE</name><parameter_list>(<parameter><type><name>dst</name></type></parameter>, <parameter><type><name>dstw</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>sljit_get_local_base(compiler, (dst), (dstw), (offset))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_CHAR_MAX</name></cpp:macro> <cpp:value>0x7fffffff</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_UTF_CHAR</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNASSIGNED_UTF_CHAR</name></cpp:macro> <cpp:value>888</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETCHARINC_INVALID</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>end</name></type></parameter>, <parameter><type><name>invalid_action</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>{ \
  if (ptr[0] &lt;= 0x7f) \
    c = *ptr++; \
  else if (ptr + 1 &lt; end &amp;&amp; ptr[1] &gt;= 0x80 &amp;&amp; ptr[1] &lt; 0xc0) \
    { \
    c = ptr[1] - 0x80; \
    \
    if (ptr[0] &gt;= 0xc2 &amp;&amp; ptr[0] &lt;= 0xdf) \
      { \
      c |= (ptr[0] - 0xc0) &lt;&lt; 6; \
      ptr += 2; \
      } \
    else if (ptr + 2 &lt; end &amp;&amp; ptr[2] &gt;= 0x80 &amp;&amp; ptr[2] &lt; 0xc0) \
      { \
      c = c &lt;&lt; 6 | (ptr[2] - 0x80); \
      \
      if (ptr[0] &gt;= 0xe0 &amp;&amp; ptr[0] &lt;= 0xef) \
        { \
        c |= (ptr[0] - 0xe0) &lt;&lt; 12; \
        ptr += 3; \
        \
        if (c &lt; 0x800 || (c &gt;= 0xd800 &amp;&amp; c &lt; 0xe000)) \
          { \
          invalid_action; \
          } \
        } \
      else if (ptr + 3 &lt; end &amp;&amp; ptr[3] &gt;= 0x80 &amp;&amp; ptr[3] &lt; 0xc0) \
        { \
        c = c &lt;&lt; 6 | (ptr[3] - 0x80); \
        \
        if (ptr[0] &gt;= 0xf0 &amp;&amp; ptr[0] &lt;= 0xf4) \
          { \
          c |= (ptr[0] - 0xf0) &lt;&lt; 18; \
          ptr += 4; \
          \
          if (c &gt;= 0x110000 || c &lt; 0x10000) \
            { \
            invalid_action; \
            } \
          } \
        else \
          { \
          invalid_action; \
          } \
        } \
      else \
        { \
        invalid_action; \
        } \
      } \
    else \
      { \
      invalid_action; \
      } \
    } \
  else \
    { \
    invalid_action; \
    } \
  }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETCHARBACK_INVALID</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>start</name></type></parameter>, <parameter><type><name>invalid_action</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>{ \
  c = ptr[-1]; \
  if (c &lt;= 0x7f) \
    ptr--; \
  else if (ptr - 1 &gt; start &amp;&amp; ptr[-1] &gt;= 0x80 &amp;&amp; ptr[-1] &lt; 0xc0) \
    { \
    c -= 0x80; \
    \
    if (ptr[-2] &gt;= 0xc2 &amp;&amp; ptr[-2] &lt;= 0xdf) \
      { \
      c |= (ptr[-2] - 0xc0) &lt;&lt; 6; \
      ptr -= 2; \
      } \
    else if (ptr - 2 &gt; start &amp;&amp; ptr[-2] &gt;= 0x80 &amp;&amp; ptr[-2] &lt; 0xc0) \
      { \
      c = c &lt;&lt; 6 | (ptr[-2] - 0x80); \
      \
      if (ptr[-3] &gt;= 0xe0 &amp;&amp; ptr[-3] &lt;= 0xef) \
        { \
        c |= (ptr[-3] - 0xe0) &lt;&lt; 12; \
        ptr -= 3; \
        \
        if (c &lt; 0x800 || (c &gt;= 0xd800 &amp;&amp; c &lt; 0xe000)) \
          { \
          invalid_action; \
          } \
        } \
      else if (ptr - 3 &gt; start &amp;&amp; ptr[-3] &gt;= 0x80 &amp;&amp; ptr[-3] &lt; 0xc0) \
        { \
        c = c &lt;&lt; 6 | (ptr[-3] - 0x80); \
        \
        if (ptr[-4] &gt;= 0xf0 &amp;&amp; ptr[-4] &lt;= 0xf4) \
          { \
          c |= (ptr[-4] - 0xf0) &lt;&lt; 18; \
          ptr -= 4; \
          \
          if (c &gt;= 0x110000 || c &lt; 0x10000) \
            { \
            invalid_action; \
            } \
          } \
        else \
          { \
          invalid_action; \
          } \
        } \
      else \
        { \
        invalid_action; \
        } \
      } \
    else \
      { \
      invalid_action; \
      } \
    } \
  else \
    { \
    invalid_action; \
    } \
  }</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETCHARINC_INVALID</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>end</name></type></parameter>, <parameter><type><name>invalid_action</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>{ \
  if (ptr[0] &lt; 0xd800 || ptr[0] &gt;= 0xe000) \
    c = *ptr++; \
  else if (ptr[0] &lt; 0xdc00 &amp;&amp; ptr + 1 &lt; end &amp;&amp; ptr[1] &gt;= 0xdc00 &amp;&amp; ptr[1] &lt; 0xe000) \
    { \
    c = (((ptr[0] - 0xd800) &lt;&lt; 10) | (ptr[1] - 0xdc00)) + 0x10000; \
    ptr += 2; \
    } \
  else \
    { \
    invalid_action; \
    } \
  }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETCHARBACK_INVALID</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>start</name></type></parameter>, <parameter><type><name>invalid_action</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>{ \
  c = ptr[-1]; \
  if (c &lt; 0xd800 || c &gt;= 0xe000) \
    ptr--; \
  else if (c &gt;= 0xdc00 &amp;&amp; ptr - 1 &gt; start &amp;&amp; ptr[-2] &gt;= 0xd800 &amp;&amp; ptr[-2] &lt; 0xdc00) \
    { \
    c = (((ptr[-2] - 0xd800) &lt;&lt; 10) | (c - 0xdc00)) + 0x10000; \
    ptr -= 2; \
    } \
  else \
    { \
    invalid_action; \
    } \
  }</cpp:value></cpp:define>


<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETCHARINC_INVALID</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>end</name></type></parameter>, <parameter><type><name>invalid_action</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>{ \
  if (ptr[0] &lt; 0xd800 || (ptr[0] &gt;= 0xe000 &amp;&amp; ptr[0] &lt; 0x110000)) \
    c = *ptr++; \
  else \
    { \
    invalid_action; \
    } \
  }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETCHARBACK_INVALID</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>start</name></type></parameter>, <parameter><type><name>invalid_action</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>{ \
  c = ptr[-1]; \
  if (ptr[-1] &lt; 0xd800 || (ptr[-1] &gt;= 0xe000 &amp;&amp; ptr[-1] &lt; 0x110000)) \
    ptr--; \
  else \
    { \
    invalid_action; \
    } \
  }</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>

<function><type><specifier>static</specifier> <name>PCRE2_SPTR</name></type> <name>bracketend</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>cc</name> <operator>&gt;=</operator> <name>OP_ASSERT</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cc</name> <operator>&lt;=</operator> <name>OP_ASSERTBACK_NA</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>*</operator><name>cc</name> <operator>&gt;=</operator> <name>OP_ONCE</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cc</name> <operator>&lt;=</operator> <name>OP_SCOND</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name> <operator>&gt;=</operator> <name>OP_KET</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cc</name> <operator>&lt;=</operator> <name>OP_KETRPOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
<return>return <expr><name>cc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>no_alternatives</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>cc</name> <operator>&gt;=</operator> <name>OP_ASSERT</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cc</name> <operator>&lt;=</operator> <name>OP_ASSERTBACK_NA</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>*</operator><name>cc</name> <operator>&gt;=</operator> <name>OP_ONCE</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cc</name> <operator>&lt;=</operator> <name>OP_SCOND</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do
  <block>{<block_content>
  <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block>
while <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name> <operator>&gt;=</operator> <name>OP_KET</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cc</name> <operator>&lt;=</operator> <name>OP_KETRPOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Functions whose might need modification for all new supported opcodes:
 next_opcode
 check_opcode_types
 set_private_data_ptrs
 get_framesize
 init_frame
 get_recurse_data_length
 copy_recurse_data
 compile_matchingpath
 compile_backtrackingpath
*/</comment>

<function><type><specifier>static</specifier> <name>PCRE2_SPTR</name></type> <name>next_opcode</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>SLJIT_UNUSED_ARG</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><operator>*</operator><name>cc</name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><name>OP_SOD</name></expr>:</case>
  <case>case <expr><name>OP_SOM</name></expr>:</case>
  <case>case <expr><name>OP_SET_SOM</name></expr>:</case>
  <case>case <expr><name>OP_NOT_WORD_BOUNDARY</name></expr>:</case>
  <case>case <expr><name>OP_WORD_BOUNDARY</name></expr>:</case>
  <case>case <expr><name>OP_NOT_DIGIT</name></expr>:</case>
  <case>case <expr><name>OP_DIGIT</name></expr>:</case>
  <case>case <expr><name>OP_NOT_WHITESPACE</name></expr>:</case>
  <case>case <expr><name>OP_WHITESPACE</name></expr>:</case>
  <case>case <expr><name>OP_NOT_WORDCHAR</name></expr>:</case>
  <case>case <expr><name>OP_WORDCHAR</name></expr>:</case>
  <case>case <expr><name>OP_ANY</name></expr>:</case>
  <case>case <expr><name>OP_ALLANY</name></expr>:</case>
  <case>case <expr><name>OP_NOTPROP</name></expr>:</case>
  <case>case <expr><name>OP_PROP</name></expr>:</case>
  <case>case <expr><name>OP_ANYNL</name></expr>:</case>
  <case>case <expr><name>OP_NOT_HSPACE</name></expr>:</case>
  <case>case <expr><name>OP_HSPACE</name></expr>:</case>
  <case>case <expr><name>OP_NOT_VSPACE</name></expr>:</case>
  <case>case <expr><name>OP_VSPACE</name></expr>:</case>
  <case>case <expr><name>OP_EXTUNI</name></expr>:</case>
  <case>case <expr><name>OP_EODN</name></expr>:</case>
  <case>case <expr><name>OP_EOD</name></expr>:</case>
  <case>case <expr><name>OP_CIRC</name></expr>:</case>
  <case>case <expr><name>OP_CIRCM</name></expr>:</case>
  <case>case <expr><name>OP_DOLL</name></expr>:</case>
  <case>case <expr><name>OP_DOLLM</name></expr>:</case>
  <case>case <expr><name>OP_CRSTAR</name></expr>:</case>
  <case>case <expr><name>OP_CRMINSTAR</name></expr>:</case>
  <case>case <expr><name>OP_CRPLUS</name></expr>:</case>
  <case>case <expr><name>OP_CRMINPLUS</name></expr>:</case>
  <case>case <expr><name>OP_CRQUERY</name></expr>:</case>
  <case>case <expr><name>OP_CRMINQUERY</name></expr>:</case>
  <case>case <expr><name>OP_CRRANGE</name></expr>:</case>
  <case>case <expr><name>OP_CRMINRANGE</name></expr>:</case>
  <case>case <expr><name>OP_CRPOSSTAR</name></expr>:</case>
  <case>case <expr><name>OP_CRPOSPLUS</name></expr>:</case>
  <case>case <expr><name>OP_CRPOSQUERY</name></expr>:</case>
  <case>case <expr><name>OP_CRPOSRANGE</name></expr>:</case>
  <case>case <expr><name>OP_CLASS</name></expr>:</case>
  <case>case <expr><name>OP_NCLASS</name></expr>:</case>
  <case>case <expr><name>OP_REF</name></expr>:</case>
  <case>case <expr><name>OP_REFI</name></expr>:</case>
  <case>case <expr><name>OP_DNREF</name></expr>:</case>
  <case>case <expr><name>OP_DNREFI</name></expr>:</case>
  <case>case <expr><name>OP_RECURSE</name></expr>:</case>
  <case>case <expr><name>OP_CALLOUT</name></expr>:</case>
  <case>case <expr><name>OP_ALT</name></expr>:</case>
  <case>case <expr><name>OP_KET</name></expr>:</case>
  <case>case <expr><name>OP_KETRMAX</name></expr>:</case>
  <case>case <expr><name>OP_KETRMIN</name></expr>:</case>
  <case>case <expr><name>OP_KETRPOS</name></expr>:</case>
  <case>case <expr><name>OP_REVERSE</name></expr>:</case>
  <case>case <expr><name>OP_ASSERT</name></expr>:</case>
  <case>case <expr><name>OP_ASSERT_NOT</name></expr>:</case>
  <case>case <expr><name>OP_ASSERTBACK</name></expr>:</case>
  <case>case <expr><name>OP_ASSERTBACK_NOT</name></expr>:</case>
  <case>case <expr><name>OP_ASSERT_NA</name></expr>:</case>
  <case>case <expr><name>OP_ASSERTBACK_NA</name></expr>:</case>
  <case>case <expr><name>OP_ONCE</name></expr>:</case>
  <case>case <expr><name>OP_SCRIPT_RUN</name></expr>:</case>
  <case>case <expr><name>OP_BRA</name></expr>:</case>
  <case>case <expr><name>OP_BRAPOS</name></expr>:</case>
  <case>case <expr><name>OP_CBRA</name></expr>:</case>
  <case>case <expr><name>OP_CBRAPOS</name></expr>:</case>
  <case>case <expr><name>OP_COND</name></expr>:</case>
  <case>case <expr><name>OP_SBRA</name></expr>:</case>
  <case>case <expr><name>OP_SBRAPOS</name></expr>:</case>
  <case>case <expr><name>OP_SCBRA</name></expr>:</case>
  <case>case <expr><name>OP_SCBRAPOS</name></expr>:</case>
  <case>case <expr><name>OP_SCOND</name></expr>:</case>
  <case>case <expr><name>OP_CREF</name></expr>:</case>
  <case>case <expr><name>OP_DNCREF</name></expr>:</case>
  <case>case <expr><name>OP_RREF</name></expr>:</case>
  <case>case <expr><name>OP_DNRREF</name></expr>:</case>
  <case>case <expr><name>OP_FALSE</name></expr>:</case>
  <case>case <expr><name>OP_TRUE</name></expr>:</case>
  <case>case <expr><name>OP_BRAZERO</name></expr>:</case>
  <case>case <expr><name>OP_BRAMINZERO</name></expr>:</case>
  <case>case <expr><name>OP_BRAPOSZERO</name></expr>:</case>
  <case>case <expr><name>OP_PRUNE</name></expr>:</case>
  <case>case <expr><name>OP_SKIP</name></expr>:</case>
  <case>case <expr><name>OP_THEN</name></expr>:</case>
  <case>case <expr><name>OP_COMMIT</name></expr>:</case>
  <case>case <expr><name>OP_FAIL</name></expr>:</case>
  <case>case <expr><name>OP_ACCEPT</name></expr>:</case>
  <case>case <expr><name>OP_ASSERT_ACCEPT</name></expr>:</case>
  <case>case <expr><name>OP_CLOSE</name></expr>:</case>
  <case>case <expr><name>OP_SKIPZERO</name></expr>:</case>
  <return>return <expr><name>cc</name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>cc</name></expr>]</index></expr>;</return>

  <case>case <expr><name>OP_CHAR</name></expr>:</case>
  <case>case <expr><name>OP_CHARI</name></expr>:</case>
  <case>case <expr><name>OP_NOT</name></expr>:</case>
  <case>case <expr><name>OP_NOTI</name></expr>:</case>
  <case>case <expr><name>OP_STAR</name></expr>:</case>
  <case>case <expr><name>OP_MINSTAR</name></expr>:</case>
  <case>case <expr><name>OP_PLUS</name></expr>:</case>
  <case>case <expr><name>OP_MINPLUS</name></expr>:</case>
  <case>case <expr><name>OP_QUERY</name></expr>:</case>
  <case>case <expr><name>OP_MINQUERY</name></expr>:</case>
  <case>case <expr><name>OP_UPTO</name></expr>:</case>
  <case>case <expr><name>OP_MINUPTO</name></expr>:</case>
  <case>case <expr><name>OP_EXACT</name></expr>:</case>
  <case>case <expr><name>OP_POSSTAR</name></expr>:</case>
  <case>case <expr><name>OP_POSPLUS</name></expr>:</case>
  <case>case <expr><name>OP_POSQUERY</name></expr>:</case>
  <case>case <expr><name>OP_POSUPTO</name></expr>:</case>
  <case>case <expr><name>OP_STARI</name></expr>:</case>
  <case>case <expr><name>OP_MINSTARI</name></expr>:</case>
  <case>case <expr><name>OP_PLUSI</name></expr>:</case>
  <case>case <expr><name>OP_MINPLUSI</name></expr>:</case>
  <case>case <expr><name>OP_QUERYI</name></expr>:</case>
  <case>case <expr><name>OP_MINQUERYI</name></expr>:</case>
  <case>case <expr><name>OP_UPTOI</name></expr>:</case>
  <case>case <expr><name>OP_MINUPTOI</name></expr>:</case>
  <case>case <expr><name>OP_EXACTI</name></expr>:</case>
  <case>case <expr><name>OP_POSSTARI</name></expr>:</case>
  <case>case <expr><name>OP_POSPLUSI</name></expr>:</case>
  <case>case <expr><name>OP_POSQUERYI</name></expr>:</case>
  <case>case <expr><name>OP_POSUPTOI</name></expr>:</case>
  <case>case <expr><name>OP_NOTSTAR</name></expr>:</case>
  <case>case <expr><name>OP_NOTMINSTAR</name></expr>:</case>
  <case>case <expr><name>OP_NOTPLUS</name></expr>:</case>
  <case>case <expr><name>OP_NOTMINPLUS</name></expr>:</case>
  <case>case <expr><name>OP_NOTQUERY</name></expr>:</case>
  <case>case <expr><name>OP_NOTMINQUERY</name></expr>:</case>
  <case>case <expr><name>OP_NOTUPTO</name></expr>:</case>
  <case>case <expr><name>OP_NOTMINUPTO</name></expr>:</case>
  <case>case <expr><name>OP_NOTEXACT</name></expr>:</case>
  <case>case <expr><name>OP_NOTPOSSTAR</name></expr>:</case>
  <case>case <expr><name>OP_NOTPOSPLUS</name></expr>:</case>
  <case>case <expr><name>OP_NOTPOSQUERY</name></expr>:</case>
  <case>case <expr><name>OP_NOTPOSUPTO</name></expr>:</case>
  <case>case <expr><name>OP_NOTSTARI</name></expr>:</case>
  <case>case <expr><name>OP_NOTMINSTARI</name></expr>:</case>
  <case>case <expr><name>OP_NOTPLUSI</name></expr>:</case>
  <case>case <expr><name>OP_NOTMINPLUSI</name></expr>:</case>
  <case>case <expr><name>OP_NOTQUERYI</name></expr>:</case>
  <case>case <expr><name>OP_NOTMINQUERYI</name></expr>:</case>
  <case>case <expr><name>OP_NOTUPTOI</name></expr>:</case>
  <case>case <expr><name>OP_NOTMINUPTOI</name></expr>:</case>
  <case>case <expr><name>OP_NOTEXACTI</name></expr>:</case>
  <case>case <expr><name>OP_NOTPOSSTARI</name></expr>:</case>
  <case>case <expr><name>OP_NOTPOSPLUSI</name></expr>:</case>
  <case>case <expr><name>OP_NOTPOSQUERYI</name></expr>:</case>
  <case>case <expr><name>OP_NOTPOSUPTOI</name></expr>:</case>
  <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>cc</name></expr>]</index></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>cc</name></expr>;</return>

  <comment type="block">/* Special cases. */</comment>
  <case>case <expr><name>OP_TYPESTAR</name></expr>:</case>
  <case>case <expr><name>OP_TYPEMINSTAR</name></expr>:</case>
  <case>case <expr><name>OP_TYPEPLUS</name></expr>:</case>
  <case>case <expr><name>OP_TYPEMINPLUS</name></expr>:</case>
  <case>case <expr><name>OP_TYPEQUERY</name></expr>:</case>
  <case>case <expr><name>OP_TYPEMINQUERY</name></expr>:</case>
  <case>case <expr><name>OP_TYPEUPTO</name></expr>:</case>
  <case>case <expr><name>OP_TYPEMINUPTO</name></expr>:</case>
  <case>case <expr><name>OP_TYPEEXACT</name></expr>:</case>
  <case>case <expr><name>OP_TYPEPOSSTAR</name></expr>:</case>
  <case>case <expr><name>OP_TYPEPOSPLUS</name></expr>:</case>
  <case>case <expr><name>OP_TYPEPOSQUERY</name></expr>:</case>
  <case>case <expr><name>OP_TYPEPOSUPTO</name></expr>:</case>
  <return>return <expr><name>cc</name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>cc</name></expr>]</index> <operator>-</operator> <literal type="number">1</literal></expr>;</return>

  <case>case <expr><name>OP_ANYBYTE</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>

  <case>case <expr><name>OP_CALLOUT_STR</name></expr>:</case>
  <return>return <expr><name>cc</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
  <case>case <expr><name>OP_XCLASS</name></expr>:</case>
  <return>return <expr><name>cc</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <case>case <expr><name>OP_MARK</name></expr>:</case>
  <case>case <expr><name>OP_COMMIT_ARG</name></expr>:</case>
  <case>case <expr><name>OP_PRUNE_ARG</name></expr>:</case>
  <case>case <expr><name>OP_SKIP_ARG</name></expr>:</case>
  <case>case <expr><name>OP_THEN_ARG</name></expr>:</case>
  <return>return <expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>

  <default>default:</default>
  <expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BOOL</name></type> <name>check_opcode_types</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ccend</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>slot</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>assert_back_end</name> <init>= <expr><name>cc</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>assert_na_end</name> <init>= <expr><name>cc</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Calculate important variables (like stack size) and checks whether all opcodes are supported. */</comment>
<while>while <condition>(<expr><name>cc</name> <operator>&lt;</operator> <name>ccend</name></expr>)</condition>
  <block>{<block_content>
  <switch>switch<condition>(<expr><operator>*</operator><name>cc</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>OP_SET_SOM</name></expr>:</case>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>has_set_som</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>might_be_empty</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_REFI</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>iref_ptr</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>iref_ptr</name></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name> <operator>+=</operator> <literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
    <comment type="block">/* Fall through. */</comment>
    <case>case <expr><name>OP_REF</name></expr>:</case>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_ASSERT_NA</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NA</name></expr>:</case>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>bracketend</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>slot</name> <operator>&gt;</operator> <name>assert_na_end</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>assert_na_end</name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CBRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SCBRAPOS</name></expr>:</case>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_COND</name></expr>:</case>
    <case>case <expr><name>OP_SCOND</name></expr>:</case>
    <comment type="block">/* Only AUTO_CALLOUT can insert this opcode. We do
       not intend to support this case. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cc</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_CALLOUT</name> <operator>||</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_CALLOUT_STR</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CREF</name></expr>:</case>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_DNREF</name></expr>:</case>
    <case>case <expr><name>OP_DNREFI</name></expr>:</case>
    <case>case <expr><name>OP_DNCREF</name></expr>:</case>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>name_table</name></name> <operator>+</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>common</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>count</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><call><name>GET2</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>slot</name> <operator>+=</operator> <name><name>common</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>
      </block_content>}</block></while>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_RECURSE</name></expr>:</case>
    <comment type="block">/* Set its value only once. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>recursive_head_ptr</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>recursive_head_ptr</name></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CALLOUT</name></expr>:</case>
    <case>case <expr><name>OP_CALLOUT_STR</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_CALLOUT</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>OP_CALLOUT</name></expr>]</index></expr> </then><else>: <expr><call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_ASSERTBACK</name></expr>:</case>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>bracketend</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>slot</name> <operator>&gt;</operator> <name>assert_back_end</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>assert_back_end</name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_THEN_ARG</name></expr>:</case>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>has_then</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="block">/* Fall through. */</comment>

    <case>case <expr><name>OP_COMMIT_ARG</name></expr>:</case>
    <case>case <expr><name>OP_PRUNE_ARG</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&lt;</operator> <name>assert_na_end</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Fall through */</comment>
    <case>case <expr><name>OP_MARK</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_THEN</name></expr>:</case>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>has_then</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_SKIP</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&lt;</operator> <name>assert_back_end</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>has_skip_in_assert_back</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&lt;</operator> <name>assert_na_end</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_SKIP_ARG</name></expr>:</case>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>has_skip_arg</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&lt;</operator> <name>assert_back_end</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>has_skip_in_assert_back</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&lt;</operator> <name>assert_na_end</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_PRUNE</name></expr>:</case>
    <case>case <expr><name>OP_COMMIT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT_ACCEPT</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&lt;</operator> <name>assert_na_end</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <default>default:</default>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>next_opcode</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></while>
<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EARLY_FAIL_ENHANCE_MAX</name></cpp:macro> <cpp:value>(1 + 1)</cpp:value></cpp:define>

<comment type="block">/*
start:
  0 - skip / early fail allowed
  1 - only early fail with range allowed
  &gt;1 - (start - 1) early fail is processed

return: current number of iterators enhanced with fast fail
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>detect_early_fail</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>private_data_start</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>next_alt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>accelerated_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>fast_forward_allowed</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ONCE</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_BRA</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_CBRA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name> <operator>!=</operator> <name>OP_CBRA</name> <operator>||</operator> <name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>start</name> <operator>&lt;</operator> <name>EARLY_FAIL_ENHANCE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<do>do
  <block>{<block_content>
  <expr_stmt><expr><name>count</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>next_alt</name> <operator>=</operator> <name>cc</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_CBRA</name><operator>)</operator></expr> ?</condition><then> <expr><name>IMM2_SIZE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

  <while>while <condition>(<expr><name>TRUE</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>accelerated_start</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <switch>switch<condition>(<expr><operator>*</operator><name>cc</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>OP_SOD</name></expr>:</case>
      <case>case <expr><name>OP_SOM</name></expr>:</case>
      <case>case <expr><name>OP_SET_SOM</name></expr>:</case>
      <case>case <expr><name>OP_NOT_WORD_BOUNDARY</name></expr>:</case>
      <case>case <expr><name>OP_WORD_BOUNDARY</name></expr>:</case>
      <case>case <expr><name>OP_EODN</name></expr>:</case>
      <case>case <expr><name>OP_EOD</name></expr>:</case>
      <case>case <expr><name>OP_CIRC</name></expr>:</case>
      <case>case <expr><name>OP_CIRCM</name></expr>:</case>
      <case>case <expr><name>OP_DOLL</name></expr>:</case>
      <case>case <expr><name>OP_DOLLM</name></expr>:</case>
      <comment type="block">/* Zero width assertions. */</comment>
      <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
      <continue>continue;</continue>

      <case>case <expr><name>OP_NOT_DIGIT</name></expr>:</case>
      <case>case <expr><name>OP_DIGIT</name></expr>:</case>
      <case>case <expr><name>OP_NOT_WHITESPACE</name></expr>:</case>
      <case>case <expr><name>OP_WHITESPACE</name></expr>:</case>
      <case>case <expr><name>OP_NOT_WORDCHAR</name></expr>:</case>
      <case>case <expr><name>OP_WORDCHAR</name></expr>:</case>
      <case>case <expr><name>OP_ANY</name></expr>:</case>
      <case>case <expr><name>OP_ALLANY</name></expr>:</case>
      <case>case <expr><name>OP_ANYBYTE</name></expr>:</case>
      <case>case <expr><name>OP_NOT_HSPACE</name></expr>:</case>
      <case>case <expr><name>OP_HSPACE</name></expr>:</case>
      <case>case <expr><name>OP_NOT_VSPACE</name></expr>:</case>
      <case>case <expr><name>OP_VSPACE</name></expr>:</case>
      <expr_stmt><expr><name>fast_forward_allowed</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
      <continue>continue;</continue>

      <case>case <expr><name>OP_ANYNL</name></expr>:</case>
      <case>case <expr><name>OP_EXTUNI</name></expr>:</case>
      <expr_stmt><expr><name>fast_forward_allowed</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
      <continue>continue;</continue>

      <case>case <expr><name>OP_NOTPROP</name></expr>:</case>
      <case>case <expr><name>OP_PROP</name></expr>:</case>
      <expr_stmt><expr><name>fast_forward_allowed</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <continue>continue;</continue>

      <case>case <expr><name>OP_CHAR</name></expr>:</case>
      <case>case <expr><name>OP_CHARI</name></expr>:</case>
      <case>case <expr><name>OP_NOT</name></expr>:</case>
      <case>case <expr><name>OP_NOTI</name></expr>:</case>
      <expr_stmt><expr><name>fast_forward_allowed</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <continue>continue;</continue>

      <case>case <expr><name>OP_TYPESTAR</name></expr>:</case>
      <case>case <expr><name>OP_TYPEMINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_TYPEPLUS</name></expr>:</case>
      <case>case <expr><name>OP_TYPEMINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_TYPEPOSSTAR</name></expr>:</case>
      <case>case <expr><name>OP_TYPEPOSPLUS</name></expr>:</case>
      <comment type="block">/* The type or prop opcode is skipped in the next iteration. */</comment>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>cc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>OP_ANYNL</name> <operator>&amp;&amp;</operator> <name><name>cc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>OP_EXTUNI</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>accelerated_start</name> <operator>=</operator> <name>cc</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
        </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>fast_forward_allowed</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <continue>continue;</continue>

      <case>case <expr><name>OP_TYPEUPTO</name></expr>:</case>
      <case>case <expr><name>OP_TYPEMINUPTO</name></expr>:</case>
      <case>case <expr><name>OP_TYPEEXACT</name></expr>:</case>
      <case>case <expr><name>OP_TYPEPOSUPTO</name></expr>:</case>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through */</comment>

      <case>case <expr><name>OP_TYPEQUERY</name></expr>:</case>
      <case>case <expr><name>OP_TYPEMINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_TYPEPOSQUERY</name></expr>:</case>
      <comment type="block">/* The type or prop opcode is skipped in the next iteration. */</comment>
      <expr_stmt><expr><name>fast_forward_allowed</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <continue>continue;</continue>

      <case>case <expr><name>OP_STAR</name></expr>:</case>
      <case>case <expr><name>OP_MINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_PLUS</name></expr>:</case>
      <case>case <expr><name>OP_MINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_POSSTAR</name></expr>:</case>
      <case>case <expr><name>OP_POSPLUS</name></expr>:</case>

      <case>case <expr><name>OP_STARI</name></expr>:</case>
      <case>case <expr><name>OP_MINSTARI</name></expr>:</case>
      <case>case <expr><name>OP_PLUSI</name></expr>:</case>
      <case>case <expr><name>OP_MINPLUSI</name></expr>:</case>
      <case>case <expr><name>OP_POSSTARI</name></expr>:</case>
      <case>case <expr><name>OP_POSPLUSI</name></expr>:</case>

      <case>case <expr><name>OP_NOTSTAR</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_NOTPLUS</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSSTAR</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSPLUS</name></expr>:</case>

      <case>case <expr><name>OP_NOTSTARI</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINSTARI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPLUSI</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINPLUSI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSSTARI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSPLUSI</name></expr>:</case>
      <expr_stmt><expr><name>accelerated_start</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>

      <case>case <expr><name>OP_UPTO</name></expr>:</case>
      <case>case <expr><name>OP_MINUPTO</name></expr>:</case>
      <case>case <expr><name>OP_EXACT</name></expr>:</case>
      <case>case <expr><name>OP_POSUPTO</name></expr>:</case>
      <case>case <expr><name>OP_UPTOI</name></expr>:</case>
      <case>case <expr><name>OP_MINUPTOI</name></expr>:</case>
      <case>case <expr><name>OP_EXACTI</name></expr>:</case>
      <case>case <expr><name>OP_POSUPTOI</name></expr>:</case>
      <case>case <expr><name>OP_NOTUPTO</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINUPTO</name></expr>:</case>
      <case>case <expr><name>OP_NOTEXACT</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSUPTO</name></expr>:</case>
      <case>case <expr><name>OP_NOTUPTOI</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINUPTOI</name></expr>:</case>
      <case>case <expr><name>OP_NOTEXACTI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSUPTOI</name></expr>:</case>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through */</comment>

      <case>case <expr><name>OP_QUERY</name></expr>:</case>
      <case>case <expr><name>OP_MINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_POSQUERY</name></expr>:</case>
      <case>case <expr><name>OP_QUERYI</name></expr>:</case>
      <case>case <expr><name>OP_MINQUERYI</name></expr>:</case>
      <case>case <expr><name>OP_POSQUERYI</name></expr>:</case>
      <case>case <expr><name>OP_NOTQUERY</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSQUERY</name></expr>:</case>
      <case>case <expr><name>OP_NOTQUERYI</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINQUERYI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSQUERYI</name></expr>:</case>
      <expr_stmt><expr><name>fast_forward_allowed</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <continue>continue;</continue>

      <case>case <expr><name>OP_CLASS</name></expr>:</case>
      <case>case <expr><name>OP_NCLASS</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
      <case>case <expr><name>OP_XCLASS</name></expr>:</case>
      <expr_stmt><expr><name>accelerated_start</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_XCLASS</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name>accelerated_start</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <switch>switch <condition>(<expr><operator>*</operator><name>cc</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>OP_CRSTAR</name></expr>:</case>
        <case>case <expr><name>OP_CRMINSTAR</name></expr>:</case>
        <case>case <expr><name>OP_CRPLUS</name></expr>:</case>
        <case>case <expr><name>OP_CRMINPLUS</name></expr>:</case>
        <case>case <expr><name>OP_CRPOSSTAR</name></expr>:</case>
        <case>case <expr><name>OP_CRPOSPLUS</name></expr>:</case>
        <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>OP_CRRANGE</name></expr>:</case>
        <case>case <expr><name>OP_CRMINRANGE</name></expr>:</case>
        <case>case <expr><name>OP_CRPOSRANGE</name></expr>:</case>
        <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">2</literal> <operator>*</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
        <comment type="block">/* Fall through */</comment>
        <case>case <expr><name>OP_CRQUERY</name></expr>:</case>
        <case>case <expr><name>OP_CRMINQUERY</name></expr>:</case>
        <case>case <expr><name>OP_CRPOSQUERY</name></expr>:</case>
        <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* Fall through */</comment>
        <default>default:</default>
        <expr_stmt><expr><name>accelerated_start</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>fast_forward_allowed</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
        <continue>continue;</continue>
        </block_content>}</block></switch>
      <break>break;</break>

      <case>case <expr><name>OP_ONCE</name></expr>:</case>
      <case>case <expr><name>OP_BRA</name></expr>:</case>
      <case>case <expr><name>OP_CBRA</name></expr>:</case>
      <expr_stmt><expr><name>end</name> <operator>=</operator> <name>cc</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>end</name> <operator>==</operator> <name>OP_KET</name> <operator>&amp;&amp;</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_CBRA</name></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>cc</name> <operator>+=</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
        <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>fast_forward_allowed</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>bracketend</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>end</name> <operator>!=</operator> <name>OP_KET</name> <operator>||</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_CBRA</name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>detect_early_fail</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>private_data_start</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <name>EARLY_FAIL_ENHANCE_MAX</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>cc</name> <operator>=</operator> <name>end</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name><operator>)</operator></expr>;</expr_stmt>
        <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_KET</name></expr>:</case>
      <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&gt;=</operator> <name>next_alt</name></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
      <continue>continue;</continue>
      </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><name>accelerated_start</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>fast_forward_allowed</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>next_alt</name> <operator>==</operator> <name>OP_KET</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>fast_forward_bc_ptr</name></name> <operator>=</operator> <name>accelerated_start</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name><index>[<expr><operator>(</operator><name>accelerated_start</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>private_data_start</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <name>type_skip</name></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>private_data_start</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
          </block_content>}</block></if>
        <else>else
          <block>{<block_content>
          <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name><index>[<expr><operator>(</operator><name>accelerated_start</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>private_data_start</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <name>type_fail</name></expr>;</expr_stmt>

          <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>early_fail_start_ptr</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>early_fail_start_ptr</name></name> <operator>=</operator> <operator>*</operator><name>private_data_start</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

          <expr_stmt><expr><operator>*</operator><name>private_data_start</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>early_fail_end_ptr</name></name> <operator>=</operator> <operator>*</operator><name>private_data_start</name></expr>;</expr_stmt>

          <if_stmt><if>if <condition>(<expr><operator>*</operator><name>private_data_start</name> <operator>&gt;</operator> <name>SLJIT_MAX_LOCAL_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>EARLY_FAIL_ENHANCE_MAX</name></expr>;</return></block_content></block></if></if_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name><index>[<expr><operator>(</operator><name>accelerated_start</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>private_data_start</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <name>type_fail_range</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>early_fail_start_ptr</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>early_fail_start_ptr</name></name> <operator>=</operator> <operator>*</operator><name>private_data_start</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><operator>*</operator><name>private_data_start</name> <operator>+=</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>early_fail_end_ptr</name></name> <operator>=</operator> <operator>*</operator><name>private_data_start</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>private_data_start</name> <operator>&gt;</operator> <name>SLJIT_MAX_LOCAL_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
          <return>return <expr><name>EARLY_FAIL_ENHANCE_MAX</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <name>EARLY_FAIL_ENHANCE_MAX</name></expr>)</condition><block type="pseudo"><block_content>
        <continue>continue;</continue></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

    <break>break;</break>
    </block_content>}</block></while>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>!=</operator> <name>OP_ALT</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cc</name> <operator>!=</operator> <name>OP_KET</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>EARLY_FAIL_ENHANCE_MAX</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>result</name> <operator>&lt;</operator> <name>count</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>fast_forward_allowed</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc</name> <operator>=</operator> <name>next_alt</name></expr>;</expr_stmt>
  </block_content>}</block>
while <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_class_iterator_size</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>sljit_u32</name></type> <name>min</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_u32</name></type> <name>max</name></decl>;</decl_stmt>
<switch>switch<condition>(<expr><operator>*</operator><name>cc</name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><name>OP_CRSTAR</name></expr>:</case>
  <case>case <expr><name>OP_CRPLUS</name></expr>:</case>
  <return>return <expr><literal type="number">2</literal></expr>;</return>

  <case>case <expr><name>OP_CRMINSTAR</name></expr>:</case>
  <case>case <expr><name>OP_CRMINPLUS</name></expr>:</case>
  <case>case <expr><name>OP_CRQUERY</name></expr>:</case>
  <case>case <expr><name>OP_CRMINQUERY</name></expr>:</case>
  <return>return <expr><literal type="number">1</literal></expr>;</return>

  <case>case <expr><name>OP_CRRANGE</name></expr>:</case>
  <case>case <expr><name>OP_CRMINRANGE</name></expr>:</case>
  <expr_stmt><expr><name>min</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>max</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_CRRANGE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>max</name> <operator>-=</operator> <name>min</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>max</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>max</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>max</name></expr>;</return>

  <default>default:</default>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BOOL</name></type> <name>detect_repeat</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>begin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>end</name> <init>= <expr><call><name>bracketend</name><argument_list>(<argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>next_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>max_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_sw</name></type> <name>length</name> <init>= <expr><name>end</name> <operator>-</operator> <name>begin</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_s32</name></type> <name>min</name></decl>, <decl><type ref="prev"/><name>max</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<comment type="block">/* Detect fixed iterations first. */</comment>
<if_stmt><if>if <condition>(<expr><name><name>end</name><index>[<expr><operator>-</operator><operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name><operator>)</operator></expr>]</index></name> <operator>!=</operator> <name>OP_KET</name></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* Already detected repeat. */</comment>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name><index>[<expr><name>end</name> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name> <operator>-</operator> <name>LINK_SIZE</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<expr_stmt><expr><name>min</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>next</name> <operator>!=</operator> <operator>*</operator><name>begin</name></expr>)</condition><block type="pseudo"><block_content>
    <break>break;</break></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>next_end</name> <operator>=</operator> <call><name>bracketend</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>next_end</name> <operator>-</operator> <name>next</name> <operator>!=</operator> <name>length</name> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <break>break;</break></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>next</name> <operator>=</operator> <name>next_end</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>min</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>min</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>max</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>max_end</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>next</name> <operator>==</operator> <name>OP_BRAZERO</name> <operator>||</operator> <operator>*</operator><name>next</name> <operator>==</operator> <name>OP_BRAMINZERO</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>type</name> <operator>=</operator> <operator>*</operator><name>next</name></expr>;</expr_stmt>
  <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>type</name> <operator>||</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>OP_BRA</name> <operator>||</operator> <name><name>next</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>]</index></name> <operator>!=</operator> <operator>*</operator><name>begin</name></expr>)</condition><block type="pseudo"><block_content>
      <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>next_end</name> <operator>=</operator> <call><name>bracketend</name><argument_list>(<argument><expr><name>next</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>next_end</name> <operator>-</operator> <name>next</name> <operator>!=</operator> <operator>(</operator><name>length</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>LINK_SIZE</name><operator>)</operator> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>next</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>next</name> <operator>=</operator> <name>next_end</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>max</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

  <if_stmt><if>if <condition>(<expr><name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>type</name> <operator>&amp;&amp;</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <operator>*</operator><name>begin</name> <operator>&amp;&amp;</operator> <name>max</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>next_end</name> <operator>=</operator> <call><name>bracketend</name><argument_list>(<argument><expr><name>next</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>next_end</name> <operator>-</operator> <name>next</name> <operator>==</operator> <operator>(</operator><name>length</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>next</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>next_end</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>next_end</name> <operator>!=</operator> <name>OP_KET</name></expr>)</condition><block type="pseudo"><block_content>
          <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name><index>[<expr><name>max_end</name> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name> <operator>-</operator> <name>LINK_SIZE</name></expr>]</index></name> <operator>=</operator> <name>next_end</name> <operator>-</operator> <name>max_end</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name><index>[<expr><name>max_end</name> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name> <operator>-</operator> <name>LINK_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>type</name> <operator>==</operator> <name>OP_BRAZERO</name><operator>)</operator></expr> ?</condition><then> <expr><name>OP_UPTO</name></expr> </then><else>: <expr><name>OP_MINUPTO</name></expr></else></ternary></expr>;</expr_stmt>
        <comment type="block">/* +2 the original and the last. */</comment>
        <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name><index>[<expr><name>max_end</name> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name> <operator>-</operator> <name>LINK_SIZE</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>max</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>min</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
          <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>min</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>max_end</name> <operator>-=</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name><operator>)</operator> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>max_end</name></expr></argument>, <argument><expr><operator>-</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>min</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name><index>[<expr><name>end</name> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name> <operator>-</operator> <name>LINK_SIZE</name></expr>]</index></name> <operator>=</operator> <name>max_end</name> <operator>-</operator> <name>end</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name><index>[<expr><name>end</name> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name> <operator>-</operator> <name>LINK_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>OP_EXACT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name><index>[<expr><name>end</name> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name> <operator>-</operator> <name>LINK_SIZE</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>min</name></expr>;</expr_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASE_ITERATOR_PRIVATE_DATA_1</name></cpp:macro> \
    <cpp:value>case OP_MINSTAR: \
    case OP_MINPLUS: \
    case OP_QUERY: \
    case OP_MINQUERY: \
    case OP_MINSTARI: \
    case OP_MINPLUSI: \
    case OP_QUERYI: \
    case OP_MINQUERYI: \
    case OP_NOTMINSTAR: \
    case OP_NOTMINPLUS: \
    case OP_NOTQUERY: \
    case OP_NOTMINQUERY: \
    case OP_NOTMINSTARI: \
    case OP_NOTMINPLUSI: \
    case OP_NOTQUERYI: \
    case OP_NOTMINQUERYI:</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASE_ITERATOR_PRIVATE_DATA_2A</name></cpp:macro> \
    <cpp:value>case OP_STAR: \
    case OP_PLUS: \
    case OP_STARI: \
    case OP_PLUSI: \
    case OP_NOTSTAR: \
    case OP_NOTPLUS: \
    case OP_NOTSTARI: \
    case OP_NOTPLUSI:</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASE_ITERATOR_PRIVATE_DATA_2B</name></cpp:macro> \
    <cpp:value>case OP_UPTO: \
    case OP_MINUPTO: \
    case OP_UPTOI: \
    case OP_MINUPTOI: \
    case OP_NOTUPTO: \
    case OP_NOTMINUPTO: \
    case OP_NOTUPTOI: \
    case OP_NOTMINUPTOI:</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASE_ITERATOR_TYPE_PRIVATE_DATA_1</name></cpp:macro> \
    <cpp:value>case OP_TYPEMINSTAR: \
    case OP_TYPEMINPLUS: \
    case OP_TYPEQUERY: \
    case OP_TYPEMINQUERY:</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASE_ITERATOR_TYPE_PRIVATE_DATA_2A</name></cpp:macro> \
    <cpp:value>case OP_TYPESTAR: \
    case OP_TYPEPLUS:</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASE_ITERATOR_TYPE_PRIVATE_DATA_2B</name></cpp:macro> \
    <cpp:value>case OP_TYPEUPTO: \
    case OP_TYPEMINUPTO:</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_private_data_ptrs</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>private_data_start</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ccend</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name> <init>= <expr><name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>alternative</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>end</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>private_data_ptr</name> <init>= <expr><operator>*</operator><name>private_data_start</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>space</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>bracketlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>repeat_check</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>cc</name> <operator>&lt;</operator> <name>ccend</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>space</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>bracketlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>private_data_ptr</name> <operator>&gt;</operator> <name>SLJIT_MAX_LOCAL_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
    <break>break;</break></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>repeat_check</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ONCE</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_BRA</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_CBRA</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_COND</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>detect_repeat</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <comment type="block">/* These brackets are converted to repeats, so no global
      based single character repeat is allowed. */</comment>
      <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>bracketend</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>repeat_check</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

  <switch>switch<condition>(<expr><operator>*</operator><name>cc</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>OP_KET</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name><index>[<expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name><index>[<expr><name>cc</name> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr>]</index></name> <operator>=</operator> <name>private_data_ptr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>private_data_ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name><index>[<expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_ASSERT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT_NOT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NOT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT_NA</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NA</name></expr>:</case>
    <case>case <expr><name>OP_ONCE</name></expr>:</case>
    <case>case <expr><name>OP_SCRIPT_RUN</name></expr>:</case>
    <case>case <expr><name>OP_BRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SBRA</name></expr>:</case>
    <case>case <expr><name>OP_SBRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SCOND</name></expr>:</case>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name><index>[<expr><name>cc</name> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr>]</index></name> <operator>=</operator> <name>private_data_ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>private_data_ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>bracketlen</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CBRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SCBRAPOS</name></expr>:</case>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name><index>[<expr><name>cc</name> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr>]</index></name> <operator>=</operator> <name>private_data_ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>private_data_ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>bracketlen</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_COND</name></expr>:</case>
    <comment type="block">/* Might be a hidden SCOND. */</comment>
    <expr_stmt><expr><name>alternative</name> <operator>=</operator> <name>cc</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>alternative</name> <operator>==</operator> <name>OP_KETRMAX</name> <operator>||</operator> <operator>*</operator><name>alternative</name> <operator>==</operator> <name>OP_KETRMIN</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name><index>[<expr><name>cc</name> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr>]</index></name> <operator>=</operator> <name>private_data_ptr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>private_data_ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>bracketlen</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_BRA</name></expr>:</case>
    <expr_stmt><expr><name>bracketlen</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CBRA</name></expr>:</case>
    <case>case <expr><name>OP_SCBRA</name></expr>:</case>
    <expr_stmt><expr><name>bracketlen</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_BRAZERO</name></expr>:</case>
    <case>case <expr><name>OP_BRAMINZERO</name></expr>:</case>
    <case>case <expr><name>OP_BRAPOSZERO</name></expr>:</case>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>repeat_check</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <break>break;</break>

    <decl_stmt><decl><type><name>CASE_ITERATOR_PRIVATE_DATA_1</name></type>
    <name>size</name> <init>= <expr><operator>-</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>space</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <break>break;</break>

    <decl_stmt><decl><type><name>CASE_ITERATOR_PRIVATE_DATA_2A</name></type>
    <name>size</name> <init>= <expr><operator>-</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>space</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <break>break;</break>

    <decl_stmt><decl><type><name>CASE_ITERATOR_PRIVATE_DATA_2B</name></type>
    <name>size</name> <init>= <expr><operator>-</operator><operator>(</operator><literal type="number">2</literal> <operator>+</operator> <name>IMM2_SIZE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>space</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <break>break;</break>

    <decl_stmt><decl><type><name>CASE_ITERATOR_TYPE_PRIVATE_DATA_1</name></type>
    <name>size</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>space</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <break>break;</break>

    <decl_stmt><decl><type><name>CASE_ITERATOR_TYPE_PRIVATE_DATA_2A</name></type>
    <name>size</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>OP_ANYNL</name> <operator>&amp;&amp;</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>OP_EXTUNI</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>space</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_TYPEUPTO</name></expr>:</case>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cc</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>]</index></name> <operator>!=</operator> <name>OP_ANYNL</name> <operator>&amp;&amp;</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>]</index></name> <operator>!=</operator> <name>OP_EXTUNI</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>space</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_TYPEMINUPTO</name></expr>:</case>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>space</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CLASS</name></expr>:</case>
    <case>case <expr><name>OP_NCLASS</name></expr>:</case>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>space</name> <operator>=</operator> <call><name>get_class_iterator_size</name><argument_list>(<argument><expr><name>cc</name> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
    <case>case <expr><name>OP_XCLASS</name></expr>:</case>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>space</name> <operator>=</operator> <call><name>get_class_iterator_size</name><argument_list>(<argument><expr><name>cc</name> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <default>default:</default>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>next_opcode</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>cc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch>

  <comment type="block">/* Character iterators, which are not inside a repeated bracket,
     gets a private slot instead of allocating it on the stack. */</comment>
  <if_stmt><if>if <condition>(<expr><name>space</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cc</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name><index>[<expr><name>cc</name> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr>]</index></name> <operator>=</operator> <name>private_data_ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>private_data_ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>space</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <operator>-</operator><name>size</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>bracketlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>bracketend</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>end</name><index>[<expr><operator>-</operator><literal type="number">1</literal> <operator>-</operator> <name>LINK_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_KET</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>end</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <name>bracketlen</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>private_data_start</name> <operator>=</operator> <name>private_data_ptr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Returns with a frame_types (always &lt; 0) if no need for frame. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>get_framesize</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ccend</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>recursive</name></decl></parameter>, <parameter><decl><type><name>BOOL</name> <modifier>*</modifier></type><name>needs_control_head</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>possessive</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>stack_restore</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>setsom_found</name> <init>= <expr><name>recursive</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>setmark_found</name> <init>= <expr><name>recursive</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* The last capture is a local variable even for recursions. */</comment>
<decl_stmt><decl><type><name>BOOL</name></type> <name>capture_last_found</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG_FORCE_CONTROL_HEAD</name> <operator>&amp;&amp;</operator> <name>DEBUG_FORCE_CONTROL_HEAD</name></expr></cpp:if>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>needs_control_head</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><operator>*</operator><name>needs_control_head</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>ccend</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>ccend</name> <operator>=</operator> <call><name>bracketend</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursive</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_CBRAPOS</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_SCBRAPOS</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>possessive</name> <operator>=</operator> <name>length</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">5</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr>;</expr_stmt>
    <comment type="block">/* This is correct regardless of common-&gt;capture_last_ptr. */</comment>
    <expr_stmt><expr><name>capture_last_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>next_opcode</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>cc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>cc</name> <operator>&lt;</operator> <name>ccend</name></expr>)</condition><block type="pseudo"><block_content>
  <switch>switch<condition>(<expr><operator>*</operator><name>cc</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>OP_SET_SOM</name></expr>:</case>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>has_set_som</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>stack_restore</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>setsom_found</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>length</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>setsom_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_MARK</name></expr>:</case>
    <case>case <expr><name>OP_COMMIT_ARG</name></expr>:</case>
    <case>case <expr><name>OP_PRUNE_ARG</name></expr>:</case>
    <case>case <expr><name>OP_THEN_ARG</name></expr>:</case>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>stack_restore</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>setmark_found</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>length</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>setmark_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><operator>*</operator><name>needs_control_head</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_RECURSE</name></expr>:</case>
    <expr_stmt><expr><name>stack_restore</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>has_set_som</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>setsom_found</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>length</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>setsom_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>setmark_found</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>length</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>setmark_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>capture_last_found</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>length</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>capture_last_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CBRA</name></expr>:</case>
    <case>case <expr><name>OP_CBRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SCBRA</name></expr>:</case>
    <case>case <expr><name>OP_SCBRAPOS</name></expr>:</case>
    <expr_stmt><expr><name>stack_restore</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>capture_last_found</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>length</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>capture_last_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>length</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_THEN</name></expr>:</case>
    <expr_stmt><expr><name>stack_restore</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><operator>*</operator><name>needs_control_head</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <default>default:</default>
    <expr_stmt><expr><name>stack_restore</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <comment type="block">/* Fall through. */</comment>

    <case>case <expr><name>OP_NOT_WORD_BOUNDARY</name></expr>:</case>
    <case>case <expr><name>OP_WORD_BOUNDARY</name></expr>:</case>
    <case>case <expr><name>OP_NOT_DIGIT</name></expr>:</case>
    <case>case <expr><name>OP_DIGIT</name></expr>:</case>
    <case>case <expr><name>OP_NOT_WHITESPACE</name></expr>:</case>
    <case>case <expr><name>OP_WHITESPACE</name></expr>:</case>
    <case>case <expr><name>OP_NOT_WORDCHAR</name></expr>:</case>
    <case>case <expr><name>OP_WORDCHAR</name></expr>:</case>
    <case>case <expr><name>OP_ANY</name></expr>:</case>
    <case>case <expr><name>OP_ALLANY</name></expr>:</case>
    <case>case <expr><name>OP_ANYBYTE</name></expr>:</case>
    <case>case <expr><name>OP_NOTPROP</name></expr>:</case>
    <case>case <expr><name>OP_PROP</name></expr>:</case>
    <case>case <expr><name>OP_ANYNL</name></expr>:</case>
    <case>case <expr><name>OP_NOT_HSPACE</name></expr>:</case>
    <case>case <expr><name>OP_HSPACE</name></expr>:</case>
    <case>case <expr><name>OP_NOT_VSPACE</name></expr>:</case>
    <case>case <expr><name>OP_VSPACE</name></expr>:</case>
    <case>case <expr><name>OP_EXTUNI</name></expr>:</case>
    <case>case <expr><name>OP_EODN</name></expr>:</case>
    <case>case <expr><name>OP_EOD</name></expr>:</case>
    <case>case <expr><name>OP_CIRC</name></expr>:</case>
    <case>case <expr><name>OP_CIRCM</name></expr>:</case>
    <case>case <expr><name>OP_DOLL</name></expr>:</case>
    <case>case <expr><name>OP_DOLLM</name></expr>:</case>
    <case>case <expr><name>OP_CHAR</name></expr>:</case>
    <case>case <expr><name>OP_CHARI</name></expr>:</case>
    <case>case <expr><name>OP_NOT</name></expr>:</case>
    <case>case <expr><name>OP_NOTI</name></expr>:</case>

    <case>case <expr><name>OP_EXACT</name></expr>:</case>
    <case>case <expr><name>OP_POSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_POSPLUS</name></expr>:</case>
    <case>case <expr><name>OP_POSQUERY</name></expr>:</case>
    <case>case <expr><name>OP_POSUPTO</name></expr>:</case>

    <case>case <expr><name>OP_EXACTI</name></expr>:</case>
    <case>case <expr><name>OP_POSSTARI</name></expr>:</case>
    <case>case <expr><name>OP_POSPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_POSQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_POSUPTOI</name></expr>:</case>

    <case>case <expr><name>OP_NOTEXACT</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSPLUS</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSQUERY</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSUPTO</name></expr>:</case>

    <case>case <expr><name>OP_NOTEXACTI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSSTARI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSUPTOI</name></expr>:</case>

    <case>case <expr><name>OP_TYPEEXACT</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSPLUS</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSQUERY</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSUPTO</name></expr>:</case>

    <case>case <expr><name>OP_CLASS</name></expr>:</case>
    <case>case <expr><name>OP_NCLASS</name></expr>:</case>
    <case>case <expr><name>OP_XCLASS</name></expr>:</case>

    <case>case <expr><name>OP_CALLOUT</name></expr>:</case>
    <case>case <expr><name>OP_CALLOUT_STR</name></expr>:</case>

    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>next_opcode</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>cc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch></block_content></block></while>

<comment type="block">/* Possessive quantifiers can use a special case. */</comment>
<if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><name>possessive</name> <operator>==</operator> <name>length</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><ternary><condition><expr><name>stack_restore</name></expr> ?</condition><then> <expr><name>no_frame</name></expr> </then><else>: <expr><name>no_stack</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>length</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><ternary><condition><expr><name>stack_restore</name></expr> ?</condition><then> <expr><name>no_frame</name></expr> </then><else>: <expr><name>no_stack</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>init_frame</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ccend</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stackpos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stacktop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>setsom_found</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>setmark_found</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* The last capture is a local variable even for recursions. */</comment>
<decl_stmt><decl><type><name>BOOL</name></type> <name>capture_last_found</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>

<comment type="block">/* &gt;= 1 + shortest item size (2) */</comment>
<expr_stmt><expr><call><name>SLJIT_UNUSED_ARG</name><argument_list>(<argument><expr><name>stacktop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>stackpos</name> <operator>&gt;=</operator> <name>stacktop</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>stackpos</name> <operator>=</operator> <call><name>STACK</name><argument_list>(<argument><expr><name>stackpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ccend</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>ccend</name> <operator>=</operator> <call><name>bracketend</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>!=</operator> <name>OP_CBRAPOS</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cc</name> <operator>!=</operator> <name>OP_SCBRAPOS</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>next_opcode</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>cc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>cc</name> <operator>&lt;</operator> <name>ccend</name></expr>)</condition><block type="pseudo"><block_content>
  <switch>switch<condition>(<expr><operator>*</operator><name>cc</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>OP_SET_SOM</name></expr>:</case>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>has_set_som</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>setsom_found</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stackpos</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>-</operator><call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>stackpos</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stackpos</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>stackpos</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><name>setsom_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_MARK</name></expr>:</case>
    <case>case <expr><name>OP_COMMIT_ARG</name></expr>:</case>
    <case>case <expr><name>OP_PRUNE_ARG</name></expr>:</case>
    <case>case <expr><name>OP_THEN_ARG</name></expr>:</case>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>setmark_found</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stackpos</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>-</operator><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>stackpos</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stackpos</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>stackpos</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><name>setmark_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_RECURSE</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>has_set_som</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>setsom_found</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stackpos</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>-</operator><call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>stackpos</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stackpos</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>stackpos</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><name>setsom_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>setmark_found</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stackpos</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>-</operator><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>stackpos</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stackpos</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>stackpos</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><name>setmark_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>capture_last_found</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stackpos</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>-</operator><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>stackpos</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stackpos</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>stackpos</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><name>capture_last_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CBRA</name></expr>:</case>
    <case>case <expr><name>OP_CBRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SCBRA</name></expr>:</case>
    <case>case <expr><name>OP_SCBRAPOS</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>capture_last_found</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stackpos</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>-</operator><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>stackpos</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stackpos</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>stackpos</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><name>capture_last_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stackpos</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>stackpos</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stackpos</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>stackpos</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stackpos</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>stackpos</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <default>default:</default>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>next_opcode</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>cc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch></block_content></block></while>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stackpos</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>stackpos</name> <operator>==</operator> <call><name>STACK</name><argument_list>(<argument><expr><name>stacktop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECURSE_TMP_REG_COUNT</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>delayed_mem_copy_status</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name><name>store_bases</name><index>[<expr><name>RECURSE_TMP_REG_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name><name>store_offsets</name><index>[<expr><name>RECURSE_TMP_REG_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name><name>tmp_regs</name><index>[<expr><name>RECURSE_TMP_REG_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name><name>saved_tmp_regs</name><index>[<expr><name>RECURSE_TMP_REG_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>next_tmp_reg</name></decl>;</decl_stmt>
}</block></struct></type> <name>delayed_mem_copy_status</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>delayed_mem_copy_init</name><parameter_list>(<parameter><decl><type><name>delayed_mem_copy_status</name> <modifier>*</modifier></type><name>status</name></decl></parameter>, <parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>RECURSE_TMP_REG_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>status</name><operator>-&gt;</operator><name>tmp_regs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><call><name>sljit_get_register_index</name><argument_list>(<argument><expr><name><name>status</name><operator>-&gt;</operator><name>saved_tmp_regs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>status</name><operator>-&gt;</operator><name>tmp_regs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>status</name><operator>-&gt;</operator><name>saved_tmp_regs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>store_bases</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
<expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>next_tmp_reg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>compiler</name></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>compiler</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>delayed_mem_copy_move</name><parameter_list>(<parameter><decl><type><name>delayed_mem_copy_status</name> <modifier>*</modifier></type><name>status</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>load_base</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>load_offset</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>store_base</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>store_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name> <init>= <expr><name><name>status</name><operator>-&gt;</operator><name>compiler</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>next_tmp_reg</name> <init>= <expr><name><name>status</name><operator>-&gt;</operator><name>next_tmp_reg</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tmp_reg</name> <init>= <expr><name><name>status</name><operator>-&gt;</operator><name>tmp_regs</name><index>[<expr><name>next_tmp_reg</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>load_base</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>store_base</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>status</name><operator>-&gt;</operator><name>store_bases</name><index>[<expr><name>next_tmp_reg</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Preserve virtual registers. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>sljit_get_register_index</name><argument_list>(<argument><expr><name><name>status</name><operator>-&gt;</operator><name>saved_tmp_regs</name><index>[<expr><name>next_tmp_reg</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name><name>status</name><operator>-&gt;</operator><name>saved_tmp_regs</name><index>[<expr><name>next_tmp_reg</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tmp_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name><name>status</name><operator>-&gt;</operator><name>store_bases</name><index>[<expr><name>next_tmp_reg</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>status</name><operator>-&gt;</operator><name>store_offsets</name><index>[<expr><name>next_tmp_reg</name></expr>]</index></name></expr></argument>, <argument><expr><name>tmp_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>tmp_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>load_base</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>load_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>store_bases</name><index>[<expr><name>next_tmp_reg</name></expr>]</index></name> <operator>=</operator> <name>store_base</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>store_offsets</name><index>[<expr><name>next_tmp_reg</name></expr>]</index></name> <operator>=</operator> <name>store_offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>next_tmp_reg</name></name> <operator>=</operator> <operator>(</operator><name>next_tmp_reg</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>RECURSE_TMP_REG_COUNT</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>delayed_mem_copy_finish</name><parameter_list>(<parameter><decl><type><name>delayed_mem_copy_status</name> <modifier>*</modifier></type><name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name> <init>= <expr><name><name>status</name><operator>-&gt;</operator><name>compiler</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>next_tmp_reg</name> <init>= <expr><name><name>status</name><operator>-&gt;</operator><name>next_tmp_reg</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tmp_reg</name></decl>, <decl><type ref="prev"/><name>saved_tmp_reg</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>RECURSE_TMP_REG_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>status</name><operator>-&gt;</operator><name>store_bases</name><index>[<expr><name>next_tmp_reg</name></expr>]</index></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>tmp_reg</name> <operator>=</operator> <name><name>status</name><operator>-&gt;</operator><name>tmp_regs</name><index>[<expr><name>next_tmp_reg</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>saved_tmp_reg</name> <operator>=</operator> <name><name>status</name><operator>-&gt;</operator><name>saved_tmp_regs</name><index>[<expr><name>next_tmp_reg</name></expr>]</index></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name><name>status</name><operator>-&gt;</operator><name>store_bases</name><index>[<expr><name>next_tmp_reg</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>status</name><operator>-&gt;</operator><name>store_offsets</name><index>[<expr><name>next_tmp_reg</name></expr>]</index></name></expr></argument>, <argument><expr><name>tmp_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Restore virtual registers. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>sljit_get_register_index</name><argument_list>(<argument><expr><name>saved_tmp_reg</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>tmp_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>saved_tmp_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>next_tmp_reg</name> <operator>=</operator> <operator>(</operator><name>next_tmp_reg</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>RECURSE_TMP_REG_COUNT</name></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RECURSE_TMP_REG_COUNT</name></cpp:undef>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_recurse_data_length</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ccend</name></decl></parameter>,
  <parameter><decl><type><name>BOOL</name> <modifier>*</modifier></type><name>needs_control_head</name></decl></parameter>, <parameter><decl><type><name>BOOL</name> <modifier>*</modifier></type><name>has_quit</name></decl></parameter>, <parameter><decl><type><name>BOOL</name> <modifier>*</modifier></type><name>has_accept</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>alternative</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>quit_found</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>accept_found</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>setsom_found</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>setmark_found</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>capture_last_found</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>control_head_found</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG_FORCE_CONTROL_HEAD</name> <operator>&amp;&amp;</operator> <name>DEBUG_FORCE_CONTROL_HEAD</name></expr></cpp:if>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>control_head_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Calculate the sum of the private machine words. */</comment>
<while>while <condition>(<expr><name>cc</name> <operator>&lt;</operator> <name>ccend</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <switch>switch<condition>(<expr><operator>*</operator><name>cc</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>OP_SET_SOM</name></expr>:</case>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>has_set_som</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>setsom_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_RECURSE</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>has_set_som</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>setsom_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>setmark_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>capture_last_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_KET</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>length</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_ASSERT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT_NOT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NOT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT_NA</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NA</name></expr>:</case>
    <case>case <expr><name>OP_ONCE</name></expr>:</case>
    <case>case <expr><name>OP_SCRIPT_RUN</name></expr>:</case>
    <case>case <expr><name>OP_BRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SBRA</name></expr>:</case>
    <case>case <expr><name>OP_SBRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SCOND</name></expr>:</case>
    <expr_stmt><expr><name>length</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CBRA</name></expr>:</case>
    <case>case <expr><name>OP_SCBRA</name></expr>:</case>
    <expr_stmt><expr><name>length</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>capture_last_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>length</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CBRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SCBRAPOS</name></expr>:</case>
    <expr_stmt><expr><name>length</name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>capture_last_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_COND</name></expr>:</case>
    <comment type="block">/* Might be a hidden SCOND. */</comment>
    <expr_stmt><expr><name>alternative</name> <operator>=</operator> <name>cc</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>alternative</name> <operator>==</operator> <name>OP_KETRMAX</name> <operator>||</operator> <operator>*</operator><name>alternative</name> <operator>==</operator> <name>OP_KETRMIN</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>length</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <macro><name>CASE_ITERATOR_PRIVATE_DATA_1</name></macro>
    <if_stmt><if>if <condition>(<expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>length</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>

    <macro><name>CASE_ITERATOR_PRIVATE_DATA_2A</name></macro>
    <if_stmt><if>if <condition>(<expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>length</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>

    <macro><name>CASE_ITERATOR_PRIVATE_DATA_2B</name></macro>
    <if_stmt><if>if <condition>(<expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>length</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>

    <macro><name>CASE_ITERATOR_TYPE_PRIVATE_DATA_1</name></macro>
    <if_stmt><if>if <condition>(<expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>length</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <break>break;</break>

    <macro><name>CASE_ITERATOR_TYPE_PRIVATE_DATA_2A</name></macro>
    <if_stmt><if>if <condition>(<expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>length</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <break>break;</break>

    <macro><name>CASE_ITERATOR_TYPE_PRIVATE_DATA_2B</name></macro>
    <if_stmt><if>if <condition>(<expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>length</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CLASS</name></expr>:</case>
    <case>case <expr><name>OP_NCLASS</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
    <case>case <expr><name>OP_XCLASS</name></expr>:</case>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_XCLASS</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">32</literal> <operator>/</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof></expr></else></ternary></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">32</literal> <operator>/</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>length</name> <operator>+=</operator> <call><name>get_class_iterator_size</name><argument_list>(<argument><expr><name>cc</name> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_MARK</name></expr>:</case>
    <case>case <expr><name>OP_COMMIT_ARG</name></expr>:</case>
    <case>case <expr><name>OP_PRUNE_ARG</name></expr>:</case>
    <case>case <expr><name>OP_THEN_ARG</name></expr>:</case>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>setmark_found</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>setmark_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>control_head_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>!=</operator> <name>OP_MARK</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>quit_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_PRUNE</name></expr>:</case>
    <case>case <expr><name>OP_SKIP</name></expr>:</case>
    <case>case <expr><name>OP_COMMIT</name></expr>:</case>
    <expr_stmt><expr><name>quit_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_SKIP_ARG</name></expr>:</case>
    <expr_stmt><expr><name>quit_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_THEN</name></expr>:</case>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>quit_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>control_head_found</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>control_head_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_ACCEPT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT_ACCEPT</name></expr>:</case>
    <expr_stmt><expr><name>accept_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <default>default:</default>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>next_opcode</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>cc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></while>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>cc</name> <operator>==</operator> <name>ccend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>control_head_found</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>length</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>capture_last_found</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>length</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>quit_found</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>setsom_found</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>length</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>setmark_found</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>length</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>needs_control_head</name> <operator>=</operator> <name>control_head_found</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>has_quit</name> <operator>=</operator> <name>quit_found</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>has_accept</name> <operator>=</operator> <name>accept_found</name></expr>;</expr_stmt>
<return>return <expr><name>length</name></expr>;</return>
</block_content>}</block></function>

<enum>enum <name>copy_recurse_data_types</name> <block>{
  <decl><name>recurse_copy_from_global</name></decl>,
  <decl><name>recurse_copy_private_to_global</name></decl>,
  <decl><name>recurse_copy_shared_to_global</name></decl>,
  <decl><name>recurse_copy_kept_shared_to_global</name></decl>,
  <decl><name>recurse_swap_global</name></decl>
}</block>;</enum>

<function><type><specifier>static</specifier> <name>void</name></type> <name>copy_recurse_data</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ccend</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stackptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stacktop</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>has_quit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>delayed_mem_copy_status</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>alternative</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_sw</name></type> <name><name>private_srcw</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_sw</name></type> <name><name>shared_srcw</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_sw</name></type> <name><name>kept_shared_srcw</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>private_count</name></decl>, <decl><type ref="prev"/><name>shared_count</name></decl>, <decl><type ref="prev"/><name>kept_shared_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>from_sp</name></decl>, <decl><type ref="prev"/><name>base_reg</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>setsom_found</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>setmark_found</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>capture_last_found</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>control_head_found</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG_FORCE_CONTROL_HEAD</name> <operator>&amp;&amp;</operator> <name>DEBUG_FORCE_CONTROL_HEAD</name></expr></cpp:if>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>control_head_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><name>recurse_copy_from_global</name></expr>:</case>
  <expr_stmt><expr><name>from_sp</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>base_reg</name> <operator>=</operator> <name>STACK_TOP</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>recurse_copy_private_to_global</name></expr>:</case>
  <case>case <expr><name>recurse_copy_shared_to_global</name></expr>:</case>
  <case>case <expr><name>recurse_copy_kept_shared_to_global</name></expr>:</case>
  <expr_stmt><expr><name>from_sp</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>base_reg</name> <operator>=</operator> <name>STACK_TOP</name></expr>;</expr_stmt>
  <break>break;</break>

  <default>default:</default>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>recurse_swap_global</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>from_sp</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>base_reg</name> <operator>=</operator> <name>TMP2</name></expr>;</expr_stmt>
  <break>break;</break>
  </block_content>}</block></switch>

<expr_stmt><expr><name>stackptr</name> <operator>=</operator> <call><name>STACK</name><argument_list>(<argument><expr><name>stackptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>stacktop</name> <operator>=</operator> <call><name>STACK</name><argument_list>(<argument><expr><name>stacktop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>status</name><operator>.</operator><name>tmp_regs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>TMP1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>status</name><operator>.</operator><name>saved_tmp_regs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>TMP1</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>base_reg</name> <operator>!=</operator> <name>TMP2</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>status</name><operator>.</operator><name>tmp_regs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>TMP2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>status</name><operator>.</operator><name>saved_tmp_regs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>TMP2</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><name><name>status</name><operator>.</operator><name>saved_tmp_regs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>RETURN_ADDR</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>status</name><operator>.</operator><name>tmp_regs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>STR_PTR</name></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>status</name><operator>.</operator><name>tmp_regs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>RETURN_ADDR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>status</name><operator>.</operator><name>saved_tmp_regs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>TMP3</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>status</name><operator>.</operator><name>tmp_regs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>STR_END</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>status</name><operator>.</operator><name>tmp_regs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>TMP3</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>delayed_mem_copy_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>recurse_copy_shared_to_global</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>!=</operator> <name>recurse_copy_kept_shared_to_global</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>recurse_copy_from_global</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>recurse_copy_private_to_global</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>recurse_swap_global</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>from_sp</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>delayed_mem_copy_move</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>base_reg</name></expr></argument>, <argument><expr><name>stackptr</name></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>recursive_head_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>from_sp</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>recurse_swap_global</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>delayed_mem_copy_move</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>recursive_head_ptr</name></name></expr></argument>, <argument><expr><name>base_reg</name></expr></argument>, <argument><expr><name>stackptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>stackptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG_FORCE_CONTROL_HEAD</name> <operator>&amp;&amp;</operator> <name>DEBUG_FORCE_CONTROL_HEAD</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>recurse_copy_shared_to_global</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>from_sp</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>delayed_mem_copy_move</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>base_reg</name></expr></argument>, <argument><expr><name>stackptr</name></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>from_sp</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>recurse_swap_global</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>delayed_mem_copy_move</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>, <argument><expr><name>base_reg</name></expr></argument>, <argument><expr><name>stackptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>stackptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<while>while <condition>(<expr><name>cc</name> <operator>&lt;</operator> <name>ccend</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>private_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>shared_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>kept_shared_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <switch>switch<condition>(<expr><operator>*</operator><name>cc</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>OP_SET_SOM</name></expr>:</case>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>has_set_som</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>has_quit</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>setsom_found</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>kept_shared_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>kept_shared_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>setsom_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_RECURSE</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>has_quit</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>has_set_som</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>setsom_found</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name><name>kept_shared_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>kept_shared_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>setsom_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>setmark_found</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name><name>kept_shared_srcw</name><index>[<expr><name>kept_shared_count</name></expr>]</index></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>kept_shared_count</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>setmark_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>capture_last_found</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>shared_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>shared_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>capture_last_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_KET</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>private_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_ASSERT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT_NOT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NOT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT_NA</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NA</name></expr>:</case>
    <case>case <expr><name>OP_ONCE</name></expr>:</case>
    <case>case <expr><name>OP_SCRIPT_RUN</name></expr>:</case>
    <case>case <expr><name>OP_BRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SBRA</name></expr>:</case>
    <case>case <expr><name>OP_SBRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SCOND</name></expr>:</case>
    <expr_stmt><expr><name>private_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CBRA</name></expr>:</case>
    <case>case <expr><name>OP_SCBRA</name></expr>:</case>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>shared_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>shared_srcw</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>shared_count</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>capture_last_found</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>shared_srcw</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>shared_count</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>capture_last_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>private_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>OVECTOR_PRIV</name><argument_list>(<argument><expr><call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CBRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SCBRAPOS</name></expr>:</case>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>shared_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>shared_srcw</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>shared_count</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>capture_last_found</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>shared_srcw</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>shared_count</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>capture_last_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>private_count</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>OVECTOR_PRIV</name><argument_list>(<argument><expr><call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_COND</name></expr>:</case>
    <comment type="block">/* Might be a hidden SCOND. */</comment>
    <expr_stmt><expr><name>alternative</name> <operator>=</operator> <name>cc</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>alternative</name> <operator>==</operator> <name>OP_KETRMAX</name> <operator>||</operator> <operator>*</operator><name>alternative</name> <operator>==</operator> <name>OP_KETRMIN</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>private_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <macro><name>CASE_ITERATOR_PRIVATE_DATA_1</name></macro>
    <if_stmt><if>if <condition>(<expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>private_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>

    <macro><name>CASE_ITERATOR_PRIVATE_DATA_2A</name></macro>
    <if_stmt><if>if <condition>(<expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>private_count</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>

    <macro><name>CASE_ITERATOR_PRIVATE_DATA_2B</name></macro>
    <if_stmt><if>if <condition>(<expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>private_count</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>

    <macro><name>CASE_ITERATOR_TYPE_PRIVATE_DATA_1</name></macro>
    <if_stmt><if>if <condition>(<expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>private_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <break>break;</break>

    <macro><name>CASE_ITERATOR_TYPE_PRIVATE_DATA_2A</name></macro>
    <if_stmt><if>if <condition>(<expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>private_count</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>private_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <break>break;</break>

    <macro><name>CASE_ITERATOR_TYPE_PRIVATE_DATA_2B</name></macro>
    <if_stmt><if>if <condition>(<expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>private_count</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>private_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CLASS</name></expr>:</case>
    <case>case <expr><name>OP_NCLASS</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
    <case>case <expr><name>OP_XCLASS</name></expr>:</case>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_XCLASS</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">32</literal> <operator>/</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof></expr></else></ternary></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">32</literal> <operator>/</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <switch>switch<condition>(<expr><call><name>get_class_iterator_size</name><argument_list>(<argument><expr><name>cc</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><literal type="number">1</literal></expr>:</case>
        <expr_stmt><expr><name>private_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><literal type="number">2</literal></expr>:</case>
        <expr_stmt><expr><name>private_count</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>private_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <break>break;</break>

        <default>default:</default>
        <expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
        </block_content>}</block></switch></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_MARK</name></expr>:</case>
    <case>case <expr><name>OP_COMMIT_ARG</name></expr>:</case>
    <case>case <expr><name>OP_PRUNE_ARG</name></expr>:</case>
    <case>case <expr><name>OP_THEN_ARG</name></expr>:</case>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>has_quit</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>setmark_found</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>kept_shared_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>kept_shared_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>setmark_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>control_head_found</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>private_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>control_head_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_THEN</name></expr>:</case>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>control_head_found</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>private_srcw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>private_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>control_head_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <default>default:</default>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>next_opcode</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>cc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch>

  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>recurse_copy_shared_to_global</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>!=</operator> <name>recurse_copy_kept_shared_to_global</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>recurse_copy_from_global</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>recurse_copy_private_to_global</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>recurse_swap_global</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>private_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
      <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>private_srcw</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>from_sp</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>delayed_mem_copy_move</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>base_reg</name></expr></argument>, <argument><expr><name>stackptr</name></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><name><name>private_srcw</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>from_sp</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>recurse_swap_global</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>delayed_mem_copy_move</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><name><name>private_srcw</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>base_reg</name></expr></argument>, <argument><expr><name>stackptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>stackptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>stackptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>private_count</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>recurse_copy_private_to_global</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>!=</operator> <name>recurse_copy_kept_shared_to_global</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>recurse_copy_from_global</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>recurse_copy_shared_to_global</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>recurse_swap_global</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>shared_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
      <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>shared_srcw</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>from_sp</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>delayed_mem_copy_move</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>base_reg</name></expr></argument>, <argument><expr><name>stackptr</name></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><name><name>shared_srcw</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>from_sp</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>recurse_swap_global</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>delayed_mem_copy_move</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><name><name>shared_srcw</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>base_reg</name></expr></argument>, <argument><expr><name>stackptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>stackptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>stackptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>shared_count</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>recurse_copy_private_to_global</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>!=</operator> <name>recurse_swap_global</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>recurse_copy_from_global</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>recurse_copy_shared_to_global</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>recurse_copy_kept_shared_to_global</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>kept_shared_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
      <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>kept_shared_srcw</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>from_sp</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>delayed_mem_copy_move</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>base_reg</name></expr></argument>, <argument><expr><name>stackptr</name></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><name><name>kept_shared_srcw</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>from_sp</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>recurse_swap_global</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>delayed_mem_copy_move</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>SLJIT_SP</name></expr></argument>, <argument><expr><name><name>kept_shared_srcw</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>base_reg</name></expr></argument>, <argument><expr><name>stackptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>stackptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>stackptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>kept_shared_count</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></while>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>cc</name> <operator>==</operator> <name>ccend</name> <operator>&amp;&amp;</operator> <name>stackptr</name> <operator>==</operator> <name>stacktop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>delayed_mem_copy_finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>PCRE2_SPTR</name></type> <name>set_then_offsets</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>current_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>end</name> <init>= <expr><call><name>bracketend</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>has_alternatives</name> <init>= <expr><name><name>cc</name><index>[<expr><call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>==</operator> <name>OP_ALT</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Assert captures then. */</comment>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>&gt;=</operator> <name>OP_ASSERT</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cc</name> <operator>&lt;=</operator> <name>OP_ASSERTBACK_NA</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>current_offset</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<comment type="block">/* Conditional block does not. */</comment>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_COND</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_SCOND</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>has_alternatives</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>next_opcode</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_alternatives</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>current_offset</name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>then_offsets</name></name> <operator>+</operator> <operator>(</operator><name>cc</name> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>cc</name> <operator>&lt;</operator> <name>end</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>cc</name> <operator>&gt;=</operator> <name>OP_ASSERT</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cc</name> <operator>&lt;=</operator> <name>OP_ASSERTBACK_NA</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>*</operator><name>cc</name> <operator>&gt;=</operator> <name>OP_ONCE</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cc</name> <operator>&lt;=</operator> <name>OP_SCOND</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>set_then_offsets</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>current_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ALT</name> <operator>&amp;&amp;</operator> <name>has_alternatives</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>current_offset</name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>then_offsets</name></name> <operator>+</operator> <operator>(</operator><name>cc</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>&gt;=</operator> <name>OP_THEN</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cc</name> <operator>&lt;=</operator> <name>OP_THEN_ARG</name> <operator>&amp;&amp;</operator> <name>current_offset</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><operator>*</operator><name>current_offset</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>next_opcode</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>

<return>return <expr><name>end</name></expr>;</return>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CASE_ITERATOR_PRIVATE_DATA_1</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CASE_ITERATOR_PRIVATE_DATA_2A</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CASE_ITERATOR_PRIVATE_DATA_2B</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CASE_ITERATOR_TYPE_PRIVATE_DATA_1</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CASE_ITERATOR_TYPE_PRIVATE_DATA_2A</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CASE_ITERATOR_TYPE_PRIVATE_DATA_2B</name></cpp:undef>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>BOOL</name></type> <name>is_powerof2</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>value</name> <operator>&amp;</operator> <operator>(</operator><name>value</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>set_jumps</name><parameter_list>(<parameter><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>label</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name>list</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* sljit_set_label is clever enough to do nothing
  if either the jump or the label is NULL. */</comment>
  <expr_stmt><expr><call><name>SET_LABEL</name><argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>add_jump</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>list_item</name> <init>= <expr><call><name>sljit_alloc_memory</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>jump_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>list_item</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>list_item</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>*</operator><name>list</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>list_item</name><operator>-&gt;</operator><name>jump</name></name> <operator>=</operator> <name>jump</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>list</name> <operator>=</operator> <name>list_item</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_stub</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>stub_list</name> <modifier>*</modifier></type><name>list_item</name> <init>= <expr><call><name>sljit_alloc_memory</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>stub_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>list_item</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>list_item</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>list_item</name><operator>-&gt;</operator><name>quit</name></name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>list_item</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>stubs</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>stubs</name></name> <operator>=</operator> <name>list_item</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>flush_stubs</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>stub_list</name> <modifier>*</modifier></type><name>list_item</name> <init>= <expr><name><name>common</name><operator>-&gt;</operator><name>stubs</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>list_item</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>list_item</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>stackalloc</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name><name>list_item</name><operator>-&gt;</operator><name>quit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>list_item</name> <operator>=</operator> <name><name>list_item</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>stubs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>count_match</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>COUNT_MATCH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>COUNT_MATCH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>calllimit</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_ZERO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>allocate_stack</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* May destroy all locals and registers except TMP2. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DESTROY_REGISTERS</name></cpp:ifdef>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">12345</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS0</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS1</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>add_stub</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_LIMIT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>free_stack</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sljit_uw</name> <modifier>*</modifier></type> <name>allocate_read_only_data</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>sljit_uw</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>sljit_uw</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><call><name>sljit_get_compiler_error</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>sljit_uw</name> <operator>*</operator><operator>)</operator><call><name>SLJIT_MALLOC</name><argument_list>(<argument><expr><name>size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_uw</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>compiler</name><operator>-&gt;</operator><name>allocator_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><name>result</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>sljit_set_compiler_memory_error</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><name>result</name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>read_only_data_head</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>read_only_data_head</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>result</name></expr>;</expr_stmt>
<return>return <expr><name>result</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>reset_ovector</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>loop</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_s32</name></type> <name>i</name></decl>;</decl_stmt>

<comment type="block">/* At this point we can freely use all temporary registers. */</comment>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>length</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* TMP1 returns with begin - 1. */</comment>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_S0</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition>
  <block>{<block_content>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_MOV</name> <operator>|</operator> <name>SLJIT_MEM_SUPP</name> <operator>|</operator> <name>SLJIT_MEM_STORE</name> <operator>|</operator> <name>SLJIT_MEM_PRE</name></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_R1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <name>SLJIT_SUCCESS</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>GET_LOCAL_BASE</name><argument_list>(<argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OVECTOR_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>length</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_MOV</name> <operator>|</operator> <name>SLJIT_MEM_STORE</name> <operator>|</operator> <name>SLJIT_MEM_PRE</name></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_R1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>GET_LOCAL_BASE</name><argument_list>(<argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OVECTOR_START</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>length</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_R1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>reset_early_fail</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>sljit_u32</name></type> <name>size</name> <init>= <expr><operator>(</operator><name>sljit_u32</name><operator>)</operator><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>early_fail_end_ptr</name></name> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>early_fail_start_ptr</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_u32</name></type> <name>uncleared_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_s32</name></type> <name>src</name> <init>= <expr><name>SLJIT_IMM</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_s32</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>loop</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>early_fail_start_ptr</name></name> <operator>&lt;</operator> <name><name>common</name><operator>-&gt;</operator><name>early_fail_end_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>early_fail_start_ptr</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>sljit_get_register_index</name><argument_list>(<argument><expr><name>TMP3</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>sljit_has_cpu_feature</name><argument_list>(<argument><expr><name>SLJIT_HAS_ZERO_REGISTER</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>src</name> <operator>=</operator> <name>TMP3</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;=</operator> <literal type="number">6</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
  <block>{<block_content>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>early_fail_start_ptr</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>common</name><operator>-&gt;</operator><name>early_fail_end_ptr</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <return>return;</return>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>GET_LOCAL_BASE</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>early_fail_start_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>uncleared_size</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>size</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>%</operator> <literal type="number">3</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>uncleared_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>sljit_sw</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal> <operator>*</operator> <operator>(</operator><name>sljit_sw</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>uncleared_size</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>uncleared_size</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>do_reset_match</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>loop</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>length</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* OVECTOR(1) contains the "string begin - 1" constant. */</comment>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition>
  <block>{<block_content>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_MOV</name> <operator>|</operator> <name>SLJIT_MEM_SUPP</name> <operator>|</operator> <name>SLJIT_MEM_STORE</name> <operator>|</operator> <name>SLJIT_MEM_PRE</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <name>SLJIT_SUCCESS</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>GET_LOCAL_BASE</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OVECTOR_START</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>length</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_MOV</name> <operator>|</operator> <name>SLJIT_MEM_STORE</name> <operator>|</operator> <name>SLJIT_MEM_PRE</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>GET_LOCAL_BASE</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OVECTOR_START</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>length</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr>struct <name>sljit_stack</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sljit_sw</name> <name>SLJIT_FUNC</name></type> <name>do_search_mark</name><parameter_list>(<parameter><decl><type><name>sljit_sw</name> <modifier>*</modifier></type><name>current</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>skip_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name>current</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <switch>switch <condition>(<expr><name><name>current</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>type_then_trap</name></expr>:</case>
    <break>break;</break>

    <case>case <expr><name>type_mark</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><call><call><name>PRIV</name><argument_list>(<argument><expr><name>strcmp</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>skip_arg</name></expr></argument>, <argument><expr><operator>(</operator><name>PCRE2_SPTR</name><operator>)</operator><name><name>current</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name><name>current</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
    <break>break;</break>

    <default>default:</default>
    <expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>current</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>current</name> <operator>&lt;</operator> <operator>(</operator><name>sljit_sw</name><operator>*</operator><operator>)</operator><name><name>current</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>current</name> <operator>=</operator> <operator>(</operator><name>sljit_sw</name><operator>*</operator><operator>)</operator><name><name>current</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></while>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>copy_ovector</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>topbracket</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>loop</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>has_pre</name></decl>;</decl_stmt>

<comment type="block">/* At this point we can freely use all registers. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_S2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_S0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U32</name></expr></argument>, <argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_R0</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>oveccount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_R0</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>startchar_ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_S0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_R0</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>mark_ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_R0</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr></argument>,
    <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>pcre2_match_data</name></expr></argument>, <argument><expr><name>ovector</name></expr></argument>)</argument_list></call> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_SIZE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_S0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U32</name></expr></argument>, <argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>oveccount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>startchar_ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_S0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>mark_ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>pcre2_match_data</name></expr></argument>, <argument><expr><name>ovector</name></expr></argument>)</argument_list></call> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_SIZE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>has_pre</name> <operator>=</operator> <call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_MOV</name> <operator>|</operator> <name>SLJIT_MEM_SUPP</name> <operator>|</operator> <name>SLJIT_MEM_PRE</name></expr></argument>, <argument><expr><name>SLJIT_S1</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_S0</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <name>SLJIT_SUCCESS</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GET_LOCAL_BASE</name><argument_list>(<argument><expr><name>SLJIT_S0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OVECTOR_START</name> <operator>-</operator> <operator>(</operator><ternary><condition><expr><name>has_pre</name></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><ternary><condition><expr><name>HAS_VIRTUAL_REGISTERS</name></expr> ?</condition><then> <expr><name>SLJIT_R0</name></expr> </then><else>: <expr><name>ARGUMENTS</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>has_pre</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_MOV</name> <operator>|</operator> <name>SLJIT_MEM_PRE</name></expr></argument>, <argument><expr><name>SLJIT_S1</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_S0</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_S1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_S0</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>SLJIT_S0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_S0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_SIZE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>SLJIT_S1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_S1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* Copy the integer value to the output buffer */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ASHR</name></expr></argument>, <argument><expr><name>SLJIT_S1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_S1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCHAR_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_SIZE</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">4</literal> <operator>||</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_SIZE</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_SIZE</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">4</literal><operator>)</operator></expr> ?</condition><then> <expr><name>SLJIT_MOV_U32</name></expr> </then><else>: <expr><name>SLJIT_MOV</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_R2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_S1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Calculate the return value, which is the maximum ovector value. */</comment>
<if_stmt><if>if <condition>(<expr><name>topbracket</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_MOV</name> <operator>|</operator> <name>SLJIT_MEM_SUPP</name> <operator>|</operator> <name>SLJIT_MEM_PRE</name></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_R0</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>sljit_sw</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <name>SLJIT_SUCCESS</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>GET_LOCAL_BASE</name><argument_list>(<argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OVECTOR_START</name> <operator>+</operator> <name>topbracket</name> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>topbracket</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* OVECTOR(0) is never equal to SLJIT_S2. */</comment>
    <expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_MOV</name> <operator>|</operator> <name>SLJIT_MEM_PRE</name></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_R0</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>sljit_sw</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_S2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>GET_LOCAL_BASE</name><argument_list>(<argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OVECTOR_START</name> <operator>+</operator> <operator>(</operator><name>topbracket</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>topbracket</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* OVECTOR(0) is never equal to SLJIT_S2. */</comment>
    <expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_R0</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>sljit_sw</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_S2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>return_with_partial_match</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>quit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>sljit_s32</name></type> <name>mov_opcode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_s32</name></type> <name>arguments_reg</name> <init>= <expr><ternary><condition><expr><operator>!</operator><name>HAS_VIRTUAL_REGISTERS</name></expr> ?</condition><then> <expr><name>ARGUMENTS</name></expr> </then><else>: <expr><name>SLJIT_R1</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SLJIT_COMPILE_ASSERT</name><argument_list>(<argument><expr><name>STR_END</name> <operator>==</operator> <name>SLJIT_S0</name></expr></argument>, <argument><expr><name>str_end_must_be_saved_reg0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_used_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>start_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal>
  <operator>&amp;&amp;</operator> <operator>(</operator><ternary><condition><expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_PARTIAL_SOFT</name></expr> ?</condition><then> <expr><name><name>common</name><operator>-&gt;</operator><name>hit_start</name></name> <operator>!=</operator> <literal type="number">0</literal></expr> </then><else>: <expr><name><name>common</name><operator>-&gt;</operator><name>hit_start</name></name> <operator>==</operator> <literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>arguments_reg</name> <operator>!=</operator> <name>ARGUMENTS</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>arguments_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>,
  <argument><expr><ternary><condition><expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_PARTIAL_SOFT</name></expr> ?</condition><then> <expr><name><name>common</name><operator>-&gt;</operator><name>hit_start</name></name></expr> </then><else>: <expr><name><name>common</name><operator>-&gt;</operator><name>start_ptr</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>PCRE2_ERROR_PARTIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Store match begin and end. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_S1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>arguments_reg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>arguments_reg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>startchar_ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>arguments_reg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mov_opcode</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_SIZE</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">4</literal><operator>)</operator></expr> ?</condition><then> <expr><name>SLJIT_MOV_U32</name></expr> </then><else>: <expr><name>SLJIT_MOV</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_S1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ASHR</name></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCHAR_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>mov_opcode</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_R1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>pcre2_match_data</name></expr></argument>, <argument><expr><name>ovector</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_S1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ASHR</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCHAR_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>mov_opcode</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_R1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>pcre2_match_data</name></expr></argument>, <argument><expr><name>ovector</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_SIZE</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name>quit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>check_start_used_ptr</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* May destroy TMP1. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_PARTIAL_SOFT</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* The value of -1 must be kept for start_used_ptr! */</comment>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Jumps if start_used_ptr &lt; STR_PTR, or start_used_ptr == -1. Although overwriting
  is not necessary if start_used_ptr == STR_PTR, it does not hurt as well. */</comment>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_PARTIAL_HARD</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>BOOL</name></type> <name>char_has_othercase</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Detects if the character has an othercase. */</comment>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>||</operator> <name><name>common</name><operator>-&gt;</operator><name>ucp</name></name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>GETCHAR</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>c</name> <operator>!=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><name><name>common</name><operator>-&gt;</operator><name>fcc</name><index>[<expr><name>c</name></expr>]</index></name> <operator>!=</operator> <name>c</name></expr>;</return>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><ternary><condition><expr><call><name>MAX_255</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>common</name><operator>-&gt;</operator><name>fcc</name><index>[<expr><name>c</name></expr>]</index></name> <operator>!=</operator> <name>c</name></expr> </then><else>: <expr><name>FALSE</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>unsigned</name> <name>int</name></type> <name>char_othercase</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Returns with the othercase. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>||</operator> <name><name>common</name><operator>-&gt;</operator><name>ucp</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><call><name>TABLE_GET</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>fcc</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>char_get_othercase_bit</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Detects if the character and its othercase has only 1 bit difference. */</comment>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>oc</name></decl>, <decl><type ref="prev"/><name>bit</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>||</operator> <name><name>common</name><operator>-&gt;</operator><name>ucp</name></name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>GETCHAR</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>oc</name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>fcc</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>oc</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>oc</name> <operator>=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>fcc</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>oc</name> <operator>=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>fcc</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>c</name> <operator>!=</operator> <name>oc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bit</name> <operator>=</operator> <name>c</name> <operator>^</operator> <name>oc</name></expr>;</expr_stmt>
<comment type="block">/* Optimized for English alphabet. */</comment>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <name>bit</name> <operator>==</operator> <literal type="number">0x20</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><operator>(</operator><literal type="number">0</literal> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x20</literal></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* Since c != oc, they must have at least 1 bit difference. */</comment>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_powerof2</name><argument_list>(<argument><expr><name>bit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><operator>(</operator><name>bit</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>bit</name> <operator>&gt;&gt;=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
    </block_content>}</block></while>
  <return>return <expr><operator>(</operator><name>n</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>bit</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
<return>return <expr><operator>(</operator><literal type="number">0</literal> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>bit</name></expr>;</return>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:elif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;</operator> <literal type="number">65535</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>bit</name> <operator>&gt;=</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">10</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>bit</name> <operator>&gt;&gt;=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><ternary><condition><expr><operator>(</operator><name>bit</name> <operator>&lt;</operator> <literal type="number">256</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><literal type="number">2</literal> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>bit</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><literal type="number">3</literal> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>bit</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr></else></ternary></expr>;</return></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>bit</name> <operator>&lt;</operator> <literal type="number">256</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><literal type="number">0u</literal> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>bit</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>bit</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr></else></ternary></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>check_partial</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Checks whether a partial matching is occurred. Does not modify registers. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name>force</name> <operator>||</operator> <name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>PCRE2_JIT_COMPLETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
  <return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>allow_empty_partial</name></name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_PARTIAL_SOFT</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_PARTIAL_SOFT</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>hit_start</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>partialmatchlabel</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>partialmatchlabel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>partialmatch</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>jump</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>check_str_end</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>end_reached</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Does not affect registers. Usually used in a tight spot. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>end_reached</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_PARTIAL_SOFT</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>end_reached</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>hit_start</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>end_reached</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>end_reached</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>partialmatchlabel</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>partialmatchlabel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>partialmatch</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>detect_partial_match</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>backtracks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Partial matching mode. */</comment>
<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>allow_empty_partial</name></name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_PARTIAL_SOFT</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_PARTIAL_SOFT</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>hit_start</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>partialmatchlabel</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>partialmatchlabel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>partialmatch</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>process_partial_match</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>

<comment type="block">/* Partial matching mode. */</comment>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_PARTIAL_SOFT</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>hit_start</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_PARTIAL_HARD</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>partialmatchlabel</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>partialmatchlabel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>partialmatch</name></name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>detect_partial_match_to</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>label</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>process_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>peek_char</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>sljit_u32</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>sljit_sw</name></type> <name>dstw</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>backtracks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Reads the character into TMP1, keeps STR_PTR.
Does not check STR_END. TMP2, dst, RETURN_ADDR Destroyed. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE &amp;&amp; PCRE2_CODE_UNIT_WIDTH != 32 */</comment>

<expr_stmt><expr><call><name>SLJIT_UNUSED_ARG</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_UNUSED_ARG</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_UNUSED_ARG</name><argument_list>(<argument><expr><name>dstw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_UNUSED_ARG</name><argument_list>(<argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>max</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>utfreadchar_invalid</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>utfreadchar</name></name></expr></else></ternary></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>backtracks</name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:elif>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>max</name> <operator>&lt;</operator> <literal type="number">0xd800</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe000</literal> <operator>-</operator> <literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>utfreadchar_invalid</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dstw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>backtracks</name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <comment type="block">/* TMP2 contains the high surrogate. */</comment>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xdc00</literal> <operator>-</operator> <literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x10000</literal> <operator>-</operator> <literal type="number">0xdc00</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:elif>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>max</name> <operator>&lt;</operator> <literal type="number">0xd800</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>backtracks</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x110000</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe000</literal> <operator>-</operator> <literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x110000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe000</literal> <operator>-</operator> <literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>peek_char_back</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>sljit_u32</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>backtracks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Reads one character back without moving STR_PTR. TMP2 must
contain the start of the subject buffer. Affects TMP1, TMP2, and RETURN_ADDR. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE &amp;&amp; PCRE2_CODE_UNIT_WIDTH != 32 */</comment>

<expr_stmt><expr><call><name>SLJIT_UNUSED_ARG</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_UNUSED_ARG</name><argument_list>(<argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>max</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>utfpeakcharback_invalid</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>backtracks</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>utfpeakcharback</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:elif>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>max</name> <operator>&lt;</operator> <literal type="number">0xd800</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>utfpeakcharback_invalid</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>backtracks</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xdc00</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe000</literal> <operator>-</operator> <literal type="number">0xdc00</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* TMP2 contains the low surrogate. */</comment>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:elif>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x110000</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe000</literal> <operator>-</operator> <literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_CHAR_UPDATE_STR_PTR</name></cpp:macro> <cpp:value>0x1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_CHAR_UTF8_NEWLINE</name></cpp:macro> <cpp:value>0x2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_CHAR_NEWLINE</name></cpp:macro> <cpp:value>(READ_CHAR_UPDATE_STR_PTR | READ_CHAR_UTF8_NEWLINE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_CHAR_VALID_UTF</name></cpp:macro> <cpp:value>0x4</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>read_char</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>sljit_u32</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>sljit_u32</name></type> <name>max</name></decl></parameter>,
  <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>backtracks</name></decl></parameter>, <parameter><decl><type><name>sljit_u32</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Reads the precise value of a character into TMP1, if the character is
between min and max (c &gt;= min &amp;&amp; c &lt;= max). Otherwise it returns with a value
outside the range. Does not check STR_END. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump2</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>SLJIT_UNUSED_ARG</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_UNUSED_ARG</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_UNUSED_ARG</name><argument_list>(<argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_UNUSED_ARG</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>min</name> <operator>&lt;=</operator> <name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>max</name> <operator>&lt;</operator> <literal type="number">128</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>READ_CHAR_UPDATE_STR_PTR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>READ_CHAR_VALID_UTF</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>READ_CHAR_UTF8_NEWLINE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>utfreadnewline_invalid</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>utfreadchar_invalid</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>backtracks</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>min</name> <operator>&gt;=</operator> <literal type="number">0x10000</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xf0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>READ_CHAR_UPDATE_STR_PTR</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>utf8_table4</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jump2</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x3f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x3f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>READ_CHAR_UPDATE_STR_PTR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x3f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>READ_CHAR_UPDATE_STR_PTR</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>min</name> <operator>&gt;=</operator> <literal type="number">0x800</literal> <operator>&amp;&amp;</operator> <name>max</name> <operator>&lt;=</operator> <literal type="number">0xffff</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>READ_CHAR_UPDATE_STR_PTR</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>utf8_table4</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jump2</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xf</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x3f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>READ_CHAR_UPDATE_STR_PTR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x3f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>READ_CHAR_UPDATE_STR_PTR</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>max</name> <operator>&gt;=</operator> <literal type="number">0x800</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>utfreadchar</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>max</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>utf8_table4</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>READ_CHAR_UPDATE_STR_PTR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>utf8_table4</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x3f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x3f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>READ_CHAR_UPDATE_STR_PTR</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:elif>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>max</name> <operator>&lt;</operator> <literal type="number">0xd800</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>READ_CHAR_UPDATE_STR_PTR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>READ_CHAR_VALID_UTF</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe000</literal> <operator>-</operator> <literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>READ_CHAR_UTF8_NEWLINE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>utfreadnewline_invalid</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>utfreadchar_invalid</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>backtracks</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>max</name> <operator>&gt;=</operator> <literal type="number">0x10000</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xdc00</literal> <operator>-</operator> <literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* TMP2 contains the high surrogate. */</comment>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x10000</literal> <operator>-</operator> <literal type="number">0xdc00</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Skip low surrogate if necessary. */</comment>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>sljit_has_cpu_feature</name><argument_list>(<argument><expr><name>SLJIT_HAS_CMOV</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>READ_CHAR_UPDATE_STR_PTR</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x400</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>READ_CHAR_UPDATE_STR_PTR</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>max</name> <operator>&gt;=</operator> <literal type="number">0xd800</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x400</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>READ_CHAR_UPDATE_STR_PTR</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>max</name> <operator>&gt;=</operator> <literal type="number">0xd800</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:elif>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>backtracks</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x110000</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe000</literal> <operator>-</operator> <literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x110000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe000</literal> <operator>-</operator> <literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>

<function><type><specifier>static</specifier> <name>BOOL</name></type> <name>is_char7_bitset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>sljit_u8</name> <modifier>*</modifier></type><name>bitset</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>nclass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Tells whether the character codes below 128 are enough
to determine a match. */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_u8</name></type> <name>value</name> <init>= <expr><ternary><condition><expr><name>nclass</name></expr> ?</condition><then> <expr><literal type="number">0xff</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_u8</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>bitset</name> <operator>+</operator> <literal type="number">32</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>bitset</name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<do>do
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>bitset</name><operator>++</operator> <operator>!=</operator> <name>value</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block>
while <condition>(<expr><name>bitset</name> <operator>&lt;</operator> <name>end</name></expr>)</condition>;</do>
<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>read_char7_type</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>backtracks</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>negated</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Reads the precise character type of a character into TMP1, if the character
is less than 128. Otherwise it returns with zero. Does not check STR_END. The
full_read argument tells whether characters above max are accepted or not. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* All values &gt; 127 are zero in ctypes. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>ctypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>negated</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>utfreadchar_invalid</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>utf8_table4</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE &amp;&amp; PCRE2_CODE_UNIT_WIDTH == 8 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>read_char8_type</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>backtracks</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>negated</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Reads the character type into TMP1, updates STR_PTR. Does not check STR_END. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump2</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>SLJIT_UNUSED_ARG</name><argument_list>(<argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_UNUSED_ARG</name><argument_list>(<argument><expr><name>negated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* The result of this read may be unused, but saves an "else" part. */</comment>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>ctypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>negated</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe0</literal> <operator>-</operator> <literal type="number">0xc2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x40</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jump2</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>ctypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>utfreadchar_invalid</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jump2</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>ctypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>utfreadtype8</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE &amp;&amp; PCRE2_CODE_UNIT_WIDTH == 8 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name> <operator>&amp;&amp;</operator> <name>negated</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x110000</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE &amp;&amp; PCRE2_CODE_UNIT_WIDTH == 32 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
<comment type="block">/* The ctypes array contains only 256 values. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH != 8 */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>ctypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH != 8 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <name>negated</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Skip low surrogate if necessary. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>sljit_has_cpu_feature</name><argument_list>(<argument><expr><name>SLJIT_HAS_CMOV</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x400</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x400</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <return>return;</return>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe000</literal> <operator>-</operator> <literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x400</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xdc00</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x400</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE &amp;&amp; PCRE2_CODE_UNIT_WIDTH == 16 */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>move_back</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>backtracks</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>must_be_valid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Goes one character back. Affects STR_PTR and TMP1. If must_be_valid is TRUE,
TMP2 is not used. Otherwise TMP2 must contain the start of the subject buffer,
and it is destroyed. Does not modify STR_PTR for invalid character sequences. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SLJIT_UNUSED_ARG</name><argument_list>(<argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_UNUSED_ARG</name><argument_list>(<argument><expr><name>must_be_valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>must_be_valid</name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>utfmoveback_invalid</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>backtracks</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:elif>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>must_be_valid</name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe000</literal> <operator>-</operator> <literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>utfmoveback_invalid</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>backtracks</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Skip low surrogate if necessary. */</comment>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xfc00</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xdc00</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCHAR_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:elif>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>must_be_valid</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>backtracks</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x110000</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x110000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>,  <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCHAR_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>check_newlinechar</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nltype</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>backtracks</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>jumpifmatch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Character comes in TMP1. Checks if it is a newline. TMP2 may be destroyed. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>nltype</name> <operator>==</operator> <name>NLTYPE_ANY</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>anynewline</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sljit_set_current_flags</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_SET_Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><ternary><condition><expr><name>jumpifmatch</name></expr> ?</condition><then> <expr><name>SLJIT_NOT_ZERO</name></expr> </then><else>: <expr><name>SLJIT_ZERO</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>nltype</name> <operator>==</operator> <name>NLTYPE_ANYCRLF</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>jumpifmatch</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>CHAR_CR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>CHAR_NL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>CHAR_CR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>CHAR_NL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>nltype</name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&lt;</operator> <literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><ternary><condition><expr><name>jumpifmatch</name></expr> ?</condition><then> <expr><name>SLJIT_EQUAL</name></expr> </then><else>: <expr><name>SLJIT_NOT_EQUAL</name></expr></else></ternary></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>newline</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>do_utfreadchar</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Fast decoding a UTF-8 character. TMP1 contains the first byte
of the character (&gt;= 0xc0). Return char value in TMP1. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x3f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Searching for the first zero. */</comment>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* Two byte sequence. */</comment>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_XOR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x3000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x3f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* Three byte sequence. */</comment>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_XOR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe0000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Four byte sequence. */</comment>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_XOR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xf0000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x3f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_utfreadtype8</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Fast decoding a UTF-8 character type. TMP2 contains the first byte
of the character (&gt;= 0xc0). Return value in TMP1. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>compare</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* Two byte sequence. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x1f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* The upper 5 bits are known at this point. */</comment>
<expr_stmt><expr><name>compare</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x3f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>ctypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* We only have types for characters less than 256. */</comment>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>utf8_table4</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_utfreadchar_invalid</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Slow decoding a UTF-8 character. TMP1 contains the first byte
of the character (&gt;= 0xc0). Return char value in TMP1. STR_PTR is
undefined for invalid characters. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>sljit_s32</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_s32</name></type> <name>has_cmov</name> <init>= <expr><call><name>sljit_has_cpu_feature</name><argument_list>(<argument><expr><name>SLJIT_HAS_CMOV</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>buffer_end_close</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>three_byte_entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>exit_invalid_label</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name><name>exit_invalid</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Usually more than 3 characters remained in the subject buffer. */</comment>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Not a valid start of a multi-byte sequence, no more bytes read. */</comment>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xf5</literal> <operator>-</operator> <literal type="number">0xc2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buffer_end_close</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* If TMP2 is in 0x80-0xbf range, TMP1 is also increased by (0x2 &lt;&lt; 6). */</comment>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Three-byte sequence. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_cmov</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x20000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>three_byte_entry</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x2d800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_cmov</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name> <operator>-</operator> <literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>has_cmov</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Four-byte sequence. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_cmov</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_cmov</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x100000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name> <operator>-</operator> <literal type="number">0x10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x100000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>buffer_end_close</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Two-byte sequence. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* If TMP2 is in 0x80-0xbf range, TMP1 is also increased by (0x2 &lt;&lt; 6). */</comment>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Three-byte sequence. */</comment>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_cmov</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<comment type="block">/* One will be substracted from STR_PTR later. */</comment>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Four byte sequences are not possible. */</comment>
<expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x30000</literal></expr></argument>, <argument><expr><name>three_byte_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>exit_invalid_label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">11</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>sljit_set_label</name><argument_list>(<argument><expr><name><name>exit_invalid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>exit_invalid_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_utfreadnewline_invalid</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Slow decoding a UTF-8 character, specialized for newlines.
TMP1 contains the first byte of the character (&gt;= 0xc0). Return
char value in TMP1. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>loop</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>skip_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>three_byte_exit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name><name>jump</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>!=</operator> <name>NLTYPE_ANY</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>!=</operator> <name>NLTYPE_FIXED</name> <operator>||</operator> <name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&lt;</operator> <literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* All newlines are ascii, just skip intermediate octets. */</comment>
  <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>MOV_UCHAR</name> <operator>|</operator> <name>SLJIT_MEM_SUPP</name> <operator>|</operator> <name>SLJIT_MEM_POST</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>SLJIT_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>MOV_UCHAR</name> <operator>|</operator> <name>SLJIT_MEM_POST</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>skip_start</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Skip intermediate octets. */</comment>
<expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>three_byte_exit</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Two byte long newline: 0x85. */</comment>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x85</literal></expr></argument>, <argument><expr><name>skip_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x85</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Three byte long newlines: 0x2028 and 0x2029. */</comment>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>, <argument><expr><name>skip_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>three_byte_exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x40</literal></expr></argument>, <argument><expr><name>skip_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x2000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_utfmoveback_invalid</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Goes one character back. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>sljit_s32</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>buffer_start_close</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>exit_ok_label</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>exit_invalid_label</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name><name>exit_invalid</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Two-byte sequence. */</comment>
<expr_stmt><expr><name>buffer_start_close</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Three-byte sequence. */</comment>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">0x40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Four-byte sequence. */</comment>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe0</literal> <operator>-</operator> <literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xf0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x05</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>exit_ok_label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Two-byte sequence. */</comment>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>buffer_start_close</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x20</literal></expr></argument>, <argument><expr><name>exit_ok_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Three-byte sequence. */</comment>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">0x40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x10</literal></expr></argument>, <argument><expr><name>exit_ok_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Four-byte sequences are not possible. */</comment>

<expr_stmt><expr><name>exit_invalid_label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sljit_set_label</name><argument_list>(<argument><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name>exit_invalid_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sljit_set_label</name><argument_list>(<argument><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>, <argument><expr><name>exit_invalid_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* -2 + 4 = 2 */</comment>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>exit_invalid_label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>sljit_set_label</name><argument_list>(<argument><expr><name><name>exit_invalid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>exit_invalid_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_utfpeakcharback</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Peak a character back. Does not modify STR_PTR. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name><name>jump</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe0</literal> <operator>-</operator> <literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xf0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_utfpeakcharback_invalid</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Peak a character back. Does not modify STR_PTR. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>sljit_s32</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_s32</name></type> <name>has_cmov</name> <init>= <expr><call><name>sljit_has_cpu_feature</name><argument_list>(<argument><expr><name>SLJIT_HAS_CMOV</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name><name>jump</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>two_byte_entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>three_byte_entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>exit_invalid_label</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name><name>exit_invalid</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Two-byte sequence. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x1e</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>two_byte_entry</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* If TMP1 is in 0x80-0xbf range, TMP1 is also increased by (0x2 &lt;&lt; 6). */</comment>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc2</literal> <operator>-</operator> <literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Three-byte sequence. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>three_byte_entry</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_cmov</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_cmov</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe0</literal> <operator>-</operator> <literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Four-byte sequence. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xf0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* ADD is used instead of OR because of the SUB 0x10000 above. */</comment>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>has_cmov</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x100000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name> <operator>-</operator> <literal type="number">0x10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x100000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Two-byte sequence. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x1e</literal></expr></argument>, <argument><expr><name>two_byte_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc2</literal> <operator>-</operator> <literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Three-byte sequence. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x10</literal></expr></argument>, <argument><expr><name>three_byte_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Two-byte sequence. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x1e</literal></expr></argument>, <argument><expr><name>two_byte_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>exit_invalid_label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>sljit_set_label</name><argument_list>(<argument><expr><name><name>exit_invalid</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>exit_invalid_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 8 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_utfreadchar_invalid</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Slow decoding a UTF-16 character. TMP1 contains the first half
of the character (&gt;= 0xd800). Return char value in TMP1. STR_PTR is
undefined for invalid characters. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name><name>exit_invalid</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* TMP2 contains the high surrogate. */</comment>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xdc00</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xdc00</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x400</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_utfreadnewline_invalid</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Slow decoding a UTF-16 character, specialized for newlines.
TMP1 contains the first half of the character (&gt;= 0xd800). Return
char value in TMP1. */</comment>

<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name><name>exit_invalid</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* TMP2 contains the high surrogate. */</comment>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xdc00</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xdc00</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x400</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCHAR_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_utfmoveback_invalid</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Goes one character back. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name><name>exit_invalid</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x400</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x400</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_utfpeakcharback_invalid</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Peak a character back. Does not modify STR_PTR. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name><name>exit_invalid</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xdc00</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x10000</literal> <operator>-</operator> <literal type="number">0xdc00</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x400</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>exit_invalid</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 16 */</comment>

<comment type="block">/* UCD_BLOCK_SIZE must be 128 (see the assert below). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UCD_BLOCK_MASK</name></cpp:macro> <cpp:value>127</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UCD_BLOCK_SHIFT</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_getucd</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Search the UCD record for the character comes in TMP1.
Returns chartype in TMP1 and UCD offset in TMP2. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SLJIT_DEBUG</name> <operator>&amp;&amp;</operator> <name>SLJIT_DEBUG</name></expr></cpp:if>
<comment type="block">/* dummy_ucd_record */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>ucd_record</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><call><name>GET_UCD</name><argument_list>(<argument><expr><name>UNASSIGNED_UTF_CHAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>script</name></name> <operator>==</operator> <name>ucp_Unknown</name> <operator>&amp;&amp;</operator> <name><name>record</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name>ucp_Cn</name> <operator>&amp;&amp;</operator> <name><name>record</name><operator>-&gt;</operator><name>gbprop</name></name> <operator>==</operator> <name>ucp_gbOther</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>caseset</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>record</name><operator>-&gt;</operator><name>other_case</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>UCD_BLOCK_SIZE</name> <operator>==</operator> <literal type="number">128</literal> <operator>&amp;&amp;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ucd_record</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>MAX_UTF_CODE_POINT</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UNASSIGNED_UTF_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_LSHR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCD_BLOCK_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U16</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_stage1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCD_BLOCK_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCD_BLOCK_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_stage2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U16</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM2</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_getucdtype</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Search the UCD record for the character comes in TMP1.
Returns chartype in TMP1 and UCD offset in TMP2. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SLJIT_DEBUG</name> <operator>&amp;&amp;</operator> <name>SLJIT_DEBUG</name></expr></cpp:if>
<comment type="block">/* dummy_ucd_record */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>ucd_record</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><call><name>GET_UCD</name><argument_list>(<argument><expr><name>UNASSIGNED_UTF_CHAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>script</name></name> <operator>==</operator> <name>ucp_Unknown</name> <operator>&amp;&amp;</operator> <name><name>record</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name>ucp_Cn</name> <operator>&amp;&amp;</operator> <name><name>record</name><operator>-&gt;</operator><name>gbprop</name></name> <operator>==</operator> <name>ucp_gbOther</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>caseset</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>record</name><operator>-&gt;</operator><name>other_case</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>UCD_BLOCK_SIZE</name> <operator>==</operator> <literal type="number">128</literal> <operator>&amp;&amp;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ucd_record</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>MAX_UTF_CODE_POINT</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UNASSIGNED_UTF_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_LSHR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCD_BLOCK_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U16</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_stage1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCD_BLOCK_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCD_BLOCK_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_stage2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U16</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM2</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* TMP2 is multiplied by 12. Same as (TMP2 &lt;&lt; 2) + ((TMP2 &lt;&lt; 2) &lt;&lt; 1). */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_records</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>ucd_record</name></expr></argument>, <argument><expr><name>chartype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM2</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>

<expr_stmt><expr><specifier>static</specifier> <name>SLJIT_INLINE</name> struct <name>sljit_label</name> <operator>*</operator><macro><name>mainloop_entry</name><argument_list>(<argument>compiler_common *common</argument>)</argument_list></macro>
<block>{
<expr><name>DEFINE_COMPILER</name></expr>;
struct <expr><name>sljit_label</name> <operator>*</operator><name>mainloop</name></expr>;
struct <expr><name>sljit_label</name> <operator>*</operator><name>newlinelabel</name> <operator>=</operator> <name>NULL</name></expr>;
struct <expr><name>sljit_jump</name> <operator>*</operator><name>start</name></expr>;
struct <expr><name>sljit_jump</name> <operator>*</operator><name>end</name> <operator>=</operator> <name>NULL</name></expr>;
struct <expr><name>sljit_jump</name> <operator>*</operator><name>end2</name> <operator>=</operator> <name>NULL</name></expr>;
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
struct <expr><name>sljit_label</name> <operator>*</operator><name>loop</name></expr>;
struct <expr><name>sljit_jump</name> <operator>*</operator><name>jump</name></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE &amp;&amp; PCRE2_CODE_UNIT_WIDTH != 32 */</comment>
<expr><name>jump_list</name> <operator>*</operator><name>newline</name> <operator>=</operator> <name>NULL</name></expr>;
<expr><name>sljit_u32</name> <name>overall_options</name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>re</name><operator>-&gt;</operator><name>overall_options</name></name></expr>;
<expr><name>BOOL</name> <name>hascrorlf</name> <operator>=</operator> <operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_HASCRORLF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;
<expr><name>BOOL</name> <name>newlinecheck</name> <operator>=</operator> <name>FALSE</name></expr>;
<expr><name>BOOL</name> <name>readuchar</name> <operator>=</operator> <name>FALSE</name></expr>;

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>hascrorlf</name> <operator>||</operator> <operator>(</operator><name>overall_options</name> <operator>&amp;</operator> <name>PCRE2_FIRSTLINE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator>
    <operator>&amp;&amp;</operator> <operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_ANY</name> <operator>||</operator> <name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_ANYCRLF</name> <operator>||</operator> <name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&gt;</operator> <literal type="number">255</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>newlinecheck</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>abort_label</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>overall_options</name> <operator>&amp;</operator> <name>PCRE2_FIRSTLINE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Search for the end of the first line. */</comment>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>mainloop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>, <argument><expr><name>mainloop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>, <argument><expr><name>mainloop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mainloop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Continual stores does not cause data dependency. */</comment>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>nlmin</name></name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>nlmax</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>READ_CHAR_NEWLINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>check_newlinechar</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newline</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mainloop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>newline</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name>overall_options</name> <operator>&amp;</operator> <name>PCRE2_USE_OFFSET_LIMIT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Check whether offset limit is set and valid. */</comment>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>offset_limit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>offset_limit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator> <name>PCRE2_UNSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCHAR_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == [16|32] */</comment>
  <if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>end2</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>end2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>PCRE2_ERROR_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>abort</name></name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>newlinecheck</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>newlinelabel</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCHAR_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == [16|32] */</comment>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>end2</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>mainloop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Increasing the STR_PTR here requires one less jump in the most common case. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>readuchar</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE &amp;&amp; PCRE2_CODE_UNIT_WIDTH != 32 */</comment>
<if_stmt><if>if <condition>(<expr><name>newlinecheck</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>readuchar</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>readuchar</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>newlinecheck</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>, <argument><expr><name>newlinelabel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Skip continuation code units. */</comment>
  <expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x40</literal></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>utf8_table4</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:elif>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Skip continuation code units. */</comment>
  <expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xdc00</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x400</literal></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>sljit_has_cpu_feature</name><argument_list>(<argument><expr><name>SLJIT_HAS_CMOV</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x400</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x400</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCHAR_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == [8|16] */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE &amp;&amp; PCRE2_CODE_UNIT_WIDTH != 32 */</comment>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>newlinecheck</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>end2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<return>return <expr><name>mainloop</name></expr>;</return>
}


static <function><type><name>SLJIT_INLINE</name> <name>void</name></type> <name>add_prefix_char</name><parameter_list>(<parameter><decl><type><name>PCRE2_UCHAR</name></type> <name>chr</name></decl></parameter>, <parameter><decl><type><name>fast_forward_char_data</name> <modifier>*</modifier></type><name>chars</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>last</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>sljit_u32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><name><name>chars</name><operator>-&gt;</operator><name>count</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">255</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>chars</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>chars</name><operator>-&gt;</operator><name>chars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>chr</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>last</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>chars</name><operator>-&gt;</operator><name>last_count</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return;</return>
  </block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
  <if_stmt><if>if <condition>(<expr><name><name>chars</name><operator>-&gt;</operator><name>chars</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>chr</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;=</operator> <name>MAX_DIFF_CHARS</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>chars</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt>
  <return>return;</return>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>chars</name><operator>-&gt;</operator><name>chars</name><index>[<expr><name>count</name></expr>]</index></name> <operator>=</operator> <name>chr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>chars</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <name>count</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>last</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>chars</name><operator>-&gt;</operator><name>last_count</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>scan_prefix</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>fast_forward_char_data</name> <modifier>*</modifier></type><name>chars</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max_chars</name></decl></parameter>, <parameter><decl><type><name>sljit_u32</name> <modifier>*</modifier></type><name>rec_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Recursive function, which scans prefix literals. */</comment>
<decl_stmt><decl><type><name>BOOL</name></type> <name>last</name></decl>, <decl><type ref="prev"/><name>any</name></decl>, <decl><type ref="prev"/><name>class</name></decl>, <decl><type ref="prev"/><name>caseless</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>repeat</name></decl>, <decl><type ref="prev"/><name>len_save</name></decl>, <decl><type ref="prev"/><name>consumed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_u32</name></type> <name>chr</name></decl>;</decl_stmt> <comment type="block">/* Any unicode character. */</comment>
<decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>bytes</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bytes_end</name></decl>, <decl><type ref="prev"/><name>byte</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>alternative</name></decl>, <decl><type ref="prev"/><name>cc_save</name></decl>, <decl><type ref="prev"/><name>oc</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name><name>othercase</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:elif>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name><name>othercase</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name><name>othercase</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>repeat</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>TRUE</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>rec_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>(</operator><operator>*</operator><name>rec_count</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>

  <expr_stmt><expr><name>last</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>any</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>class</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>caseless</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><operator>*</operator><name>cc</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>OP_CHARI</name></expr>:</case>
    <expr_stmt><expr><name>caseless</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>
    <case>case <expr><name>OP_CHAR</name></expr>:</case>
    <expr_stmt><expr><name>last</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_SOD</name></expr>:</case>
    <case>case <expr><name>OP_SOM</name></expr>:</case>
    <case>case <expr><name>OP_SET_SOM</name></expr>:</case>
    <case>case <expr><name>OP_NOT_WORD_BOUNDARY</name></expr>:</case>
    <case>case <expr><name>OP_WORD_BOUNDARY</name></expr>:</case>
    <case>case <expr><name>OP_EODN</name></expr>:</case>
    <case>case <expr><name>OP_EOD</name></expr>:</case>
    <case>case <expr><name>OP_CIRC</name></expr>:</case>
    <case>case <expr><name>OP_CIRCM</name></expr>:</case>
    <case>case <expr><name>OP_DOLL</name></expr>:</case>
    <case>case <expr><name>OP_DOLLM</name></expr>:</case>
    <comment type="block">/* Zero width assertions. */</comment>
    <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
    <continue>continue;</continue>

    <case>case <expr><name>OP_ASSERT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT_NOT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NOT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT_NA</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NA</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>bracketend</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <continue>continue;</continue>

    <case>case <expr><name>OP_PLUSI</name></expr>:</case>
    <case>case <expr><name>OP_MINPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_POSPLUSI</name></expr>:</case>
    <expr_stmt><expr><name>caseless</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>
    <case>case <expr><name>OP_PLUS</name></expr>:</case>
    <case>case <expr><name>OP_MINPLUS</name></expr>:</case>
    <case>case <expr><name>OP_POSPLUS</name></expr>:</case>
    <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_EXACTI</name></expr>:</case>
    <expr_stmt><expr><name>caseless</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>
    <case>case <expr><name>OP_EXACT</name></expr>:</case>
    <expr_stmt><expr><name>repeat</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>last</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_QUERYI</name></expr>:</case>
    <case>case <expr><name>OP_MINQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_POSQUERYI</name></expr>:</case>
    <expr_stmt><expr><name>caseless</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>
    <case>case <expr><name>OP_QUERY</name></expr>:</case>
    <case>case <expr><name>OP_MINQUERY</name></expr>:</case>
    <case>case <expr><name>OP_POSQUERY</name></expr>:</case>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>max_chars</name> <operator>=</operator> <call><name>scan_prefix</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>max_chars</name></expr></argument>, <argument><expr><name>rec_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>max_chars</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>consumed</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>last</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_KET</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <continue>continue;</continue>

    <case>case <expr><name>OP_ALT</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <continue>continue;</continue>

    <case>case <expr><name>OP_ONCE</name></expr>:</case>
    <case>case <expr><name>OP_BRA</name></expr>:</case>
    <case>case <expr><name>OP_BRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_CBRA</name></expr>:</case>
    <case>case <expr><name>OP_CBRAPOS</name></expr>:</case>
    <expr_stmt><expr><name>alternative</name> <operator>=</operator> <name>cc</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>*</operator><name>alternative</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>max_chars</name> <operator>=</operator> <call><name>scan_prefix</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>alternative</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>max_chars</name></expr></argument>, <argument><expr><name>rec_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>max_chars</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>consumed</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>alternative</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>alternative</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_CBRA</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_CBRAPOS</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <continue>continue;</continue>

    <case>case <expr><name>OP_CLASS</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_char7_bitset</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>sljit_u8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>cc</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>consumed</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>class</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_NCLASS</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>consumed</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>class</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
    <case>case <expr><name>OP_XCLASS</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>consumed</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>any</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>OP_DIGIT</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_char7_bitset</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>sljit_u8</name> <operator>*</operator><operator>)</operator><name><name>common</name><operator>-&gt;</operator><name>ctypes</name></name> <operator>-</operator> <name>cbit_length</name> <operator>+</operator> <name>cbit_digit</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>consumed</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>any</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_WHITESPACE</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_char7_bitset</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>sljit_u8</name> <operator>*</operator><operator>)</operator><name><name>common</name><operator>-&gt;</operator><name>ctypes</name></name> <operator>-</operator> <name>cbit_length</name> <operator>+</operator> <name>cbit_space</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>consumed</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>any</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_WORDCHAR</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_char7_bitset</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>sljit_u8</name> <operator>*</operator><operator>)</operator><name><name>common</name><operator>-&gt;</operator><name>ctypes</name></name> <operator>-</operator> <name>cbit_length</name> <operator>+</operator> <name>cbit_word</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>consumed</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>any</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_NOT</name></expr>:</case>
    <case>case <expr><name>OP_NOTI</name></expr>:</case>
    <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
    <comment type="block">/* Fall through. */</comment>
    <case>case <expr><name>OP_NOT_DIGIT</name></expr>:</case>
    <case>case <expr><name>OP_NOT_WHITESPACE</name></expr>:</case>
    <case>case <expr><name>OP_NOT_WORDCHAR</name></expr>:</case>
    <case>case <expr><name>OP_ANY</name></expr>:</case>
    <case>case <expr><name>OP_ALLANY</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>consumed</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>any</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <case>case <expr><name>OP_NOTPROP</name></expr>:</case>
    <case>case <expr><name>OP_PROP</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>consumed</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>any</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>OP_TYPEEXACT</name></expr>:</case>
    <expr_stmt><expr><name>repeat</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <continue>continue;</continue>

    <case>case <expr><name>OP_NOTEXACT</name></expr>:</case>
    <case>case <expr><name>OP_NOTEXACTI</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>consumed</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>any</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>repeat</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <break>break;</break>

    <default>default:</default>
    <return>return <expr><name>consumed</name></expr>;</return>
    </block_content>}</block></switch>

  <if_stmt><if>if <condition>(<expr><name>any</name></expr>)</condition>
    <block>{<block_content>
    <do>do
      <block>{<block_content>
      <expr_stmt><expr><name><name>chars</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt>

      <expr_stmt><expr><name>consumed</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>--</operator><name>max_chars</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>consumed</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>chars</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block>
    while <condition>(<expr><operator>--</operator><name>repeat</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>

    <expr_stmt><expr><name>repeat</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>class</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>bytes</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator> <operator>(</operator><name>cc</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><operator>*</operator><name>cc</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>OP_CRSTAR</name></expr>:</case>
      <case>case <expr><name>OP_CRMINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_CRPOSSTAR</name></expr>:</case>
      <case>case <expr><name>OP_CRQUERY</name></expr>:</case>
      <case>case <expr><name>OP_CRMINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_CRPOSQUERY</name></expr>:</case>
      <expr_stmt><expr><name>max_chars</name> <operator>=</operator> <call><name>scan_prefix</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>max_chars</name></expr></argument>, <argument><expr><name>rec_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>max_chars</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>consumed</name></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>

      <default>default:</default>
      <case>case <expr><name>OP_CRPLUS</name></expr>:</case>
      <case>case <expr><name>OP_CRMINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_CRPOSPLUS</name></expr>:</case>
      <break>break;</break>

      <case>case <expr><name>OP_CRRANGE</name></expr>:</case>
      <case>case <expr><name>OP_CRMINRANGE</name></expr>:</case>
      <case>case <expr><name>OP_CRPOSRANGE</name></expr>:</case>
      <expr_stmt><expr><name>repeat</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>repeat</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>consumed</name></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>
      </block_content>}</block></switch>

    <do>do
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>bytes</name><index>[<expr><literal type="number">31</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>chars</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name><name>chars</name><operator>-&gt;</operator><name>count</name></name> <operator>!=</operator> <literal type="number">255</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>bytes_end</name> <operator>=</operator> <name>bytes</name> <operator>+</operator> <literal type="number">32</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>chr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <do>do
          <block>{<block_content>
          <expr_stmt><expr><name>byte</name> <operator>=</operator> <operator>*</operator><name>bytes</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>chr</name> <operator>&amp;</operator> <literal type="number">0x7</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>byte</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>chr</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if>
          <else>else
            <block>{<block_content>
            <do>do
              <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><operator>(</operator><name>byte</name> <operator>&amp;</operator> <literal type="number">0x1</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>add_prefix_char</name><argument_list>(<argument><expr><name>chr</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
              <expr_stmt><expr><name>byte</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
              <expr_stmt><expr><name>chr</name><operator>++</operator></expr>;</expr_stmt>
              </block_content>}</block>
            while <condition>(<expr><name>byte</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
            <expr_stmt><expr><name>chr</name> <operator>=</operator> <operator>(</operator><name>chr</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><literal type="number">7</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block>
        while <condition>(<expr><name><name>chars</name><operator>-&gt;</operator><name>count</name></name> <operator>!=</operator> <literal type="number">255</literal> <operator>&amp;&amp;</operator> <name>bytes</name> <operator>&lt;</operator> <name>bytes_end</name></expr>)</condition>;</do>
        <expr_stmt><expr><name>bytes</name> <operator>=</operator> <name>bytes_end</name> <operator>-</operator> <literal type="number">32</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>consumed</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>--</operator><name>max_chars</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>consumed</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>chars</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block>
    while <condition>(<expr><operator>--</operator><name>repeat</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>

    <switch>switch <condition>(<expr><operator>*</operator><name>cc</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>OP_CRSTAR</name></expr>:</case>
      <case>case <expr><name>OP_CRMINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_CRPOSSTAR</name></expr>:</case>
      <return>return <expr><name>consumed</name></expr>;</return>

      <case>case <expr><name>OP_CRQUERY</name></expr>:</case>
      <case>case <expr><name>OP_CRMINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_CRPOSQUERY</name></expr>:</case>
      <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_CRRANGE</name></expr>:</case>
      <case>case <expr><name>OP_CRMINRANGE</name></expr>:</case>
      <case>case <expr><name>OP_CRPOSRANGE</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>consumed</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></switch>

    <expr_stmt><expr><name>repeat</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if <condition>(<expr><name>caseless</name> <operator>&amp;&amp;</operator> <call><name>char_has_othercase</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>GETCHAR</name><argument_list>(<argument><expr><name>chr</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><call><call><name>PRIV</name><argument_list>(<argument><expr><name>ord2utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><call><name>char_othercase</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>othercase</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>consumed</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if>
    <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <block>{<block_content>
      <expr_stmt><expr><name>chr</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>ucp</name></name> <operator>&amp;&amp;</operator> <name>chr</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>othercase</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>chr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name><name>othercase</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>chr</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>fcc</name></name></expr></argument>, <argument><expr><name>chr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><name>caseless</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>othercase</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* Stops compiler warning - PH */</comment>
    </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>len_save</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc_save</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>TRUE</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>oc</name> <operator>=</operator> <name>othercase</name></expr>;</expr_stmt>
    <do>do
      <block>{<block_content>
      <expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>consumed</name><operator>++</operator></expr>;</expr_stmt>

      <expr_stmt><expr><name>chr</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_prefix_char</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>caseless</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>add_prefix_char</name><argument_list>(<argument><expr><operator>*</operator><name>oc</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><operator>--</operator><name>max_chars</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>consumed</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>chars</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>oc</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block>
    while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>

    <if_stmt><if>if <condition>(<expr><operator>--</operator><name>repeat</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <break>break;</break></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <name>len_save</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <name>cc_save</name></expr>;</expr_stmt>
    </block_content>}</block></while>

  <expr_stmt><expr><name>repeat</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>last</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>consumed</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>jumpto_if_not_utf_char_start</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>label</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:elif>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xfc00</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xdc00</literal></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"Unknown code width"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_jit_simd_inc.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>BOOL</name></type> <name>check_fast_forward_char_pair_simd</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>fast_forward_char_data</name> <modifier>*</modifier></type><name>chars</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>sljit_s32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>max_i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>max_j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>sljit_u32</name></type> <name>max_pri</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>a1</name></decl>, <decl><type ref="prev"/><name>a2</name></decl>, <decl><type ref="prev"/><name>a_pri</name></decl>, <decl><type ref="prev"/><name>b1</name></decl>, <decl><type ref="prev"/><name>b2</name></decl>, <decl><type ref="prev"/><name>b_pri</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>max</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last_count</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>a1</name> <operator>=</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>a2</name> <operator>=</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>a_pri</name> <operator>=</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last_count</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>-</operator> <call><name>max_fast_forward_char_pair_offset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <while>while <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>b_pri</name> <operator>=</operator> <name><name>chars</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>last_count</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>b_pri</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>a_pri</name> <operator>+</operator> <name>b_pri</name> <operator>&gt;=</operator> <name>max_pri</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>b1</name> <operator>=</operator> <name><name>chars</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>b2</name> <operator>=</operator> <name><name>chars</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

          <if_stmt><if>if <condition>(<expr><name>a1</name> <operator>!=</operator> <name>b1</name> <operator>&amp;&amp;</operator> <name>a1</name> <operator>!=</operator> <name>b2</name> <operator>&amp;&amp;</operator> <name>a2</name> <operator>!=</operator> <name>b1</name> <operator>&amp;&amp;</operator> <name>a2</name> <operator>!=</operator> <name>b2</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>max_pri</name> <operator>=</operator> <name>a_pri</name> <operator>+</operator> <name>b_pri</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>max_i</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>max_j</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>max_pri</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>fast_forward_char_pair_simd</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>max_i</name></expr></argument>, <argument><expr><name><name>chars</name><index>[<expr><name>max_i</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>chars</name><index>[<expr><name>max_i</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>max_j</name></expr></argument>, <argument><expr><name><name>chars</name><index>[<expr><name>max_j</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>chars</name><index>[<expr><name>max_j</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fast_forward_first_char2</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name></type> <name>char1</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name></type> <name>char2</name></decl></parameter>, <parameter><decl><type><name>sljit_s32</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>match</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>partial_quit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>mask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>has_match_end</name> <init>= <expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name> <operator>||</operator> <name>offset</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>has_match_end</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_match_end</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_GREATER</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JIT_HAS_FAST_FORWARD_CHAR_SIMD</name></cpp:ifdef>

<if_stmt><if>if <condition>(<expr><name>JIT_HAS_FAST_FORWARD_CHAR_SIMD</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fast_forward_char_simd</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>char1</name></expr></argument>, <argument><expr><name>char2</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>has_match_end</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return;</return>
  </block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>partial_quit</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>failed_match</name></name></expr></argument>, <argument><expr><name>partial_quit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>char1</name> <operator>==</operator> <name>char2</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>char1</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><name>mask</name> <operator>=</operator> <name>char1</name> <operator>^</operator> <name>char2</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>is_powerof2</name><argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>char1</name> <operator>|</operator> <name>mask</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>char1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>char2</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name>offset</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>jumpto_if_not_utf_char_start</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>partial_quit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_match_end</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>BOOL</name></type> <name>fast_forward_first_n_chars</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>match</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>fast_forward_char_data</name></type> <name><name>chars</name><index>[<expr><name>MAX_N_CHARS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_s32</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>mask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>char_set</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>char_set_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>max</name></decl>, <decl><type ref="prev"/><name>from</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>range_right</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>range_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_u8</name> <modifier>*</modifier></type><name>update_table</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>in_range</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_u32</name></type> <name>rec_count</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_N_CHARS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <expr_stmt><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></for>

<expr_stmt><expr><name>rec_count</name> <operator>=</operator> <literal type="number">10000</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>scan_prefix</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>MAX_N_CHARS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rec_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>max</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* Convert last_count to priority. */</comment>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last_count</name> <operator>&lt;=</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last_count</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last_count</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">7</literal></expr> </then><else>: <expr><literal type="number">5</literal></expr></else></ternary></expr>;</expr_stmt>
    <comment type="block">/* Simplifies algorithms later. */</comment>
    <expr_stmt><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>is_powerof2</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>^</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last_count</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last_count</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">6</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last_count</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last_count</name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last_count</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>==</operator> <literal type="number">255</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD</name> <operator>&amp;&amp;</operator> <call><name>check_fast_forward_char_pair_simd</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>chars</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>in_range</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<comment type="block">/* Prevent compiler "uninitialized" warning */</comment>
<expr_stmt><expr><name>from</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>range_len</name> <operator>=</operator> <literal type="number">4</literal> <comment type="block">/* minimum length */</comment> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>in_range</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>i</name> <operator>-</operator> <name>from</name><operator>)</operator> <operator>&gt;</operator> <name>range_len</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>chars</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name> <operator>&lt;</operator> <literal type="number">255</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>range_len</name> <operator>=</operator> <name>i</name> <operator>-</operator> <name>from</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>range_right</name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>max</name> <operator>&amp;&amp;</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&lt;</operator> <literal type="number">255</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_range</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>in_range</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>from</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>in_range</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>range_right</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>update_table</name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name> <operator>*</operator><operator>)</operator><call><name>allocate_read_only_data</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>update_table</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>update_table</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>range_len</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>range_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>chars</name><index>[<expr><name>range_right</name> <operator>-</operator> <name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>chars</name><index>[<expr><name>range_right</name> <operator>-</operator> <name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&lt;</operator> <literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>char_set</name> <operator>=</operator> <name><name>chars</name><index>[<expr><name>range_right</name> <operator>-</operator> <name>i</name></expr>]</index></name><operator>.</operator><name>chars</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>char_set_end</name> <operator>=</operator> <name>char_set</name> <operator>+</operator> <name><name>chars</name><index>[<expr><name>range_right</name> <operator>-</operator> <name>i</name></expr>]</index></name><operator>.</operator><name>count</name></expr>;</expr_stmt>
    <do>do
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>update_table</name><index>[<expr><operator>(</operator><operator>*</operator><name>char_set</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>]</index></name> <operator>&gt;</operator> <call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>update_table</name><index>[<expr><operator>(</operator><operator>*</operator><name>char_set</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>]</index></name> <operator>=</operator> <call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>char_set</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block>
    while <condition>(<expr><name>char_set</name> <operator>&lt;</operator> <name>char_set_end</name></expr>)</condition>;</do>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<comment type="block">/* Scan forward. */</comment>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>range_right</name> <operator>==</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
    <continue>continue;</continue></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last_count</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>chars</name><index>[<expr><name>offset</name></expr>]</index></name><operator>.</operator><name>last_count</name> <operator>&lt;</operator> <name><name>chars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last_count</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>offset</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name><name>chars</name><index>[<expr><name>offset</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>chars</name><index>[<expr><name>offset</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&lt;=</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>range_right</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  <comment type="block">/* Works regardless the value is 1 or 2. */</comment>
  <expr_stmt><expr><call><name>fast_forward_first_char2</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>chars</name><index>[<expr><name>offset</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>chars</name><index>[<expr><name>offset</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>range_right</name> <operator>!=</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>failed_match</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_GREATER</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>failed_match</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>range_right</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><name>update_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>failed_match</name></name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal> <operator>||</operator> <operator>(</operator><name>defined</name> <name>SLJIT_LITTLE_ENDIAN</name> <operator>&amp;&amp;</operator> <name>SLJIT_LITTLE_ENDIAN</name><operator>)</operator></expr></cpp:if>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>range_right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>range_right</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM2</name><argument_list>(<argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><name>update_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>chars</name><index>[<expr><name>offset</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>chars</name><index>[<expr><name>offset</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><name>mask</name> <operator>=</operator> <name><name>chars</name><index>[<expr><name>offset</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>^</operator> <name><name>chars</name><index>[<expr><name>offset</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>is_powerof2</name><argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>chars</name><index>[<expr><name>offset</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|</operator> <name>mask</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>chars</name><index>[<expr><name>offset</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>chars</name><index>[<expr><name>offset</name></expr>]</index></name><operator>.</operator><name><name>chars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <name>offset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <expr_stmt><expr><call><name>jumpto_if_not_utf_char_start</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>fast_forward_first_char</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>first_char</name> <init>= <expr><operator>(</operator><name>PCRE2_UCHAR</name><operator>)</operator><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>re</name><operator>-&gt;</operator><name>first_codeunit</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>oc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>oc</name> <operator>=</operator> <name>first_char</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_FIRSTCASELESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>oc</name> <operator>=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>first_char</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>fcc</name></name></expr></argument>, <argument><expr><name>first_char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>first_char</name> <operator>&gt;</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>||</operator> <name><name>common</name><operator>-&gt;</operator><name>ucp</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>oc</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>first_char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fast_forward_first_char2</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>first_char</name></expr></argument>, <argument><expr><name>oc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>fast_forward_newline</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>loop</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>lastchar</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>firstchar</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>quit</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>foundcr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>notfoundnl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>newline</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition>
  <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD</name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>firstchar</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCHAR_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>fast_forward_char_pair_simd</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JIT_HAS_FAST_FORWARD_CHAR_PAIR_SIMD */</comment>
    <block>{<block_content>
    <expr_stmt><expr><name>lastchar</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>firstchar</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCHAR_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>quit</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>quit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>lastchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return;</return>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<comment type="block">/* Example: match /^/ to \r\n from offset 1. */</comment>
<expr_stmt><expr><name>firstchar</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_ANY</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>move_back</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>ff_newline_shortcut</name></name> <operator>=</operator> <name>loop</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JIT_HAS_FAST_FORWARD_CHAR_SIMD</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>JIT_HAS_FAST_FORWARD_CHAR_SIMD</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>||</operator> <name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_ANYCRLF</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_ANYCRLF</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fast_forward_char_simd</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>CHAR_CR</name></expr></argument>, <argument><expr><name>CHAR_LF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>lastchar</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>quit</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>CHAR_CR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
   <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>fast_forward_char_simd</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>newline</name></name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>newline</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_GREATER</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* JIT_HAS_FAST_FORWARD_CHAR_SIMD */</comment>
  <block>{<block_content>
  <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>nlmin</name></name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>nlmax</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>READ_CHAR_NEWLINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>lastchar</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_ANY</name> <operator>||</operator> <name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_ANYCRLF</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>foundcr</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>CHAR_CR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>check_newlinechar</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newline</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>newline</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_ANY</name> <operator>||</operator> <name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_ANYCRLF</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>quit</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>quit</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>foundcr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>notfoundnl</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>CHAR_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCHAR_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>notfoundnl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>quit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>lastchar</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>lastchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>optimize_class</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>sljit_u8</name> <modifier>*</modifier></type><name>bits</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>nclass</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>invert</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>backtracks</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>fast_forward_start_bits</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_u8</name> <modifier>*</modifier></type><name>start_bits</name> <init>= <expr><name><name>common</name><operator>-&gt;</operator><name>re</name><operator>-&gt;</operator><name>start_bitmap</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>partial_quit</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>found</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>matches</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_GREATER</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>partial_quit</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>failed_match</name></name></expr></argument>, <argument><expr><name>partial_quit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>optimize_class</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>start_bits</name></expr></argument>, <argument><expr><operator>(</operator><name><name>start_bits</name><index>[<expr><literal type="number">31</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>matches</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>start_bits</name><index>[<expr><literal type="number">31</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name></expr></cpp:elif>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>is_char7_bitset</name><argument_list>(<argument><expr><name>start_bits</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">127</literal></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_LSHR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><name>start_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_ZERO</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>matches</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>found</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>partial_quit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>jump_list</name> <modifier>*</modifier></type><name>search_requested_char</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name></type> <name>req_char</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>caseless</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>has_firstchar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>loop</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>toolong</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>already_found</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>found</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>found_oc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>not_found</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_u32</name></type> <name>oc</name></decl>, <decl><type ref="prev"/><name>bit</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>req_char_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>REQ_CU_MAX</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>req_char_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>toolong</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>already_found</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>has_firstchar</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>oc</name> <operator>=</operator> <name>req_char</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>caseless</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>oc</name> <operator>=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>req_char</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>fcc</name></name></expr></argument>, <argument><expr><name>req_char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>req_char</name> <operator>&gt;</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>||</operator> <name><name>common</name><operator>-&gt;</operator><name>ucp</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>oc</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>req_char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JIT_HAS_FAST_REQUESTED_CHAR_SIMD</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>JIT_HAS_FAST_REQUESTED_CHAR_SIMD</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>not_found</name> <operator>=</operator> <call><name>fast_requested_char_simd</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>req_char</name></expr></argument>, <argument><expr><name>oc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
  <expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>not_found</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>req_char</name> <operator>==</operator> <name>oc</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>req_char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><name>bit</name> <operator>=</operator> <name>req_char</name> <operator>^</operator> <name>oc</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>is_powerof2</name><argument_list>(<argument><expr><name>bit</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
       <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>bit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>req_char</name> <operator>|</operator> <name>bit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>req_char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>found_oc</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>oc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>found_oc</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>found_oc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>req_char_ptr</name></name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>already_found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>toolong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>not_found</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_revertframes</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>mainloop</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GET_LOCAL_BASE</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Drop frames until we reach STACK_TOP. */</comment>
<expr_stmt><expr><name>mainloop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_SIG_LESS_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>GET_LOCAL_BASE</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name>mainloop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument> <comment type="block">/* SIG_LESS */</comment>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* End of reverting values. */</comment>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_NEG</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name>mainloop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>check_wordboundary</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>skipread</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>skipread_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>valid_utf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>invalid_utf1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>invalid_utf2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal> <operator>||</operator> <name>defined</name> <name>SUPPORT_UNICODE</name></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH != 8 || SUPPORT_UNICODE */</comment>

<expr_stmt><expr><call><name>SLJIT_COMPILE_ASSERT</name><argument_list>(<argument><expr><name>ctype_word</name> <operator>==</operator> <literal type="number">0x10</literal></expr></argument>, <argument><expr><name>ctype_word_must_be_16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* Get type of the previous char, and put it to TMP3. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>skipread</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>peek_char_back</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>READ_CHAR_MAX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>invalid_utf1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>move_back</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>check_start_used_ptr</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>peek_char_back</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>READ_CHAR_MAX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>move_back</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>check_start_used_ptr</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>READ_CHAR_MAX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>READ_CHAR_UPDATE_STR_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

<comment type="block">/* Testing char type. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>ucp</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>CHAR_UNDERSCORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>getucdtype</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_Ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_Lu</name> <operator>-</operator> <name>ucp_Ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_Nd</name> <operator>-</operator> <name>ucp_Ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_No</name> <operator>-</operator> <name>ucp_Nd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name></expr></cpp:elif>
  <comment type="block">/* Here TMP3 has already been zeroed. */</comment>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 8 */</comment>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>ctypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_LSHR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument> <comment type="block">/* ctype_word */</comment>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name></expr></cpp:elif>
  <if_stmt><if>if <condition>(<expr><name>jump</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 8 */</comment>
  </block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>skipread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>check_str_end</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>skipread_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>peek_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>READ_CHAR_MAX</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>invalid_utf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Testing char type. This is a code duplication. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>

<expr_stmt><expr><name>valid_utf</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>ucp</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>CHAR_UNDERSCORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>getucdtype</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_Ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_Lu</name> <operator>-</operator> <name>ucp_Ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_Nd</name> <operator>-</operator> <name>ucp_Ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_No</name> <operator>-</operator> <name>ucp_Nd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
  <comment type="block">/* TMP2 may be destroyed by peek_char. */</comment>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name></expr></cpp:elif>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>ctypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_LSHR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument> <comment type="block">/* ctype_word */</comment>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name></expr></cpp:elif>
  <if_stmt><if>if <condition>(<expr><name>jump</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 8 */</comment>
  </block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>skipread_list</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_XOR</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>invalid_utf1</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>peek_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>READ_CHAR_MAX</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>INVALID_UTF_CHAR</name></expr></argument>, <argument><expr><name>valid_utf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>invalid_utf2</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BOOL</name></type> <name>optimize_class_ranges</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>sljit_u8</name> <modifier>*</modifier></type><name>bits</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>nclass</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>invert</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>backtracks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* May destroy TMP1. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>ranges</name><index>[<expr><name>MAX_CLASS_RANGE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_u8</name></type> <name>bit</name></decl>, <decl><type ref="prev"/><name>cbit</name></decl>, <decl><type ref="prev"/><name>all</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>byte</name></decl>, <decl><type ref="prev"/><name>length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>bit</name> <operator>=</operator> <name><name>bits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x1</literal></expr>;</expr_stmt>
<comment type="block">/* All bits will be zero or one (since bit is zero or one). */</comment>
<expr_stmt><expr><name>all</name> <operator>=</operator> <operator>-</operator><name>bit</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr/>)</control>
  <block>{<block_content>
  <expr_stmt><expr><name>byte</name> <operator>=</operator> <name>i</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>&amp;</operator> <literal type="number">0x7</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>bits</name><index>[<expr><name>byte</name></expr>]</index></name> <operator>==</operator> <name>all</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><name>cbit</name> <operator>=</operator> <operator>(</operator><name><name>bits</name><index>[<expr><name>byte</name></expr>]</index></name> <operator>&gt;&gt;</operator> <operator>(</operator><name>i</name> <operator>&amp;</operator> <literal type="number">0x7</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x1</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>cbit</name> <operator>!=</operator> <name>bit</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;=</operator> <name>MAX_CLASS_RANGE_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>ranges</name><index>[<expr><name>length</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>length</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>bit</name> <operator>=</operator> <name>cbit</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>all</name> <operator>=</operator> <operator>-</operator><name>cbit</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>bit</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>nclass</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><name>bit</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>nclass</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;=</operator> <name>MAX_CLASS_RANGE_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>ranges</name><index>[<expr><name>length</name></expr>]</index></name> <operator>=</operator> <literal type="number">256</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>length</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>length</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>length</name></expr></argument> &gt;</argument_list></name> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>bit</name> <operator>=</operator> <name><name>bits</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>invert</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bit</name> <operator>^=</operator> <literal type="number">0x1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* No character is accepted. */</comment>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bit</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch<condition>(<expr><name>length</name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><literal type="number">0</literal></expr>:</case>
  <comment type="block">/* When bit != 0, all characters are accepted. */</comment>
  <return>return <expr><name>TRUE</name></expr>;</return>

  <case>case <expr><literal type="number">1</literal></expr>:</case>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><ternary><condition><expr><name>bit</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>SLJIT_LESS</name></expr> </then><else>: <expr><name>SLJIT_GREATER_EQUAL</name></expr></else></ternary></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>

  <case>case <expr><literal type="number">2</literal></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal> <operator>!=</operator> <name><name>ranges</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><ternary><condition><expr><name>bit</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>SLJIT_LESS</name></expr> </then><else>: <expr><name>SLJIT_GREATER_EQUAL</name></expr></else></ternary></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><ternary><condition><expr><name>bit</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>SLJIT_EQUAL</name></expr> </then><else>: <expr><name>SLJIT_NOT_EQUAL</name></expr></else></ternary></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>

  <case>case <expr><literal type="number">3</literal></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>bit</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal> <operator>!=</operator> <name><name>ranges</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <return>return <expr><name>TRUE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ranges</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal> <operator>!=</operator> <name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>ranges</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>

  <case>case <expr><literal type="number">4</literal></expr>:</case>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ranges</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>==</operator> <operator>(</operator><name><name>ranges</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator>
      <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|</operator> <operator>(</operator><name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>)</operator> <operator>==</operator> <name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name>
      <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ranges</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>
      <operator>&amp;&amp;</operator> <call><name>is_powerof2</name><argument_list>(<argument><expr><name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <name><name>ranges</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal> <operator>!=</operator> <name><name>ranges</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><ternary><condition><expr><name>bit</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>SLJIT_LESS</name></expr> </then><else>: <expr><name>SLJIT_GREATER_EQUAL</name></expr></else></ternary></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><ternary><condition><expr><name>bit</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>SLJIT_EQUAL</name></expr> </then><else>: <expr><name>SLJIT_NOT_EQUAL</name></expr></else></ternary></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <return>return <expr><name>TRUE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>bit</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal> <operator>!=</operator> <name><name>ranges</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal> <operator>!=</operator> <name><name>ranges</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <return>return <expr><name>TRUE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ranges</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal> <operator>!=</operator> <name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>ranges</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>ranges</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>ranges</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>

  <default>default:</default>
  <expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BOOL</name></type> <name>optimize_class_chars</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>sljit_u8</name> <modifier>*</modifier></type><name>bits</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>nclass</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>invert</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>backtracks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* May destroy TMP1. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name><name>char_list</name><index>[<expr><name>MAX_CLASS_CHARS_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>byte</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_s32</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sljit_has_cpu_feature</name><argument_list>(<argument><expr><name>SLJIT_HAS_CMOV</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <expr_stmt><expr><name>byte</name> <operator>=</operator> <name><name>bits</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>nclass</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>byte</name> <operator>=</operator> <operator>~</operator><name>byte</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>byte</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>byte</name> <operator>&amp;</operator> <literal type="number">0x1</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <name>i</name> <operator>*</operator> <literal type="number">8</literal> <operator>+</operator> <name>j</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>k</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x20</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
          <if_stmt><if>if <condition>(<expr><name><name>char_list</name><index>[<expr><name>k</name></expr>]</index></name> <operator>==</operator> <name>c</name> <operator>-</operator> <literal type="number">0x20</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name><name>char_list</name><index>[<expr><name>k</name></expr>]</index></name> <operator>|=</operator> <literal type="number">0x120</literal></expr>;</expr_stmt>
            <break>break;</break>
            </block_content>}</block></if></if_stmt></block_content></block></for>
        </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <name>len</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>MAX_CLASS_CHARS_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
          <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>char_list</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator> <name>c</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>byte</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Should never occur, but stops analyzers complaining. */</comment>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>char_list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>char_list</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x100</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>char_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_ZERO</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>char_list</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x100</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>char_list</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_ZERO</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>invert</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>nclass</name> <operator>=</operator> <operator>!</operator><name>nclass</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <ternary><condition><expr><name>nclass</name></expr> ?</condition><then> <expr><name>SLJIT_NOT_EQUAL</name></expr> </then><else>: <expr><name>SLJIT_EQUAL</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BOOL</name></type> <name>optimize_class</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>sljit_u8</name> <modifier>*</modifier></type><name>bits</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>nclass</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>invert</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>backtracks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* May destroy TMP1. */</comment>
<if_stmt><if>if <condition>(<expr><call><name>optimize_class_ranges</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>, <argument><expr><name>nclass</name></expr></argument>, <argument><expr><name>invert</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>optimize_class_chars</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>bits</name></expr></argument>, <argument><expr><name>nclass</name></expr></argument>, <argument><expr><name>invert</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>check_anynewline</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Check whether TMP1 contains a newline character. TMP2 destroyed. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x0a</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x0d</literal> <operator>-</operator> <literal type="number">0x0a</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x85</literal> <operator>-</operator> <literal type="number">0x0a</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
  <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x2029</literal> <operator>-</operator> <literal type="number">0x0a</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == [16|32] */</comment>
<expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>check_hspace</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Check whether TMP1 contains a newline character. TMP2 destroyed. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x09</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xa0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
  <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x1680</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x180e</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x2000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x200A</literal> <operator>-</operator> <literal type="number">0x2000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x202f</literal> <operator>-</operator> <literal type="number">0x2000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x205f</literal> <operator>-</operator> <literal type="number">0x2000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x3000</literal> <operator>-</operator> <literal type="number">0x2000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == [16|32] */</comment>
<expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>check_vspace</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Check whether TMP1 contains a newline character. TMP2 destroyed. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x0a</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x0d</literal> <operator>-</operator> <literal type="number">0x0a</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x85</literal> <operator>-</operator> <literal type="number">0x0a</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
  <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x2029</literal> <operator>-</operator> <literal type="number">0x0a</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == [16|32] */</comment>
<expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_casefulcmp</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>char1_reg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>char2_reg</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>char1_reg</name> <operator>=</operator> <name>STR_END</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>char2_reg</name> <operator>=</operator> <name>STACK_TOP</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><name>char1_reg</name> <operator>=</operator> <name>TMP3</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>char2_reg</name> <operator>=</operator> <name>RETURN_ADDR</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>char1_reg</name> <operator>==</operator> <name>STR_END</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>char2_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>MOV_UCHAR</name> <operator>|</operator> <name>SLJIT_MEM_SUPP</name> <operator>|</operator> <name>SLJIT_MEM_POST</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>SLJIT_SUCCESS</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>MOV_UCHAR</name> <operator>|</operator> <name>SLJIT_MEM_POST</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>MOV_UCHAR</name> <operator>|</operator> <name>SLJIT_MEM_POST</name></expr></argument>, <argument><expr><name>char2_reg</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>char2_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>MOV_UCHAR</name> <operator>|</operator> <name>SLJIT_MEM_SUPP</name> <operator>|</operator> <name>SLJIT_MEM_PRE</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>SLJIT_SUCCESS</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>MOV_UCHAR</name> <operator>|</operator> <name>SLJIT_MEM_PRE</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>MOV_UCHAR</name> <operator>|</operator> <name>SLJIT_MEM_PRE</name></expr></argument>, <argument><expr><name>char2_reg</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>char2_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>char2_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>char2_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>char1_reg</name> <operator>==</operator> <name>STR_END</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>char2_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_caselesscmp</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>char1_reg</name> <init>= <expr><name>STR_END</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>char2_reg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lcc_table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>opt_type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>char2_reg</name> <operator>=</operator> <name>STACK_TOP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>lcc_table</name> <operator>=</operator> <name>STACK_LIMIT</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><name>char2_reg</name> <operator>=</operator> <name>RETURN_ADDR</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>lcc_table</name> <operator>=</operator> <name>TMP3</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>MOV_UCHAR</name> <operator>|</operator> <name>SLJIT_MEM_SUPP</name> <operator>|</operator> <name>SLJIT_MEM_POST</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>SLJIT_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>opt_type</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>MOV_UCHAR</name> <operator>|</operator> <name>SLJIT_MEM_SUPP</name> <operator>|</operator> <name>SLJIT_MEM_PRE</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>SLJIT_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>opt_type</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS1</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>char2_reg</name> <operator>==</operator> <name>STACK_TOP</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>char2_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lcc_table</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>lcc_table</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>lcc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>opt_type</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>MOV_UCHAR</name> <operator>|</operator> <name>SLJIT_MEM_POST</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>MOV_UCHAR</name> <operator>|</operator> <name>SLJIT_MEM_POST</name></expr></argument>, <argument><expr><name>char2_reg</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>opt_type</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>MOV_UCHAR</name> <operator>|</operator> <name>SLJIT_MEM_PRE</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sljit_emit_mem</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>MOV_UCHAR</name> <operator>|</operator> <name>SLJIT_MEM_PRE</name></expr></argument>, <argument><expr><name>char2_reg</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>char2_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM2</name><argument_list>(<argument><expr><name>lcc_table</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>char2_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>char2_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM2</name><argument_list>(<argument><expr><name>lcc_table</name></expr></argument>, <argument><expr><name>char2_reg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>opt_type</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>char2_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>opt_type</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>char2_reg</name> <operator>==</operator> <name>STACK_TOP</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>char2_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>lcc_table</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PCRE2_SPTR</name></type> <name>byte_sequence_compare</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>caseless</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>,
    <parameter><decl><type><name>compare_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>backtracks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>othercasebit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>othercasechar</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>utflength</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>caseless</name> <operator>&amp;&amp;</operator> <call><name>char_has_othercase</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>othercasebit</name> <operator>=</operator> <call><name>char_get_othercase_bit</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>othercasebit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Extracting bit difference info. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
  <expr_stmt><expr><name>othercasechar</name> <operator>=</operator> <name>cc</name> <operator>+</operator> <operator>(</operator><name>othercasebit</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>othercasebit</name> <operator>&amp;=</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:elif>
  <comment type="block">/* Note that this code only handles characters in the BMP. If there
  ever are characters outside the BMP whose othercase differs in only one
  bit from itself (there currently are none), this code will need to be
  revised for PCRE2_CODE_UNIT_WIDTH == 32. */</comment>
  <expr_stmt><expr><name>othercasechar</name> <operator>=</operator> <name>cc</name> <operator>+</operator> <operator>(</operator><name>othercasebit</name> <operator>&gt;&gt;</operator> <literal type="number">9</literal><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>othercasebit</name> <operator>&amp;</operator> <literal type="number">0x100</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>othercasebit</name> <operator>=</operator> <operator>(</operator><name>othercasebit</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>othercasebit</name> <operator>&amp;=</operator> <literal type="number">0xff</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */</comment>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SLJIT_UNALIGNED</name> <operator>&amp;&amp;</operator> <name>SLJIT_UNALIGNED</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_S32</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><name><name>context</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U16</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><name><name>context</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><name><name>context</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:elif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SLJIT_UNALIGNED</name> <operator>&amp;&amp;</operator> <name>SLJIT_UNALIGNED</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_S32</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><name><name>context</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><name><name>context</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:elif>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><name><name>context</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == [8|16|32] */</comment>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name> <operator>=</operator> <name>TMP2</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<expr_stmt><expr><name>utflength</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>utflength</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<do>do
  <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>length</name></name> <operator>-=</operator> <call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>SLJIT_UNALIGNED</name> <operator>&amp;&amp;</operator> <name>SLJIT_UNALIGNED</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal><operator>)</operator></expr></cpp:if>

  <comment type="block">/* Unaligned read is supported. */</comment>
  <if_stmt><if>if <condition>(<expr><name>othercasebit</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>othercasechar</name> <operator>==</operator> <name>cc</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>asuchars</name><index>[<expr><name><name>context</name><operator>-&gt;</operator><name>ucharptr</name></name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>cc</name> <operator>|</operator> <name>othercasebit</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>oc</name><operator>.</operator><name>asuchars</name><index>[<expr><name><name>context</name><operator>-&gt;</operator><name>ucharptr</name></name></expr>]</index></name> <operator>=</operator> <name>othercasebit</name></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>asuchars</name><index>[<expr><name><name>context</name><operator>-&gt;</operator><name>ucharptr</name></name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>oc</name><operator>.</operator><name>asuchars</name><index>[<expr><name><name>context</name><operator>-&gt;</operator><name>ucharptr</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>ucharptr</name></name><operator>++</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>ucharptr</name></name> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name><name>context</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>ucharptr</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>ucharptr</name></name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>||</operator> <name><name>context</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_S32</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><name><name>context</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U16</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><name><name>context</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <if type="elseif">else if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><name><name>context</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 8 */</comment>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name> <operator>=</operator> <ternary><condition><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name> <operator>==</operator> <name>TMP1</name></expr> ?</condition><then> <expr><name>TMP2</name></expr> </then><else>: <expr><name>TMP1</name></expr></else></ternary></expr>;</expr_stmt>

    <switch>switch<condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>ucharptr</name></name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><literal type="number">4</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>oc</name><operator>.</operator><name>asint</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>oc</name><operator>.</operator><name>asint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>asint</name></name> <operator>|</operator> <name><name>context</name><operator>-&gt;</operator><name>oc</name><operator>.</operator><name>asint</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><literal type="number">2</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>oc</name><operator>.</operator><name>asushort</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>oc</name><operator>.</operator><name>asushort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>asushort</name></name> <operator>|</operator> <name><name>context</name><operator>-&gt;</operator><name>oc</name><operator>.</operator><name>asushort</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
      <case>case <expr><literal type="number">1</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>oc</name><operator>.</operator><name>asbyte</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>oc</name><operator>.</operator><name>asbyte</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>asbyte</name></name> <operator>|</operator> <name><name>context</name><operator>-&gt;</operator><name>oc</name><operator>.</operator><name>asbyte</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <default>default:</default>
      <expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></switch>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>ucharptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

  <comment type="block">/* Unaligned read is unsupported or in 32 bit mode. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><name><name>context</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name> <operator>=</operator> <ternary><condition><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name> <operator>==</operator> <name>TMP1</name></expr> ?</condition><then> <expr><name>TMP2</name></expr> </then><else>: <expr><name>TMP1</name></expr></else></ternary></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>othercasebit</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>othercasechar</name> <operator>==</operator> <name>cc</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>othercasebit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>*</operator><name>cc</name> <operator>|</operator> <name>othercasebit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sourcereg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>*</operator><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <expr_stmt><expr><name>utflength</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block>
while <condition>(<expr><name>utflength</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>cc</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_TYPE_OFFSET</name><parameter_list>(<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if ((value) != typeoffset) \
    { \
    if ((value) &lt; typeoffset) \
      OP2(SLJIT_ADD, typereg, 0, typereg, 0, SLJIT_IMM, typeoffset - (value)); \
    else \
      OP2(SLJIT_SUB, typereg, 0, typereg, 0, SLJIT_IMM, (value) - typeoffset); \
    } \
  typeoffset = (value);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_CHAR_OFFSET</name><parameter_list>(<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if ((value) != charoffset) \
    { \
    if ((value) &lt; charoffset) \
      OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)(charoffset - (value))); \
    else \
      OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)((value) - charoffset)); \
    } \
  charoffset = (value);</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>PCRE2_SPTR</name></type> <name>compile_char1_matchingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>backtracks</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>check_str_ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type> <name>compile_xclass_matchingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>backtracks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>found</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>cc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <name>XCL_NOT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>&amp;</operator><name>found</name></expr> </then><else>: <expr><name>backtracks</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_uw</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>charoffset</name></decl>, <decl><type ref="prev"/><name>max</name> <init>= <expr><literal type="number">256</literal></expr></init></decl>, <decl><type ref="prev"/><name>min</name> <init>= <expr><name>READ_CHAR_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ccbegin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>compares</name></decl>, <decl><type ref="prev"/><name>invertcmp</name></decl>, <decl><type ref="prev"/><name>numberofcmps</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal><operator>)</operator></expr></cpp:if>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE &amp;&amp; PCRE2_CODE_UNIT_WIDTH == [8|16] */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<decl_stmt><decl><type><name>BOOL</name></type> <name>needstype</name> <init>= <expr><name>FALSE</name></expr></init></decl>, <decl><type ref="prev"/><name>needsscript</name> <init>= <expr><name>FALSE</name></expr></init></decl>, <decl><type ref="prev"/><name>needschar</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>charsaved</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>typereg</name> <init>= <expr><name>TMP1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_u32</name> <modifier>*</modifier></type><name>other_cases</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_uw</name></type> <name>typeoffset</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>

<comment type="block">/* Scanning the necessary info. */</comment>
<expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>ccbegin</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>compares</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <name>XCL_MAP</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>min</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>*</operator><name>cc</name> <operator>!=</operator> <name>XCL_END</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>compares</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>XCL_SINGLE</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>cc</name> <operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>max</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <name>min</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>min</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <expr_stmt><expr><name>needschar</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>XCL_RANGE</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>cc</name> <operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <name>min</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>min</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>max</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <expr_stmt><expr><name>needschar</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
    </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>XCL_PROP</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>XCL_NOTPROP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>PT_CLIST</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>other_cases</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_caseless_sets</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <while>while <condition>(<expr><operator>*</operator><name>other_cases</name> <operator>!=</operator> <name>NOTACHAR</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>other_cases</name> <operator>&gt;</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>max</name> <operator>=</operator> <operator>*</operator><name>other_cases</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>other_cases</name> <operator>&lt;</operator> <name>min</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>min</name> <operator>=</operator> <operator>*</operator><name>other_cases</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>other_cases</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name>max</name> <operator>=</operator> <name>READ_CHAR_MAX</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>min</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

    <switch>switch<condition>(<expr><operator>*</operator><name>cc</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>PT_ANY</name></expr>:</case>
      <comment type="block">/* Any either accepts everything or ignored. */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>XCL_PROP</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>OP_ALLANY</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>backtracks</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return;</return>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <case>case <expr><name>PT_LAMP</name></expr>:</case>
      <case>case <expr><name>PT_GC</name></expr>:</case>
      <case>case <expr><name>PT_PC</name></expr>:</case>
      <case>case <expr><name>PT_ALNUM</name></expr>:</case>
      <expr_stmt><expr><name>needstype</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>PT_SC</name></expr>:</case>
      <expr_stmt><expr><name>needsscript</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>PT_SPACE</name></expr>:</case>
      <case>case <expr><name>PT_PXSPACE</name></expr>:</case>
      <case>case <expr><name>PT_WORD</name></expr>:</case>
      <case>case <expr><name>PT_PXGRAPH</name></expr>:</case>
      <case>case <expr><name>PT_PXPRINT</name></expr>:</case>
      <case>case <expr><name>PT_PXPUNCT</name></expr>:</case>
      <expr_stmt><expr><name>needstype</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>needschar</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>PT_CLIST</name></expr>:</case>
      <case>case <expr><name>PT_UCNC</name></expr>:</case>
      <expr_stmt><expr><name>needschar</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <break>break;</break>

      <default>default:</default>
      <expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></switch>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
  </block_content>}</block></while>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>compares</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* We are not necessary in utf mode even in 8 bit mode. */</comment>
<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>ccbegin</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <name>XCL_NOT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>READ_CHAR_UPDATE_STR_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else
  <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>needstype</name> <operator>||</operator> <name>needsscript</name><operator>)</operator></expr> ?</condition><then> <expr><name>backtracks</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !SUPPORT_UNICODE */</comment>
  <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
  </block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <name>XCL_HASPROP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <name>XCL_MAP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>optimize_class</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>sljit_u8</name> <operator>*</operator><operator>)</operator><name>cc</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>sljit_u8</name> <operator>*</operator><operator>)</operator><name>cc</name><operator>)</operator><index>[<expr><literal type="number">31</literal></expr>]</index> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_LSHR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <name>XCL_NOT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>backtracks</name></expr> </then><else>: <expr><operator>&amp;</operator><name>found</name></expr></else></ternary></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>max</name> <operator>-</operator> <name>min</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <name>XCL_MAP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <expr_stmt><expr><name>charsaved</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>optimize_class</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>sljit_u8</name> <operator>*</operator><operator>)</operator><name>cc</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 8 */</comment>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_LSHR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 8 */</comment>
      <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>needstype</name> <operator>||</operator> <name>needsscript</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>needschar</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>charsaved</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>MAX_UTF_CODE_POINT</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UNASSIGNED_UTF_CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 32 */</comment>

  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_LSHR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCD_BLOCK_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U16</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_stage1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCD_BLOCK_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>UCD_BLOCK_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_stage2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U16</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM2</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Before anything else, we deal with scripts. */</comment>
  <if_stmt><if>if <condition>(<expr><name>needsscript</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_records</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>ucd_record</name></expr></argument>, <argument><expr><name>script</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ccbegin</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>*</operator><name>cc</name> <operator>!=</operator> <name>XCL_END</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>XCL_SINGLE</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>cc</name> <operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>XCL_RANGE</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>cc</name> <operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>XCL_PROP</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>XCL_NOTPROP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>PT_SC</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>compares</name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>invertcmp</name> <operator>=</operator> <operator>(</operator><name>compares</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>list</name> <operator>!=</operator> <name>backtracks</name><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name><name>cc</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>XCL_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>invertcmp</name> <operator>^=</operator> <literal type="number">0x1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name> <operator>^</operator> <name>invertcmp</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><ternary><condition><expr><name>compares</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>list</name></expr> </then><else>: <expr><name>backtracks</name></expr></else></ternary></expr></argument>, <argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></while>

    <expr_stmt><expr><name>cc</name> <operator>=</operator> <name>ccbegin</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>needstype</name></expr>)</condition>
      <block>{<block_content>
      <comment type="block">/* TMP2 has already been shifted by 2 */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>needschar</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_records</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>ucd_record</name></expr></argument>, <argument><expr><name>chartype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_records</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>ucd_record</name></expr></argument>, <argument><expr><name>chartype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>typereg</name> <operator>=</operator> <name>RETURN_ADDR</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>needschar</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>needstype</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>needschar</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_records</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>ucd_record</name></expr></argument>, <argument><expr><name>chartype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_records</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>ucd_record</name></expr></argument>, <argument><expr><name>chartype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>typereg</name> <operator>=</operator> <name>RETURN_ADDR</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>needschar</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>RETURN_ADDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>

<comment type="block">/* Generating code. */</comment>
<expr_stmt><expr><name>charoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>numberofcmps</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<expr_stmt><expr><name>typeoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>

<while>while <condition>(<expr><operator>*</operator><name>cc</name> <operator>!=</operator> <name>XCL_END</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>compares</name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>invertcmp</name> <operator>=</operator> <operator>(</operator><name>compares</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>list</name> <operator>!=</operator> <name>backtracks</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>XCL_SINGLE</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>cc</name> <operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>numberofcmps</name> <operator>&lt;</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>cc</name> <operator>==</operator> <name>XCL_SINGLE</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>XCL_RANGE</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><name>c</name> <operator>-</operator> <name>charoffset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><ternary><condition><expr><name>numberofcmps</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>SLJIT_MOV</name></expr> </then><else>: <expr><name>SLJIT_OR</name></expr></else></ternary></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>numberofcmps</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>numberofcmps</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><name>c</name> <operator>-</operator> <name>charoffset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name> <operator>^</operator> <name>invertcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>numberofcmps</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name> <operator>^</operator> <name>invertcmp</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><name>c</name> <operator>-</operator> <name>charoffset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>numberofcmps</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>XCL_RANGE</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>cc</name> <operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_CHAR_OFFSET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>numberofcmps</name> <operator>&lt;</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>cc</name> <operator>==</operator> <name>XCL_SINGLE</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>XCL_RANGE</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><name>c</name> <operator>-</operator> <name>charoffset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><ternary><condition><expr><name>numberofcmps</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>SLJIT_MOV</name></expr> </then><else>: <expr><name>SLJIT_OR</name></expr></else></ternary></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>numberofcmps</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>numberofcmps</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><name>c</name> <operator>-</operator> <name>charoffset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name> <operator>^</operator> <name>invertcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>numberofcmps</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS_EQUAL</name> <operator>^</operator> <name>invertcmp</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><name>c</name> <operator>-</operator> <name>charoffset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>numberofcmps</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>XCL_PROP</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>XCL_NOTPROP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>XCL_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>invertcmp</name> <operator>^=</operator> <literal type="number">0x1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
    <switch>switch<condition>(<expr><operator>*</operator><name>cc</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>PT_ANY</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>invertcmp</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>

      <case>case <expr><name>PT_LAMP</name></expr>:</case>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>typereg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_Lu</name> <operator>-</operator> <name>typeoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>typereg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_Ll</name> <operator>-</operator> <name>typeoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>typereg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_Lt</name> <operator>-</operator> <name>typeoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name> <operator>^</operator> <name>invertcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>PT_GC</name></expr>:</case>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_typerange</name></expr></argument>)</argument_list></call><index>[<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SET_TYPE_OFFSET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS_EQUAL</name> <operator>^</operator> <name>invertcmp</name></expr></argument>, <argument><expr><name>typereg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_typerange</name></expr></argument>)</argument_list></call><index>[<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index> <operator>-</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>PT_PC</name></expr>:</case>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name> <operator>^</operator> <name>invertcmp</name></expr></argument>, <argument><expr><name>typereg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name>typeoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>PT_SC</name></expr>:</case>
      <expr_stmt><expr><name>compares</name><operator>++</operator></expr>;</expr_stmt>
      <comment type="block">/* Do nothing. */</comment>
      <break>break;</break>

      <case>case <expr><name>PT_SPACE</name></expr>:</case>
      <case>case <expr><name>PT_PXSPACE</name></expr>:</case>
      <expr_stmt><expr><call><name>SET_CHAR_OFFSET</name><argument_list>(<argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd</literal> <operator>-</operator> <literal type="number">0x9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x85</literal> <operator>-</operator> <literal type="number">0x9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x180e</literal> <operator>-</operator> <literal type="number">0x9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SET_TYPE_OFFSET</name><argument_list>(<argument><expr><name>ucp_Zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>typereg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_Zs</name> <operator>-</operator> <name>ucp_Zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name> <operator>^</operator> <name>invertcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>PT_WORD</name></expr>:</case>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><name>CHAR_UNDERSCORE</name> <operator>-</operator> <name>charoffset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Fall through. */</comment>

      <case>case <expr><name>PT_ALNUM</name></expr>:</case>
      <expr_stmt><expr><call><name>SET_TYPE_OFFSET</name><argument_list>(<argument><expr><name>ucp_Ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>typereg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_Lu</name> <operator>-</operator> <name>ucp_Ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>cc</name> <operator>==</operator> <name>PT_ALNUM</name><operator>)</operator></expr> ?</condition><then> <expr><name>SLJIT_MOV</name></expr> </then><else>: <expr><name>SLJIT_OR</name></expr></else></ternary></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SET_TYPE_OFFSET</name><argument_list>(<argument><expr><name>ucp_Nd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>typereg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_No</name> <operator>-</operator> <name>ucp_Nd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name> <operator>^</operator> <name>invertcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>PT_CLIST</name></expr>:</case>
      <expr_stmt><expr><name>other_cases</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_caseless_sets</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

      <comment type="block">/* At least three characters are required.
         Otherwise this case would be handled by the normal code path. */</comment>
      <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>other_cases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NOTACHAR</name> <operator>&amp;&amp;</operator> <name><name>other_cases</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NOTACHAR</name> <operator>&amp;&amp;</operator> <name><name>other_cases</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <name>NOTACHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>other_cases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>other_cases</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>other_cases</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>other_cases</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Optimizing character pairs, if their difference is power of 2. */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>is_powerof2</name><argument_list>(<argument><expr><name><name>other_cases</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>^</operator> <name><name>other_cases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>charoffset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>other_cases</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>^</operator> <name><name>other_cases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
          <block>{<block_content>
          <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><name>charoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>other_cases</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>^</operator> <name><name>other_cases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>other_cases</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>other_cases</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><call><name>is_powerof2</name><argument_list>(<argument><expr><name><name>other_cases</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>^</operator> <name><name>other_cases</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>charoffset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>other_cases</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>^</operator> <name><name>other_cases</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
          <block>{<block_content>
          <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><name>charoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>other_cases</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>^</operator> <name><name>other_cases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>other_cases</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><name><name>other_cases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>charoffset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>other_cases</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <name>NOTACHAR</name><operator>)</operator></expr> ?</condition><then> <expr><name>SLJIT_SET_Z</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>other_cases</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><operator>*</operator><name>other_cases</name><operator>++</operator> <operator>-</operator> <name>charoffset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

      <while>while <condition>(<expr><operator>*</operator><name>other_cases</name> <operator>!=</operator> <name>NOTACHAR</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><operator>*</operator><name>other_cases</name><operator>++</operator> <operator>-</operator> <name>charoffset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>*</operator><name>other_cases</name> <operator>==</operator> <name>NOTACHAR</name><operator>)</operator></expr> ?</condition><then> <expr><name>SLJIT_SET_Z</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name> <operator>^</operator> <name>invertcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>PT_UCNC</name></expr>:</case>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><name>CHAR_DOLLAR_SIGN</name> <operator>-</operator> <name>charoffset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><name>CHAR_COMMERCIAL_AT</name> <operator>-</operator> <name>charoffset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><name>CHAR_GRAVE_ACCENT</name> <operator>-</operator> <name>charoffset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SET_CHAR_OFFSET</name><argument_list>(<argument><expr><literal type="number">0xa0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><literal type="number">0xd7ff</literal> <operator>-</operator> <name>charoffset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SET_CHAR_OFFSET</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xe000</literal> <operator>-</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name> <operator>^</operator> <name>invertcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>PT_PXGRAPH</name></expr>:</case>
      <comment type="block">/* C and Z groups are the farthest two groups. */</comment>
      <expr_stmt><expr><call><name>SET_TYPE_OFFSET</name><argument_list>(<argument><expr><name>ucp_Ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_GREATER</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>typereg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_So</name> <operator>-</operator> <name>ucp_Ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_GREATER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>typereg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_Cf</name> <operator>-</operator> <name>ucp_Ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* In case of ucp_Cf, we overwrite the result. */</comment>
      <expr_stmt><expr><call><name>SET_CHAR_OFFSET</name><argument_list>(<argument><expr><literal type="number">0x2066</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x2069</literal> <operator>-</operator> <literal type="number">0x2066</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x061c</literal> <operator>-</operator> <literal type="number">0x2066</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x180e</literal> <operator>-</operator> <literal type="number">0x2066</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_ZERO</name> <operator>^</operator> <name>invertcmp</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>PT_PXPRINT</name></expr>:</case>
      <comment type="block">/* C and Z groups are the farthest two groups. */</comment>
      <expr_stmt><expr><call><name>SET_TYPE_OFFSET</name><argument_list>(<argument><expr><name>ucp_Ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_GREATER</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>typereg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_So</name> <operator>-</operator> <name>ucp_Ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_GREATER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>typereg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_Zs</name> <operator>-</operator> <name>ucp_Ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>typereg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_Cf</name> <operator>-</operator> <name>ucp_Ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* In case of ucp_Cf, we overwrite the result. */</comment>
      <expr_stmt><expr><call><name>SET_CHAR_OFFSET</name><argument_list>(<argument><expr><literal type="number">0x2066</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x2069</literal> <operator>-</operator> <literal type="number">0x2066</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x061c</literal> <operator>-</operator> <literal type="number">0x2066</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_ZERO</name> <operator>^</operator> <name>invertcmp</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>PT_PXPUNCT</name></expr>:</case>
      <expr_stmt><expr><call><name>SET_TYPE_OFFSET</name><argument_list>(<argument><expr><name>ucp_Sc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>typereg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_So</name> <operator>-</operator> <name>ucp_Sc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SET_CHAR_OFFSET</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x7f</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SET_TYPE_OFFSET</name><argument_list>(<argument><expr><name>ucp_Pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>typereg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ucp_Ps</name> <operator>-</operator> <name>ucp_Pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name> <operator>^</operator> <name>invertcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <default>default:</default>
      <expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></switch>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>

  <if_stmt><if>if <condition>(<expr><name>jump</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><ternary><condition><expr><name>compares</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>list</name></expr> </then><else>: <expr><name>backtracks</name></expr></else></ternary></expr></argument>, <argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>found</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>found</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET_TYPE_OFFSET</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET_CHAR_OFFSET</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>PCRE2_SPTR</name></type> <name>compile_simple_assertion_matchingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>backtracks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name><name>jump</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>

<switch>switch<condition>(<expr><name>type</name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><name>OP_SOD</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>cc</name></expr>;</return>

  <case>case <expr><name>OP_SOM</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>cc</name></expr>;</return>

  <case>case <expr><name>OP_NOT_WORD_BOUNDARY</name></expr>:</case>
  <case>case <expr><name>OP_WORD_BOUNDARY</name></expr>:</case>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>wordboundary</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>type</name> <operator>==</operator> <name>OP_NOT_WORD_BOUNDARY</name><operator>)</operator></expr> ?</condition><then> <expr><name>SLJIT_NOT_EQUAL</name></expr> </then><else>: <expr><name>SLJIT_SIG_LESS_EQUAL</name></expr></else></ternary></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>cc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
  <expr_stmt><expr><call><name>sljit_set_current_flags</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_SET_Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>OP_NOT_WORD_BOUNDARY</name></expr> ?</condition><then> <expr><name>SLJIT_NOT_ZERO</name></expr> </then><else>: <expr><name>SLJIT_ZERO</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>cc</name></expr>;</return>

  <case>case <expr><name>OP_EODN</name></expr>:</case>
  <comment type="block">/* Requires rather complex checks. */</comment>
  <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_LESS</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_LESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_OR</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>check_partial</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>newline</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>CHAR_CR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name> <operator>|</operator> <name>SLJIT_SET_GREATER</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>)</argument_list></call></expr></argument> <comment type="block">/* LESS */</comment>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Equal. */</comment>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>CHAR_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_ANYCRLF</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>CHAR_NL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>nlmin</name></name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>nlmax</name></name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>READ_CHAR_UPDATE_STR_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>anynewline</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sljit_set_current_flags</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_SET_Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_ZERO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>check_partial</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>cc</name></expr>;</return>

  <case>case <expr><name>OP_EOD</name></expr>:</case>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>check_partial</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>cc</name></expr>;</return>

  <case>case <expr><name>OP_DOLL</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND32</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>PCRE2_NOTEOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND32</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>PCRE2_NOTEOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO32</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>endonly</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>compile_simple_assertion_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>OP_EODN</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>check_partial</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <return>return <expr><name>cc</name></expr>;</return>

  <case>case <expr><name>OP_DOLLM</name></expr>:</case>
  <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND32</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>PCRE2_NOTEOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND32</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>PCRE2_NOTEOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO32</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>check_partial</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* STR_PTR = STR_END - IN_UCHARS(1) */</comment>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>check_partial</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>peek_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>nlmax</name></name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>check_newlinechar</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>cc</name></expr>;</return>

  <case>case <expr><name>OP_CIRC</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND32</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>PCRE2_NOTBOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO32</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND32</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>PCRE2_NOTBOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO32</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <return>return <expr><name>cc</name></expr>;</return>

  <case>case <expr><name>OP_CIRCM</name></expr>:</case>
  <comment type="block">/* TMP2 might be used by peek_char_back. */</comment>
  <if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND32</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>PCRE2_NOTBOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND32</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>PCRE2_NOTBOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO32</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>alt_circumflex</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>peek_char_back</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>nlmax</name></name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>check_newlinechar</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>cc</name></expr>;</return>

  <case>case <expr><name>OP_REVERSE</name></expr>:</case>
  <expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>cc</name> <operator>+</operator> <name>LINK_SIZE</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>move_back</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>check_start_used_ptr</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>cc</name> <operator>+</operator> <name>LINK_SIZE</name></expr>;</return>
  </block_content>}</block></switch>
<expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>cc</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>

<function><type><specifier>static</specifier> <name>PCRE2_SPTR</name> <name>SLJIT_FUNC</name></type> <name>do_extuni_utf</name><parameter_list>(<parameter><decl><type><name>jit_arguments</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>start_subject</name> <init>= <expr><name><name>args</name><operator>-&gt;</operator><name>begin</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>end_subject</name> <init>= <expr><name><name>args</name><operator>-&gt;</operator><name>end</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lgb</name></decl>, <decl><type ref="prev"/><name>rgb</name></decl>, <decl><type ref="prev"/><name>ricount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>prevcc</name></decl>, <decl><type ref="prev"/><name>endcc</name></decl>, <decl><type ref="prev"/><name>bptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>first</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>prevcc</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endcc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<do>do
  <block>{<block_content>
  <expr_stmt><expr><call><name>GETCHARINC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rgb</name> <operator>=</operator> <call><name>UCD_GRAPHBREAK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>lgb</name> <operator>=</operator> <name>rgb</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>endcc</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>first</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gbtable</name></expr></argument>)</argument_list></call><index>[<expr><name>lgb</name></expr>]</index> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>rgb</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <break>break;</break></block_content></block></if></if_stmt>

  <comment type="block">/* Not breaking between Regional Indicators is allowed only if there
  are an even number of preceding RIs. */</comment>

  <if_stmt><if>if <condition>(<expr><name>lgb</name> <operator>==</operator> <name>ucp_gbRegionalIndicator</name> <operator>&amp;&amp;</operator> <name>rgb</name> <operator>==</operator> <name>ucp_gbRegionalIndicator</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>ricount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>bptr</name> <operator>=</operator> <name>prevcc</name></expr>;</expr_stmt>

    <comment type="block">/* bptr is pointing to the left-hand character */</comment>
    <while>while <condition>(<expr><name>bptr</name> <operator>&gt;</operator> <name>start_subject</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>bptr</name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>BACKCHAR</name><argument_list>(<argument><expr><name>bptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETCHAR</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>bptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><call><name>UCD_GRAPHBREAK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ucp_gbRegionalIndicator</name></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>ricount</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ricount</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* Grapheme break required */</comment>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this
  allows any number of them before a following Extended_Pictographic. */</comment>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>rgb</name> <operator>!=</operator> <name>ucp_gbExtend</name> <operator>&amp;&amp;</operator> <name>rgb</name> <operator>!=</operator> <name>ucp_gbZWJ</name><operator>)</operator> <operator>||</operator>
       <name>lgb</name> <operator>!=</operator> <name>ucp_gbExtended_Pictographic</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>lgb</name> <operator>=</operator> <name>rgb</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>prevcc</name> <operator>=</operator> <name>endcc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>endcc</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>
  </block_content>}</block>
while <condition>(<expr><name>cc</name> <operator>&lt;</operator> <name>end_subject</name></expr>)</condition>;</do>

<return>return <expr><name>endcc</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH != 32 */</comment>

<function><type><specifier>static</specifier> <name>PCRE2_SPTR</name> <name>SLJIT_FUNC</name></type> <name>do_extuni_utf_invalid</name><parameter_list>(<parameter><decl><type><name>jit_arguments</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>start_subject</name> <init>= <expr><name><name>args</name><operator>-&gt;</operator><name>begin</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>end_subject</name> <init>= <expr><name><name>args</name><operator>-&gt;</operator><name>end</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lgb</name></decl>, <decl><type ref="prev"/><name>rgb</name></decl>, <decl><type ref="prev"/><name>ricount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>prevcc</name></decl>, <decl><type ref="prev"/><name>endcc</name></decl>, <decl><type ref="prev"/><name>bptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>first</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>prevcc</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endcc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<do>do
  <block>{<block_content>
  <macro><name>GETCHARINC_INVALID</name><argument_list>(<argument>c</argument>, <argument>cc</argument>, <argument>end_subject</argument>, <argument>break</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><name>rgb</name> <operator>=</operator> <call><name>UCD_GRAPHBREAK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>lgb</name> <operator>=</operator> <name>rgb</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>endcc</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>first</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gbtable</name></expr></argument>)</argument_list></call><index>[<expr><name>lgb</name></expr>]</index> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>rgb</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <break>break;</break></block_content></block></if></if_stmt>

  <comment type="block">/* Not breaking between Regional Indicators is allowed only if there
  are an even number of preceding RIs. */</comment>

  <if_stmt><if>if <condition>(<expr><name>lgb</name> <operator>==</operator> <name>ucp_gbRegionalIndicator</name> <operator>&amp;&amp;</operator> <name>rgb</name> <operator>==</operator> <name>ucp_gbRegionalIndicator</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>ricount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>bptr</name> <operator>=</operator> <name>prevcc</name></expr>;</expr_stmt>

    <comment type="block">/* bptr is pointing to the left-hand character */</comment>
    <while>while <condition>(<expr><name>bptr</name> <operator>&gt;</operator> <name>start_subject</name></expr>)</condition>
      <block>{<block_content>
      <macro><name>GETCHARBACK_INVALID</name><argument_list>(<argument>c</argument>, <argument>bptr</argument>, <argument>start_subject</argument>, <argument>break</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

      <if_stmt><if>if <condition>(<expr><call><name>UCD_GRAPHBREAK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ucp_gbRegionalIndicator</name></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>ricount</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ricount</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* Grapheme break required */</comment>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this
  allows any number of them before a following Extended_Pictographic. */</comment>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>rgb</name> <operator>!=</operator> <name>ucp_gbExtend</name> <operator>&amp;&amp;</operator> <name>rgb</name> <operator>!=</operator> <name>ucp_gbZWJ</name><operator>)</operator> <operator>||</operator>
       <name>lgb</name> <operator>!=</operator> <name>ucp_gbExtended_Pictographic</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>lgb</name> <operator>=</operator> <name>rgb</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>prevcc</name> <operator>=</operator> <name>endcc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>endcc</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>
  </block_content>}</block>
while <condition>(<expr><name>cc</name> <operator>&lt;</operator> <name>end_subject</name></expr>)</condition>;</do>

<return>return <expr><name>endcc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PCRE2_SPTR</name> <name>SLJIT_FUNC</name></type> <name>do_extuni_no_utf</name><parameter_list>(<parameter><decl><type><name>jit_arguments</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>start_subject</name> <init>= <expr><name><name>args</name><operator>-&gt;</operator><name>begin</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>end_subject</name> <init>= <expr><name><name>args</name><operator>-&gt;</operator><name>end</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lgb</name></decl>, <decl><type ref="prev"/><name>rgb</name></decl>, <decl><type ref="prev"/><name>ricount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>bptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>;</decl_stmt>

<comment type="block">/* Patch by PH */</comment>
<comment type="block">/* GETCHARINC(c, cc); */</comment>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cc</name><operator>++</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">0x110000</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 32 */</comment>
<expr_stmt><expr><name>lgb</name> <operator>=</operator> <call><name>UCD_GRAPHBREAK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>cc</name> <operator>&lt;</operator> <name>end_subject</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">0x110000</literal></expr>)</condition><block type="pseudo"><block_content>
    <break>break;</break></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 32 */</comment>
  <expr_stmt><expr><name>rgb</name> <operator>=</operator> <call><name>UCD_GRAPHBREAK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gbtable</name></expr></argument>)</argument_list></call><index>[<expr><name>lgb</name></expr>]</index> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>rgb</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <break>break;</break></block_content></block></if></if_stmt>

  <comment type="block">/* Not breaking between Regional Indicators is allowed only if there
  are an even number of preceding RIs. */</comment>

  <if_stmt><if>if <condition>(<expr><name>lgb</name> <operator>==</operator> <name>ucp_gbRegionalIndicator</name> <operator>&amp;&amp;</operator> <name>rgb</name> <operator>==</operator> <name>ucp_gbRegionalIndicator</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>ricount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>bptr</name> <operator>=</operator> <name>cc</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* bptr is pointing to the left-hand character */</comment>
    <while>while <condition>(<expr><name>bptr</name> <operator>&gt;</operator> <name>start_subject</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>bptr</name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>bptr</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">0x110000</literal></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 32 */</comment>

      <if_stmt><if>if <condition>(<expr><call><name>UCD_GRAPHBREAK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ucp_gbRegionalIndicator</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>ricount</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ricount</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* Grapheme break required */</comment>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* If Extend or ZWJ follows Extended_Pictographic, do not update lgb; this
  allows any number of them before a following Extended_Pictographic. */</comment>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>rgb</name> <operator>!=</operator> <name>ucp_gbExtend</name> <operator>&amp;&amp;</operator> <name>rgb</name> <operator>!=</operator> <name>ucp_gbZWJ</name><operator>)</operator> <operator>||</operator>
       <name>lgb</name> <operator>!=</operator> <name>ucp_gbExtended_Pictographic</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>lgb</name> <operator>=</operator> <name>rgb</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

<return>return <expr><name>cc</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>

<function><type><specifier>static</specifier> <name>PCRE2_SPTR</name></type> <name>compile_char1_matchingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>backtracks</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>check_str_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>oc</name></decl>, <decl><type ref="prev"/><name>bit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>compare_context</name></type> <name>context</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name><name>jump</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>end_list</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name><name>propdata</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>

<switch>switch<condition>(<expr><name>type</name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><name>OP_NOT_DIGIT</name></expr>:</case>
  <case>case <expr><name>OP_DIGIT</name></expr>:</case>
  <comment type="block">/* Digits are usually 0-9, so it is worth to optimize them. */</comment>
  <if_stmt><if>if <condition>(<expr><name>check_str_ptr</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>is_char7_bitset</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>sljit_u8</name><operator>*</operator><operator>)</operator><name><name>common</name><operator>-&gt;</operator><name>ctypes</name></name> <operator>-</operator> <name>cbit_length</name> <operator>+</operator> <name>cbit_digit</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>read_char7_type</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>type</name> <operator>==</operator> <name>OP_NOT_DIGIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>read_char8_type</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>type</name> <operator>==</operator> <name>OP_NOT_DIGIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <comment type="block">/* Flip the starting bit in the negative case. */</comment>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ctype_digit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>OP_DIGIT</name></expr> ?</condition><then> <expr><name>SLJIT_ZERO</name></expr> </then><else>: <expr><name>SLJIT_NOT_ZERO</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>cc</name></expr>;</return>

  <case>case <expr><name>OP_NOT_WHITESPACE</name></expr>:</case>
  <case>case <expr><name>OP_WHITESPACE</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>check_str_ptr</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>is_char7_bitset</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>sljit_u8</name><operator>*</operator><operator>)</operator><name><name>common</name><operator>-&gt;</operator><name>ctypes</name></name> <operator>-</operator> <name>cbit_length</name> <operator>+</operator> <name>cbit_space</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>read_char7_type</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>type</name> <operator>==</operator> <name>OP_NOT_WHITESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>read_char8_type</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>type</name> <operator>==</operator> <name>OP_NOT_WHITESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ctype_space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>OP_WHITESPACE</name></expr> ?</condition><then> <expr><name>SLJIT_ZERO</name></expr> </then><else>: <expr><name>SLJIT_NOT_ZERO</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>cc</name></expr>;</return>

  <case>case <expr><name>OP_NOT_WORDCHAR</name></expr>:</case>
  <case>case <expr><name>OP_WORDCHAR</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>check_str_ptr</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>is_char7_bitset</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>sljit_u8</name><operator>*</operator><operator>)</operator><name><name>common</name><operator>-&gt;</operator><name>ctypes</name></name> <operator>-</operator> <name>cbit_length</name> <operator>+</operator> <name>cbit_word</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>read_char7_type</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>type</name> <operator>==</operator> <name>OP_NOT_WORDCHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>read_char8_type</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>type</name> <operator>==</operator> <name>OP_NOT_WORDCHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>ctype_word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>OP_WORDCHAR</name></expr> ?</condition><then> <expr><name>SLJIT_ZERO</name></expr> </then><else>: <expr><name>SLJIT_NOT_ZERO</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>cc</name></expr>;</return>

  <case>case <expr><name>OP_ANY</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>check_str_ptr</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>nlmin</name></name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>nlmax</name></name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>READ_CHAR_UPDATE_STR_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>end_list</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>PCRE2_JIT_PARTIAL_HARD</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_list</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>check_str_end</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>end_list</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>check_newlinechar</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <return>return <expr><name>cc</name></expr>;</return>

  <case>case <expr><name>OP_ALLANY</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>check_str_ptr</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>READ_CHAR_MAX</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>READ_CHAR_UPDATE_STR_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>cc</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:if>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>utf8_table4</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:elif>
    <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xfc00</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xd800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP_FLAGS</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 8 */</comment>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>cc</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == [8|16] */</comment>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>cc</name></expr>;</return>

  <case>case <expr><name>OP_ANYBYTE</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>check_str_ptr</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>cc</name></expr>;</return>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <case>case <expr><name>OP_NOTPROP</name></expr>:</case>
  <case>case <expr><name>OP_PROP</name></expr>:</case>
  <expr_stmt><expr><name><name>propdata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>XCL_HASPROP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>propdata</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>type</name> <operator>==</operator> <name>OP_NOTPROP</name></expr> ?</condition><then> <expr><name>XCL_NOTPROP</name></expr> </then><else>: <expr><name>XCL_PROP</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>propdata</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>cc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>propdata</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>propdata</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>XCL_END</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>check_str_ptr</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>compile_xclass_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>propdata</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>cc</name> <operator>+</operator> <literal type="number">2</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <case>case <expr><name>OP_ANYNL</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>check_str_ptr</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>bsr_nlmin</name></name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>bsr_nlmax</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>CHAR_CR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* We don't need to handle soft partial matching case. */</comment>
  <expr_stmt><expr><name>end_list</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>PCRE2_JIT_PARTIAL_HARD</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_list</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>check_str_end</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>CHAR_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>check_newlinechar</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>bsr_nltype</name></name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>end_list</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>cc</name></expr>;</return>

  <case>case <expr><name>OP_NOT_HSPACE</name></expr>:</case>
  <case>case <expr><name>OP_HSPACE</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>check_str_ptr</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>OP_NOT_HSPACE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">0x9</literal></expr></argument>, <argument><expr><literal type="number">0x3000</literal></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>READ_CHAR_UPDATE_STR_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">0x9</literal></expr></argument>, <argument><expr><literal type="number">0x3000</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>hspace</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sljit_set_current_flags</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_SET_Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>OP_NOT_HSPACE</name></expr> ?</condition><then> <expr><name>SLJIT_NOT_ZERO</name></expr> </then><else>: <expr><name>SLJIT_ZERO</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>cc</name></expr>;</return>

  <case>case <expr><name>OP_NOT_VSPACE</name></expr>:</case>
  <case>case <expr><name>OP_VSPACE</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>check_str_ptr</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>OP_NOT_VSPACE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">0xa</literal></expr></argument>, <argument><expr><literal type="number">0x2029</literal></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>READ_CHAR_UPDATE_STR_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">0xa</literal></expr></argument>, <argument><expr><literal type="number">0x2029</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>vspace</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sljit_set_current_flags</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_SET_Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>OP_NOT_VSPACE</name></expr> ?</condition><then> <expr><name>SLJIT_NOT_ZERO</name></expr> </then><else>: <expr><name>SLJIT_ZERO</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>cc</name></expr>;</return>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <case>case <expr><name>OP_EXTUNI</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>check_str_ptr</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>TMP1</name> <operator>==</operator> <name>SLJIT_R0</name> <operator>&amp;&amp;</operator> <name>STR_PTR</name> <operator>==</operator> <name>SLJIT_R1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
  <expr_stmt><expr><call><name>sljit_emit_icall</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_CALL</name></expr></argument>, <argument><expr><call><name>SLJIT_RET</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>SLJIT_ARG1</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>SLJIT_ARG2</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>,
    <argument><expr><ternary><condition><expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr> ?</condition><then> <expr><call><name>SLJIT_FUNC_OFFSET</name><argument_list>(<argument><expr><name>do_extuni_utf_invalid</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>SLJIT_FUNC_OFFSET</name><argument_list>(<argument><expr><name>do_extuni_utf</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr> </then><else>: <expr><call><name>SLJIT_FUNC_OFFSET</name><argument_list>(<argument><expr><name>do_extuni_no_utf</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>sljit_emit_icall</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_CALL</name></expr></argument>, <argument><expr><call><name>SLJIT_RET</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>SLJIT_ARG1</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>SLJIT_ARG2</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>,
    <argument><expr><ternary><condition><expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr> ?</condition><then> <expr><call><name>SLJIT_FUNC_OFFSET</name><argument_list>(<argument><expr><name>do_extuni_utf_invalid</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>SLJIT_FUNC_OFFSET</name><argument_list>(<argument><expr><name>do_extuni_no_utf</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>||</operator> <name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_PARTIAL_HARD</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Since we successfully read a char above, partial matching must occure. */</comment>
    <expr_stmt><expr><call><name>check_partial</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <return>return <expr><name>cc</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <case>case <expr><name>OP_CHAR</name></expr>:</case>
  <case>case <expr><name>OP_CHARI</name></expr>:</case>
  <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>length</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if <condition>(<expr><name>check_str_ptr</name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>OP_CHAR</name> <operator>||</operator> <operator>!</operator><call><name>char_has_othercase</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>char_get_othercase_bit</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>check_str_ptr</name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>length</name></name> <operator>=</operator> <call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>sourcereg</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SLJIT_UNALIGNED</name> <operator>&amp;&amp;</operator> <name>SLJIT_UNALIGNED</name></expr></cpp:if>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>ucharptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><call><name>byte_sequence_compare</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>type</name> <operator>==</operator> <name>OP_CHARI</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>GETCHAR</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>OP_CHARI</name> <operator>&amp;&amp;</operator> <call><name>char_has_othercase</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>check_str_ptr</name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>oc</name> <operator>=</operator> <call><name>char_othercase</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><ternary><condition><expr><name>c</name> <operator>&lt;</operator> <name>oc</name></expr> ?</condition><then> <expr><name>c</name></expr> </then><else>: <expr><name>oc</name></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><name>c</name> <operator>&gt;</operator> <name>oc</name></expr> ?</condition><then> <expr><name>c</name></expr> </then><else>: <expr><name>oc</name></expr></else></ternary></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>is_powerof2</name><argument_list>(<argument><expr><name>c</name> <operator>^</operator> <name>oc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>sljit_has_cpu_feature</name><argument_list>(<argument><expr><name>SLJIT_HAS_CMOV</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>oc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>oc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <return>return <expr><name>cc</name> <operator>+</operator> <name>length</name></expr>;</return>

  <case>case <expr><name>OP_NOT</name></expr>:</case>
  <case>case <expr><name>OP_NOTI</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>check_str_ptr</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">128</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>OP_NOT</name> <operator>||</operator> <operator>!</operator><call><name>char_has_othercase</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else
        <block>{<block_content>
        <comment type="block">/* Since UTF8 code page is fixed, we know that c is in [a-z] or [A-Z] range. */</comment>
        <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>c</name> <operator>|</operator> <literal type="number">0x20</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      <comment type="block">/* Skip the variable-length character. */</comment>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>utf8_table4</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if>
    <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 8 */</comment>
      <block>{<block_content>
      <expr_stmt><expr><call><name>GETCHARLEN</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>OP_NOT</name> <operator>||</operator> <operator>!</operator><call><name>char_has_othercase</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>READ_CHAR_UPDATE_STR_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><name>oc</name> <operator>=</operator> <call><name>char_othercase</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><ternary><condition><expr><name>c</name> <operator>&lt;</operator> <name>oc</name></expr> ?</condition><then> <expr><name>c</name></expr> </then><else>: <expr><name>oc</name></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><name>c</name> <operator>&gt;</operator> <name>oc</name></expr> ?</condition><then> <expr><name>c</name></expr> </then><else>: <expr><name>oc</name></expr></else></ternary></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>READ_CHAR_UPDATE_STR_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bit</name> <operator>=</operator> <name>c</name> <operator>^</operator> <name>oc</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>is_powerof2</name><argument_list>(<argument><expr><name>bit</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>bit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>c</name> <operator>|</operator> <name>bit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>oc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  <return>return <expr><name>cc</name> <operator>+</operator> <name>length</name></expr>;</return>

  <case>case <expr><name>OP_CLASS</name></expr>:</case>
  <case>case <expr><name>OP_NCLASS</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>check_str_ptr</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
  <expr_stmt><expr><name>bit</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>is_char7_bitset</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>sljit_u8</name> <operator>*</operator><operator>)</operator><name>cc</name></expr></argument>, <argument><expr><name>type</name> <operator>==</operator> <name>OP_NCLASS</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">127</literal></expr> </then><else>: <expr><literal type="number">255</literal></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>OP_NCLASS</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bit</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>READ_CHAR_UPDATE_STR_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>OP_NCLASS</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>READ_CHAR_UPDATE_STR_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if <condition>(<expr><call><name>optimize_class</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>sljit_u8</name> <operator>*</operator><operator>)</operator><name>cc</name></expr></argument>, <argument><expr><name>type</name> <operator>==</operator> <name>OP_NCLASS</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>cc</name> <operator>+</operator> <literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
  <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>bit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>OP_CLASS</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:elif>
  <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>OP_CLASS</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE &amp;&amp; PCRE2_CODE_UNIT_WIDTH == 8 */</comment>

  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0x7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_LSHR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_ZERO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name><name>jump</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>cc</name> <operator>+</operator> <literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof></expr>;</return>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
  <case>case <expr><name>OP_XCLASS</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>check_str_ptr</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>compile_xclass_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>cc</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></switch>
<expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>cc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>PCRE2_SPTR</name></type> <name>compile_charn_matchingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ccend</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>backtracks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* This function consumes at least one input character. */</comment>
<comment type="block">/* To decrease the number of length checks, we try to concatenate the fixed length character sequences. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ccbegin</name> <init>= <expr><name>cc</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>compare_context</name></type> <name>context</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>context</name><operator>.</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<do>do
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&gt;=</operator> <name>ccend</name></expr>)</condition><block type="pseudo"><block_content>
    <break>break;</break></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_CHAR</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_CHARI</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>char_has_othercase</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>char_get_othercase_bit</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if>
    <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    if <condition>(<expr><call><name>char_has_othercase</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>char_get_othercase_bit</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>length</name></name> <operator>+=</operator> <call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block>
while <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>context</name><operator>.</operator><name>length</name></name> <operator>&lt;=</operator> <literal type="number">128</literal></expr>)</condition>;</do>

<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>ccbegin</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* We have a fixed-length byte sequence. */</comment>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>sourcereg</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SLJIT_UNALIGNED</name> <operator>&amp;&amp;</operator> <name>SLJIT_UNALIGNED</name></expr></cpp:if>
  <expr_stmt><expr><name><name>context</name><operator>.</operator><name>ucharptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>byte_sequence_compare</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_CHARI</name></expr></argument>, <argument><expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><name><name>context</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
  <return>return <expr><name>cc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* A non-fixed length character will be checked if length == 0. */</comment>
<return>return <expr><call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>*</operator><name>cc</name></expr></argument>, <argument><expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Forward definitions. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compile_matchingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type></decl></parameter>, <parameter><decl><type><name>backtrack_common</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compile_backtrackingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>backtrack_common</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUSH_BACKTRACK</name><parameter_list>(<parameter><type><name>size</name></type></parameter>, <parameter><type><name>ccstart</name></type></parameter>, <parameter><type><name>error</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>do \
    { \
    backtrack = sljit_alloc_memory(compiler, (size)); \
    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \
      return error; \
    memset(backtrack, 0, size); \
    backtrack-&gt;prev = parent-&gt;top; \
    backtrack-&gt;cc = (ccstart); \
    parent-&gt;top = backtrack; \
    } \
  while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUSH_BACKTRACK_NOVALUE</name><parameter_list>(<parameter><type><name>size</name></type></parameter>, <parameter><type><name>ccstart</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>do \
    { \
    backtrack = sljit_alloc_memory(compiler, (size)); \
    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \
      return; \
    memset(backtrack, 0, size); \
    backtrack-&gt;prev = parent-&gt;top; \
    backtrack-&gt;cc = (ccstart); \
    parent-&gt;top = backtrack; \
    } \
  while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKTRACK_AS</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((type *)backtrack)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>compile_dnref_search</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>backtracks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* The OVECTOR offset goes to TMP2. */</comment>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>slot</name> <init>= <expr><name><name>common</name><operator>-&gt;</operator><name>name_table</name></name> <operator>+</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>common</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>found</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_DNREF</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_DNREFI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
<while>while <condition>(<expr><name>count</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>GET_LOCAL_BASE</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>slot</name> <operator>+=</operator> <name><name>common</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GET_LOCAL_BASE</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>backtracks</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>unset_backref</name></name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>found</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>compile_ref_matchingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>backtracks</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>withchecks</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>emptyfail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>ref</name> <init>= <expr><operator>(</operator><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_REF</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_REFI</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>partial</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>nopartial</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>loop</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>caseless_loop</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>no_match</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>source_reg</name> <init>= <expr><name>COUNT_MATCH</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>source_end_reg</name> <init>= <expr><name>ARGUMENTS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>char1_reg</name> <init>= <expr><name>STACK_LIMIT</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>

<if_stmt><if>if <condition>(<expr><name>ref</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* OVECTOR(1) contains the "string begin - 1" constant. */</comment>
  <if_stmt><if>if <condition>(<expr><name>withchecks</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>unset_backref</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_REFI</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>iref_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>ref</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>withchecks</name> <operator>&amp;&amp;</operator> <name>emptyfail</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>iref_ptr</name></name></expr></argument>, <argument><expr><name>source_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>iref_ptr</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>source_end_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>iref_ptr</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>source_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>source_end_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>source_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>source_end_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>partial</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read original character. It must be a valid UTF character. */</comment>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>source_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>READ_CHAR_MAX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>READ_CHAR_UPDATE_STR_PTR</name> <operator>|</operator> <name>READ_CHAR_VALID_UTF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>source_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read second character. */</comment>
  <expr_stmt><expr><call><name>read_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>READ_CHAR_MAX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_match</name></expr></argument>, <argument><expr><name>READ_CHAR_UPDATE_STR_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>getucd</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_records</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_S32</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>ucd_record</name></expr></argument>, <argument><expr><name>other_case</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U8</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>ucd_record</name></expr></argument>, <argument><expr><name>caseset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_match</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SHL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_caseless_sets</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>caseless_loop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U32</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name> <operator>|</operator> <name>SLJIT_SET_LESS</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>caseless_loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>no_match</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>partial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>source_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>iref_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>source_end_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>iref_ptr</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>iref_ptr</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>partial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>source_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>iref_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>source_end_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>iref_ptr</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>iref_ptr</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>check_partial</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>source_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>iref_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>source_end_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>iref_ptr</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>char1_reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>iref_ptr</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
  </block_content>}</block></if>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>ref</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>withchecks</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>partial</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>partial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_REF</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>casefulcmp</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>caselesscmp</name></name></expr></else></ternary></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>nopartial</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>partial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* TMP2 -= STR_END - STR_PTR */</comment>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>partial</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_REF</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>casefulcmp</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>caselesscmp</name></name></expr></else></ternary></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>partial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>check_partial</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>nopartial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>jump</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>emptyfail</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>backtracks</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>PCRE2_SPTR</name></type> <name>compile_ref_iterator_matchingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>ref</name> <init>= <expr><operator>(</operator><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_REF</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_REFI</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>backtrack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>zerolength</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ccbegin</name> <init>= <expr><name>cc</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>min</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>minimize</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PUSH_BACKTRACK</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ref_iterator_backtrack</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ref</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><name>cc</name> <operator>+=</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SLJIT_COMPILE_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>OP_CRSTAR</name> <operator>&amp;</operator> <literal type="number">0x1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>crstar_opcode_must_be_even</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>minimize</name> <operator>=</operator> <operator>(</operator><name>type</name> <operator>&amp;</operator> <literal type="number">0x1</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name>type</name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><name>OP_CRSTAR</name></expr>:</case>
  <case>case <expr><name>OP_CRMINSTAR</name></expr>:</case>
  <expr_stmt><expr><name>min</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>max</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <break>break;</break>
  <case>case <expr><name>OP_CRPLUS</name></expr>:</case>
  <case>case <expr><name>OP_CRMINPLUS</name></expr>:</case>
  <expr_stmt><expr><name>min</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>max</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <break>break;</break>
  <case>case <expr><name>OP_CRQUERY</name></expr>:</case>
  <case>case <expr><name>OP_CRMINQUERY</name></expr>:</case>
  <expr_stmt><expr><name>min</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>max</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <break>break;</break>
  <case>case <expr><name>OP_CRRANGE</name></expr>:</case>
  <case>case <expr><name>OP_CRMINRANGE</name></expr>:</case>
  <expr_stmt><expr><name>min</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
  <break>break;</break>
  <default>default:</default>
  <expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
  </block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>minimize</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>min</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ref</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Temporary release of STR_PTR. */</comment>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Handles both invalid and empty cases. Since the minimum repeat,
    is zero the invalid case is basically the same as an empty case. */</comment>
    <if_stmt><if>if <condition>(<expr><name>ref</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>zerolength</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>compile_dnref_search</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ccbegin</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>POSSESSIVE1</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zerolength</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <comment type="block">/* Restore if not zero length. */</comment>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ref</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ref</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zerolength</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>compile_dnref_search</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ccbegin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>POSSESSIVE1</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>zerolength</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>min</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>max</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>POSSESSIVE0</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ref</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>POSSESSIVE1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>compile_ref_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ccbegin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>min</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>max</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>POSSESSIVE0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>POSSESSIVE0</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>min</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>max</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>max</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* Includes min &gt; 1 case as well. */</comment>
    <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>zerolength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>ref_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>count_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>cc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><ternary><condition><expr><name>ref</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ref</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>OP_CRMINSTAR</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>min</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Handles both invalid and empty cases. Since the minimum repeat,
  is zero the invalid case is basically the same as an empty case. */</comment>
  <if_stmt><if>if <condition>(<expr><name>ref</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>zerolength</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>compile_dnref_search</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ccbegin</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zerolength</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <comment type="block">/* Length is non-zero, we can match real repeats. */</comment>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>ref</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zerolength</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>compile_dnref_search</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ccbegin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>zerolength</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>ref_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>max</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ref</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>compile_ref_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ccbegin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>min</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>ref_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>max</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>jump</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>zerolength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>count_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>cc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>PCRE2_SPTR</name></type> <name>compile_recurse_matchingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>backtrack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>recurse_entry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name><name>common</name><operator>-&gt;</operator><name>entries</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>recurse_entry</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_sw</name></type> <name>start</name> <init>= <expr><call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>start_cc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>needs_control_head</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PUSH_BACKTRACK</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>recurse_backtrack</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Inlining simple patterns. */</comment>
<if_stmt><if>if <condition>(<expr><call><name>get_framesize</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start</name></name> <operator>+</operator> <name>start</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>needs_control_head</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>no_stack</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>start_cc</name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name> <operator>+</operator> <name>start</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>compile_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><call><name>next_opcode</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>start_cc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>bracketend</name><argument_list>(<argument><expr><name>start_cc</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name><operator>)</operator></expr></argument>, <argument><expr><name>backtrack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>recurse_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>inlined_pattern</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <return>return <expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>entry</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>start</name></name> <operator>==</operator> <name>start</name></expr>)</condition><block type="pseudo"><block_content>
    <break>break;</break></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>entry</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>sljit_alloc_memory</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>recurse_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><call><name>sljit_get_compiler_error</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>entry_label</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>backtrack_label</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>entry_calls</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>backtrack_calls</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>prev</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>entries</name></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>recurse_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>entry</name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>entry_label</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>entry_calls</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>entry_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<comment type="block">/* Leave if the match is failed. */</comment>
<expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>recurse_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sljit_s32</name> <name>SLJIT_FUNC</name></type> <name>do_callout</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>jit_arguments</name></name> <modifier>*</modifier></type><name>arguments</name></decl></parameter>, <parameter><decl><type><name>pcre2_callout_block</name> <modifier>*</modifier></type><name>callout_block</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name> <modifier>*</modifier></type><name>jit_ovector</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>begin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>ovector</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_u32</name></type> <name>oveccount</name></decl>, <decl><type ref="prev"/><name>capture_top</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>arguments</name><operator>-&gt;</operator><name>callout</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>SLJIT_COMPILE_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>PCRE2_SIZE</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>pcre2_size_must_be_lower_than_sljit_sw_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>begin</name> <operator>=</operator> <name><name>arguments</name><operator>-&gt;</operator><name>begin</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ovector</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>*</operator><operator>)</operator><operator>(</operator><name>callout_block</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>oveccount</name> <operator>=</operator> <name><name>callout_block</name><operator>-&gt;</operator><name>capture_top</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>oveccount</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>callout_block</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>callout_block</name><operator>-&gt;</operator><name>callout_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<comment type="block">/* Offsets in subject. */</comment>
<expr_stmt><expr><name><name>callout_block</name><operator>-&gt;</operator><name>subject_length</name></name> <operator>=</operator> <name><name>arguments</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>arguments</name><operator>-&gt;</operator><name>begin</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>callout_block</name><operator>-&gt;</operator><name>start_match</name></name> <operator>=</operator> <name><name>jit_ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>begin</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>callout_block</name><operator>-&gt;</operator><name>current_position</name></name> <operator>=</operator> <operator>(</operator><name>PCRE2_SPTR</name><operator>)</operator><name><name>callout_block</name><operator>-&gt;</operator><name>offset_vector</name></name> <operator>-</operator> <name>begin</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>callout_block</name><operator>-&gt;</operator><name>subject</name></name> <operator>=</operator> <name>begin</name></expr>;</expr_stmt>

<comment type="block">/* Convert and copy the JIT offset vector to the ovector array. */</comment>
<expr_stmt><expr><name><name>callout_block</name><operator>-&gt;</operator><name>capture_top</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>callout_block</name><operator>-&gt;</operator><name>offset_vector</name></name> <operator>=</operator> <name>ovector</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>PCRE2_UNSET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>PCRE2_UNSET</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ovector</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>jit_ovector</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>capture_top</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<comment type="block">/* Convert pointers to sizes. */</comment>
<while>while <condition>(<expr><operator>--</operator><name>oveccount</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>capture_top</name><operator>++</operator></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name><name>jit_ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>begin</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name><name>jit_ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name>begin</name><operator>)</operator></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>PCRE2_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>callout_block</name><operator>-&gt;</operator><name>capture_top</name></name> <operator>=</operator> <name>capture_top</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>ovector</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>jit_ovector</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></while>

<return>return <expr><operator>(</operator><name><name>arguments</name><operator>-&gt;</operator><name>callout</name></name><operator>)</operator><operator>(</operator><name>callout_block</name><operator>,</operator> <name><name>arguments</name><operator>-&gt;</operator><name>callout_data</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLOUT_ARG_OFFSET</name><parameter_list>(<parameter><type><name>arg</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>SLJIT_OFFSETOF(pcre2_callout_block, arg)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>PCRE2_SPTR</name></type> <name>compile_callout_matchingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>backtrack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_s32</name></type> <name>mov_opcode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>callout_length</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_CALLOUT</name><operator>)</operator></expr>
    ?</condition><then> <expr><call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>OP_CALLOUT</name></expr>]</index></expr> </then><else>: <expr><call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_sw</name></type> <name>value1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_sw</name></type> <name>value2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_sw</name></type> <name>value3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_uw</name></type> <name>callout_arg_size</name> <init>= <expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>re</name><operator>-&gt;</operator><name>top_bracket</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PUSH_BACKTRACK</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>backtrack_common</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>callout_arg_size</name> <operator>=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pcre2_callout_block</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>callout_arg_size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>callout_arg_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>value1</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_CALLOUT</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>cc</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>LINK_SIZE</name></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U32</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CALLOUT_ARG_OFFSET</name><argument_list>(<argument><expr><name>callout_number</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>value1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U32</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CALLOUT_ARG_OFFSET</name><argument_list>(<argument><expr><name>capture_last</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U32</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CALLOUT_ARG_OFFSET</name><argument_list>(<argument><expr><name>capture_top</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>re</name><operator>-&gt;</operator><name>top_bracket</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* These pointer sized fields temporarly stores internal variables. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CALLOUT_ARG_OFFSET</name><argument_list>(<argument><expr><name>offset_vector</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>mark_ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>mov_opcode</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_SIZE</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">4</literal><operator>)</operator></expr> ?</condition><then> <expr><name>SLJIT_MOV_U32</name></expr> </then><else>: <expr><name>SLJIT_MOV</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>mov_opcode</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CALLOUT_ARG_OFFSET</name><argument_list>(<argument><expr><name>pattern_position</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>mov_opcode</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CALLOUT_ARG_OFFSET</name><argument_list>(<argument><expr><name>next_item_length</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_CALLOUT</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>value1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>value2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>value3</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><name>value1</name> <operator>=</operator> <operator>(</operator><name>sljit_sw</name><operator>)</operator> <operator>(</operator><name>cc</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>LINK_SIZE</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>value2</name> <operator>=</operator> <operator>(</operator><name>callout_length</name> <operator>-</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>LINK_SIZE</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>value3</name> <operator>=</operator> <operator>(</operator><name>sljit_sw</name><operator>)</operator> <operator>(</operator><call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">3</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CALLOUT_ARG_OFFSET</name><argument_list>(<argument><expr><name>callout_string</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>value1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>mov_opcode</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CALLOUT_ARG_OFFSET</name><argument_list>(<argument><expr><name>callout_string_length</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>value2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>mov_opcode</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CALLOUT_ARG_OFFSET</name><argument_list>(<argument><expr><name>callout_string_offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>value3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CALLOUT_ARG_OFFSET</name><argument_list>(<argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>TMP2</name></expr> </then><else>: <expr><name>SLJIT_IMM</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>TMP1</name> <operator>==</operator> <name>SLJIT_R0</name> <operator>&amp;&amp;</operator> <name>STR_PTR</name> <operator>==</operator> <name>SLJIT_R1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Needed to save important temporary registers. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS0</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* SLJIT_R0 = arguments */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GET_LOCAL_BASE</name><argument_list>(<argument><expr><name>SLJIT_R2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>OVECTOR_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sljit_emit_icall</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_CALL</name></expr></argument>, <argument><expr><call><name>SLJIT_RET</name><argument_list>(<argument><expr><name>S32</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>SLJIT_ARG1</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>SLJIT_ARG2</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>SLJIT_ARG3</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>SLJIT_FUNC_OFFSET</name><argument_list>(<argument><expr><name>do_callout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>callout_arg_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Check return value. */</comment>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB32</name> <operator>|</operator> <name>SLJIT_SET_Z</name> <operator>|</operator> <name>SLJIT_SET_SIG_GREATER</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_SIG_GREATER32</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>abort_label</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>abort</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL32</name></expr></argument>)</argument_list></call></expr></argument> <comment type="block">/* SIG_LESS */</comment>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL32</name></expr></argument> <comment type="block">/* SIG_LESS */</comment>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>abort_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><name>cc</name> <operator>+</operator> <name>callout_length</name></expr>;</return>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CALLOUT_ARG_SIZE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CALLOUT_ARG_OFFSET</name></cpp:undef>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>BOOL</name></type> <name>assert_needs_str_ptr_saving</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name>TRUE</name></expr>)</condition>
  <block>{<block_content>
  <switch>switch <condition>(<expr><operator>*</operator><name>cc</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>OP_CALLOUT_STR</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_NOT_WORD_BOUNDARY</name></expr>:</case>
    <case>case <expr><name>OP_WORD_BOUNDARY</name></expr>:</case>
    <case>case <expr><name>OP_CIRC</name></expr>:</case>
    <case>case <expr><name>OP_CIRCM</name></expr>:</case>
    <case>case <expr><name>OP_DOLL</name></expr>:</case>
    <case>case <expr><name>OP_DOLLM</name></expr>:</case>
    <case>case <expr><name>OP_CALLOUT</name></expr>:</case>
    <case>case <expr><name>OP_ALT</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>cc</name></expr>]</index></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_KET</name></expr>:</case>
    <return>return <expr><name>FALSE</name></expr>;</return>

    <default>default:</default>
    <return>return <expr><name>TRUE</name></expr>;</return>
    </block_content>}</block></switch>
  </block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PCRE2_SPTR</name></type> <name>compile_assert_matchingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>assert_backtrack</name> <modifier>*</modifier></type><name>backtrack</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>conditional</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>framesize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>extrasize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>local_quit_available</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>needs_control_head</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>private_data_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>backtrack_common</name></type> <name>altbacktrack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ccbegin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>opcode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>bra</name> <init>= <expr><name>OP_BRA</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>target</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>conditional</name><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>condfailed</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>topbacktracks</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier><modifier>*</modifier></type><name>found</name></decl>;</decl_stmt>
<comment type="block">/* Saving previous accept variables. */</comment>
<decl_stmt><decl><type><name>BOOL</name></type> <name>save_local_quit_available</name> <init>= <expr><name><name>common</name><operator>-&gt;</operator><name>local_quit_available</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>save_in_positive_assertion</name> <init>= <expr><name><name>common</name><operator>-&gt;</operator><name>in_positive_assertion</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>then_trap_backtrack</name> <modifier>*</modifier></type><name>save_then_trap</name> <init>= <expr><name><name>common</name><operator>-&gt;</operator><name>then_trap</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>save_quit_label</name> <init>= <expr><name><name>common</name><operator>-&gt;</operator><name>quit_label</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>save_accept_label</name> <init>= <expr><name><name>common</name><operator>-&gt;</operator><name>accept_label</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>save_quit</name> <init>= <expr><name><name>common</name><operator>-&gt;</operator><name>quit</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>save_positive_assertion_quit</name> <init>= <expr><name><name>common</name><operator>-&gt;</operator><name>positive_assertion_quit</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>save_accept</name> <init>= <expr><name><name>common</name><operator>-&gt;</operator><name>accept</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>brajump</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Assert captures then. */</comment>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>then_trap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_BRAZERO</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_BRAMINZERO</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name>conditional</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>bra</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>private_data_ptr</name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>private_data_ptr</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>framesize</name> <operator>=</operator> <call><name>get_framesize</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>needs_control_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>backtrack</name><operator>-&gt;</operator><name>framesize</name></name> <operator>=</operator> <name>framesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>backtrack</name><operator>-&gt;</operator><name>private_data_ptr</name></name> <operator>=</operator> <name>private_data_ptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>opcode</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>opcode</name> <operator>&gt;=</operator> <name>OP_ASSERT</name> <operator>&amp;&amp;</operator> <name>opcode</name> <operator>&lt;=</operator> <name>OP_ASSERTBACK_NOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>opcode</name> <operator>==</operator> <name>OP_ASSERT</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_ASSERTBACK</name><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name>tmp</name></expr> </then><else>: <expr><name>target</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>ccbegin</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAMINZERO</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* This is a braminzero backtrack path. */</comment>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>brajump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>framesize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>extrasize</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRA</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>assert_needs_str_ptr_saving</name><argument_list>(<argument><expr><name>ccbegin</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>extrasize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>extrasize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>framesize</name> <operator>==</operator> <name>no_frame</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>extrasize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>extrasize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>extrasize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>extrasize</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><name>extrasize</name> <operator>=</operator> <ternary><condition><expr><name>needs_control_head</name></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>framesize</name> <operator>+</operator> <name>extrasize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>framesize</name> <operator>+</operator> <name>extrasize</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <expr_stmt><expr><call><name>init_frame</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ccbegin</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>framesize</name> <operator>+</operator> <name>extrasize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>extrasize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>altbacktrack</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>backtrack_common</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>conditional</name> <operator>||</operator> <operator>(</operator><name>opcode</name> <operator>==</operator> <name>OP_ASSERT_NOT</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_ASSERTBACK_NOT</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Control verbs cannot escape from these asserts. */</comment>
  <expr_stmt><expr><name>local_quit_available</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>local_quit_available</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>quit_label</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>quit</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>in_positive_assertion</name></name> <operator>=</operator> <operator>(</operator><name>opcode</name> <operator>==</operator> <name>OP_ASSERT</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_ASSERTBACK</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>positive_assertion_quit</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>accept_label</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>accept</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>altbacktrack</name><operator>.</operator><name>top</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>altbacktrack</name><operator>.</operator><name>topbacktracks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ccbegin</name> <operator>==</operator> <name>OP_ALT</name> <operator>&amp;&amp;</operator> <name>extrasize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>altbacktrack</name><operator>.</operator><name>cc</name></name> <operator>=</operator> <name>ccbegin</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>compile_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ccbegin</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>altbacktrack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><call><name>sljit_get_compiler_error</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>local_quit_available</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>local_quit_available</name></name> <operator>=</operator> <name>save_local_quit_available</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>quit_label</name></name> <operator>=</operator> <name>save_quit_label</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>quit</name></name> <operator>=</operator> <name>save_quit</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>in_positive_assertion</name></name> <operator>=</operator> <name>save_in_positive_assertion</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>then_trap</name></name> <operator>=</operator> <name>save_then_trap</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>accept_label</name></name> <operator>=</operator> <name>save_accept_label</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>positive_assertion_quit</name></name> <operator>=</operator> <name>save_positive_assertion_quit</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>accept</name></name> <operator>=</operator> <name>save_accept</name></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>accept_label</name></name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>accept</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>accept</name></name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>accept_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Reset stack. */</comment>
  <if_stmt><if>if <condition>(<expr><name>framesize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>framesize</name> <operator>==</operator> <name>no_frame</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>extrasize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>extrasize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>opcode</name> <operator>!=</operator> <name>OP_ASSERT_NOT</name> <operator>&amp;&amp;</operator> <name>opcode</name> <operator>!=</operator> <name>OP_ASSERTBACK_NOT</name><operator>)</operator> <operator>||</operator> <name>conditional</name></expr>)</condition>
      <block>{<block_content>
      <comment type="block">/* We don't need to keep the STR_PTR, only the previous private_data_ptr. */</comment>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>framesize</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><name>framesize</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>revertframes</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>framesize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_ASSERT_NOT</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_ASSERTBACK_NOT</name></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* We know that STR_PTR was stored on the top of the stack. */</comment>
    <if_stmt><if>if <condition>(<expr><name>conditional</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>extrasize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name>needs_control_head</name></expr> ?</condition><then> <expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>framesize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><name>extrasize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><name>framesize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><name>framesize</name> <operator>-</operator> <name>extrasize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>framesize</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <comment type="block">/* For OP_BRA and OP_BRAMINZERO. */</comment>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><name>framesize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>found</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>compile_backtrackingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>altbacktrack</name><operator>.</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><call><name>sljit_get_compiler_error</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>local_quit_available</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>local_quit_available</name></name> <operator>=</operator> <name>save_local_quit_available</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>quit_label</name></name> <operator>=</operator> <name>save_quit_label</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>quit</name></name> <operator>=</operator> <name>save_quit</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>in_positive_assertion</name></name> <operator>=</operator> <name>save_in_positive_assertion</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>then_trap</name></name> <operator>=</operator> <name>save_then_trap</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>accept_label</name></name> <operator>=</operator> <name>save_accept_label</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>positive_assertion_quit</name></name> <operator>=</operator> <name>save_positive_assertion_quit</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>accept</name></name> <operator>=</operator> <name>save_accept</name></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>altbacktrack</name><operator>.</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>!=</operator> <name>OP_ALT</name></expr>)</condition><block type="pseudo"><block_content>
    <break>break;</break></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>ccbegin</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>local_quit_available</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>positive_assertion_quit</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Makes the check less complicated below. */</comment>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>positive_assertion_quit</name></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>quit</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* None of them matched. */</comment>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>positive_assertion_quit</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>positive_assertion_quit</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>framesize</name> <operator>!=</operator> <name>no_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>framesize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>extrasize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>revertframes</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>extrasize</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_ASSERT</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_ASSERTBACK</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Assert is failed. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>conditional</name> <operator>&amp;&amp;</operator> <name>extrasize</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>framesize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* The topmost item should be 0. */</comment>
    <if_stmt><if>if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>extrasize</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>extrasize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>extrasize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>extrasize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* The topmost item should be 0. */</comment>
    <if_stmt><if>if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>framesize</name> <operator>+</operator> <name>extrasize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>framesize</name> <operator>+</operator> <name>extrasize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>bra</name> <operator>!=</operator> <name>OP_BRAZERO</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Assert is successful. */</comment>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>framesize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* We know that STR_PTR was stored on the top of the stack. */</comment>
    <if_stmt><if>if <condition>(<expr><name>extrasize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><name>extrasize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Keep the STR_PTR on the top of the stack. */</comment>
    <if_stmt><if>if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>extrasize</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAMINZERO</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRA</name></expr>)</condition>
      <block>{<block_content>
      <comment type="block">/* We don't need to keep the STR_PTR, only the previous private_data_ptr. */</comment>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>framesize</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><name>extrasize</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <comment type="block">/* We don't need to keep the STR_PTR, only the previous private_data_ptr. */</comment>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>framesize</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>extrasize</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAMINZERO</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>extrasize</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name></expr> ?</condition><then> <expr><name>STR_PTR</name></expr> </then><else>: <expr><name>SLJIT_IMM</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name><name>backtrack</name><operator>-&gt;</operator><name>matchingpath</name></name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_LABEL</name><argument_list>(<argument><expr><name>jump</name></expr></argument>, <argument><expr><name><name>backtrack</name><operator>-&gt;</operator><name>matchingpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAMINZERO</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name><name>backtrack</name><operator>-&gt;</operator><name>matchingpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>brajump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>framesize</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>revertframes</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>framesize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>backtrack</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <comment type="block">/* AssertNot is successful. */</comment>
  <if_stmt><if>if <condition>(<expr><name>framesize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>extrasize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>bra</name> <operator>!=</operator> <name>OP_BRA</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>extrasize</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>extrasize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>extrasize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>extrasize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* The topmost item should be 0. */</comment>
    <if_stmt><if>if <condition>(<expr><name>bra</name> <operator>!=</operator> <name>OP_BRA</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>framesize</name> <operator>+</operator> <name>extrasize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>framesize</name> <operator>+</operator> <name>extrasize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>backtrack</name><operator>-&gt;</operator><name>matchingpath</name></name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAMINZERO</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name><name>backtrack</name><operator>-&gt;</operator><name>matchingpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>brajump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>bra</name> <operator>!=</operator> <name>OP_BRA</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>found</name> <operator>==</operator> <operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>topbacktracks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>backtrack</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>backtrack</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>topbacktracks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>local_quit_available</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>local_quit_available</name></name> <operator>=</operator> <name>save_local_quit_available</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>quit_label</name></name> <operator>=</operator> <name>save_quit_label</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>quit</name></name> <operator>=</operator> <name>save_quit</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>in_positive_assertion</name></name> <operator>=</operator> <name>save_in_positive_assertion</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>then_trap</name></name> <operator>=</operator> <name>save_then_trap</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>accept_label</name></name> <operator>=</operator> <name>save_accept_label</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>positive_assertion_quit</name></name> <operator>=</operator> <name>save_positive_assertion_quit</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>accept</name></name> <operator>=</operator> <name>save_accept</name></expr>;</expr_stmt>
<return>return <expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>match_once_common</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name></type> <name>ket</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>framesize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>private_data_ptr</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>has_alternatives</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>needs_control_head</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stacksize</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>framesize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>framesize</name> <operator>==</operator> <name>no_frame</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <ternary><condition><expr><name>needs_control_head</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ket</name> <operator>!=</operator> <name>OP_KET</name> <operator>||</operator> <name>has_alternatives</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>stacksize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>ket</name> <operator>!=</operator> <name>OP_KET</name> <operator>||</operator> <name>has_alternatives</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* TMP2 which is set here used by OP_KETRMAX below. */</comment>
  <if_stmt><if>if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KETRMAX</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KETRMIN</name></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* Move the STR_PTR to the private_data_ptr. */</comment>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>ket</name> <operator>!=</operator> <name>OP_KET</name> <operator>||</operator> <name>has_alternatives</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>framesize</name> <operator>+</operator> <name>stacksize</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KETRMAX</name></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* TMP2 which is set here used by OP_KETRMAX below. */</comment>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>int</name></type> <name>match_capture_common</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stacksize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>private_data_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>offset</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><name>offset</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>stacksize</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<return>return <expr><name>stacksize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PCRE2_SPTR</name> <name>SLJIT_FUNC</name></type> <name>do_script_run</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>endptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><call><name>PRIV</name><argument_list>(<argument><expr><name>script_run</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>endptr</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>endptr</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>PCRE2_SPTR</name> <name>SLJIT_FUNC</name></type> <name>do_script_run_utf</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>endptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><call><name>PRIV</name><argument_list>(<argument><expr><name>script_run</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>endptr</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>endptr</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>match_script_run_common</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>private_data_ptr</name></decl></parameter>, <parameter><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>TMP1</name> <operator>==</operator> <name>SLJIT_R0</name> <operator>&amp;&amp;</operator> <name>STR_PTR</name> <operator>==</operator> <name>SLJIT_R1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<expr_stmt><expr><call><name>sljit_emit_icall</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_CALL</name></expr></argument>, <argument><expr><call><name>SLJIT_RET</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>SLJIT_ARG1</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>SLJIT_ARG2</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>,
  <argument><expr><ternary><condition><expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr> ?</condition><then> <expr><call><name>SLJIT_FUNC_OFFSET</name><argument_list>(<argument><expr><name>do_script_run_utf</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>SLJIT_FUNC_OFFSET</name><argument_list>(<argument><expr><name>do_script_run</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>sljit_emit_icall</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_CALL</name></expr></argument>, <argument><expr><call><name>SLJIT_RET</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>SLJIT_ARG1</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>SLJIT_ARG2</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>SLJIT_FUNC_OFFSET</name><argument_list>(<argument><expr><name>do_script_run</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>parent</name><operator>-&gt;</operator><name>top</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>top</name><operator>-&gt;</operator><name>nextbacktracks</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></else></ternary></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
  Handling bracketed expressions is probably the most complex part.

  Stack layout naming characters:
    S - Push the current STR_PTR
    0 - Push a 0 (NULL)
    A - Push the current STR_PTR. Needed for restoring the STR_PTR
        before the next alternative. Not pushed if there are no alternatives.
    M - Any values pushed by the current alternative. Can be empty, or anything.
    C - Push the previous OVECTOR(i), OVECTOR(i+1) and OVECTOR_PRIV(i) to the stack.
    L - Push the previous local (pointed by localptr) to the stack
   () - opional values stored on the stack
  ()* - optonal, can be stored multiple times

  The following list shows the regular expression templates, their PCRE byte codes
  and stack layout supported by pcre-sljit.

  (?:)                     OP_BRA     | OP_KET                A M
  ()                       OP_CBRA    | OP_KET                C M
  (?:)+                    OP_BRA     | OP_KETRMAX        0   A M S   ( A M S )*
                           OP_SBRA    | OP_KETRMAX        0   L M S   ( L M S )*
  (?:)+?                   OP_BRA     | OP_KETRMIN        0   A M S   ( A M S )*
                           OP_SBRA    | OP_KETRMIN        0   L M S   ( L M S )*
  ()+                      OP_CBRA    | OP_KETRMAX        0   C M S   ( C M S )*
                           OP_SCBRA   | OP_KETRMAX        0   C M S   ( C M S )*
  ()+?                     OP_CBRA    | OP_KETRMIN        0   C M S   ( C M S )*
                           OP_SCBRA   | OP_KETRMIN        0   C M S   ( C M S )*
  (?:)?    OP_BRAZERO    | OP_BRA     | OP_KET            S ( A M 0 )
  (?:)??   OP_BRAMINZERO | OP_BRA     | OP_KET            S ( A M 0 )
  ()?      OP_BRAZERO    | OP_CBRA    | OP_KET            S ( C M 0 )
  ()??     OP_BRAMINZERO | OP_CBRA    | OP_KET            S ( C M 0 )
  (?:)*    OP_BRAZERO    | OP_BRA     | OP_KETRMAX      S 0 ( A M S )*
           OP_BRAZERO    | OP_SBRA    | OP_KETRMAX      S 0 ( L M S )*
  (?:)*?   OP_BRAMINZERO | OP_BRA     | OP_KETRMIN      S 0 ( A M S )*
           OP_BRAMINZERO | OP_SBRA    | OP_KETRMIN      S 0 ( L M S )*
  ()*      OP_BRAZERO    | OP_CBRA    | OP_KETRMAX      S 0 ( C M S )*
           OP_BRAZERO    | OP_SCBRA   | OP_KETRMAX      S 0 ( C M S )*
  ()*?     OP_BRAMINZERO | OP_CBRA    | OP_KETRMIN      S 0 ( C M S )*
           OP_BRAMINZERO | OP_SCBRA   | OP_KETRMIN      S 0 ( C M S )*


  Stack layout naming characters:
    A - Push the alternative index (starting from 0) on the stack.
        Not pushed if there is no alternatives.
    M - Any values pushed by the current alternative. Can be empty, or anything.

  The next list shows the possible content of a bracket:
  (|)     OP_*BRA    | OP_ALT ...         M A
  (?()|)  OP_*COND   | OP_ALT             M A
  (?&gt;|)   OP_ONCE    | OP_ALT ...         [stack trace] M A
                                          Or nothing, if trace is unnecessary
*/</comment>

<function><type><specifier>static</specifier> <name>PCRE2_SPTR</name></type> <name>compile_bracket_matchingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>backtrack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>opcode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>private_data_ptr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>stacksize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>repeat_ptr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>repeat_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>repeat_type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>repeat_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ccbegin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>matchingpath</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>slot</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>bra</name> <init>= <expr><name>OP_BRA</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>ket</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>assert_backtrack</name> <modifier>*</modifier></type><name>assert</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>has_alternatives</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>needs_control_head</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>skip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>rmax_label</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>braminzero</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PUSH_BACKTRACK</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_BRAZERO</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_BRAMINZERO</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>bra</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>opcode</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>opcode</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ccbegin</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>matchingpath</name> <operator>=</operator> <call><name>bracketend</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ket</name> <operator>=</operator> <operator>*</operator><name>matchingpath</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KET</name> <operator>&amp;&amp;</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>matchingpath</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>repeat_ptr</name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>repeat_length</name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>matchingpath</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>repeat_type</name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>matchingpath</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>repeat_count</name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>matchingpath</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>repeat_length</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>repeat_type</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>repeat_count</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>repeat_type</name> <operator>==</operator> <name>OP_UPTO</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>ket</name> <operator>=</operator> <name>OP_KETRMAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>repeat_type</name> <operator>==</operator> <name>OP_MINUPTO</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>ket</name> <operator>=</operator> <name>OP_KETRMIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>matchingpath</name> <operator>=</operator> <name>ccbegin</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>ket</name> <operator>==</operator> <name>OP_KET</name> <operator>||</operator> <name>ket</name> <operator>==</operator> <name>OP_KETRMAX</name> <operator>||</operator> <name>ket</name> <operator>==</operator> <name>OP_KETRMIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><operator>(</operator><name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name> <operator>&amp;&amp;</operator> <name>ket</name> <operator>==</operator> <name>OP_KETRMIN</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>bra</name> <operator>==</operator> <name>OP_BRAMINZERO</name> <operator>&amp;&amp;</operator> <name>ket</name> <operator>==</operator> <name>OP_KETRMAX</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>has_alternatives</name> <operator>=</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ALT</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><name>opcode</name> <operator>==</operator> <name>OP_COND</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_SCOND</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_COMPILE_ASSERT</name><argument_list>(<argument><expr><name>OP_DNRREF</name> <operator>==</operator> <name>OP_RREF</name> <operator>+</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>OP_FALSE</name> <operator>==</operator> <name>OP_RREF</name> <operator>+</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>OP_TRUE</name> <operator>==</operator> <name>OP_RREF</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>,
    <argument><expr><name>compile_time_checks_must_be_grouped_together</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>has_alternatives</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><operator>*</operator><name>matchingpath</name> <operator>&gt;=</operator> <name>OP_RREF</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>matchingpath</name> <operator>&lt;=</operator> <name>OP_TRUE</name><operator>)</operator> <operator>||</operator> <operator>*</operator><name>matchingpath</name> <operator>==</operator> <name>OP_FAIL</name><operator>)</operator></expr> ?</condition><then> <expr><name>FALSE</name></expr> </then><else>: <expr><name>TRUE</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><name>opcode</name> <operator>==</operator> <name>OP_COND</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_KETRMAX</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_KETRMIN</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>OP_SCOND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_CBRA</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_SCBRA</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Capturing brackets has a pre-allocated space. */</comment>
  <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>ccbegin</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>private_data_ptr</name> <operator>=</operator> <call><name>OVECTOR_PRIV</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><name>offset</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>private_data_ptr</name> <operator>=</operator> <call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>private_data_ptr</name> <operator>=</operator> <name>private_data_ptr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>matchingpath</name> <operator>+=</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_ASSERT_NA</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_ASSERTBACK_NA</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_ONCE</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_SCRIPT_RUN</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_SBRA</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_SCOND</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Other brackets simply allocate the next entry. */</comment>
  <expr_stmt><expr><name>private_data_ptr</name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>ccbegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>private_data_ptr</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>private_data_ptr</name> <operator>=</operator> <name>private_data_ptr</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_ONCE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>=</operator> <call><name>get_framesize</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ccbegin</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>needs_control_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Instructions before the first alternative. */</comment>
<expr_stmt><expr><name>stacksize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KETRMAX</name> <operator>||</operator> <operator>(</operator><name>ket</name> <operator>==</operator> <name>OP_KETRMIN</name> <operator>&amp;&amp;</operator> <name>bra</name> <operator>!=</operator> <name>OP_BRAMINZERO</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>stacksize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>stacksize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KETRMAX</name> <operator>||</operator> <operator>(</operator><name>ket</name> <operator>==</operator> <name>OP_KETRMIN</name> <operator>&amp;&amp;</operator> <name>bra</name> <operator>!=</operator> <name>OP_BRAMINZERO</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAMINZERO</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* This is a backtrack path! (Since the try-path of OP_BRAMINZERO matches to the empty string) */</comment>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>ket</name> <operator>!=</operator> <name>OP_KETRMIN</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>braminzero</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_ONCE</name> <operator>||</operator> <name>opcode</name> <operator>&gt;=</operator> <name>OP_SBRA</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Nothing stored during the first run. */</comment>
    <expr_stmt><expr><name>skip</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Checking zero-length iteration. */</comment>
    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>!=</operator> <name>OP_ONCE</name> <operator>||</operator> <call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <comment type="block">/* When we come from outside, private_data_ptr contains the previous STR_PTR. */</comment>
      <expr_stmt><expr><name>braminzero</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <comment type="block">/* Except when the whole stack frame must be saved. */</comment>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>braminzero</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>repeat_type</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repeat_ptr</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>repeat_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>repeat_type</name> <operator>==</operator> <name>OP_EXACT</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>rmax_label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KETRMIN</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>recursive_matchingpath</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KETRMAX</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>rmax_label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>has_alternatives</name> <operator>&amp;&amp;</operator> <name>opcode</name> <operator>&gt;=</operator> <name>OP_BRA</name> <operator>&amp;&amp;</operator> <name>opcode</name> <operator>&lt;</operator> <name>OP_SBRA</name> <operator>&amp;&amp;</operator> <name>repeat_type</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>alternative_matchingpath</name> <operator>=</operator> <name>rmax_label</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Handling capturing brackets and alternatives. */</comment>
<if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_ONCE</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* Neither capturing brackets nor recursions are found in the block. */</comment>
    <if_stmt><if>if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KETRMIN</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>stacksize</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>==</operator> <name>no_frame</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KETRMAX</name> <operator>||</operator> <name>has_alternatives</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>stacksize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KETRMIN</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>==</operator> <name>no_frame</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><ternary><condition><expr><name>needs_control_head</name></expr> ?</condition><then> <expr><operator>(</operator><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr> </then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KETRMAX</name> <operator>||</operator> <name>has_alternatives</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>ket</name> <operator>!=</operator> <name>OP_KET</name> <operator>||</operator> <name>has_alternatives</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>stacksize</name> <operator>+=</operator> <call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>stacksize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <ternary><condition><expr><name>needs_control_head</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ket</name> <operator>!=</operator> <name>OP_KET</name> <operator>||</operator> <name>has_alternatives</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>init_frame</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ccbegin</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>+</operator> <name>stacksize</name></expr></argument>, <argument><expr><name>stacksize</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_CBRA</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_SCBRA</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Saving the previous values. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><name>offset</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>private_data_ptr</name> <operator>==</operator> <call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_ASSERT_NA</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_ASSERTBACK_NA</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_SCRIPT_RUN</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_SBRA</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_SCOND</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Saving the previous value. */</comment>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>has_alternatives</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Pushing the starting string pointer. */</comment>
  <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Generating code for the first alternative. */</comment>
<if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_COND</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_SCOND</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>matchingpath</name> <operator>==</operator> <name>OP_CREF</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>has_alternatives</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>condfailed</name></name><operator>)</operator></expr></argument>,
      <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><call><name>GET2</name><argument_list>(<argument><expr><name>matchingpath</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>matchingpath</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>*</operator><name>matchingpath</name> <operator>==</operator> <name>OP_DNCREF</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>has_alternatives</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>matchingpath</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>name_table</name></name> <operator>+</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>matchingpath</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>common</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><call><name>GET2</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>slot</name> <operator>+=</operator> <name><name>common</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>i</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><call><name>GET2</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>slot</name> <operator>+=</operator> <name><name>common</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>
      </block_content>}</block></while>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>condfailed</name></name><operator>)</operator></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_ZERO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>matchingpath</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>*</operator><name>matchingpath</name> <operator>&gt;=</operator> <name>OP_RREF</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>matchingpath</name> <operator>&lt;=</operator> <name>OP_TRUE</name><operator>)</operator> <operator>||</operator> <operator>*</operator><name>matchingpath</name> <operator>==</operator> <name>OP_FAIL</name></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* Never has other case. */</comment>
    <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>condfailed</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name>has_alternatives</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>matchingpath</name> <operator>==</operator> <name>OP_TRUE</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>matchingpath</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>*</operator><name>matchingpath</name> <operator>==</operator> <name>OP_FALSE</name> <operator>||</operator> <operator>*</operator><name>matchingpath</name> <operator>==</operator> <name>OP_FAIL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>*</operator><name>matchingpath</name> <operator>==</operator> <name>OP_RREF</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>matchingpath</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>currententry</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name>stacksize</name> <operator>==</operator> <name>RREF_ANY</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>currententry</name><operator>-&gt;</operator><name>start</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <name>stacksize</name> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <name>stacksize</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GET2</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>currententry</name><operator>-&gt;</operator><name>start</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>stacksize</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>matchingpath</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>currententry</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>common</name><operator>-&gt;</operator><name>currententry</name><operator>-&gt;</operator><name>start</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>matchingpath</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>name_table</name></name> <operator>+</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>matchingpath</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>common</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GET2</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>currententry</name><operator>-&gt;</operator><name>start</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>stacksize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><call><name>GET2</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>slot</name> <operator>+=</operator> <name><name>common</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>stacksize</name><operator>--</operator></expr>;</expr_stmt>
          </block_content>}</block></while>
        </block_content>}</block></else></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>stacksize</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>matchingpath</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>

      <comment type="block">/* The stacksize == 0 is a common "else" case. */</comment>
      <if_stmt><if>if <condition>(<expr><name>stacksize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>matchingpath</name> <operator>=</operator> <name>cc</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><name>matchingpath</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>has_alternatives</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>matchingpath</name> <operator>&gt;=</operator> <name>OP_ASSERT</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>matchingpath</name> <operator>&lt;=</operator> <name>OP_ASSERTBACK_NOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Similar code as PUSH_BACKTRACK macro. */</comment>
    <expr_stmt><expr><name>assert</name> <operator>=</operator> <call><name>sljit_alloc_memory</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>assert_backtrack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><call><name>sljit_get_compiler_error</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>assert</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>assert_backtrack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>assert</name><operator>-&gt;</operator><name>common</name><operator>.</operator><name>cc</name></name> <operator>=</operator> <name>matchingpath</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>assert</name></name> <operator>=</operator> <name>assert</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>matchingpath</name> <operator>=</operator> <call><name>compile_assert_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>matchingpath</name></expr></argument>, <argument><expr><name>assert</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>compile_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>matchingpath</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>backtrack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><call><name>sljit_get_compiler_error</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_ASSERT_NA</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_ASSERTBACK_NA</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_ONCE</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>match_once_common</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ket</name></expr></argument>, <argument><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>has_alternatives</name></expr></argument>, <argument><expr><name>needs_control_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_SCRIPT_RUN</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>match_script_run_common</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>backtrack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>stacksize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>repeat_type</name> <operator>==</operator> <name>OP_MINUPTO</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* We need to preserve the counter. TMP2 will be used below. */</comment>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repeat_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ket</name> <operator>!=</operator> <name>OP_KET</name> <operator>||</operator> <name>bra</name> <operator>!=</operator> <name>OP_BRA</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><name>offset</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>stacksize</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>has_alternatives</name> <operator>&amp;&amp;</operator> <name>opcode</name> <operator>!=</operator> <name>OP_ONCE</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>stacksize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>stacksize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>repeat_type</name> <operator>==</operator> <name>OP_MINUPTO</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* TMP2 was set above. */</comment>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ket</name> <operator>!=</operator> <name>OP_KET</name> <operator>||</operator> <name>bra</name> <operator>!=</operator> <name>OP_BRA</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>ket</name> <operator>!=</operator> <name>OP_KET</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <call><name>match_capture_common</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>stacksize</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* Skip and count the other alternatives. */</comment>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>has_alternatives</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>!=</operator> <name>OP_ONCE</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>matching_put_label</name></name> <operator>=</operator> <call><name>sljit_emit_put_label</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>ket</name> <operator>!=</operator> <name>OP_KETRMAX</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>alternative_matchingpath</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Must be after the matchingpath label. */</comment>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><name>offset</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>private_data_ptr</name> <operator>==</operator> <call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KETRMAX</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>repeat_type</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>has_alternatives</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>alternative_matchingpath</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repeat_ptr</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repeat_ptr</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>, <argument><expr><name>rmax_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Drop STR_PTR for greedy plus quantifier. */</comment>
    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>!=</operator> <name>OP_ONCE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>opcode</name> <operator>&lt;</operator> <name>OP_BRA</name> <operator>||</operator> <name>opcode</name> <operator>&gt;=</operator> <name>OP_SBRA</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>has_alternatives</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>alternative_matchingpath</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Checking zero-length iteration. */</comment>
    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>!=</operator> <name>OP_ONCE</name></expr>)</condition>
      <block>{<block_content>
      <comment type="block">/* This case includes opcodes such as OP_SCRIPT_RUN. */</comment>
      <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rmax_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Drop STR_PTR for greedy plus quantifier. */</comment>
      <if_stmt><if>if <condition>(<expr><name>bra</name> <operator>!=</operator> <name>OP_BRAZERO</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
      <comment type="block">/* TMP2 must contain the starting STR_PTR. */</comment>
      <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rmax_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name>rmax_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>recursive_matchingpath</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>repeat_type</name> <operator>==</operator> <name>OP_EXACT</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>count_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repeat_ptr</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repeat_ptr</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>, <argument><expr><name>rmax_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>repeat_type</name> <operator>==</operator> <name>OP_UPTO</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* We need to preserve the counter. */</comment>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repeat_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>zero_matchingpath</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAMINZERO</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* This is a backtrack path! (From the viewpoint of OP_BRAMINZERO) */</comment>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>braminzero_backtrack</name> <operator>*</operator><operator>)</operator><name>parent</name><operator>)</operator><operator>-&gt;</operator><name>matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>braminzero</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>braminzero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* We need to release the end pointer to perform the
    backtrack for the zero-length iteration. When
    framesize is &lt; 0, OP_ONCE will do the release itself. */</comment>
    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_ONCE</name> <operator>&amp;&amp;</operator> <call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>revertframes</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KETRMIN</name> <operator>&amp;&amp;</operator> <name>opcode</name> <operator>!=</operator> <name>OP_ONCE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  <comment type="block">/* Continue to the normal backtrack. */</comment>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ket</name> <operator>!=</operator> <name>OP_KET</name> <operator>&amp;&amp;</operator> <name>bra</name> <operator>!=</operator> <name>OP_BRAMINZERO</name><operator>)</operator> <operator>||</operator> <name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>count_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_ONCE</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* We temporarily encode the needs_control_head in the lowest bit.
     Note: on the target architectures of SLJIT the ((x &lt;&lt; 1) &gt;&gt; 1) returns
     the same value for small signed numbers (including negative numbers). */</comment>
  <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>needs_control_head</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<return>return <expr><name>cc</name> <operator>+</operator> <name>repeat_length</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PCRE2_SPTR</name></type> <name>compile_bracketpos_matchingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>backtrack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>opcode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>private_data_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cbraprivptr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>needs_control_head</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>framesize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stacksize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>zero</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ccbegin</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stack</name></decl>;</decl_stmt> <comment type="block">/* Also contains the offset of control head. */</comment>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>loop</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>jump_list</name></name> <modifier>*</modifier></type><name>emptymatch</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PUSH_BACKTRACK</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bracketpos_backtrack</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_BRAPOSZERO</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>zero</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>opcode</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>private_data_ptr</name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>private_data_ptr</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracketpos_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>private_data_ptr</name> <operator>=</operator> <name>private_data_ptr</name></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name>opcode</name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><name>OP_BRAPOS</name></expr>:</case>
  <case>case <expr><name>OP_SBRAPOS</name></expr>:</case>
  <expr_stmt><expr><name>ccbegin</name> <operator>=</operator> <name>cc</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>OP_CBRAPOS</name></expr>:</case>
  <case>case <expr><name>OP_SCBRAPOS</name></expr>:</case>
  <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* This case cannot be optimized in the same was as
  normal capturing brackets. */</comment>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cbraprivptr</name> <operator>=</operator> <call><name>OVECTOR_PRIV</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>offset</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>ccbegin</name> <operator>=</operator> <name>cc</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
  <break>break;</break>

  <default>default:</default>
  <expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
  </block_content>}</block></switch>

<expr_stmt><expr><name>framesize</name> <operator>=</operator> <call><name>get_framesize</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>needs_control_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracketpos_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>framesize</name> <operator>=</operator> <name>framesize</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>framesize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>zero</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracketpos_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>stacksize</name> <operator>=</operator> <name>stacksize</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>framesize</name> <operator>==</operator> <name>no_frame</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>stack</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>stack</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>stack</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>stack</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>stack</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>zero</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>stack</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <name>framesize</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>zero</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>bracketpos_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>stacksize</name> <operator>=</operator> <name>stacksize</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>stacksize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>stack</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>zero</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>stack</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>stack</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>stack</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>init_frame</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>stacksize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>stacksize</name> <operator>-</operator> <name>framesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>stack</name> <operator>-=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>offset</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cbraprivptr</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>cc</name> <operator>!=</operator> <name>OP_KETRPOS</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>backtrack</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>compile_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ccbegin</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>backtrack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><call><name>sljit_get_compiler_error</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>framesize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>framesize</name> <operator>==</operator> <name>no_frame</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cbraprivptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cbraprivptr</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>offset</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_SBRAPOS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

    <comment type="block">/* Even if the match is empty, we need to reset the control head. */</comment>
    <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_SBRAPOS</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_SCBRAPOS</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>emptymatch</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>zero</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>stacksize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cbraprivptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cbraprivptr</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>offset</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>stacksize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_SBRAPOS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><name>framesize</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><name>framesize</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

    <comment type="block">/* Even if the match is empty, we need to reset the control head. */</comment>
    <if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_SBRAPOS</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_SCBRAPOS</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>emptymatch</name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>zero</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>framesize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>flush_stubs</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>compile_backtrackingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>backtrack</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><call><name>sljit_get_compiler_error</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>framesize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cbraprivptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <comment type="block">/* Last alternative. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_KETRPOS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cbraprivptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><name>framesize</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_KETRPOS</name></expr>)</condition><block type="pseudo"><block_content>
    <break>break;</break></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>ccbegin</name> <operator>=</operator> <name>cc</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
  </block_content>}</block></while>

<comment type="block">/* We don't have to restore the control head in case of a failed match. */</comment>

<expr_stmt><expr><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>zero</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>framesize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content> <comment type="block">/* TMP2 is set to [private_data_ptr] above. */</comment>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><name>stacksize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* None of them matched. */</comment>
<expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>emptymatch</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>count_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>PCRE2_SPTR</name></type> <name>get_iterator_parameters</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>opcode</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>sljit_u32</name> <modifier>*</modifier></type><name>max</name></decl></parameter>, <parameter><decl><type><name>sljit_u32</name> <modifier>*</modifier></type><name>exact</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>class_len</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>opcode</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>exact</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>opcode</name> <operator>&gt;=</operator> <name>OP_STAR</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>opcode</name> <operator>&lt;=</operator> <name>OP_POSUPTO</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>OP_CHAR</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>opcode</name> <operator>&gt;=</operator> <name>OP_STARI</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>opcode</name> <operator>&lt;=</operator> <name>OP_POSUPTOI</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>OP_CHARI</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>opcode</name> <operator>-=</operator> <name>OP_STARI</name> <operator>-</operator> <name>OP_STAR</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>opcode</name> <operator>&gt;=</operator> <name>OP_NOTSTAR</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>opcode</name> <operator>&lt;=</operator> <name>OP_NOTPOSUPTO</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>OP_NOT</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>opcode</name> <operator>-=</operator> <name>OP_NOTSTAR</name> <operator>-</operator> <name>OP_STAR</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>opcode</name> <operator>&gt;=</operator> <name>OP_NOTSTARI</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>opcode</name> <operator>&lt;=</operator> <name>OP_NOTPOSUPTOI</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>OP_NOTI</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>opcode</name> <operator>-=</operator> <name>OP_NOTSTARI</name> <operator>-</operator> <name>OP_STAR</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>opcode</name> <operator>&gt;=</operator> <name>OP_TYPESTAR</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>opcode</name> <operator>&lt;=</operator> <name>OP_TYPEPOSUPTO</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>opcode</name> <operator>-=</operator> <name>OP_TYPESTAR</name> <operator>-</operator> <name>OP_STAR</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>OP_END</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>*</operator><name>opcode</name> <operator>==</operator> <name>OP_CLASS</name> <operator>||</operator> <operator>*</operator><name>opcode</name> <operator>==</operator> <name>OP_NCLASS</name> <operator>||</operator> <operator>*</operator><name>opcode</name> <operator>==</operator> <name>OP_XCLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <operator>*</operator><name>opcode</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>class_len</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name>type</name> <operator>&lt;</operator> <name>OP_XCLASS</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>)</operator></expr> </then><else>: <expr><call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>opcode</name> <operator>=</operator> <name><name>cc</name><index>[<expr><name>class_len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>opcode</name> <operator>&gt;=</operator> <name>OP_CRSTAR</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>opcode</name> <operator>&lt;=</operator> <name>OP_CRMINQUERY</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>opcode</name> <operator>-=</operator> <name>OP_CRSTAR</name> <operator>-</operator> <name>OP_STAR</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <name>cc</name> <operator>+</operator> <name>class_len</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>opcode</name> <operator>==</operator> <name>OP_PLUS</name> <operator>||</operator> <operator>*</operator><name>opcode</name> <operator>==</operator> <name>OP_MINPLUS</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>exact</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>opcode</name> <operator>-=</operator> <name>OP_PLUS</name> <operator>-</operator> <name>OP_STAR</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>*</operator><name>opcode</name> <operator>&gt;=</operator> <name>OP_CRPOSSTAR</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>opcode</name> <operator>&lt;=</operator> <name>OP_CRPOSQUERY</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>opcode</name> <operator>-=</operator> <name>OP_CRPOSSTAR</name> <operator>-</operator> <name>OP_POSSTAR</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <name>cc</name> <operator>+</operator> <name>class_len</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>opcode</name> <operator>==</operator> <name>OP_POSPLUS</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>exact</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>opcode</name> <operator>=</operator> <name>OP_POSSTAR</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>*</operator><name>opcode</name> <operator>==</operator> <name>OP_CRRANGE</name> <operator>||</operator> <operator>*</operator><name>opcode</name> <operator>==</operator> <name>OP_CRMINRANGE</name> <operator>||</operator> <operator>*</operator><name>opcode</name> <operator>==</operator> <name>OP_CRPOSRANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>(</operator><name>class_len</name> <operator>+</operator> <name>IMM2_SIZE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>exact</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>class_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>max</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>opcode</name> <operator>==</operator> <name>OP_CRPOSRANGE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>opcode</name> <operator>=</operator> <name>OP_POSSTAR</name></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>opcode</name> <operator>-=</operator> <name>OP_CRRANGE</name> <operator>-</operator> <name>OP_STAR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>max</name> <operator>-=</operator> <operator>*</operator><name>exact</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>max</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>opcode</name> <operator>=</operator> <name>OP_EXACT</name></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><operator>*</operator><name>max</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>opcode</name> <operator>==</operator> <name>OP_CRPOSRANGE</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><operator>*</operator><name>opcode</name> <operator>=</operator> <name>OP_POSQUERY</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><operator>*</operator><name>opcode</name> <operator>-=</operator> <name>OP_CRRANGE</name> <operator>-</operator> <name>OP_QUERY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>opcode</name> <operator>==</operator> <name>OP_CRPOSRANGE</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><operator>*</operator><name>opcode</name> <operator>=</operator> <name>OP_POSUPTO</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><operator>*</operator><name>opcode</name> <operator>-=</operator> <name>OP_CRRANGE</name> <operator>-</operator> <name>OP_UPTO</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <name>cc</name> <operator>+</operator> <name>class_len</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <return>return <expr><name>cc</name></expr>;</return>
  </block_content>}</block></else></if_stmt>

<switch>switch<condition>(<expr><operator>*</operator><name>opcode</name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><name>OP_EXACT</name></expr>:</case>
  <expr_stmt><expr><operator>*</operator><name>exact</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc</name> <operator>+=</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>OP_PLUS</name></expr>:</case>
  <case>case <expr><name>OP_MINPLUS</name></expr>:</case>
  <expr_stmt><expr><operator>*</operator><name>exact</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>opcode</name> <operator>-=</operator> <name>OP_PLUS</name> <operator>-</operator> <name>OP_STAR</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>OP_POSPLUS</name></expr>:</case>
  <expr_stmt><expr><operator>*</operator><name>exact</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>opcode</name> <operator>=</operator> <name>OP_POSSTAR</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>OP_UPTO</name></expr>:</case>
  <case>case <expr><name>OP_MINUPTO</name></expr>:</case>
  <case>case <expr><name>OP_POSUPTO</name></expr>:</case>
  <expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc</name> <operator>+=</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
  <break>break;</break>
  </block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>type</name> <operator>==</operator> <name>OP_END</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <call><name>next_opcode</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>cc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>end</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>cc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PCRE2_SPTR</name></type> <name>compile_iterator_matchingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>backtrack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>opcode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_u32</name></type> <name>max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>exact</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_s32</name></type> <name>early_fail_ptr</name> <init>= <expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_s32</name></type> <name>early_fail_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>charpos_enabled</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>charpos_char</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>charpos_othercasebit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>no_match</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>no_char1_match</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>private_data_ptr</name> <init>= <expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset0</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>private_data_ptr</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset1</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>private_data_ptr</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tmp_base</name></decl>, <decl><type ref="prev"/><name>tmp_offset</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
<decl_stmt><decl><type><name>BOOL</name></type> <name>use_tmp</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>PUSH_BACKTRACK</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>early_fail_type</name> <operator>=</operator> <operator>(</operator><name>early_fail_ptr</name> <operator>&amp;</operator> <literal type="number">0x7</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>early_fail_ptr</name> <operator>&gt;&gt;=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<comment type="block">/* During recursion, these optimizations are disabled. */</comment>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>early_fail_start_ptr</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>early_fail_ptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>early_fail_type</name> <operator>=</operator> <name>type_skip</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>fast_forward_bc_ptr</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>early_fail_ptr</name> <operator>==</operator> <literal type="number">0</literal>
  <operator>||</operator> <operator>(</operator><name>early_fail_ptr</name> <operator>&gt;=</operator> <name><name>common</name><operator>-&gt;</operator><name>early_fail_start_ptr</name></name> <operator>&amp;&amp;</operator> <name>early_fail_ptr</name> <operator>&lt;=</operator> <name><name>common</name><operator>-&gt;</operator><name>early_fail_end_ptr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>early_fail_type</name> <operator>==</operator> <name>type_fail</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>early_fail_ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>get_iterator_parameters</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opcode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exact</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>OP_EXTUNI</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>tmp_base</name> <operator>=</operator> <name>TMP3</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmp_offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><name>tmp_base</name> <operator>=</operator> <call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmp_offset</name> <operator>=</operator> <name>POSSESSIVE0</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<comment type="block">/* Handle fixed part first. */</comment>
<if_stmt><if>if <condition>(<expr><name>exact</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>early_fail_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <operator>&amp;&amp;</operator> <operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>utf</name></name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <operator>&amp;&amp;</operator> <name>type</name> <operator>!=</operator> <name>OP_ANYNL</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>!=</operator> <name>OP_EXTUNI</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>exact</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>exact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>exact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>exact</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>early_fail_type</name> <operator>==</operator> <name>type_fail_range</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>early_fail_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>early_fail_ptr</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>early_fail_ptr</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<switch>switch<condition>(<expr><name>opcode</name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><name>OP_STAR</name></expr>:</case>
  <case>case <expr><name>OP_UPTO</name></expr>:</case>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>early_fail_ptr</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_STAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>OP_ANYNL</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>OP_EXTUNI</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>early_fail_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_UPTO</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>POSSESSIVE0</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>backtracks</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_UPTO</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>POSSESSIVE0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>POSSESSIVE0</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* We cannot use TMP3 because of allocate_stack. */</comment>
    <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>jump</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>OP_ALLANY</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>OP_ALLANY</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_STAR</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset1</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>process_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>early_fail_ptr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>early_fail_ptr</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset1</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_GREATER</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>process_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>early_fail_ptr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>early_fail_ptr</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></else></if_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>charpos_enabled</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>charpos_char</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>charpos_othercasebit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>type</name> <operator>!=</operator> <name>OP_CHAR</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>!=</operator> <name>OP_CHARI</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>end</name> <operator>==</operator> <name>OP_CHAR</name> <operator>||</operator> <operator>*</operator><name>end</name> <operator>==</operator> <name>OP_CHARI</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <expr_stmt><expr><name>charpos_enabled</name> <operator>=</operator> <operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>||</operator> <operator>!</operator><call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><name><name>end</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>charpos_enabled</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>charpos_enabled</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>end</name> <operator>==</operator> <name>OP_CHARI</name> <operator>&amp;&amp;</operator> <call><name>char_has_othercase</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>end</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>charpos_othercasebit</name> <operator>=</operator> <call><name>char_get_othercase_bit</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>end</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>charpos_othercasebit</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>charpos_enabled</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>charpos_enabled</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>charpos_char</name> <operator>=</operator> <name><name>end</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <comment type="block">/* Consume the OP_CHAR opcode. */</comment>
      <expr_stmt><expr><name>end</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
      <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>charpos_othercasebit</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:elif>
      <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>charpos_othercasebit</name> <operator>&gt;&gt;</operator> <literal type="number">9</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>charpos_othercasebit</name> <operator>&amp;</operator> <literal type="number">0x100</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>charpos_othercasebit</name> <operator>=</operator> <operator>(</operator><name>charpos_othercasebit</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if_stmt><if>if <condition>(<expr><name>charpos_othercasebit</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>charpos_char</name> <operator>|=</operator> <name>charpos_othercasebit</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>charpos</name><operator>.</operator><name>enabled</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>charpos</name><operator>.</operator><name>chr</name></name> <operator>=</operator> <name>charpos_char</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>charpos</name><operator>.</operator><name>othercasebit</name></name> <operator>=</operator> <name>charpos_othercasebit</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>charpos_enabled</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_UPTO</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>max</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Search the first instance of charpos_char. */</comment>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_UPTO</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_ZERO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>early_fail_ptr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>early_fail_ptr</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>charpos_othercasebit</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>charpos_othercasebit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>charpos_char</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset1</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_UPTO</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_match</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_ZERO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Search the last instance of charpos_char. */</comment>
    <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_match</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>early_fail_ptr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>early_fail_ptr</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>charpos_othercasebit</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>charpos_othercasebit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_STAR</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>charpos_char</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>charpos_char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>no_match</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset1</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
    <expr_stmt><expr><name>use_tmp</name> <operator>=</operator> <operator>(</operator><operator>!</operator><name>HAS_VIRTUAL_REGISTERS</name> <operator>&amp;&amp;</operator> <name>opcode</name> <operator>==</operator> <name>OP_STAR</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name>use_tmp</name> <operator>||</operator> <name>tmp_base</name> <operator>==</operator> <name>TMP3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><ternary><condition><expr><name>use_tmp</name></expr> ?</condition><then> <expr><name>TMP3</name></expr> </then><else>: <expr><name>base</name></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><name>use_tmp</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>offset0</name></expr></else></ternary></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_UPTO</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_char1_match</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><ternary><condition><expr><name>use_tmp</name></expr> ?</condition><then> <expr><name>TMP3</name></expr> </then><else>: <expr><name>base</name></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><name>use_tmp</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>offset0</name></expr></else></ternary></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_UPTO</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_match</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_ZERO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>detect_partial_match_to</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>no_char1_match</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>no_match</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>use_tmp</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></if>
    <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>no_match</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>early_fail_ptr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>early_fail_ptr</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>OP_MINSTAR</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>early_fail_ptr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>early_fail_ptr</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <break>break;</break>

  <case>case <expr><name>OP_MINUPTO</name></expr>:</case>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>early_fail_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset1</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>max</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>OP_QUERY</name></expr>:</case>
  <case>case <expr><name>OP_MINQUERY</name></expr>:</case>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>early_fail_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_QUERY</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>backtracks</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>OP_EXACT</name></expr>:</case>
  <break>break;</break>

  <case>case <expr><name>OP_POSSTAR</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>OP_ALLANY</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>OP_ALLANY</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>process_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>early_fail_ptr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>early_fail_ptr</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <break>break;</break>
    </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_match</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>detect_partial_match_to</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>no_match</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>early_fail_ptr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>HAS_VIRTUAL_REGISTERS</name> <operator>&amp;&amp;</operator> <name>tmp_base</name> <operator>==</operator> <name>TMP3</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>early_fail_ptr</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>early_fail_ptr</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    <break>break;</break>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_char1_match</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>detect_partial_match_to</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>no_char1_match</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>no_match</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>early_fail_ptr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>early_fail_ptr</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <break>break;</break>

  <case>case <expr><name>OP_POSUPTO</name></expr>:</case>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>early_fail_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>POSSESSIVE1</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_match</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>POSSESSIVE1</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_match</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_ZERO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>detect_partial_match_to</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>no_match</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>POSSESSIVE1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>OP_ALLANY</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_GREATER</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>CMOV</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>process_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <break>break;</break>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>detect_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_char1_match</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_match</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_ZERO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>detect_partial_match_to</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>no_char1_match</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>no_match</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>OP_POSQUERY</name></expr>:</case>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>early_fail_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_match</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>no_match</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tmp_base</name></expr></argument>, <argument><expr><name>tmp_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>

  <default>default:</default>
  <expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
  </block_content>}</block></switch>

<expr_stmt><expr><call><name>count_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>end</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>PCRE2_SPTR</name></type> <name>compile_fail_accept_matchingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>backtrack</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PUSH_BACKTRACK</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>backtrack_common</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_FAIL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ACCEPT</name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>currententry</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_ENDANCHORED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>reset_match</name></name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ASSERT_ACCEPT</name> <operator>||</operator> <name><name>common</name><operator>-&gt;</operator><name>currententry</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>might_be_empty</name></name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* No need to check notempty conditions. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>accept_label</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>accept</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>accept_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <return>return <expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>accept_label</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>accept</name></name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>accept_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U32</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U32</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>PCRE2_NOTEMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>PCRE2_NOTEMPTY_ATSTART</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>accept_label</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>accept</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_ZERO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_ZERO</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>accept_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><ternary><condition><expr><name>HAS_VIRTUAL_REGISTERS</name></expr> ?</condition><then> <expr><name>TMP1</name></expr> </then><else>: <expr><name>ARGUMENTS</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>accept_label</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>accept</name></name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>accept_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backtrack</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>PCRE2_SPTR</name></type> <name>compile_close_matchingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><call><name>GET2</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>optimized_cbracket</name> <init>= <expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Data will be discarded anyway... */</comment>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>currententry</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>optimized_cbracket</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR_PRIV</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>offset</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>optimized_cbracket</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>PCRE2_SPTR</name></type> <name>compile_control_verb_matchingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>backtrack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>opcode</name> <init>= <expr><operator>*</operator><name>cc</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ccend</name> <init>= <expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_COMMIT_ARG</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_PRUNE_ARG</name> <operator>||</operator>
    <name>opcode</name> <operator>==</operator> <name>OP_SKIP_ARG</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_THEN_ARG</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>ccend</name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>PUSH_BACKTRACK</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>backtrack_common</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_SKIP</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>ccend</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_COMMIT_ARG</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_PRUNE_ARG</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_THEN_ARG</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><name>cc</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><ternary><condition><expr><name>HAS_VIRTUAL_REGISTERS</name></expr> ?</condition><then> <expr><name>TMP1</name></expr> </then><else>: <expr><name>ARGUMENTS</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>mark_ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<return>return <expr><name>ccend</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PCRE2_UCHAR</name></type> <name><name>then_trap_opcode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>OP_THEN_TRAP</name></expr> }</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>compile_then_trap_matchingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ccend</name></decl></parameter>, <parameter><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>backtrack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>needs_control_head</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PUSH_BACKTRACK_NOVALUE</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>then_trap_backtrack</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>then_trap</name></name> <operator>=</operator> <call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>then_trap_backtrack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>then_trap_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>common</name><operator>.</operator><name>cc</name></name> <operator>=</operator> <name>then_trap_opcode</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>then_trap_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>start</name> <operator>=</operator> <operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><name>cc</name> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>then_trap_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>framesize</name> <operator>=</operator> <call><name>get_framesize</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>ccend</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>needs_control_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>then_trap_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>framesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">3</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>size</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>size</name> <operator>-</operator> <literal type="number">3</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>size</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>then_trap_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>size</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>type_then_trap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>size</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>then_trap_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>framesize</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>init_frame</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>ccend</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>compile_matchingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ccend</name></decl></parameter>, <parameter><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>backtrack_common</name> <modifier>*</modifier></type><name>backtrack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>has_then_trap</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>then_trap_backtrack</name> <modifier>*</modifier></type><name>save_then_trap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>*</operator><name>ccend</name> <operator>==</operator> <name>OP_END</name> <operator>||</operator> <operator>(</operator><operator>*</operator><name>ccend</name> <operator>&gt;=</operator> <name>OP_ALT</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ccend</name> <operator>&lt;=</operator> <name>OP_KETRPOS</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>has_then</name></name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>then_offsets</name><index>[<expr><name>cc</name> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>*</operator><name>ccend</name> <operator>!=</operator> <name>OP_END</name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>has_then_trap</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>save_then_trap</name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>then_trap</name></name></expr>;</expr_stmt>
  <comment type="block">/* Tail item on backtrack. */</comment>
  <expr_stmt><expr><call><name>compile_then_trap_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>ccend</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>cc</name> <operator>&lt;</operator> <name>ccend</name></expr>)</condition>
  <block>{<block_content>
  <switch>switch<condition>(<expr><operator>*</operator><name>cc</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>OP_SOD</name></expr>:</case>
    <case>case <expr><name>OP_SOM</name></expr>:</case>
    <case>case <expr><name>OP_NOT_WORD_BOUNDARY</name></expr>:</case>
    <case>case <expr><name>OP_WORD_BOUNDARY</name></expr>:</case>
    <case>case <expr><name>OP_EODN</name></expr>:</case>
    <case>case <expr><name>OP_EOD</name></expr>:</case>
    <case>case <expr><name>OP_DOLL</name></expr>:</case>
    <case>case <expr><name>OP_DOLLM</name></expr>:</case>
    <case>case <expr><name>OP_CIRC</name></expr>:</case>
    <case>case <expr><name>OP_CIRCM</name></expr>:</case>
    <case>case <expr><name>OP_REVERSE</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_simple_assertion_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>*</operator><name>cc</name></expr></argument>, <argument><expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>parent</name><operator>-&gt;</operator><name>top</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>top</name><operator>-&gt;</operator><name>nextbacktracks</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_NOT_DIGIT</name></expr>:</case>
    <case>case <expr><name>OP_DIGIT</name></expr>:</case>
    <case>case <expr><name>OP_NOT_WHITESPACE</name></expr>:</case>
    <case>case <expr><name>OP_WHITESPACE</name></expr>:</case>
    <case>case <expr><name>OP_NOT_WORDCHAR</name></expr>:</case>
    <case>case <expr><name>OP_WORDCHAR</name></expr>:</case>
    <case>case <expr><name>OP_ANY</name></expr>:</case>
    <case>case <expr><name>OP_ALLANY</name></expr>:</case>
    <case>case <expr><name>OP_ANYBYTE</name></expr>:</case>
    <case>case <expr><name>OP_NOTPROP</name></expr>:</case>
    <case>case <expr><name>OP_PROP</name></expr>:</case>
    <case>case <expr><name>OP_ANYNL</name></expr>:</case>
    <case>case <expr><name>OP_NOT_HSPACE</name></expr>:</case>
    <case>case <expr><name>OP_HSPACE</name></expr>:</case>
    <case>case <expr><name>OP_NOT_VSPACE</name></expr>:</case>
    <case>case <expr><name>OP_VSPACE</name></expr>:</case>
    <case>case <expr><name>OP_EXTUNI</name></expr>:</case>
    <case>case <expr><name>OP_NOT</name></expr>:</case>
    <case>case <expr><name>OP_NOTI</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>*</operator><name>cc</name></expr></argument>, <argument><expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>parent</name><operator>-&gt;</operator><name>top</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>top</name><operator>-&gt;</operator><name>nextbacktracks</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></else></ternary></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_SET_SOM</name></expr>:</case>
    <expr_stmt><expr><call><name>PUSH_BACKTRACK_NOVALUE</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>backtrack_common</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CHAR</name></expr>:</case>
    <case>case <expr><name>OP_CHARI</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_charn_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>ccend</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>parent</name><operator>-&gt;</operator><name>top</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>top</name><operator>-&gt;</operator><name>nextbacktracks</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>*</operator><name>cc</name></expr></argument>, <argument><expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>parent</name><operator>-&gt;</operator><name>top</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>top</name><operator>-&gt;</operator><name>nextbacktracks</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></else></ternary></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_STAR</name></expr>:</case>
    <case>case <expr><name>OP_MINSTAR</name></expr>:</case>
    <case>case <expr><name>OP_PLUS</name></expr>:</case>
    <case>case <expr><name>OP_MINPLUS</name></expr>:</case>
    <case>case <expr><name>OP_QUERY</name></expr>:</case>
    <case>case <expr><name>OP_MINQUERY</name></expr>:</case>
    <case>case <expr><name>OP_UPTO</name></expr>:</case>
    <case>case <expr><name>OP_MINUPTO</name></expr>:</case>
    <case>case <expr><name>OP_EXACT</name></expr>:</case>
    <case>case <expr><name>OP_POSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_POSPLUS</name></expr>:</case>
    <case>case <expr><name>OP_POSQUERY</name></expr>:</case>
    <case>case <expr><name>OP_POSUPTO</name></expr>:</case>
    <case>case <expr><name>OP_STARI</name></expr>:</case>
    <case>case <expr><name>OP_MINSTARI</name></expr>:</case>
    <case>case <expr><name>OP_PLUSI</name></expr>:</case>
    <case>case <expr><name>OP_MINPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_QUERYI</name></expr>:</case>
    <case>case <expr><name>OP_MINQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_UPTOI</name></expr>:</case>
    <case>case <expr><name>OP_MINUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_EXACTI</name></expr>:</case>
    <case>case <expr><name>OP_POSSTARI</name></expr>:</case>
    <case>case <expr><name>OP_POSPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_POSQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_POSUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_NOTSTAR</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINSTAR</name></expr>:</case>
    <case>case <expr><name>OP_NOTPLUS</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINPLUS</name></expr>:</case>
    <case>case <expr><name>OP_NOTQUERY</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINQUERY</name></expr>:</case>
    <case>case <expr><name>OP_NOTUPTO</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINUPTO</name></expr>:</case>
    <case>case <expr><name>OP_NOTEXACT</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSPLUS</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSQUERY</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSUPTO</name></expr>:</case>
    <case>case <expr><name>OP_NOTSTARI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINSTARI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_NOTQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_NOTUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_NOTEXACTI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSSTARI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_TYPESTAR</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINSTAR</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPLUS</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINPLUS</name></expr>:</case>
    <case>case <expr><name>OP_TYPEQUERY</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINQUERY</name></expr>:</case>
    <case>case <expr><name>OP_TYPEUPTO</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINUPTO</name></expr>:</case>
    <case>case <expr><name>OP_TYPEEXACT</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSPLUS</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSQUERY</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSUPTO</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_iterator_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CLASS</name></expr>:</case>
    <case>case <expr><name>OP_NCLASS</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>cc</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>]</index></name> <operator>&gt;=</operator> <name>OP_CRSTAR</name> <operator>&amp;&amp;</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>]</index></name> <operator>&lt;=</operator> <name>OP_CRPOSRANGE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_iterator_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>*</operator><name>cc</name></expr></argument>, <argument><expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>parent</name><operator>-&gt;</operator><name>top</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>top</name><operator>-&gt;</operator><name>nextbacktracks</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></else></ternary></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
    <case>case <expr><name>OP_XCLASS</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>cc</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <name>OP_CRSTAR</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>cc</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;=</operator> <name>OP_CRPOSRANGE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_iterator_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>*</operator><name>cc</name></expr></argument>, <argument><expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>parent</name><operator>-&gt;</operator><name>top</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>top</name><operator>-&gt;</operator><name>nextbacktracks</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></else></ternary></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>OP_REF</name></expr>:</case>
    <case>case <expr><name>OP_REFI</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>cc</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>]</index></name> <operator>&gt;=</operator> <name>OP_CRSTAR</name> <operator>&amp;&amp;</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>]</index></name> <operator>&lt;=</operator> <name>OP_CRPOSRANGE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_ref_iterator_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>compile_ref_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>parent</name><operator>-&gt;</operator><name>top</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>top</name><operator>-&gt;</operator><name>nextbacktracks</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></else></ternary></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_DNREF</name></expr>:</case>
    <case>case <expr><name>OP_DNREFI</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>cc</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>IMM2_SIZE</name></expr>]</index></name> <operator>&gt;=</operator> <name>OP_CRSTAR</name> <operator>&amp;&amp;</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>IMM2_SIZE</name></expr>]</index></name> <operator>&lt;=</operator> <name>OP_CRPOSRANGE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_ref_iterator_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>compile_dnref_search</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>parent</name><operator>-&gt;</operator><name>top</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>top</name><operator>-&gt;</operator><name>nextbacktracks</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>compile_ref_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>parent</name><operator>-&gt;</operator><name>top</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>top</name><operator>-&gt;</operator><name>nextbacktracks</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></else></ternary></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_RECURSE</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_recurse_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CALLOUT</name></expr>:</case>
    <case>case <expr><name>OP_CALLOUT_STR</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_callout_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_ASSERT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT_NOT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NOT</name></expr>:</case>
    <expr_stmt><expr><call><name>PUSH_BACKTRACK_NOVALUE</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>assert_backtrack</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_assert_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>assert_backtrack</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_BRAMINZERO</name></expr>:</case>
    <expr_stmt><expr><call><name>PUSH_BACKTRACK_NOVALUE</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>braminzero_backtrack</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>bracketend</name><argument_list>(<argument><expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>cc</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>LINK_SIZE</name><operator>)</operator> <operator>!=</operator> <name>OP_KETRMIN</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>braminzero_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>count_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_ASSERT_NA</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NA</name></expr>:</case>
    <case>case <expr><name>OP_ONCE</name></expr>:</case>
    <case>case <expr><name>OP_SCRIPT_RUN</name></expr>:</case>
    <case>case <expr><name>OP_BRA</name></expr>:</case>
    <case>case <expr><name>OP_CBRA</name></expr>:</case>
    <case>case <expr><name>OP_COND</name></expr>:</case>
    <case>case <expr><name>OP_SBRA</name></expr>:</case>
    <case>case <expr><name>OP_SCBRA</name></expr>:</case>
    <case>case <expr><name>OP_SCOND</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_bracket_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_BRAZERO</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <name>OP_ASSERTBACK_NOT</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_bracket_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>PUSH_BACKTRACK_NOVALUE</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>assert_backtrack</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_assert_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>assert_backtrack</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_BRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_CBRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SBRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SCBRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_BRAPOSZERO</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_bracketpos_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_MARK</name></expr>:</case>
    <expr_stmt><expr><call><name>PUSH_BACKTRACK_NOVALUE</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>backtrack_common</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>common</name><operator>-&gt;</operator><name>has_skip_arg</name></name></expr> ?</condition><then> <expr><literal type="number">5</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>HAS_VIRTUAL_REGISTERS</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>common</name><operator>-&gt;</operator><name>has_skip_arg</name></name></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><name>cc</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><ternary><condition><expr><name>HAS_VIRTUAL_REGISTERS</name></expr> ?</condition><then> <expr><name>TMP1</name></expr> </then><else>: <expr><name>ARGUMENTS</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>mark_ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>has_skip_arg</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>type_mark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><name>cc</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cc</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_PRUNE</name></expr>:</case>
    <case>case <expr><name>OP_PRUNE_ARG</name></expr>:</case>
    <case>case <expr><name>OP_SKIP</name></expr>:</case>
    <case>case <expr><name>OP_SKIP_ARG</name></expr>:</case>
    <case>case <expr><name>OP_THEN</name></expr>:</case>
    <case>case <expr><name>OP_THEN_ARG</name></expr>:</case>
    <case>case <expr><name>OP_COMMIT</name></expr>:</case>
    <case>case <expr><name>OP_COMMIT_ARG</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_control_verb_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_FAIL</name></expr>:</case>
    <case>case <expr><name>OP_ACCEPT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT_ACCEPT</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_fail_accept_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CLOSE</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>compile_close_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_SKIPZERO</name></expr>:</case>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>bracketend</name><argument_list>(<argument><expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <default>default:</default>
    <expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
    </block_content>}</block></switch>
  <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>
  </block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>has_then_trap</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Head item on backtrack. */</comment>
  <expr_stmt><expr><call><name>PUSH_BACKTRACK_NOVALUE</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>then_trap_backtrack</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>then_trap_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>common</name><operator>.</operator><name>cc</name></name> <operator>=</operator> <name>then_trap_opcode</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>BACKTRACK_AS</name><argument_list>(<argument><expr><name>then_trap_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>then_trap</name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>then_trap</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>then_trap</name></name> <operator>=</operator> <name>save_then_trap</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>cc</name> <operator>==</operator> <name>ccend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PUSH_BACKTRACK</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PUSH_BACKTRACK_NOVALUE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BACKTRACK_AS</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPILE_BACKTRACKINGPATH</name><parameter_list>(<parameter><type><name>current</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>do \
    { \
    compile_backtrackingpath(common, (current)); \
    if (SLJIT_UNLIKELY(sljit_get_compiler_error(compiler))) \
      return; \
    } \
  while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURRENT_AS</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((type *)current)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>compile_iterator_backtrackingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>backtrack_common</name></name> <modifier>*</modifier></type><name>current</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name> <init>= <expr><name><name>current</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>opcode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_u32</name></type> <name>max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>exact</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>label</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>jumplist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>private_data_ptr</name> <init>= <expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset0</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>private_data_ptr</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset1</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>private_data_ptr</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>get_iterator_parameters</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opcode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exact</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch<condition>(<expr><name>opcode</name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><name>OP_STAR</name></expr>:</case>
  <case>case <expr><name>OP_UPTO</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>OP_ANYNL</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>OP_EXTUNI</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>backtracks</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>charpos</name><operator>.</operator><name>enabled</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>MOV_UCHAR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STR_PTR</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>charpos</name><operator>.</operator><name>othercasebit</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_OR</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>charpos</name><operator>.</operator><name>othercasebit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>charpos</name><operator>.</operator><name>chr</name></name></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>move_back</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>move_back</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  <break>break;</break>

  <case>case <expr><name>OP_MINSTAR</name></expr>:</case>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jumplist</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>jumplist</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <break>break;</break>

  <case>case <expr><name>OP_MINUPTO</name></expr>:</case>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jumplist</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_ZERO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset1</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jumplist</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>jumplist</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <break>break;</break>

  <case>case <expr><name>OP_QUERY</name></expr>:</case>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>backtracks</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <break>break;</break>

  <case>case <expr><name>OP_MINQUERY</name></expr>:</case>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>offset0</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>compile_char1_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jumplist</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>char_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>jumplist</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <break>break;</break>

  <case>case <expr><name>OP_EXACT</name></expr>:</case>
  <case>case <expr><name>OP_POSSTAR</name></expr>:</case>
  <case>case <expr><name>OP_POSQUERY</name></expr>:</case>
  <case>case <expr><name>OP_POSUPTO</name></expr>:</case>
  <break>break;</break>

  <default>default:</default>
  <expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
  </block_content>}</block></switch>

<expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>compile_ref_iterator_backtrackingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>backtrack_common</name></name> <modifier>*</modifier></type><name>current</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name> <init>= <expr><name><name>current</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>ref</name> <init>= <expr><operator>(</operator><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_REF</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_REFI</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>type</name></decl>;</decl_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>cc</name><index>[<expr><ternary><condition><expr><name>ref</name></expr> ?</condition><then> <expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr> </then><else>: <expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>IMM2_SIZE</name></expr></else></ternary></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>type</name> <operator>&amp;</operator> <literal type="number">0x1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Maximize case. */</comment>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>ref_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>ref_iterator_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><ternary><condition><expr><name>ref</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>compile_recurse_backtrackingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>backtrack_common</name></name> <modifier>*</modifier></type><name>current</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>recurse_entry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>recurse_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>inlined_pattern</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>recurse_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>entry</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>backtrack_label</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>backtrack_calls</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>backtrack_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>recurse_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>compile_backtrackingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>compile_assert_backtrackingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>backtrack_common</name></name> <modifier>*</modifier></type><name>current</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name> <init>= <expr><name><name>current</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>bra</name> <init>= <expr><name>OP_BRA</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>brajump</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name> <operator>!=</operator> <name>OP_BRAMINZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_BRAZERO</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>bra</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>topbacktracks</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>assert_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>framesize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>assert_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <return>return;</return>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ASSERT_NOT</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ASSERTBACK_NOT</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>assert_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>brajump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ASSERT</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ASSERTBACK</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>assert_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>revertframes</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>assert_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>framesize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>assert_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>private_data_ptr</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* We know there is enough place on the stack. */</comment>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>assert_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>brajump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>compile_bracket_backtrackingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>backtrack_common</name></name> <modifier>*</modifier></type><name>current</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>opcode</name></decl>, <decl><type ref="prev"/><name>stacksize</name></decl>, <decl><type ref="prev"/><name>alt_count</name></decl>, <decl><type ref="prev"/><name>alt_max</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>private_data_ptr</name> <init>= <expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>private_data_ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>repeat_ptr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>repeat_type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>repeat_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name> <init>= <expr><name><name>current</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ccbegin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ccprev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>bra</name> <init>= <expr><name>OP_BRA</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>ket</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>assert_backtrack</name> <modifier>*</modifier></type><name>assert</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>has_alternatives</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>needs_control_head</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>brazero</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>next_alt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>once</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>cond</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>rmin_label</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>exact_label</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_put_label</name></name> <modifier>*</modifier></type><name>put_label</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_BRAZERO</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_BRAMINZERO</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>bra</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>opcode</name> <operator>=</operator> <operator>*</operator><name>cc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ccbegin</name> <operator>=</operator> <call><name>bracketend</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ket</name> <operator>=</operator> <operator>*</operator><name>ccbegin</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KET</name> <operator>&amp;&amp;</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>ccbegin</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>repeat_ptr</name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>ccbegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>repeat_type</name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>ccbegin</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>repeat_count</name> <operator>=</operator> <call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name>ccbegin</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>repeat_type</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>repeat_count</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>repeat_type</name> <operator>==</operator> <name>OP_UPTO</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>ket</name> <operator>=</operator> <name>OP_KETRMAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>repeat_type</name> <operator>==</operator> <name>OP_MINUPTO</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>ket</name> <operator>=</operator> <name>OP_KETRMIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ccbegin</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>has_alternatives</name> <operator>=</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ALT</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><name>opcode</name> <operator>==</operator> <name>OP_COND</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><name>opcode</name> <operator>==</operator> <name>OP_SCOND</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>has_alternatives</name> <operator>=</operator> <operator>(</operator><name><name>ccbegin</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>]</index></name> <operator>&gt;=</operator> <name>OP_ASSERT</name> <operator>&amp;&amp;</operator> <name><name>ccbegin</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>]</index></name> <operator>&lt;=</operator> <name>OP_ASSERTBACK_NOT</name><operator>)</operator> <operator>||</operator> <call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>condfailed</name></name> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_CBRA</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_SCBRA</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><call><name>GET2</name><argument_list>(<argument><expr><name>ccbegin</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><name>opcode</name> <operator>==</operator> <name>OP_COND</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_KETRMAX</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_KETRMIN</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>opcode</name> <operator>=</operator> <name>OP_SCOND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>alt_max</name> <operator>=</operator> <ternary><condition><expr><name>has_alternatives</name></expr> ?</condition><then> <expr><call><name>no_alternatives</name><argument_list>(<argument><expr><name>ccbegin</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<comment type="block">/* Decoding the needs_control_head in framesize. */</comment>
<if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_ONCE</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>needs_control_head</name> <operator>=</operator> <operator>(</operator><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>&amp;</operator> <literal type="number">0x1</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ket</name> <operator>!=</operator> <name>OP_KET</name> <operator>&amp;&amp;</operator> <name>repeat_type</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* TMP1 is used in OP_KETRMIN below. */</comment>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>repeat_type</name> <operator>==</operator> <name>OP_UPTO</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repeat_ptr</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repeat_ptr</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KETRMAX</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>brazero</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KETRMIN</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>bra</name> <operator>!=</operator> <name>OP_BRAMINZERO</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>repeat_type</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <comment type="block">/* TMP1 was set a few lines above. */</comment>
      <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>recursive_matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Drop STR_PTR for non-greedy plus quantifier. */</comment>
      <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>!=</operator> <name>OP_ONCE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>opcode</name> <operator>&gt;=</operator> <name>OP_SBRA</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_ONCE</name></expr>)</condition>
      <block>{<block_content>
      <comment type="block">/* Checking zero-length iteration. */</comment>
      <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>!=</operator> <name>OP_ONCE</name> <operator>||</operator> <call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>recursive_matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>recursive_matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      <comment type="block">/* Drop STR_PTR for non-greedy plus quantifier. */</comment>
      <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>!=</operator> <name>OP_ONCE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>recursive_matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>rmin_label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>repeat_type</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repeat_ptr</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repeat_ptr</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>brazero</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>repeat_type</name> <operator>==</operator> <name>OP_EXACT</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repeat_ptr</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>exact_label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><name>offset</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><name>offset</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><name>opcode</name> <operator>==</operator> <name>OP_ONCE</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>revertframes</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>once</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><name>opcode</name> <operator>==</operator> <name>OP_COND</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><name>opcode</name> <operator>==</operator> <name>OP_SCOND</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>has_alternatives</name></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* Always exactly one alternative. */</comment>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>alt_max</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>next_alt</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>has_alternatives</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>alt_max</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>sljit_emit_ijump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>matching_put_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sljit_set_put_label</name><argument_list>(<argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>matching_put_label</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sljit_emit_op0</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_ENDBR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>next_alt</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>COMPILE_BACKTRACKINGPATH</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>current</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><name>opcode</name> <operator>==</operator> <name>OP_COND</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><name>opcode</name> <operator>==</operator> <name>OP_SCOND</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Conditional block always has at most one alternative. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>ccbegin</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>]</index></name> <operator>&gt;=</operator> <name>OP_ASSERT</name> <operator>&amp;&amp;</operator> <name><name>ccbegin</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>]</index></name> <operator>&lt;=</operator> <name>OP_ASSERTBACK_NOT</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>has_alternatives</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>assert</name> <operator>=</operator> <call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>assert</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>assert</name><operator>-&gt;</operator><name>framesize</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ccbegin</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_ASSERT</name> <operator>||</operator> <name><name>ccbegin</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_ASSERTBACK</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>assert</name><operator>-&gt;</operator><name>private_data_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>revertframes</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name><name>assert</name><operator>-&gt;</operator><name>framesize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>assert</name><operator>-&gt;</operator><name>private_data_ptr</name></name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>cond</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>assert</name><operator>-&gt;</operator><name>condfailed</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>condfailed</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>has_alternatives</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cond</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>condfailed</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name>has_alternatives</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_alternatives</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>alt_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <do>do
    <block>{<block_content>
    <expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>topbacktracks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>nextbacktracks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <comment type="block">/* Conditional blocks always have an additional alternative, even if it is empty. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>ccprev</name> <operator>=</operator> <name>cc</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>!=</operator> <name>OP_COND</name> <operator>&amp;&amp;</operator> <name>opcode</name> <operator>!=</operator> <name>OP_SCOND</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>!=</operator> <name>OP_ONCE</name></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>private_data_ptr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
          <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
          </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><ternary><condition><expr><name>needs_control_head</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>compile_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ccprev</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><call><name>sljit_get_compiler_error</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_ASSERT_NA</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_ASSERTBACK_NA</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_SCRIPT_RUN</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>match_script_run_common</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Instructions after the current alternative is successfully matched. */</comment>
    <comment type="block">/* There is a similar code in compile_bracket_matchingpath. */</comment>
    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_ONCE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>match_once_common</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ket</name></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>has_alternatives</name></expr></argument>, <argument><expr><name>needs_control_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>repeat_type</name> <operator>==</operator> <name>OP_MINUPTO</name></expr>)</condition>
      <block>{<block_content>
      <comment type="block">/* We need to preserve the counter. TMP2 will be used below. */</comment>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repeat_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>ket</name> <operator>!=</operator> <name>OP_KET</name> <operator>||</operator> <name>bra</name> <operator>!=</operator> <name>OP_BRA</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><name>offset</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>stacksize</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>!=</operator> <name>OP_ONCE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>stacksize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>repeat_type</name> <operator>==</operator> <name>OP_MINUPTO</name></expr>)</condition>
      <block>{<block_content>
      <comment type="block">/* TMP2 was set above. */</comment>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>ket</name> <operator>!=</operator> <name>OP_KET</name> <operator>||</operator> <name>bra</name> <operator>!=</operator> <name>OP_BRA</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>ket</name> <operator>!=</operator> <name>OP_KET</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <call><name>match_capture_common</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>stacksize</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>!=</operator> <name>OP_ONCE</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>alt_max</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>alt_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>put_label</name> <operator>=</operator> <call><name>sljit_emit_put_label</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ket</name> <operator>==</operator> <name>OP_KETRMAX</name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><name>offset</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <comment type="block">/* If ket is not OP_KETRMAX, this code path is executed after the jump to alternative_matchingpath. */</comment>
      <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>private_data_ptr</name> <operator>==</operator> <call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>alternative_matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>!=</operator> <name>OP_ONCE</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>alt_max</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>next_alt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>alt_count</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>alt_count</name> <operator>&lt;</operator> <name>alt_max</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>alt_count</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>alt_max</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>next_alt</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><call><name>sljit_set_put_label</name><argument_list>(<argument><expr><name>put_label</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sljit_emit_op0</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_ENDBR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>COMPILE_BACKTRACKINGPATH</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>current</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name><name>current</name><operator>-&gt;</operator><name>nextbacktracks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
  while <condition>(<expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>

  <if_stmt><if>if <condition>(<expr><name>cond</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>opcode</name> <operator>==</operator> <name>OP_COND</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_SCOND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>assert</name> <operator>=</operator> <call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>assert</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ccbegin</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_ASSERT_NOT</name> <operator>||</operator> <name><name>ccbegin</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_ASSERTBACK_NOT</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>assert</name><operator>-&gt;</operator><name>framesize</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>assert</name><operator>-&gt;</operator><name>private_data_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>revertframes</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name><name>assert</name><operator>-&gt;</operator><name>framesize</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>assert</name><operator>-&gt;</operator><name>private_data_ptr</name></name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Free the STR_PTR. */</comment>
  <if_stmt><if>if <condition>(<expr><name>private_data_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Using both tmp register is better for instruction scheduling. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name><index>[<expr><name>offset</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_ASSERT_NA</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_ASSERTBACK_NA</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_SCRIPT_RUN</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_SBRA</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_SCOND</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_ONCE</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>cc</name> <operator>=</operator> <name>ccbegin</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>ccbegin</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>stacksize</name> <operator>=</operator> <ternary><condition><expr><name>needs_control_head</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* Reset head and drop saved frame. */</comment>
    <expr_stmt><expr><name>stacksize</name> <operator>+=</operator> <call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>ket</name> <operator>!=</operator> <name>OP_KET</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ALT</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KETRMAX</name> <operator>||</operator> <operator>(</operator><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_ALT</name> <operator>&amp;&amp;</operator> <name>ket</name> <operator>!=</operator> <name>OP_KETRMIN</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* The STR_PTR must be released. */</comment>
    <expr_stmt><expr><name>stacksize</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>stacksize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>stacksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>once</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Restore previous private_data_ptr */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>framesize</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KETRMIN</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* See the comment below. */</comment>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>private_data_ptr</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>repeat_type</name> <operator>==</operator> <name>OP_EXACT</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repeat_ptr</name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repeat_ptr</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_LESS_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>repeat_count</name></expr></argument>, <argument><expr><name>exact_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KETRMAX</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>bra</name> <operator>!=</operator> <name>OP_BRAZERO</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>recursive_matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>zero_matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>brazero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>ket</name> <operator>==</operator> <name>OP_KETRMIN</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* OP_ONCE removes everything in case of a backtrack, so we don't
  need to explicitly release the STR_PTR. The extra release would
  affect badly the free_stack(2) above. */</comment>
  <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>!=</operator> <name>OP_ONCE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rmin_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_ONCE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><ternary><condition><expr><name>bra</name> <operator>==</operator> <name>OP_BRAMINZERO</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAMINZERO</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>bra</name> <operator>==</operator> <name>OP_BRAZERO</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracket_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>zero_matchingpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>brazero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>compile_bracketpos_backtrackingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>backtrack_common</name></name> <modifier>*</modifier></type><name>current</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracketpos_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>framesize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>current</name><operator>-&gt;</operator><name>cc</name></name> <operator>==</operator> <name>OP_CBRAPOS</name> <operator>||</operator> <operator>*</operator><name><name>current</name><operator>-&gt;</operator><name>cc</name></name> <operator>==</operator> <name>OP_SCBRAPOS</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><call><name>GET2</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracketpos_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>stacksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracketpos_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>private_data_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>revertframes</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracketpos_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>framesize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>current</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Drop the stack frame. */</comment>
  <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracketpos_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>stacksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracketpos_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>private_data_ptr</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><operator>-</operator><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>bracketpos_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>framesize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>compile_braminzero_backtrackingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>backtrack_common</name></name> <modifier>*</modifier></type><name>current</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>assert_backtrack</name></type> <name>backtrack</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>topbacktracks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>current</name><operator>-&gt;</operator><name>nextbacktracks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>current</name><operator>-&gt;</operator><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <name>OP_ASSERTBACK_NOT</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Manual call of compile_bracket_matchingpath and compile_bracket_backtrackingpath. */</comment>
  <expr_stmt><expr><call><name>compile_bracket_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>compile_bracket_backtrackingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>backtrack</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>backtrack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>backtrack</name><operator>.</operator><name>common</name><operator>.</operator><name>cc</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>cc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>backtrack</name><operator>.</operator><name>matchingpath</name></name> <operator>=</operator> <call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>braminzero_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>matchingpath</name></expr>;</expr_stmt>
  <comment type="block">/* Manual call of compile_assert_matchingpath. */</comment>
  <expr_stmt><expr><call><name>compile_assert_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>backtrack</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name><name>current</name><operator>-&gt;</operator><name>nextbacktracks</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>current</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>compile_control_verb_backtrackingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>backtrack_common</name></name> <modifier>*</modifier></type><name>current</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>opcode</name> <init>= <expr><operator>*</operator><name><name>current</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>loop</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_THEN</name> <operator>||</operator> <name>opcode</name> <operator>==</operator> <name>OP_THEN_ARG</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>then_trap</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>type_then_trap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>then_trap</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>loop</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>loop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>then_trap</name><operator>-&gt;</operator><name>quit</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>local_quit_available</name></name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>in_positive_assertion</name></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>positive_assertion_quit</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>local_quit_available</name></name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Abort match with a fail. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>quit_label</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>quit</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>quit_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <return>return;</return>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_SKIP_ARG</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>TMP1</name> <operator>==</operator> <name>SLJIT_R0</name> <operator>&amp;&amp;</operator> <name>STR_PTR</name> <operator>==</operator> <name>SLJIT_R1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><name><name>current</name><operator>-&gt;</operator><name>cc</name></name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sljit_emit_icall</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_CALL</name></expr></argument>, <argument><expr><call><name>SLJIT_RET</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>SLJIT_ARG1</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>SLJIT_ARG2</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>SLJIT_FUNC_OFFSET</name><argument_list>(<argument><expr><name>do_search_mark</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>reset_match</name></name></expr></argument>, <argument><expr><call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return;</return>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>opcode</name> <operator>==</operator> <name>OP_SKIP</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>reset_match</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>compile_then_trap_backtrackingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>backtrack_common</name></name> <modifier>*</modifier></type><name>current</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>then_trap_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>then_trap</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>then_trap</name></name> <operator>=</operator> <call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>then_trap_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>then_trap</name></expr>;</expr_stmt>
  <return>return;</return>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>then_trap_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>framesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">3</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>size</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>size</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>then_trap_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>quit</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* STACK_TOP is set by THEN. */</comment>
<if_stmt><if>if <condition>(<expr><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>then_trap_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>framesize</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>revertframes</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_FAST_CALL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>(</operator><call><name>CURRENT_AS</name><argument_list>(<argument><expr><name>then_trap_backtrack</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>framesize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>compile_backtrackingpath</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>backtrack_common</name></name> <modifier>*</modifier></type><name>current</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>then_trap_backtrack</name> <modifier>*</modifier></type><name>save_then_trap</name> <init>= <expr><name><name>common</name><operator>-&gt;</operator><name>then_trap</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>current</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>current</name><operator>-&gt;</operator><name>nextbacktracks</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>nextbacktracks</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <switch>switch<condition>(<expr><operator>*</operator><name><name>current</name><operator>-&gt;</operator><name>cc</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>OP_SET_SOM</name></expr>:</case>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_STAR</name></expr>:</case>
    <case>case <expr><name>OP_MINSTAR</name></expr>:</case>
    <case>case <expr><name>OP_PLUS</name></expr>:</case>
    <case>case <expr><name>OP_MINPLUS</name></expr>:</case>
    <case>case <expr><name>OP_QUERY</name></expr>:</case>
    <case>case <expr><name>OP_MINQUERY</name></expr>:</case>
    <case>case <expr><name>OP_UPTO</name></expr>:</case>
    <case>case <expr><name>OP_MINUPTO</name></expr>:</case>
    <case>case <expr><name>OP_EXACT</name></expr>:</case>
    <case>case <expr><name>OP_POSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_POSPLUS</name></expr>:</case>
    <case>case <expr><name>OP_POSQUERY</name></expr>:</case>
    <case>case <expr><name>OP_POSUPTO</name></expr>:</case>
    <case>case <expr><name>OP_STARI</name></expr>:</case>
    <case>case <expr><name>OP_MINSTARI</name></expr>:</case>
    <case>case <expr><name>OP_PLUSI</name></expr>:</case>
    <case>case <expr><name>OP_MINPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_QUERYI</name></expr>:</case>
    <case>case <expr><name>OP_MINQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_UPTOI</name></expr>:</case>
    <case>case <expr><name>OP_MINUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_EXACTI</name></expr>:</case>
    <case>case <expr><name>OP_POSSTARI</name></expr>:</case>
    <case>case <expr><name>OP_POSPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_POSQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_POSUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_NOTSTAR</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINSTAR</name></expr>:</case>
    <case>case <expr><name>OP_NOTPLUS</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINPLUS</name></expr>:</case>
    <case>case <expr><name>OP_NOTQUERY</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINQUERY</name></expr>:</case>
    <case>case <expr><name>OP_NOTUPTO</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINUPTO</name></expr>:</case>
    <case>case <expr><name>OP_NOTEXACT</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSPLUS</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSQUERY</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSUPTO</name></expr>:</case>
    <case>case <expr><name>OP_NOTSTARI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINSTARI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_NOTQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_NOTUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_NOTEXACTI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSSTARI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_TYPESTAR</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINSTAR</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPLUS</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINPLUS</name></expr>:</case>
    <case>case <expr><name>OP_TYPEQUERY</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINQUERY</name></expr>:</case>
    <case>case <expr><name>OP_TYPEUPTO</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINUPTO</name></expr>:</case>
    <case>case <expr><name>OP_TYPEEXACT</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSPLUS</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSQUERY</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSUPTO</name></expr>:</case>
    <case>case <expr><name>OP_CLASS</name></expr>:</case>
    <case>case <expr><name>OP_NCLASS</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
    <case>case <expr><name>OP_XCLASS</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>compile_iterator_backtrackingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_REF</name></expr>:</case>
    <case>case <expr><name>OP_REFI</name></expr>:</case>
    <case>case <expr><name>OP_DNREF</name></expr>:</case>
    <case>case <expr><name>OP_DNREFI</name></expr>:</case>
    <expr_stmt><expr><call><name>compile_ref_iterator_backtrackingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_RECURSE</name></expr>:</case>
    <expr_stmt><expr><call><name>compile_recurse_backtrackingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_ASSERT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT_NOT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NOT</name></expr>:</case>
    <expr_stmt><expr><call><name>compile_assert_backtrackingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_ASSERT_NA</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NA</name></expr>:</case>
    <case>case <expr><name>OP_ONCE</name></expr>:</case>
    <case>case <expr><name>OP_SCRIPT_RUN</name></expr>:</case>
    <case>case <expr><name>OP_BRA</name></expr>:</case>
    <case>case <expr><name>OP_CBRA</name></expr>:</case>
    <case>case <expr><name>OP_COND</name></expr>:</case>
    <case>case <expr><name>OP_SBRA</name></expr>:</case>
    <case>case <expr><name>OP_SCBRA</name></expr>:</case>
    <case>case <expr><name>OP_SCOND</name></expr>:</case>
    <expr_stmt><expr><call><name>compile_bracket_backtrackingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_BRAZERO</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>current</name><operator>-&gt;</operator><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <name>OP_ASSERTBACK_NOT</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>compile_bracket_backtrackingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>compile_assert_backtrackingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_BRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_CBRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SBRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SCBRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_BRAPOSZERO</name></expr>:</case>
    <expr_stmt><expr><call><name>compile_bracketpos_backtrackingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_BRAMINZERO</name></expr>:</case>
    <expr_stmt><expr><call><name>compile_braminzero_backtrackingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_MARK</name></expr>:</case>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>common</name><operator>-&gt;</operator><name>has_skip_arg</name></name></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>has_skip_arg</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>common</name><operator>-&gt;</operator><name>has_skip_arg</name></name></expr> ?</condition><then> <expr><literal type="number">5</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>has_skip_arg</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_THEN</name></expr>:</case>
    <case>case <expr><name>OP_THEN_ARG</name></expr>:</case>
    <case>case <expr><name>OP_PRUNE</name></expr>:</case>
    <case>case <expr><name>OP_PRUNE_ARG</name></expr>:</case>
    <case>case <expr><name>OP_SKIP</name></expr>:</case>
    <case>case <expr><name>OP_SKIP_ARG</name></expr>:</case>
    <expr_stmt><expr><call><name>compile_control_verb_backtrackingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_COMMIT</name></expr>:</case>
    <case>case <expr><name>OP_COMMIT_ARG</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>local_quit_available</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>PCRE2_ERROR_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>quit_label</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>common</name><operator>-&gt;</operator><name>quit</name></name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>quit_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CALLOUT</name></expr>:</case>
    <case>case <expr><name>OP_CALLOUT_STR</name></expr>:</case>
    <case>case <expr><name>OP_FAIL</name></expr>:</case>
    <case>case <expr><name>OP_ACCEPT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT_ACCEPT</name></expr>:</case>
    <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_THEN_TRAP</name></expr>:</case>
    <comment type="block">/* A virtual opcode for then traps. */</comment>
    <expr_stmt><expr><call><name>compile_then_trap_backtrackingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <default>default:</default>
    <expr_stmt><expr><call><name>SLJIT_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch>
  <expr_stmt><expr><name>current</name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>then_trap</name></name> <operator>=</operator> <name>save_then_trap</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SLJIT_INLINE</name> <name>void</name></type> <name>compile_recurse</name><parameter_list>(<parameter><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>DEFINE_COMPILER</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>cc</name> <init>= <expr><name><name>common</name><operator>-&gt;</operator><name>start</name></name> <operator>+</operator> <name><name>common</name><operator>-&gt;</operator><name>currententry</name><operator>-&gt;</operator><name>start</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ccbegin</name> <init>= <expr><name>cc</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_BRA</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>IMM2_SIZE</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ccend</name> <init>= <expr><call><name>bracketend</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>needs_control_head</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>has_quit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>has_accept</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>private_data_size</name> <init>= <expr><call><name>get_recurse_data_length</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ccbegin</name></expr></argument>, <argument><expr><name>ccend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>needs_control_head</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>has_quit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>has_accept</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>alt_count</name></decl>, <decl><type ref="prev"/><name>alt_max</name></decl>, <decl><type ref="prev"/><name>local_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>backtrack_common</name></type> <name>altbacktrack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>match</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>next_alt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>accept_exit</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>quit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_put_label</name></name> <modifier>*</modifier></type><name>put_label</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Recurse captures then. */</comment>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>then_trap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_BRA</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_CBRA</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_CBRAPOS</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_SCBRA</name> <operator>||</operator> <operator>*</operator><name>cc</name> <operator>==</operator> <name>OP_SCBRAPOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>alt_max</name> <operator>=</operator> <call><name>no_alternatives</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>alt_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<comment type="block">/* Matching path. */</comment>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>currententry</name><operator>-&gt;</operator><name>entry_label</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>recursive_head_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>currententry</name><operator>-&gt;</operator><name>entry_label</name></name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>currententry</name><operator>-&gt;</operator><name>entry_calls</name></name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>currententry</name><operator>-&gt;</operator><name>entry_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>count_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>local_size</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>alt_max</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<comment type="block">/* (Reversed) stack layout:
   [private data][return address][optional: str ptr] ... [optional: alternative index][recursive_head_ptr] */</comment>

<expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>private_data_size</name> <operator>+</operator> <name>local_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* Save return address. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>local_size</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>copy_recurse_data</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ccbegin</name></expr></argument>, <argument><expr><name>ccend</name></expr></argument>, <argument><expr><name>recurse_copy_from_global</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>, <argument><expr><name>private_data_size</name> <operator>+</operator> <name>local_size</name></expr></argument>, <argument><expr><name>has_quit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* This variable is saved and restored all time when we enter or exit from a recursive context. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>recursive_head_ptr</name></name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>needs_control_head</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>alt_max</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>altbacktrack</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>backtrack_common</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>quit_label</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>accept_label</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>quit</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>accept</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>altbacktrack</name><operator>.</operator><name>cc</name></name> <operator>=</operator> <name>ccbegin</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>altbacktrack</name><operator>.</operator><name>top</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>altbacktrack</name><operator>.</operator><name>topbacktracks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>altbacktrack</name><operator>.</operator><name>cc</name></name> <operator>!=</operator> <name>ccbegin</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>compile_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>altbacktrack</name><operator>.</operator><name>cc</name></name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>altbacktrack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><call><name>sljit_get_compiler_error</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>alt_max</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>has_accept</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>recursive_head_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>alt_max</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>has_accept</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>alt_max</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>put_label</name> <operator>=</operator> <call><name>sljit_emit_put_label</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>alt_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>add_jump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>match</name></expr></argument>, <argument><expr><call><name>JUMP</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>alt_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* Backtracking path entry. */</comment>
    <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>currententry</name><operator>-&gt;</operator><name>backtrack_label</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>currententry</name><operator>-&gt;</operator><name>backtrack_label</name></name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>currententry</name><operator>-&gt;</operator><name>backtrack_calls</name></name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>currententry</name><operator>-&gt;</operator><name>backtrack_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>has_accept</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>accept_exit</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Save return address. */</comment>
    <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>local_size</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_recurse_data</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ccbegin</name></expr></argument>, <argument><expr><name>ccend</name></expr></argument>, <argument><expr><name>recurse_swap_global</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>, <argument><expr><name>private_data_size</name> <operator>+</operator> <name>local_size</name></expr></argument>, <argument><expr><name>has_quit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>alt_max</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>alt_max</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>sljit_emit_ijump</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sljit_set_put_label</name><argument_list>(<argument><expr><name>put_label</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sljit_emit_op0</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_ENDBR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>next_alt</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><ternary><condition><expr><name>has_accept</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>alt_max</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>sljit_set_put_label</name><argument_list>(<argument><expr><name>put_label</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sljit_emit_op0</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_ENDBR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>next_alt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>alt_count</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>alt_max</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>alt_count</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>alt_max</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>next_alt</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>alt_count</name><operator>++</operator></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>compile_backtrackingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>altbacktrack</name><operator>.</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><call><name>sljit_get_compiler_error</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>altbacktrack</name><operator>.</operator><name>topbacktracks</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cc</name> <operator>!=</operator> <name>OP_ALT</name></expr>)</condition><block type="pseudo"><block_content>
    <break>break;</break></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>altbacktrack</name><operator>.</operator><name>cc</name></name> <operator>=</operator> <name>cc</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

<comment type="block">/* No alternative is matched. */</comment>

<expr_stmt><expr><name>quit</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>copy_recurse_data</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ccbegin</name></expr></argument>, <argument><expr><name>ccend</name></expr></argument>, <argument><expr><name>recurse_copy_private_to_global</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>, <argument><expr><name>private_data_size</name> <operator>+</operator> <name>local_size</name></expr></argument>, <argument><expr><name>has_quit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>local_size</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>private_data_size</name> <operator>+</operator> <name>local_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>quit</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>has_quit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>quit</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>recursive_head_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>copy_recurse_data</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ccbegin</name></expr></argument>, <argument><expr><name>ccend</name></expr></argument>, <argument><expr><name>recurse_copy_shared_to_global</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>, <argument><expr><name>private_data_size</name> <operator>+</operator> <name>local_size</name></expr></argument>, <argument><expr><name>has_quit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name>quit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_accept</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>accept_exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Save return address. */</comment>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>local_size</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>copy_recurse_data</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ccbegin</name></expr></argument>, <argument><expr><name>ccend</name></expr></argument>, <argument><expr><name>recurse_copy_kept_shared_to_global</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>, <argument><expr><name>private_data_size</name> <operator>+</operator> <name>local_size</name></expr></argument>, <argument><expr><name>has_quit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>local_size</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>private_data_size</name> <operator>+</operator> <name>local_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>accept</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>has_accept</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>accept</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>recursive_head_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>allocate_stack</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>STACK_TOP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>copy_recurse_data</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>ccbegin</name></expr></argument>, <argument><expr><name>ccend</name></expr></argument>, <argument><expr><name>recurse_swap_global</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>, <argument><expr><name>private_data_size</name> <operator>+</operator> <name>local_size</name></expr></argument>, <argument><expr><name>has_quit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STACK</name><argument_list>(<argument><expr><name>local_size</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>COMPILE_BACKTRACKINGPATH</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CURRENT_AS</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUBLIC_JIT_COMPILE_CONFIGURATION_OPTIONS</name></cpp:macro> \
  <cpp:value>(PCRE2_JIT_INVALID_UTF)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type> <name>jit_compile</name><parameter_list>(<parameter><decl><type><name>pcre2_code</name> <modifier>*</modifier></type><name>code</name></decl></parameter>, <parameter><decl><type><name>sljit_u32</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcre2_real_code</name> <modifier>*</modifier></type><name>re</name> <init>= <expr><operator>(</operator><name>pcre2_real_code</name> <operator>*</operator><operator>)</operator><name>code</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_compiler</name></name> <modifier>*</modifier></type><name>compiler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>backtrack_common</name></type> <name>rootbacktrack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>compiler_common</name></type> <name>common_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>compiler_common</name> <modifier>*</modifier></type><name>common</name> <init>= <expr><operator>&amp;</operator><name>common_data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>sljit_u8</name> <modifier>*</modifier></type><name>tables</name> <init>= <expr><name><name>re</name><operator>-&gt;</operator><name>tables</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>allocator_data</name> <init>= <expr><operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>memctl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>private_data_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ccend</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>executable_functions</name> <modifier>*</modifier></type><name>functions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>executable_func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_uw</name></type> <name>executable_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sljit_uw</name></type> <name>total_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>mainloop_label</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>continue_match_label</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>empty_match_found_label</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>empty_match_backtrack_label</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>reset_match_label</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_label</name></name> <modifier>*</modifier></type><name>quit_label</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>jump</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>minlength_check_failed</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>empty_match</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sljit_jump</name></name> <modifier>*</modifier></type><name>end_anchor_failed</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jump_list</name> <modifier>*</modifier></type><name>reqcu_not_found</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAS_VIRTUAL_REGISTERS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><call><name>sljit_get_register_index</name><argument_list>(<argument><expr><name>TMP3</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sljit_get_register_index</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sljit_get_register_index</name><argument_list>(<argument><expr><name>RETURN_ADDR</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>HAS_VIRTUAL_REGISTERS</name> <operator>==</operator> <literal type="number">0</literal></expr></cpp:elif>
<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><call><name>sljit_get_register_index</name><argument_list>(<argument><expr><name>TMP3</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sljit_get_register_index</name><argument_list>(<argument><expr><name>ARGUMENTS</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sljit_get_register_index</name><argument_list>(<argument><expr><name>RETURN_ADDR</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"Invalid value for HAS_VIRTUAL_REGISTERS"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rootbacktrack</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>backtrack_common</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>compiler_common</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>re</name></name> <operator>=</operator> <name>re</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>name_table</name></name> <operator>=</operator> <operator>(</operator><name>PCRE2_SPTR</name><operator>)</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>re</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pcre2_real_code</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rootbacktrack</name><operator>.</operator><name>cc</name></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>name_table</name></name> <operator>+</operator> <name><name>re</name><operator>-&gt;</operator><name>name_count</name></name> <operator>*</operator> <name><name>re</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name> <operator>=</operator> <operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>PCRE2_JIT_INVALID_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
<expr_stmt><expr><name>mode</name> <operator>&amp;=</operator> <operator>~</operator><name>PUBLIC_JIT_COMPILE_CONFIGURATION_OPTIONS</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name><name>rootbacktrack</name><operator>.</operator><name>cc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>read_only_data_head</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>fcc</name></name> <operator>=</operator> <name>tables</name> <operator>+</operator> <name>fcc_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>lcc</name></name> <operator>=</operator> <operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><name>tables</name> <operator>+</operator> <name>lcc_offset</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>mode</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>might_be_empty</name></name> <operator>=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>minlength</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_MATCH_EMPTY</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>allow_empty_partial</name></name> <operator>=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>max_lookbehind</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_MATCH_EMPTY</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>=</operator> <name>NLTYPE_FIXED</name></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>newline_convention</name></name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><name>PCRE2_NEWLINE_CR</name></expr>:</case> <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>=</operator> <name>CHAR_CR</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>PCRE2_NEWLINE_LF</name></expr>:</case> <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>=</operator> <name>CHAR_NL</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>PCRE2_NEWLINE_CRLF</name></expr>:</case> <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>=</operator> <operator>(</operator><name>CHAR_CR</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>CHAR_NL</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>PCRE2_NEWLINE_ANY</name></expr>:</case> <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>=</operator> <operator>(</operator><name>CHAR_CR</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>CHAR_NL</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>=</operator> <name>NLTYPE_ANY</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>PCRE2_NEWLINE_ANYCRLF</name></expr>:</case> <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>=</operator> <operator>(</operator><name>CHAR_CR</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>CHAR_NL</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>=</operator> <name>NLTYPE_ANYCRLF</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>PCRE2_NEWLINE_NUL</name></expr>:</case> <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>=</operator> <name>CHAR_NUL</name></expr>;</expr_stmt> <break>break;</break>
  <default>default:</default> <return>return <expr><name>PCRE2_ERROR_INTERNAL</name></expr>;</return>
  </block_content>}</block></switch>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>nlmax</name></name> <operator>=</operator> <name>READ_CHAR_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>nlmin</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>bsr_convention</name></name> <operator>==</operator> <name>PCRE2_BSR_UNICODE</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>bsr_nltype</name></name> <operator>=</operator> <name>NLTYPE_ANY</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>bsr_convention</name></name> <operator>==</operator> <name>PCRE2_BSR_ANYCRLF</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>bsr_nltype</name></name> <operator>=</operator> <name>NLTYPE_ANYCRLF</name></expr>;</expr_stmt></block_content></block></if>
<else>else
  <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BSR_ANYCRLF</name></cpp:ifdef>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>bsr_nltype</name></name> <operator>=</operator> <name>NLTYPE_ANYCRLF</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>bsr_nltype</name></name> <operator>=</operator> <name>NLTYPE_ANY</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>bsr_nlmax</name></name> <operator>=</operator> <name>READ_CHAR_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>bsr_nlmin</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>endonly</name></name> <operator>=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_DOLLAR_ENDONLY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>ctypes</name></name> <operator>=</operator> <operator>(</operator><name>sljit_sw</name><operator>)</operator><operator>(</operator><name>tables</name> <operator>+</operator> <name>ctypes_offset</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>name_count</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>name_count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>name_entry_size</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>unset_backref</name></name> <operator>=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_MATCH_UNSET_BACKREF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>alt_circumflex</name></name> <operator>=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_ALT_CIRCUMFLEX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<comment type="block">/* PCRE_UTF[16|32] have the same value as PCRE_UTF8. */</comment>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name> <operator>=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>ucp</name></name> <operator>=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utf</name></name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_ANY</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>nlmax</name></name> <operator>=</operator> <literal type="number">0x2029</literal></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_ANYCRLF</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>nlmax</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>CHAR_CR</name> <operator>&gt;</operator> <name>CHAR_NL</name><operator>)</operator></expr> ?</condition><then> <expr><name>CHAR_CR</name></expr> </then><else>: <expr><name>CHAR_NL</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
    <comment type="block">/* We only care about the first newline character. */</comment>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>nlmax</name></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>nlmin</name></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>newline</name></name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>nlmin</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>CHAR_CR</name> <operator>&lt;</operator> <name>CHAR_NL</name><operator>)</operator></expr> ?</condition><then> <expr><name>CHAR_CR</name></expr> </then><else>: <expr><name>CHAR_NL</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>bsr_nltype</name></name> <operator>==</operator> <name>NLTYPE_ANY</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>bsr_nlmax</name></name> <operator>=</operator> <literal type="number">0x2029</literal></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>bsr_nlmax</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>CHAR_CR</name> <operator>&gt;</operator> <name>CHAR_NL</name><operator>)</operator></expr> ?</condition><then> <expr><name>CHAR_CR</name></expr> </then><else>: <expr><name>CHAR_NL</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>bsr_nlmin</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>CHAR_CR</name> <operator>&lt;</operator> <name>CHAR_NL</name><operator>)</operator></expr> ?</condition><then> <expr><name>CHAR_CR</name></expr> </then><else>: <expr><name>CHAR_NL</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>invalid_utf</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>
<expr_stmt><expr><name>ccend</name> <operator>=</operator> <call><name>bracketend</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Calculate the local space size on the stack. */</comment>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name> <operator>=</operator> <name>LIMIT_MATCH</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name></name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name> <operator>*</operator><operator>)</operator><call><name>SLJIT_MALLOC</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>top_bracket</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>allocator_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name></name></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG_FORCE_UNOPTIMIZED_CBRAS</name> <operator>&amp;&amp;</operator> <name>DEBUG_FORCE_UNOPTIMIZED_CBRAS</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>top_bracket</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>top_bracket</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>*</operator><name><name>common</name><operator>-&gt;</operator><name>start</name></name> <operator>==</operator> <name>OP_BRA</name> <operator>&amp;&amp;</operator> <name><name>ccend</name><index>[<expr><operator>-</operator><operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name><operator>)</operator></expr>]</index></name> <operator>==</operator> <name>OP_KET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG_FORCE_UNOPTIMIZED_CBRAS</name> <operator>&amp;&amp;</operator> <name>DEBUG_FORCE_UNOPTIMIZED_CBRAS</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:if>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_opcode_types</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr></argument>, <argument><expr><name>ccend</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_FREE</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name></name></expr></argument>, <argument><expr><name>allocator_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Checking flags and updating ovector_start. */</comment>
<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_LASTSET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_NO_START_OPTIMIZE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>req_char_ptr</name></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>!=</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>start_used_ptr</name></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>PCRE2_JIT_PARTIAL_SOFT</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>hit_start</name></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_FIRSTLINE</name> <operator>|</operator> <name>PCRE2_USE_OFFSET_LIMIT</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DEBUG_FORCE_CONTROL_HEAD</name> <operator>&amp;&amp;</operator> <name>DEBUG_FORCE_CONTROL_HEAD</name></expr></cpp:if>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>has_set_som</name></name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Saving the real start pointer is necessary. */</comment>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>start_ptr</name></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Aligning ovector to even number of sljit words. */</comment>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name> <operator>&amp;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>ovector_start</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>start_ptr</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>start_ptr</name></name> <operator>=</operator> <call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* Capturing brackets cannot be optimized if callouts are allowed. */</comment>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>top_bracket</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>req_char_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>start_used_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>cbra_ptr</name></name> <operator>=</operator> <name>OVECTOR_START</name> <operator>+</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>top_bracket</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name>total_length</name> <operator>=</operator> <name>ccend</name> <operator>-</operator> <name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name></name> <operator>=</operator> <operator>(</operator><name>sljit_s32</name> <operator>*</operator><operator>)</operator><call><name>SLJIT_MALLOC</name><argument_list>(<argument><expr><name>total_length</name> <operator>*</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>sljit_s32</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>common</name><operator>-&gt;</operator><name>has_then</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>)</operator></expr></argument>, <argument><expr><name>allocator_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_FREE</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name></name></expr></argument>, <argument><expr><name>allocator_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>total_length</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_s32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>private_data_size</name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>cbra_ptr</name></name> <operator>+</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>top_bracket</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sljit_sw</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_private_data_ptrs</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>private_data_size</name></expr></argument>, <argument><expr><name>ccend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_ANCHORED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_NO_START_OPTIMIZE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>common</name><operator>-&gt;</operator><name>has_skip_in_assert_back</name></name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>detect_early_fail</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>private_data_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>early_fail_start_ptr</name></name> <operator>&lt;=</operator> <name><name>common</name><operator>-&gt;</operator><name>early_fail_end_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>private_data_size</name> <operator>&gt;</operator> <name>SLJIT_MAX_LOCAL_SIZE</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_FREE</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name></name></expr></argument>, <argument><expr><name>allocator_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SLJIT_FREE</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name></name></expr></argument>, <argument><expr><name>allocator_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>has_then</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>then_offsets</name></name> <operator>=</operator> <operator>(</operator><name>sljit_u8</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name></name> <operator>+</operator> <name>total_length</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>then_offsets</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>total_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>set_then_offsets</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>compiler</name> <operator>=</operator> <call><name>sljit_create_compiler</name><argument_list>(<argument><expr><name>allocator_data</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>compiler</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_FREE</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name></name></expr></argument>, <argument><expr><name>allocator_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SLJIT_FREE</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name></name></expr></argument>, <argument><expr><name>allocator_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>compiler</name></name> <operator>=</operator> <name>compiler</name></expr>;</expr_stmt>

<comment type="block">/* Main pcre_jit_exec entry. */</comment>
<expr_stmt><expr><call><name>sljit_emit_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_ARG1</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>private_data_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Register init. */</comment>
<expr_stmt><expr><call><name>reset_ovector</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>top_bracket</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>req_char_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>req_char_ptr</name></name></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_S0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_S0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U32</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>limit_match</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_TOP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr>struct <name>sljit_stack</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_LIMIT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr>struct <name>sljit_stack</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LIMIT_MATCH</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>early_fail_start_ptr</name></name> <operator>&lt;</operator> <name><name>common</name><operator>-&gt;</operator><name>early_fail_end_ptr</name></name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>reset_early_fail</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>PCRE2_JIT_PARTIAL_SOFT</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>hit_start</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>mark_ptr</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>control_head_ptr</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* Main part of the matching */</comment>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_ANCHORED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>mainloop_label</name> <operator>=</operator> <call><name>mainloop_entry</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>continue_match_label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Forward search if possible. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_NO_START_OPTIMIZE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name> <operator>&amp;&amp;</operator> <call><name>fast_forward_first_n_chars</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <empty_stmt>;</empty_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_FIRSTSET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fast_forward_first_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_STARTLINE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fast_forward_newline</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_FIRSTMAPSET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fast_forward_start_bits</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><name>continue_match_label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name> <operator>&amp;&amp;</operator> <name><name>re</name><operator>-&gt;</operator><name>minlength</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_NO_START_OPTIMIZE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>PCRE2_ERROR_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_ADD</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>IN_UCHARS</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>minlength</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>minlength_check_failed</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>req_char_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>reqcu_not_found</name> <operator>=</operator> <call><name>search_requested_char</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>(</operator><name>PCRE2_UCHAR</name><operator>)</operator><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>last_codeunit</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_LASTCASELESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_FIRSTSET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* Store the current STR_PTR in OVECTOR(0). */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* Copy the limit of allowed recursions. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>COUNT_MATCH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LIMIT_MATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>capture_last_ptr</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>fast_forward_bc_ptr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>fast_forward_bc_ptr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>start_ptr</name></name> <operator>!=</operator> <call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_ptr</name></name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* Copy the beginning of the string. */</comment>
<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>PCRE2_JIT_PARTIAL_SOFT</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>hit_start</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>PCRE2_JIT_PARTIAL_HARD</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>compile_matchingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start</name></name></expr></argument>, <argument><expr><name>ccend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rootbacktrack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><call><name>sljit_get_compiler_error</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>sljit_free_compiler</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SLJIT_FREE</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name></name></expr></argument>, <argument><expr><name>allocator_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SLJIT_FREE</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name></name></expr></argument>, <argument><expr><name>allocator_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <function_decl><type><name>PRIV</name></type>(<name>jit_free_rodata</name>)<parameter_list>(<parameter><decl><type><name><name>common</name><operator>-&gt;</operator><name>read_only_data_head</name></name></type></decl></parameter>, <parameter><decl><type><name>allocator_data</name></type></decl></parameter>)</parameter_list>;</function_decl>
  <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_ENDANCHORED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>end_anchor_failed</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>might_be_empty</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>empty_match</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>OVECTOR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>empty_match_found_label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>accept_label</name></name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>accept</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>accept</name></name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>accept_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* This means we have a match. Update the ovector. */</comment>
<expr_stmt><expr><call><name>copy_ovector</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>top_bracket</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>quit_label</name></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>abort_label</name></name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>quit</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>quit</name></name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>quit_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>abort</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>abort</name></name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>abort_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>minlength_check_failed</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>SET_LABEL</name><argument_list>(<argument><expr><name>minlength_check_failed</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>abort_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>sljit_emit_op0</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_SKIP_FRAMES_BEFORE_RETURN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sljit_emit_return</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>failed_match</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>failed_match</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>PCRE2_ERROR_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>abort_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_ENDANCHORED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>end_anchor_failed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>!=</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>partialmatchlabel</name></name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>partialmatch</name></name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>partialmatchlabel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>return_with_partial_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>quit_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>might_be_empty</name></name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>empty_match_backtrack_label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>compile_backtrackingpath</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name><name>rootbacktrack</name><operator>.</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><call><name>sljit_get_compiler_error</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>sljit_free_compiler</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SLJIT_FREE</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name></name></expr></argument>, <argument><expr><name>allocator_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SLJIT_FREE</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name></name></expr></argument>, <argument><expr><name>allocator_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <function_decl><type><name>PRIV</name></type>(<name>jit_free_rodata</name>)<parameter_list>(<parameter><decl><type><name><name>common</name><operator>-&gt;</operator><name>read_only_data_head</name></name></type></decl></parameter>, <parameter><decl><type><name>allocator_data</name></type></decl></parameter>)</parameter_list>;</function_decl>
  <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name><name>rootbacktrack</name><operator>.</operator><name>prev</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>reset_match_label</name> <operator>=</operator> <call><name>LABEL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>PCRE2_JIT_PARTIAL_SOFT</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Update hit_start only in the first time. */</comment>
  <expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>hit_start</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>hit_start</name></name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Check we have remaining characters. */</comment>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_ANCHORED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>,
    <argument><expr><ternary><condition><expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>fast_forward_bc_ptr</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><call><name>PRIVATE_DATA</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>fast_forward_bc_ptr</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr> </then><else>: <expr><name><name>common</name><operator>-&gt;</operator><name>start_ptr</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_ANCHORED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>ff_newline_shortcut</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* There cannot be more newlines if PCRE2_FIRSTLINE is set. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_FIRSTLINE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>ff_newline_shortcut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_END</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>ff_newline_shortcut</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_LESS</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>common</name><operator>-&gt;</operator><name>match_end_ptr</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>STR_END</name></expr> </then><else>: <expr><name>TMP1</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mainloop_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* No more remaining characters. */</comment>
<if_stmt><if>if <condition>(<expr><name>reqcu_not_found</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name>reqcu_not_found</name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>PCRE2_JIT_PARTIAL_SOFT</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>hit_start</name></name></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>partialmatchlabel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>PCRE2_ERROR_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>quit_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>flush_stubs</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>might_be_empty</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>empty_match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV_U32</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>PCRE2_NOTEMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_ZERO</name></expr></argument>, <argument><expr><name>empty_match_backtrack_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_AND</name> <operator>|</operator> <name>SLJIT_SET_Z</name></expr></argument>, <argument><expr><name>SLJIT_UNUSED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>PCRE2_NOTEMPTY_ATSTART</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_ZERO</name></expr></argument>, <argument><expr><name>empty_match_found_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>TMP1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_NOT_EQUAL</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>empty_match_found_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name>empty_match_backtrack_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>fast_forward_bc_ptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>early_fail_start_ptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>early_fail_end_ptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>currententry</name></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>entries</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>local_quit_available</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>quit_label</name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>quit_label</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>currententry</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Might add new entries. */</comment>
  <expr_stmt><expr><call><name>compile_recurse</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>SLJIT_UNLIKELY</name><argument_list>(<argument><expr><call><name>sljit_get_compiler_error</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>sljit_free_compiler</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SLJIT_FREE</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name></name></expr></argument>, <argument><expr><name>allocator_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SLJIT_FREE</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name></name></expr></argument>, <argument><expr><name>allocator_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <function_decl><type><name>PRIV</name></type>(<name>jit_free_rodata</name>)<parameter_list>(<parameter><decl><type><name><name>common</name><operator>-&gt;</operator><name>read_only_data_head</name></name></type></decl></parameter>, <parameter><decl><type><name>allocator_data</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>flush_stubs</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>currententry</name></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>currententry</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  </block_content>}</block></while>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>local_quit_available</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>common</name><operator>-&gt;</operator><name>quit_label</name></name> <operator>=</operator> <name>quit_label</name></expr>;</expr_stmt>

<comment type="block">/* Allocating stack, returns with PCRE_ERROR_JIT_STACKLIMIT if fails. */</comment>
<comment type="block">/* This is a (really) rare case. */</comment>
<expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>stackalloc</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* RETURN_ADDR is not a saved register. */</comment>
<expr_stmt><expr><call><name>sljit_emit_fast_enter</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>TMP1</name> <operator>==</operator> <name>SLJIT_R0</name> <operator>&amp;&amp;</operator> <name>STR_PTR</name> <operator>==</operator> <name>SLJIT_R1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS1</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARGUMENTS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP2</name><argument_list>(<argument><expr><name>SLJIT_SUB</name></expr></argument>, <argument><expr><name>SLJIT_R1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_LIMIT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>STACK_GROWTH_RATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_R0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_R0</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SLJIT_OFFSETOF</name><argument_list>(<argument><expr><name>jit_arguments</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_LIMIT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sljit_emit_icall</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>, <argument><expr><name>SLJIT_CALL</name></expr></argument>, <argument><expr><call><name>SLJIT_RET</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>SLJIT_ARG1</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>SLJIT_ARG2</name><argument_list>(<argument><expr><name>SW</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><call><name>SLJIT_FUNC_OFFSET</name><argument_list>(<argument><expr><name>sljit_stack_resize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>jump</name> <operator>=</operator> <call><name>CMP</name><argument_list>(<argument><expr><name>SLJIT_EQUAL</name></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>STACK_LIMIT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STACK_LIMIT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>SLJIT_MEM1</name><argument_list>(<argument><expr><name>SLJIT_SP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOCALS1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP_SRC</name><argument_list>(<argument><expr><name>SLJIT_FAST_RETURN</name></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Allocation failed. */</comment>
<expr_stmt><expr><call><name>JUMPHERE</name><argument_list>(<argument><expr><name>jump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* We break the return address cache here, but this is a really rare case. */</comment>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>PCRE2_ERROR_JIT_STACKLIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>quit_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Call limit reached. */</comment>
<expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>calllimit</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>SLJIT_RETURN_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SLJIT_IMM</name></expr></argument>, <argument><expr><name>PCRE2_ERROR_MATCHLIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name><name>common</name><operator>-&gt;</operator><name>quit_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>revertframes</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>revertframes</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>do_revertframes</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>wordboundary</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>wordboundary</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>check_wordboundary</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>anynewline</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>anynewline</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>check_anynewline</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>hspace</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>hspace</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>check_hspace</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>vspace</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>vspace</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>check_vspace</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>casefulcmp</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>casefulcmp</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>do_casefulcmp</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>caselesscmp</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>caselesscmp</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>do_caselesscmp</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>reset_match</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>reset_match</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>do_reset_match</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>top_bracket</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CMPTO</name><argument_list>(<argument><expr><name>SLJIT_GREATER</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>continue_match_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>OP1</name><argument_list>(<argument><expr><name>SLJIT_MOV</name></expr></argument>, <argument><expr><name>STR_PTR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMP1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>JUMPTO</name><argument_list>(<argument><expr><name>SLJIT_JUMP</name></expr></argument>, <argument><expr><name>reset_match_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utfreadchar</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>utfreadchar</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>do_utfreadchar</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utfreadtype8</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>utfreadtype8</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>do_utfreadtype8</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utfpeakcharback</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>utfpeakcharback</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>do_utfpeakcharback</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 8 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal> <operator>||</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utfreadchar_invalid</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>utfreadchar_invalid</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>do_utfreadchar_invalid</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utfreadnewline_invalid</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>utfreadnewline_invalid</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>do_utfreadnewline_invalid</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utfmoveback_invalid</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>utfmoveback_invalid</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>do_utfmoveback_invalid</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>utfpeakcharback_invalid</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>utfpeakcharback_invalid</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>do_utfpeakcharback_invalid</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16 */</comment>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>getucd</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>getucd</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>do_getucd</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>common</name><operator>-&gt;</operator><name>getucdtype</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>set_jumps</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>getucdtype</name></name></expr></argument>, <argument><expr><call><name>LABEL</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>do_getucdtype</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>

<expr_stmt><expr><call><name>SLJIT_FREE</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>optimized_cbracket</name></name></expr></argument>, <argument><expr><name>allocator_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLJIT_FREE</name><argument_list>(<argument><expr><name><name>common</name><operator>-&gt;</operator><name>private_data_ptrs</name></name></expr></argument>, <argument><expr><name>allocator_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>executable_func</name> <operator>=</operator> <call><name>sljit_generate_code</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>executable_size</name> <operator>=</operator> <call><name>sljit_get_generated_code_size</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sljit_free_compiler</name><argument_list>(<argument><expr><name>compiler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>executable_func</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <function_decl><type><name>PRIV</name></type>(<name>jit_free_rodata</name>)<parameter_list>(<parameter><decl><type><name><name>common</name><operator>-&gt;</operator><name>read_only_data_head</name></name></type></decl></parameter>, <parameter><decl><type><name>allocator_data</name></type></decl></parameter>)</parameter_list>;</function_decl>
  <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Reuse the function descriptor if possible. */</comment>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>executable_jit</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>functions</name> <operator>=</operator> <operator>(</operator><name>executable_functions</name> <operator>*</operator><operator>)</operator><name><name>re</name><operator>-&gt;</operator><name>executable_jit</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><name>functions</name> <operator>=</operator> <call><name>SLJIT_MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>executable_functions</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>allocator_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>functions</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* This case is highly unlikely since we just recently
    freed a lot of memory. Not impossible though. */</comment>
    <expr_stmt><expr><call><name>sljit_free_code</name><argument_list>(<argument><expr><name>executable_func</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <function_decl><type><name>PRIV</name></type>(<name>jit_free_rodata</name>)<parameter_list>(<parameter><decl><type><name><name>common</name><operator>-&gt;</operator><name>read_only_data_head</name></name></type></decl></parameter>, <parameter><decl><type><name>allocator_data</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>functions</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>executable_functions</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>functions</name><operator>-&gt;</operator><name>top_bracket</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>top_bracket</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>functions</name><operator>-&gt;</operator><name>limit_match</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>limit_match</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>executable_jit</name></name> <operator>=</operator> <name>functions</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<comment type="block">/* Turn mode into an index. */</comment>
<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>PCRE2_JIT_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>mode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><name>mode</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>mode</name> <operator>==</operator> <name>PCRE2_JIT_PARTIAL_SOFT</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>SLJIT_ASSERT</name><argument_list>(<argument><expr><name>mode</name> <operator>&lt;</operator> <name>JIT_NUMBER_OF_COMPILE_MODES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>functions</name><operator>-&gt;</operator><name>executable_funcs</name><index>[<expr><name>mode</name></expr>]</index></name> <operator>=</operator> <name>executable_func</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>functions</name><operator>-&gt;</operator><name>read_only_data_heads</name><index>[<expr><name>mode</name></expr>]</index></name> <operator>=</operator> <name><name>common</name><operator>-&gt;</operator><name>read_only_data_head</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>functions</name><operator>-&gt;</operator><name>executable_sizes</name><index>[<expr><name>mode</name></expr>]</index></name> <operator>=</operator> <name>executable_size</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*************************************************
*        JIT compile a Regular Expression        *
*************************************************/</comment>

<comment type="block">/* This function used JIT to convert a previously-compiled pattern into machine
code.

Arguments:
  code          a compiled pattern
  options       JIT option bits

Returns:        0: success or (*NOJIT) was used
               &lt;0: an error code
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUBLIC_JIT_COMPILE_OPTIONS</name></cpp:macro> \
  <cpp:value>(PCRE2_JIT_COMPLETE|PCRE2_JIT_PARTIAL_SOFT|PCRE2_JIT_PARTIAL_HARD|PCRE2_JIT_INVALID_UTF)</cpp:value></cpp:define>

<function><type><name>PCRE2_EXP_DEFN</name> <name>int</name> <name>PCRE2_CALL_CONVENTION</name></type>
<name>pcre2_jit_compile</name><parameter_list>(<parameter><decl><type><name>pcre2_code</name> <modifier>*</modifier></type><name>code</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcre2_real_code</name> <modifier>*</modifier></type><name>re</name> <init>= <expr><operator>(</operator><name>pcre2_real_code</name> <operator>*</operator><operator>)</operator><name>code</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>code</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>PCRE2_ERROR_NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <operator>~</operator><name>PUBLIC_JIT_COMPILE_OPTIONS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>PCRE2_ERROR_JIT_BADOPTION</name></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* Support for invalid UTF was first introduced in JIT, with the option
PCRE2_JIT_INVALID_UTF. Later, support was added to the interpreter, and the
compile-time option PCRE2_MATCH_INVALID_UTF was created. This is now the
preferred feature, with the earlier option deprecated. However, for backward
compatibility, if the earlier option is set, it forces the new option so that
if JIT matching falls back to the interpreter, there is still support for
invalid UTF. However, if this function has already been successfully called
without PCRE2_JIT_INVALID_UTF and without PCRE2_MATCH_INVALID_UTF (meaning that
non-invalid-supporting JIT code was compiled), give an error.

If in the future support for PCRE2_JIT_INVALID_UTF is withdrawn, the following
actions are needed:

  1. Remove the definition from pcre2.h.in and from the list in
     PUBLIC_JIT_COMPILE_OPTIONS above.

  2. Replace PCRE2_JIT_INVALID_UTF with a local flag in this module.

  3. Replace PCRE2_JIT_INVALID_UTF in pcre2_jit_test.c.

  4. Delete the following short block of code. The setting of "re" and
     "functions" can be moved into the JIT-only block below, but if that is
     done, (void)re and (void)functions will be needed in the non-JIT case, to
     avoid compiler warnings.
*/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_JIT</name></cpp:ifdef>
<decl_stmt><decl><type><name>executable_functions</name> <modifier>*</modifier></type><name>functions</name> <init>= <expr><operator>(</operator><name>executable_functions</name> <operator>*</operator><operator>)</operator><name><name>re</name><operator>-&gt;</operator><name>executable_jit</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>executable_allocator_is_working</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_JIT_INVALID_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_MATCH_INVALID_UTF</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_JIT</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>functions</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_JIT_BADOPTION</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>|=</operator> <name>PCRE2_MATCH_INVALID_UTF</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* The above tests are run with and without JIT support. This means that
PCRE2_JIT_INVALID_UTF propagates back into the regex options (ensuring
interpreter support) even in the absence of JIT. But now, if there is no JIT
support, give an error return. */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SUPPORT_JIT</name></cpp:ifndef>
<return>return <expr><name>PCRE2_ERROR_JIT_BADOPTION</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* SUPPORT_JIT */</comment>

<comment type="block">/* There is JIT support. Do the necessary. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_NOJIT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>executable_allocator_is_working</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Checks whether the executable allocator is working. This check
     might run multiple times in multi-threaded environments, but the
     result should not be affected by it. */</comment>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>SLJIT_MALLOC_EXEC</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>executable_allocator_is_working</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SLJIT_FREE_EXEC</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>sljit_u8</name><operator>*</operator><operator>)</operator><operator>(</operator><name>ptr</name><operator>)</operator><operator>)</operator> <operator>+</operator> <call><name>SLJIT_EXEC_OFFSET</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>executable_allocator_is_working</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>executable_allocator_is_working</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_MATCH_INVALID_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_JIT_INVALID_UTF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_JIT_COMPLETE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>functions</name> <operator>==</operator> <name>NULL</name>
    <operator>||</operator> <name><name>functions</name><operator>-&gt;</operator><name>executable_funcs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>excluded_options</name> <init>= <expr><operator>(</operator><name>PCRE2_JIT_PARTIAL_SOFT</name> <operator>|</operator> <name>PCRE2_JIT_PARTIAL_HARD</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>jit_compile</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>options</name> <operator>&amp;</operator> <operator>~</operator><name>excluded_options</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_JIT_PARTIAL_SOFT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>functions</name> <operator>==</operator> <name>NULL</name>
    <operator>||</operator> <name><name>functions</name><operator>-&gt;</operator><name>executable_funcs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>excluded_options</name> <init>= <expr><operator>(</operator><name>PCRE2_JIT_COMPLETE</name> <operator>|</operator> <name>PCRE2_JIT_PARTIAL_HARD</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>jit_compile</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>options</name> <operator>&amp;</operator> <operator>~</operator><name>excluded_options</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_JIT_PARTIAL_HARD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>functions</name> <operator>==</operator> <name>NULL</name>
    <operator>||</operator> <name><name>functions</name><operator>-&gt;</operator><name>executable_funcs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>excluded_options</name> <init>= <expr><operator>(</operator><name>PCRE2_JIT_COMPLETE</name> <operator>|</operator> <name>PCRE2_JIT_PARTIAL_SOFT</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>jit_compile</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>options</name> <operator>&amp;</operator> <operator>~</operator><name>excluded_options</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_JIT */</comment>
</block_content>}</block></function>

<comment type="block">/* JIT compiler uses an all-in-one approach. This improves security,
   since the code generator functions are not exported. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCLUDED_FROM_PCRE2_JIT_COMPILE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_jit_match.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_jit_misc.c"</cpp:file></cpp:include>

<comment type="block">/* End of pcre2_jit_compile.c */</comment>
</unit>
