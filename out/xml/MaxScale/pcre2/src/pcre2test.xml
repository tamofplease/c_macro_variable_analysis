<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/pcre2/src/pcre2test.c"><comment type="block" format="doxygen">/*************************************************
*             PCRE2 testing program              *
*************************************************/</comment>

<comment type="block">/* PCRE2 is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language. In 2014
the API was completely revised and '2' was added to the name, because the old
API, which had lasted for 16 years, could not accommodate new requirements. At
the same time, this testing program was re-designed because its original
hacked-up (non-) design had also run out of steam.

                       Written by Philip Hazel
     Original code Copyright (c) 1997-2012 University of Cambridge
    Rewritten code Copyright (c) 2016-2020 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/</comment>


<comment type="block">/* This program supports testing of the 8-bit, 16-bit, and 32-bit PCRE2
libraries in a single program, though its input and output are always 8-bit.
It is different from modules such as pcre2_compile.c in the library itself,
which are compiled separately for each code unit width. If two widths are
enabled, for example, pcre2_compile.c is compiled twice. In contrast,
pcre2test.c is compiled only once, and linked with all the enabled libraries.
Therefore, it must not make use of any of the macros from pcre2.h or
pcre2_internal.h that depend on PCRE2_CODE_UNIT_WIDTH. It does, however, make
use of SUPPORT_PCRE2_8, SUPPORT_PCRE2_16, and SUPPORT_PCRE2_32, to ensure that
it references only the enabled library functions. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;locale.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NATIVE_ZOS</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcrzoscs.h"</cpp:file></cpp:include>
<comment type="block">/* That header is not included in the main PCRE2 distribution because other
apparatus is needed to compile pcre2test for z/OS. The header can be found in
the special z/OS distribution, which is available from www.zaconsultants.net or
from www.cbttape.org. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNISTD_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Debugging code enabler */</comment>

<comment type="block">/* #define DEBUG_SHOW_MALLOC_ADDRESSES */</comment>

<comment type="block">/* Both libreadline and libedit are optionally supported. The user-supplied
original patch uses readline/readline.h for libedit, but in at least one system
it is installed as editline/readline.h, so the configuration code now looks for
that first, falling back to readline/readline.h. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_LIBREADLINE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_LIBEDIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_LIBREADLINE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;readline/readline.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;readline/history.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_EDITLINE_READLINE_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;editline/readline.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;readline/readline.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Put the test for interactive input into a macro so that it can be changed if
required for different environments. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTERACTIVE</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>isatty(fileno(f))</cpp:value></cpp:define>


<comment type="block">/* ---------------------- System-specific definitions ---------------------- */</comment>

<comment type="block">/* A number of things vary for Windows builds. Originally, pcretest opened its
input and output without "b"; then I was told that "b" was needed in some
environments, so it was added for release 5.0 to both the input and output. (It
makes no difference on Unix-like systems.) Later I was told that it is wrong
for the input on Windows. I've now abstracted the modes into macros that are
set here, to make it easier to fiddle with them, and removed "b" from the input
mode under Windows. The BINARY versions are used when saving/restoring compiled
patterns. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>                <comment type="block">/* For _setmode() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>             <comment type="block">/* For _O_BINARY */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INPUT_MODE</name></cpp:macro>          <cpp:value>"r"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUTPUT_MODE</name></cpp:macro>         <cpp:value>"wb"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BINARY_INPUT_MODE</name></cpp:macro>   <cpp:value>"rb"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BINARY_OUTPUT_MODE</name></cpp:macro>  <cpp:value>"wb"</cpp:value></cpp:define>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>isatty</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isatty</name></cpp:macro> <cpp:value>_isatty</cpp:value></cpp:define>         <comment type="block">/* This is what Windows calls them, I'm told, */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                         <comment type="block">/* though in some environments they seem to   */</comment>
                               <comment type="block">/* be already defined, hence the #ifndefs.    */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>fileno</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fileno</name></cpp:macro> <cpp:value>_fileno</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* A user sent this fix for Borland Builder 5 under Windows. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__BORLANDC__</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_setmode</name><parameter_list>(<parameter><type><name>handle</name></type></parameter>, <parameter><type><name>mode</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>setmode(handle, mode)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Not Windows */</comment>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>          <comment type="block">/* These two includes are needed */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>      <comment type="block">/* for setrlimit(). */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NATIVE_ZOS</name></expr></cpp:if>         <comment type="block">/* z/OS uses non-binary I/O */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INPUT_MODE</name></cpp:macro>   <cpp:value>"r"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUTPUT_MODE</name></cpp:macro>  <cpp:value>"w"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BINARY_INPUT_MODE</name></cpp:macro>   <cpp:value>"rb"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BINARY_OUTPUT_MODE</name></cpp:macro>  <cpp:value>"wb"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INPUT_MODE</name></cpp:macro>          <cpp:value>"rb"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUTPUT_MODE</name></cpp:macro>         <cpp:value>"wb"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BINARY_INPUT_MODE</name></cpp:macro>   <cpp:value>"rb"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BINARY_OUTPUT_MODE</name></cpp:macro>  <cpp:value>"wb"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* VMS-specific code was included as suggested by a VMS user [1]. Another VMS
user [2] provided alternative code which worked better for him. I have
commented out the original, but kept it around just in case. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ssdef.h&gt;</cpp:file></cpp:include>
<comment type="block">/* These two includes came from [2]. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> descrip</cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> lib$routines</cpp:include>
<comment type="block">/* void vms_setsymbol( char *, char *, int ); Original code from [1]. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* VC and older compilers don't support %td or %zu, and even some that claim to
be C99 don't support it (hence DISABLE_PERCENT_ZT). There are some non-C99
environments where %lu gives a warning with 32-bit pointers. As there doesn't
seem to be an easy way round this, just live with it (the cases are rare). */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__STDC_VERSION__</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>__STDC_VERSION__</name> <operator>&lt;</operator> <literal type="number">199901L</literal> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>DISABLE_PERCENT_ZT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PTR_FORM</name></cpp:macro> <cpp:value>"lu"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZ_FORM</name></cpp:macro> <cpp:value>"lu"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZ_CAST</name></cpp:macro> <cpp:value>(unsigned long int)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PTR_FORM</name></cpp:macro> <cpp:value>"td"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZ_FORM</name></cpp:macro> <cpp:value>"zu"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZ_CAST</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ------------------End of system-specific definitions -------------------- */</comment>

<comment type="block">/* Glueing macros that are used in several places below. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>glue</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a##b</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>G</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>glue(a,b)</cpp:value></cpp:define>

<comment type="block">/* Miscellaneous parameters and manifests */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CLOCKS_PER_SEC</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CLK_TCK</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLOCKS_PER_SEC</name></cpp:macro> <cpp:value>CLK_TCK</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLOCKS_PER_SEC</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CFORE_UNSET</name></cpp:macro> <cpp:value>UINT32_MAX</cpp:value></cpp:define>    <comment type="block">/* Unset value for startend/cfail/cerror fields */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONVERT_UNSET</name></cpp:macro> <cpp:value>UINT32_MAX</cpp:value></cpp:define>  <comment type="block">/* Unset value for convert_type field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DFA_WS_DIMENSION</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>     <comment type="block">/* Size of DFA workspace */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_OVECCOUNT</name></cpp:macro> <cpp:value>15</cpp:value></cpp:define>      <comment type="block">/* Default ovector count */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JUNK_OFFSET</name></cpp:macro> <cpp:value>0xdeadbeef</cpp:value></cpp:define>    <comment type="block">/* For initializing ovector */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCALESIZE</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>             <comment type="block">/* Size of locale name */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOOPREPEAT</name></cpp:macro> <cpp:value>500000</cpp:value></cpp:define>         <comment type="block">/* Default loop count for timing */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOCLISTSIZE</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>         <comment type="block">/* For remembering mallocs */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARENS_NEST_DEFAULT</name></cpp:macro> <cpp:value>220</cpp:value></cpp:define>   <comment type="block">/* Default parentheses nest limit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATSTACKSIZE</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>           <comment type="block">/* Pattern stack for save/restore testing */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPLACE_MODSIZE</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>       <comment type="block">/* Field for reading 8-bit replacement */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERSION_SIZE</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>           <comment type="block">/* Size of buffer for the version strings */</comment>

<comment type="block">/* Default JIT compile options */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JIT_DEFAULT</name></cpp:macro> <cpp:value>(PCRE2_JIT_COMPLETE|\
                     PCRE2_JIT_PARTIAL_SOFT|\
                     PCRE2_JIT_PARTIAL_HARD)</cpp:value></cpp:define>

<comment type="block">/* Make sure the buffer into which replacement strings are copied is big enough
to hold them as 32-bit code units. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPLACE_BUFFSIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>   <comment type="block">/* This is a byte value */</comment>

<comment type="block">/* Execution modes */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE8_MODE</name></cpp:macro>   <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE16_MODE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE32_MODE</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

<comment type="block">/* Processing returns */</comment>

<enum>enum <block>{ <decl><name>PR_OK</name></decl>, <decl><name>PR_SKIP</name></decl>, <decl><name>PR_ABEND</name></decl> }</block>;</enum>

<comment type="block">/* The macro PRINTABLE determines whether to print an output character as-is or
as a hex value when showing compiled patterns. is We use it in cases when the
locale has not been explicitly changed, so as to get consistent output from
systems that differ in their output from isprint() even in the "C" locale. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EBCDIC</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINTABLE</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((c) &gt;= 64 &amp;&amp; (c) &lt; 255)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINTABLE</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((c) &gt;= 32 &amp;&amp; (c) &lt; 127)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINTOK</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((use_tables != NULL &amp;&amp; c &lt; 256)? isprint(c) : PRINTABLE(c))</cpp:value></cpp:define>

<comment type="block">/* We have to include some of the library source files because we need
to use some of the macros, internal structure definitions, and other internal
values - pcre2test has "inside information" compared to an application program
that strictly follows the PCRE2 API.

Before including pcre2_internal.h we define PRIV so that it does not get
defined therein. This ensures that PRIV names in the included files do not
clash with those in the libraries. Also, although pcre2_internal.h does itself
include pcre2.h, we explicitly include it beforehand, along with pcre2posix.h,
so that the PCRE2_EXP_xxx macros get set appropriately for an application, not
for building the library. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRIV</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CODE_UNIT_WIDTH</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2posix.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_internal.h"</cpp:file></cpp:include>

<comment type="block">/* We need access to some of the data tables that PCRE2 uses. Defining
PCRE2_PCRETEST makes some minor changes in the files. The previous definition
of PRIV avoids name clashes. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_PCRE2TEST</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_tables.c"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_ucd.c"</cpp:file></cpp:include>

<comment type="block">/* 32-bit integer values in the input are read by strtoul() or strtol(). The
check needed for overflow depends on whether long ints are in fact longer than
ints. They are defined not to be shorter. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ULONG_MAX</name> <operator>&gt;</operator> <name>UINT32_MAX</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>U32OVERFLOW</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x &gt; UINT32_MAX)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>U32OVERFLOW</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x == UINT32_MAX)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LONG_MAX</name> <operator>&gt;</operator> <name>INT32_MAX</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S32OVERFLOW</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x &gt; INT32_MAX || x &lt; INT32_MIN)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S32OVERFLOW</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x == INT32_MAX || x == INT32_MIN)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* When PCRE2_CODE_UNIT_WIDTH is zero, pcre2_internal.h does not include
pcre2_intmodedep.h, which is where mode-dependent macros and structures are
defined. We can now include it for each supported code unit width. Because
PCRE2_CODE_UNIT_WIDTH was defined as zero before including pcre2.h, it will
have left PCRE2_SUFFIX defined as a no-op. We must re-define it appropriately
while including these files, and then restore it to a no-op. Because LINK_SIZE
may be changed in 16-bit mode and forced to 1 in 32-bit mode, the order of
these inclusions should not be changed. */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PCRE2_SUFFIX</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PCRE2_CODE_UNIT_WIDTH</name></cpp:undef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>   <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>PCRE2_CODE_UNIT_WIDTH</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>PCRE2_SUFFIX</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(a,8)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_intmodedep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_printint.c"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive>   <name>PCRE2_CODE_UNIT_WIDTH</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>   <name>PCRE2_SUFFIX</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* SUPPORT_PCRE2_8 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>   <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>PCRE2_CODE_UNIT_WIDTH</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>PCRE2_SUFFIX</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(a,16)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_intmodedep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_printint.c"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive>   <name>PCRE2_CODE_UNIT_WIDTH</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>   <name>PCRE2_SUFFIX</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* SUPPORT_PCRE2_16 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>   <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>PCRE2_CODE_UNIT_WIDTH</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>PCRE2_SUFFIX</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(a,32)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_intmodedep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_printint.c"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive>   <name>PCRE2_CODE_UNIT_WIDTH</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>   <name>PCRE2_SUFFIX</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* SUPPORT_PCRE2_32 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUFFIX</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a</cpp:value></cpp:define>

<comment type="block">/* We need to be able to check input text for UTF-8 validity, whatever code
widths are actually available, because the input to pcre2test is always in
8-bit code units. So we include the UTF validity checking function for 8-bit
code units. */</comment>

<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>valid_utf</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR8</name></type></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>PCRE2_CODE_UNIT_WIDTH</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive>   <name>PCRE2_SPTR</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>PCRE2_SPTR</name></cpp:macro> <cpp:value>PCRE2_SPTR8</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_valid_utf.c"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive>   <name>PCRE2_CODE_UNIT_WIDTH</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive>   <name>PCRE2_SPTR</name></cpp:undef>

<comment type="block">/* If we have 8-bit support, default to it; if there is also 16-or 32-bit
support, it can be selected by a command-line option. If there is no 8-bit
support, there must be 16-bit or 32-bit support, so default to one of them. The
config function, JIT stack, contexts, and version string are the same in all
modes, so use the form of the first that is available. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_PCRE2_8</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_TEST_MODE</name></cpp:macro> <cpp:value>PCRE8_MODE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERSION_TYPE</name></cpp:macro> <cpp:value>PCRE2_UCHAR8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CONFIG</name></cpp:macro> <cpp:value>pcre2_config_8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_STACK</name></cpp:macro> <cpp:value>pcre2_jit_stack_8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_REAL_GENERAL_CONTEXT</name></cpp:macro> <cpp:value>pcre2_real_general_context_8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_REAL_COMPILE_CONTEXT</name></cpp:macro> <cpp:value>pcre2_real_compile_context_8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_REAL_CONVERT_CONTEXT</name></cpp:macro> <cpp:value>pcre2_real_convert_context_8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_REAL_MATCH_CONTEXT</name></cpp:macro> <cpp:value>pcre2_real_match_context_8</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>SUPPORT_PCRE2_16</name></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_TEST_MODE</name></cpp:macro> <cpp:value>PCRE16_MODE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERSION_TYPE</name></cpp:macro> <cpp:value>PCRE2_UCHAR16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CONFIG</name></cpp:macro> <cpp:value>pcre2_config_16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_STACK</name></cpp:macro> <cpp:value>pcre2_jit_stack_16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_REAL_GENERAL_CONTEXT</name></cpp:macro> <cpp:value>pcre2_real_general_context_16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_REAL_COMPILE_CONTEXT</name></cpp:macro> <cpp:value>pcre2_real_compile_context_16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_REAL_CONVERT_CONTEXT</name></cpp:macro> <cpp:value>pcre2_real_convert_context_16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_REAL_MATCH_CONTEXT</name></cpp:macro> <cpp:value>pcre2_real_match_context_16</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>SUPPORT_PCRE2_32</name></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_TEST_MODE</name></cpp:macro> <cpp:value>PCRE32_MODE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERSION_TYPE</name></cpp:macro> <cpp:value>PCRE2_UCHAR32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CONFIG</name></cpp:macro> <cpp:value>pcre2_config_32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_STACK</name></cpp:macro> <cpp:value>pcre2_jit_stack_32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_REAL_GENERAL_CONTEXT</name></cpp:macro> <cpp:value>pcre2_real_general_context_32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_REAL_COMPILE_CONTEXT</name></cpp:macro> <cpp:value>pcre2_real_compile_context_32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_REAL_CONVERT_CONTEXT</name></cpp:macro> <cpp:value>pcre2_real_convert_context_32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_REAL_MATCH_CONTEXT</name></cpp:macro> <cpp:value>pcre2_real_match_context_32</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ------------- Structure and table for handling #-commands ------------- */</comment>

<typedef>typedef <type><struct>struct <name>cmdstruct</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>  <name>value</name></decl>;</decl_stmt>
}</block></struct></type> <name>cmdstruct</name>;</typedef>

<enum>enum <block>{ <decl><name>CMD_FORBID_UTF</name></decl>, <decl><name>CMD_LOAD</name></decl>, <decl><name>CMD_LOADTABLES</name></decl>, <decl><name>CMD_NEWLINE_DEFAULT</name></decl>,
  <decl><name>CMD_PATTERN</name></decl>, <decl><name>CMD_PERLTEST</name></decl>, <decl><name>CMD_POP</name></decl>, <decl><name>CMD_POPCOPY</name></decl>, <decl><name>CMD_SAVE</name></decl>, <decl><name>CMD_SUBJECT</name></decl>,
  <decl><name>CMD_UNKNOWN</name></decl> }</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <name>cmdstruct</name></type> <name><name>cmdlist</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{ <expr><literal type="string">"forbid_utf"</literal></expr>,      <expr><name>CMD_FORBID_UTF</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"load"</literal></expr>,            <expr><name>CMD_LOAD</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"loadtables"</literal></expr>,      <expr><name>CMD_LOADTABLES</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"newline_default"</literal></expr>, <expr><name>CMD_NEWLINE_DEFAULT</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"pattern"</literal></expr>,         <expr><name>CMD_PATTERN</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"perltest"</literal></expr>,        <expr><name>CMD_PERLTEST</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"pop"</literal></expr>,             <expr><name>CMD_POP</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"popcopy"</literal></expr>,         <expr><name>CMD_POPCOPY</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"save"</literal></expr>,            <expr><name>CMD_SAVE</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"subject"</literal></expr>,         <expr><name>CMD_SUBJECT</name></expr> }</block></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cmdlistcount</name></cpp:macro> <cpp:value>(sizeof(cmdlist)/sizeof(cmdstruct))</cpp:value></cpp:define>

<comment type="block">/* ------------- Structures and tables for handling modifiers -------------- */</comment>

<comment type="block">/* Table of names for newline types. Must be kept in step with the definitions
of PCRE2_NEWLINE_xx in pcre2.h. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>newlines</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="string">"DEFAULT"</literal></expr>, <expr><literal type="string">"CR"</literal></expr>, <expr><literal type="string">"LF"</literal></expr>, <expr><literal type="string">"CRLF"</literal></expr>, <expr><literal type="string">"ANY"</literal></expr>, <expr><literal type="string">"ANYCRLF"</literal></expr>, <expr><literal type="string">"NUL"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Structure and table for handling pattern conversion types. */</comment>

<typedef>typedef <type><struct>struct <name>convertstruct</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>option</name></decl>;</decl_stmt>
}</block></struct></type> <name>convertstruct</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>convertstruct</name></type> <name><name>convertlist</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{ <expr><literal type="string">"glob"</literal></expr>,                   <expr><name>PCRE2_CONVERT_GLOB</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"glob_no_starstar"</literal></expr>,       <expr><name>PCRE2_CONVERT_GLOB_NO_STARSTAR</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"glob_no_wild_separator"</literal></expr>, <expr><name>PCRE2_CONVERT_GLOB_NO_WILD_SEPARATOR</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"posix_basic"</literal></expr>,            <expr><name>PCRE2_CONVERT_POSIX_BASIC</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"posix_extended"</literal></expr>,         <expr><name>PCRE2_CONVERT_POSIX_EXTENDED</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"unset"</literal></expr>,                  <expr><name>CONVERT_UNSET</name></expr> }</block></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>convertlistcount</name></cpp:macro> <cpp:value>(sizeof(convertlist)/sizeof(convertstruct))</cpp:value></cpp:define>

<comment type="block">/* Modifier types and applicability */</comment>

<enum>enum <block>{ <decl><name>MOD_CTC</name></decl>,    <comment type="block">/* Applies to a compile context */</comment>
       <decl><name>MOD_CTM</name></decl>,    <comment type="block">/* Applies to a match context */</comment>
       <decl><name>MOD_PAT</name></decl>,    <comment type="block">/* Applies to a pattern */</comment>
       <decl><name>MOD_PATP</name></decl>,   <comment type="block">/* Ditto, OK for Perl test */</comment>
       <decl><name>MOD_DAT</name></decl>,    <comment type="block">/* Applies to a data line */</comment>
       <decl><name>MOD_PD</name></decl>,     <comment type="block">/* Applies to a pattern or a data line */</comment>
       <decl><name>MOD_PDP</name></decl>,    <comment type="block">/* As MOD_PD, OK for Perl test */</comment>
       <decl><name>MOD_PND</name></decl>,    <comment type="block">/* As MOD_PD, but not for a default pattern */</comment>
       <decl><name>MOD_PNDP</name></decl>,   <comment type="block">/* As MOD_PND, OK for Perl test */</comment>
       <decl><name>MOD_CHR</name></decl>,    <comment type="block">/* Is a single character */</comment>
       <decl><name>MOD_CON</name></decl>,    <comment type="block">/* Is a "convert" type/options list */</comment>
       <decl><name>MOD_CTL</name></decl>,    <comment type="block">/* Is a control bit */</comment>
       <decl><name>MOD_BSR</name></decl>,    <comment type="block">/* Is a BSR value */</comment>
       <decl><name>MOD_IN2</name></decl>,    <comment type="block">/* Is one or two unsigned integers */</comment>
       <decl><name>MOD_INS</name></decl>,    <comment type="block">/* Is a signed integer */</comment>
       <decl><name>MOD_INT</name></decl>,    <comment type="block">/* Is an unsigned integer */</comment>
       <decl><name>MOD_IND</name></decl>,    <comment type="block">/* Is an unsigned integer, but no value =&gt; default */</comment>
       <decl><name>MOD_NL</name></decl>,     <comment type="block">/* Is a newline value */</comment>
       <decl><name>MOD_NN</name></decl>,     <comment type="block">/* Is a number or a name; more than one may occur */</comment>
       <decl><name>MOD_OPT</name></decl>,    <comment type="block">/* Is an option bit */</comment>
       <decl><name>MOD_SIZ</name></decl>,    <comment type="block">/* Is a PCRE2_SIZE value */</comment>
       <decl><name>MOD_STR</name></decl> }</block>;</enum>  <comment type="block">/* Is a string */</comment>

<comment type="block">/* Control bits. Some apply to compiling, some to matching, but some can be set
either on a pattern or a data line, so they must all be distinct. There are now
so many of them that they are split into two fields. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_AFTERTEXT</name></cpp:macro>                    <cpp:value>0x00000001u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_ALLAFTERTEXT</name></cpp:macro>                 <cpp:value>0x00000002u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_ALLCAPTURES</name></cpp:macro>                  <cpp:value>0x00000004u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_ALLUSEDTEXT</name></cpp:macro>                  <cpp:value>0x00000008u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_ALTGLOBAL</name></cpp:macro>                    <cpp:value>0x00000010u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_BINCODE</name></cpp:macro>                      <cpp:value>0x00000020u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_CALLOUT_CAPTURE</name></cpp:macro>              <cpp:value>0x00000040u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_CALLOUT_INFO</name></cpp:macro>                 <cpp:value>0x00000080u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_CALLOUT_NONE</name></cpp:macro>                 <cpp:value>0x00000100u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_DFA</name></cpp:macro>                          <cpp:value>0x00000200u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_EXPAND</name></cpp:macro>                       <cpp:value>0x00000400u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_FINDLIMITS</name></cpp:macro>                   <cpp:value>0x00000800u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_FRAMESIZE</name></cpp:macro>                    <cpp:value>0x00001000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_FULLBINCODE</name></cpp:macro>                  <cpp:value>0x00002000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_GETALL</name></cpp:macro>                       <cpp:value>0x00004000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_GLOBAL</name></cpp:macro>                       <cpp:value>0x00008000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_HEXPAT</name></cpp:macro>                       <cpp:value>0x00010000u</cpp:value></cpp:define>  <comment type="block">/* Same word as USE_LENGTH */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_INFO</name></cpp:macro>                         <cpp:value>0x00020000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_JITFAST</name></cpp:macro>                      <cpp:value>0x00040000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_JITVERIFY</name></cpp:macro>                    <cpp:value>0x00080000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_MARK</name></cpp:macro>                         <cpp:value>0x00100000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_MEMORY</name></cpp:macro>                       <cpp:value>0x00200000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_NULLCONTEXT</name></cpp:macro>                  <cpp:value>0x00400000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_POSIX</name></cpp:macro>                        <cpp:value>0x00800000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_POSIX_NOSUB</name></cpp:macro>                  <cpp:value>0x01000000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_PUSH</name></cpp:macro>                         <cpp:value>0x02000000u</cpp:value></cpp:define>  <comment type="block">/* These three must be */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_PUSHCOPY</name></cpp:macro>                     <cpp:value>0x04000000u</cpp:value></cpp:define>  <comment type="block">/*   all in the same */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_PUSHTABLESCOPY</name></cpp:macro>               <cpp:value>0x08000000u</cpp:value></cpp:define>  <comment type="block">/*     word. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_STARTCHAR</name></cpp:macro>                    <cpp:value>0x10000000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_USE_LENGTH</name></cpp:macro>                   <cpp:value>0x20000000u</cpp:value></cpp:define>  <comment type="block">/* Same word as HEXPAT */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_UTF8_INPUT</name></cpp:macro>                   <cpp:value>0x40000000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_ZERO_TERMINATE</name></cpp:macro>               <cpp:value>0x80000000u</cpp:value></cpp:define>

<comment type="block">/* Combinations */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_DEBUG</name></cpp:macro>            <cpp:value>(CTL_FULLBINCODE|CTL_INFO)</cpp:value></cpp:define>  <comment type="block">/* For setting */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_ANYINFO</name></cpp:macro>          <cpp:value>(CTL_DEBUG|CTL_BINCODE|CTL_CALLOUT_INFO)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_ANYGLOB</name></cpp:macro>          <cpp:value>(CTL_ALTGLOBAL|CTL_GLOBAL)</cpp:value></cpp:define>

<comment type="block">/* Second control word */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL2_SUBSTITUTE_CALLOUT</name></cpp:macro>          <cpp:value>0x00000001u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL2_SUBSTITUTE_EXTENDED</name></cpp:macro>         <cpp:value>0x00000002u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL2_SUBSTITUTE_LITERAL</name></cpp:macro>          <cpp:value>0x00000004u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL2_SUBSTITUTE_MATCHED</name></cpp:macro>          <cpp:value>0x00000008u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL2_SUBSTITUTE_OVERFLOW_LENGTH</name></cpp:macro>  <cpp:value>0x00000010u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL2_SUBSTITUTE_REPLACEMENT_ONLY</name></cpp:macro> <cpp:value>0x00000020u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL2_SUBSTITUTE_UNKNOWN_UNSET</name></cpp:macro>    <cpp:value>0x00000040u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL2_SUBSTITUTE_UNSET_EMPTY</name></cpp:macro>      <cpp:value>0x00000080u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL2_SUBJECT_LITERAL</name></cpp:macro>             <cpp:value>0x00000100u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL2_CALLOUT_NO_WHERE</name></cpp:macro>            <cpp:value>0x00000200u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL2_CALLOUT_EXTRA</name></cpp:macro>               <cpp:value>0x00000400u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL2_ALLVECTOR</name></cpp:macro>                   <cpp:value>0x00000800u</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL2_NL_SET</name></cpp:macro>                      <cpp:value>0x40000000u</cpp:value></cpp:define>  <comment type="block">/* Informational */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL2_BSR_SET</name></cpp:macro>                     <cpp:value>0x80000000u</cpp:value></cpp:define>  <comment type="block">/* Informational */</comment>

<comment type="block">/* These are the matching controls that may be set either on a pattern or on a
data line. They are copied from the pattern controls as initial settings for
data line controls. Note that CTL_MEMORY is not included here, because it does
different things in the two cases. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL_ALLPD</name></cpp:macro>  <cpp:value>(CTL_AFTERTEXT|\
                    CTL_ALLAFTERTEXT|\
                    CTL_ALLCAPTURES|\
                    CTL_ALLUSEDTEXT|\
                    CTL_ALTGLOBAL|\
                    CTL_GLOBAL|\
                    CTL_MARK|\
                    CTL_STARTCHAR|\
                    CTL_UTF8_INPUT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTL2_ALLPD</name></cpp:macro> <cpp:value>(CTL2_SUBSTITUTE_CALLOUT|\
                    CTL2_SUBSTITUTE_EXTENDED|\
                    CTL2_SUBSTITUTE_LITERAL|\
                    CTL2_SUBSTITUTE_MATCHED|\
                    CTL2_SUBSTITUTE_OVERFLOW_LENGTH|\
                    CTL2_SUBSTITUTE_REPLACEMENT_ONLY|\
                    CTL2_SUBSTITUTE_UNKNOWN_UNSET|\
                    CTL2_SUBSTITUTE_UNSET_EMPTY|\
                    CTL2_ALLVECTOR)</cpp:value></cpp:define>

<comment type="block">/* Structures for holding modifier information for patterns and subject strings
(data). Fields containing modifiers that can be set either for a pattern or a
subject must be at the start and in the same order in both cases so that the
same offset in the big table below works for both. */</comment>

<typedef>typedef <type><struct>struct <name>patctl</name> <block>{       <comment type="block">/* Structure for pattern modifiers. */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>options</name></decl>;</decl_stmt>          <comment type="block">/* Must be in same position as datctl */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>control</name></decl>;</decl_stmt>          <comment type="block">/* Must be in same position as datctl */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>control2</name></decl>;</decl_stmt>         <comment type="block">/* Must be in same position as datctl */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>jitstack</name></decl>;</decl_stmt>         <comment type="block">/* Must be in same position as datctl */</comment>
   <decl_stmt><decl><type><name>uint8_t</name></type>  <name><name>replacement</name><index>[<expr><name>REPLACE_MODSIZE</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* So must this */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>substitute_skip</name></decl>;</decl_stmt>  <comment type="block">/* Must be in same position as patctl */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>substitute_stop</name></decl>;</decl_stmt>  <comment type="block">/* Must be in same position as patctl */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>jit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>stackguard_test</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>tables_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>convert_type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>convert_length</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>convert_glob_escape</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>convert_glob_separator</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>regerror_buffsize</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>uint8_t</name></type>  <name><name>locale</name><index>[<expr><name>LOCALESIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>patctl</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXCPYGET</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LENCPYGET</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>datctl</name> <block>{       <comment type="block">/* Structure for data line modifiers. */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>options</name></decl>;</decl_stmt>          <comment type="block">/* Must be in same position as patctl */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>control</name></decl>;</decl_stmt>          <comment type="block">/* Must be in same position as patctl */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>control2</name></decl>;</decl_stmt>         <comment type="block">/* Must be in same position as patctl */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>jitstack</name></decl>;</decl_stmt>         <comment type="block">/* Must be in same position as patctl */</comment>
   <decl_stmt><decl><type><name>uint8_t</name></type>  <name><name>replacement</name><index>[<expr><name>REPLACE_MODSIZE</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* So must this */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>substitute_skip</name></decl>;</decl_stmt>  <comment type="block">/* Must be in same position as patctl */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>substitute_stop</name></decl>;</decl_stmt>  <comment type="block">/* Must be in same position as patctl */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name><name>startend</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name><name>cerror</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name><name>cfail</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>int32_t</name></type>  <name>callout_data</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>int32_t</name></type>  <name><name>copy_numbers</name><index>[<expr><name>MAXCPYGET</name></expr>]</index></name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>int32_t</name></type>  <name><name>get_numbers</name><index>[<expr><name>MAXCPYGET</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>oveccount</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>offset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type>   <name><name>copy_names</name><index>[<expr><name>LENCPYGET</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type>   <name><name>get_names</name><index>[<expr><name>LENCPYGET</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>datctl</name>;</typedef>

<comment type="block">/* Ids for which context to modify. */</comment>

<enum>enum <block>{ <decl><name>CTX_PAT</name></decl>,            <comment type="block">/* Active pattern context */</comment>
       <decl><name>CTX_POPPAT</name></decl>,         <comment type="block">/* Ditto, for a popped pattern */</comment>
       <decl><name>CTX_DEFPAT</name></decl>,         <comment type="block">/* Default pattern context */</comment>
       <decl><name>CTX_DAT</name></decl>,            <comment type="block">/* Active data (match) context */</comment>
       <decl><name>CTX_DEFDAT</name></decl> }</block>;</enum>       <comment type="block">/* Default data (match) context */</comment>

<comment type="block">/* Macros to simplify the big table below. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CO</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offsetof(PCRE2_REAL_COMPILE_CONTEXT, name)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MO</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offsetof(PCRE2_REAL_MATCH_CONTEXT, name)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PO</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offsetof(patctl, name)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PD</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>PO(name)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>offsetof(datctl, name)</cpp:value></cpp:define>

<comment type="block">/* Table of all long-form modifiers. Must be in collating sequence of modifier
name because it is searched by binary chop. */</comment>

<typedef>typedef <type><struct>struct <name>modstruct</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type>      <name>which</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type>      <name>type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type>      <name>value</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type>    <name>offset</name></decl>;</decl_stmt>
}</block></struct></type> <name>modstruct</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>modstruct</name></type> <name><name>modlist</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{ <expr><literal type="string">"aftertext"</literal></expr>,                   <expr><name>MOD_PNDP</name></expr>, <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_AFTERTEXT</name></expr>,              <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"allaftertext"</literal></expr>,                <expr><name>MOD_PNDP</name></expr>, <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_ALLAFTERTEXT</name></expr>,           <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"allcaptures"</literal></expr>,                 <expr><name>MOD_PND</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_ALLCAPTURES</name></expr>,            <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"allow_empty_class"</literal></expr>,           <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_ALLOW_EMPTY_CLASS</name></expr>,    <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"allow_surrogate_escapes"</literal></expr>,     <expr><name>MOD_CTC</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES</name></expr>, <macro><name>CO</name><argument_list>(<argument>extra_options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"allusedtext"</literal></expr>,                 <expr><name>MOD_PNDP</name></expr>, <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_ALLUSEDTEXT</name></expr>,            <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"allvector"</literal></expr>,                   <expr><name>MOD_PND</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL2_ALLVECTOR</name></expr>,             <macro><name>PO</name><argument_list>(<argument>control2</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"alt_bsux"</literal></expr>,                    <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_ALT_BSUX</name></expr>,             <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"alt_circumflex"</literal></expr>,              <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_ALT_CIRCUMFLEX</name></expr>,       <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"alt_verbnames"</literal></expr>,               <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_ALT_VERBNAMES</name></expr>,        <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"altglobal"</literal></expr>,                   <expr><name>MOD_PND</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_ALTGLOBAL</name></expr>,              <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"anchored"</literal></expr>,                    <expr><name>MOD_PD</name></expr>,   <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_ANCHORED</name></expr>,             <macro><name>PD</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"auto_callout"</literal></expr>,                <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_AUTO_CALLOUT</name></expr>,         <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"bad_escape_is_literal"</literal></expr>,       <expr><name>MOD_CTC</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL</name></expr>, <macro><name>CO</name><argument_list>(<argument>extra_options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"bincode"</literal></expr>,                     <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_BINCODE</name></expr>,                <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"bsr"</literal></expr>,                         <expr><name>MOD_CTC</name></expr>,  <expr><name>MOD_BSR</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>CO</name><argument_list>(<argument>bsr_convention</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"callout_capture"</literal></expr>,             <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_CALLOUT_CAPTURE</name></expr>,        <macro><name>DO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"callout_data"</literal></expr>,                <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_INS</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>DO</name><argument_list>(<argument>callout_data</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"callout_error"</literal></expr>,               <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_IN2</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>DO</name><argument_list>(<argument>cerror</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"callout_extra"</literal></expr>,               <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL2_CALLOUT_EXTRA</name></expr>,         <macro><name>DO</name><argument_list>(<argument>control2</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"callout_fail"</literal></expr>,                <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_IN2</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>DO</name><argument_list>(<argument>cfail</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"callout_info"</literal></expr>,                <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_CALLOUT_INFO</name></expr>,           <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"callout_no_where"</literal></expr>,            <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL2_CALLOUT_NO_WHERE</name></expr>,      <macro><name>DO</name><argument_list>(<argument>control2</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"callout_none"</literal></expr>,                <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_CALLOUT_NONE</name></expr>,           <macro><name>DO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"caseless"</literal></expr>,                    <expr><name>MOD_PATP</name></expr>, <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_CASELESS</name></expr>,             <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"convert"</literal></expr>,                     <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_CON</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>PO</name><argument_list>(<argument>convert_type</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"convert_glob_escape"</literal></expr>,         <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_CHR</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>PO</name><argument_list>(<argument>convert_glob_escape</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"convert_glob_separator"</literal></expr>,      <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_CHR</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>PO</name><argument_list>(<argument>convert_glob_separator</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"convert_length"</literal></expr>,              <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_INT</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>PO</name><argument_list>(<argument>convert_length</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"copy"</literal></expr>,                        <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_NN</name></expr>,  <expr><call><name>DO</name><argument_list>(<argument><expr><name>copy_numbers</name></expr></argument>)</argument_list></call></expr>,           <macro><name>DO</name><argument_list>(<argument>copy_names</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"copy_matched_subject"</literal></expr>,        <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_COPY_MATCHED_SUBJECT</name></expr>, <macro><name>DO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"debug"</literal></expr>,                       <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_DEBUG</name></expr>,                  <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"depth_limit"</literal></expr>,                 <expr><name>MOD_CTM</name></expr>,  <expr><name>MOD_INT</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>MO</name><argument_list>(<argument>depth_limit</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"dfa"</literal></expr>,                         <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_DFA</name></expr>,                    <macro><name>DO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"dfa_restart"</literal></expr>,                 <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_DFA_RESTART</name></expr>,          <macro><name>DO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"dfa_shortest"</literal></expr>,                <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_DFA_SHORTEST</name></expr>,         <macro><name>DO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"dollar_endonly"</literal></expr>,              <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_DOLLAR_ENDONLY</name></expr>,       <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"dotall"</literal></expr>,                      <expr><name>MOD_PATP</name></expr>, <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_DOTALL</name></expr>,               <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"dupnames"</literal></expr>,                    <expr><name>MOD_PATP</name></expr>, <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_DUPNAMES</name></expr>,             <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"endanchored"</literal></expr>,                 <expr><name>MOD_PD</name></expr>,   <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_ENDANCHORED</name></expr>,          <macro><name>PD</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"escaped_cr_is_lf"</literal></expr>,            <expr><name>MOD_CTC</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_EXTRA_ESCAPED_CR_IS_LF</name></expr>, <macro><name>CO</name><argument_list>(<argument>extra_options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"expand"</literal></expr>,                      <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_EXPAND</name></expr>,                 <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"extended"</literal></expr>,                    <expr><name>MOD_PATP</name></expr>, <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_EXTENDED</name></expr>,             <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"extended_more"</literal></expr>,               <expr><name>MOD_PATP</name></expr>, <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_EXTENDED_MORE</name></expr>,        <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"extra_alt_bsux"</literal></expr>,              <expr><name>MOD_CTC</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_EXTRA_ALT_BSUX</name></expr>,       <macro><name>CO</name><argument_list>(<argument>extra_options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"find_limits"</literal></expr>,                 <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_FINDLIMITS</name></expr>,             <macro><name>DO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"firstline"</literal></expr>,                   <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_FIRSTLINE</name></expr>,            <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"framesize"</literal></expr>,                   <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_FRAMESIZE</name></expr>,              <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"fullbincode"</literal></expr>,                 <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_FULLBINCODE</name></expr>,            <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"get"</literal></expr>,                         <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_NN</name></expr>,  <expr><call><name>DO</name><argument_list>(<argument><expr><name>get_numbers</name></expr></argument>)</argument_list></call></expr>,            <macro><name>DO</name><argument_list>(<argument>get_names</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"getall"</literal></expr>,                      <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_GETALL</name></expr>,                 <macro><name>DO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"global"</literal></expr>,                      <expr><name>MOD_PNDP</name></expr>, <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_GLOBAL</name></expr>,                 <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"heap_limit"</literal></expr>,                  <expr><name>MOD_CTM</name></expr>,  <expr><name>MOD_INT</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>MO</name><argument_list>(<argument>heap_limit</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"hex"</literal></expr>,                         <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_HEXPAT</name></expr>,                 <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"info"</literal></expr>,                        <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_INFO</name></expr>,                   <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"jit"</literal></expr>,                         <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_IND</name></expr>, <expr><literal type="number">7</literal></expr>,                          <macro><name>PO</name><argument_list>(<argument>jit</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"jitfast"</literal></expr>,                     <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_JITFAST</name></expr>,                <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"jitstack"</literal></expr>,                    <expr><name>MOD_PNDP</name></expr>, <expr><name>MOD_INT</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>PO</name><argument_list>(<argument>jitstack</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"jitverify"</literal></expr>,                   <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_JITVERIFY</name></expr>,              <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"literal"</literal></expr>,                     <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_LITERAL</name></expr>,              <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"locale"</literal></expr>,                      <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_STR</name></expr>, <expr><name>LOCALESIZE</name></expr>,                 <macro><name>PO</name><argument_list>(<argument>locale</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"mark"</literal></expr>,                        <expr><name>MOD_PNDP</name></expr>, <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_MARK</name></expr>,                   <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"match_invalid_utf"</literal></expr>,           <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_MATCH_INVALID_UTF</name></expr>,    <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"match_limit"</literal></expr>,                 <expr><name>MOD_CTM</name></expr>,  <expr><name>MOD_INT</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>MO</name><argument_list>(<argument>match_limit</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"match_line"</literal></expr>,                  <expr><name>MOD_CTC</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_EXTRA_MATCH_LINE</name></expr>,     <macro><name>CO</name><argument_list>(<argument>extra_options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"match_unset_backref"</literal></expr>,         <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_MATCH_UNSET_BACKREF</name></expr>,  <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"match_word"</literal></expr>,                  <expr><name>MOD_CTC</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_EXTRA_MATCH_WORD</name></expr>,     <macro><name>CO</name><argument_list>(<argument>extra_options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"max_pattern_length"</literal></expr>,          <expr><name>MOD_CTC</name></expr>,  <expr><name>MOD_SIZ</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>CO</name><argument_list>(<argument>max_pattern_length</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"memory"</literal></expr>,                      <expr><name>MOD_PD</name></expr>,   <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_MEMORY</name></expr>,                 <macro><name>PD</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"multiline"</literal></expr>,                   <expr><name>MOD_PATP</name></expr>, <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_MULTILINE</name></expr>,            <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"never_backslash_c"</literal></expr>,           <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_NEVER_BACKSLASH_C</name></expr>,    <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"never_ucp"</literal></expr>,                   <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_NEVER_UCP</name></expr>,            <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"never_utf"</literal></expr>,                   <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_NEVER_UTF</name></expr>,            <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"newline"</literal></expr>,                     <expr><name>MOD_CTC</name></expr>,  <expr><name>MOD_NL</name></expr>,  <expr><literal type="number">0</literal></expr>,                          <macro><name>CO</name><argument_list>(<argument>newline_convention</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"no_auto_capture"</literal></expr>,             <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_NO_AUTO_CAPTURE</name></expr>,      <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"no_auto_possess"</literal></expr>,             <expr><name>MOD_PATP</name></expr>, <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_NO_AUTO_POSSESS</name></expr>,      <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"no_dotstar_anchor"</literal></expr>,           <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_NO_DOTSTAR_ANCHOR</name></expr>,    <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"no_jit"</literal></expr>,                      <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_NO_JIT</name></expr>,               <macro><name>DO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"no_start_optimize"</literal></expr>,           <expr><name>MOD_PATP</name></expr>, <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_NO_START_OPTIMIZE</name></expr>,    <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"no_utf_check"</literal></expr>,                <expr><name>MOD_PD</name></expr>,   <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_NO_UTF_CHECK</name></expr>,         <macro><name>PD</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"notbol"</literal></expr>,                      <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_NOTBOL</name></expr>,               <macro><name>DO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"notempty"</literal></expr>,                    <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_NOTEMPTY</name></expr>,             <macro><name>DO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"notempty_atstart"</literal></expr>,            <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_NOTEMPTY_ATSTART</name></expr>,     <macro><name>DO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"noteol"</literal></expr>,                      <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_NOTEOL</name></expr>,               <macro><name>DO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"null_context"</literal></expr>,                <expr><name>MOD_PD</name></expr>,   <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_NULLCONTEXT</name></expr>,            <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"offset"</literal></expr>,                      <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_INT</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>DO</name><argument_list>(<argument>offset</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"offset_limit"</literal></expr>,                <expr><name>MOD_CTM</name></expr>,  <expr><name>MOD_SIZ</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>MO</name><argument_list>(<argument>offset_limit</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{ <expr><literal type="string">"ovector"</literal></expr>,                     <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_INT</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>DO</name><argument_list>(<argument>oveccount</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"parens_nest_limit"</literal></expr>,           <expr><name>MOD_CTC</name></expr>,  <expr><name>MOD_INT</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>CO</name><argument_list>(<argument>parens_nest_limit</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"partial_hard"</literal></expr>,                <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_PARTIAL_HARD</name></expr>,         <macro><name>DO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"partial_soft"</literal></expr>,                <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_PARTIAL_SOFT</name></expr>,         <macro><name>DO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"ph"</literal></expr>,                          <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_PARTIAL_HARD</name></expr>,         <macro><name>DO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"posix"</literal></expr>,                       <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_POSIX</name></expr>,                  <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"posix_nosub"</literal></expr>,                 <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_POSIX</name><operator>|</operator><name>CTL_POSIX_NOSUB</name></expr>,  <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"posix_startend"</literal></expr>,              <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_IN2</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>DO</name><argument_list>(<argument>startend</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"ps"</literal></expr>,                          <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_PARTIAL_SOFT</name></expr>,         <macro><name>DO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"push"</literal></expr>,                        <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_PUSH</name></expr>,                   <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"pushcopy"</literal></expr>,                    <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_PUSHCOPY</name></expr>,               <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"pushtablescopy"</literal></expr>,              <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_PUSHTABLESCOPY</name></expr>,         <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"recursion_limit"</literal></expr>,             <expr><name>MOD_CTM</name></expr>,  <expr><name>MOD_INT</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>MO</name><argument_list>(<argument>depth_limit</argument>)</argument_list></macro> }</block></expr>,  <comment type="block">/* Obsolete synonym */</comment>
  <expr><block>{ <expr><literal type="string">"regerror_buffsize"</literal></expr>,           <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_INT</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>PO</name><argument_list>(<argument>regerror_buffsize</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"replace"</literal></expr>,                     <expr><name>MOD_PND</name></expr>,  <expr><name>MOD_STR</name></expr>, <expr><name>REPLACE_MODSIZE</name></expr>,            <macro><name>PO</name><argument_list>(<argument>replacement</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"stackguard"</literal></expr>,                  <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_INT</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>PO</name><argument_list>(<argument>stackguard_test</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"startchar"</literal></expr>,                   <expr><name>MOD_PND</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_STARTCHAR</name></expr>,              <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"startoffset"</literal></expr>,                 <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_INT</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>DO</name><argument_list>(<argument>offset</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"subject_literal"</literal></expr>,             <expr><name>MOD_PATP</name></expr>, <expr><name>MOD_CTL</name></expr>, <expr><name>CTL2_SUBJECT_LITERAL</name></expr>,       <macro><name>PO</name><argument_list>(<argument>control2</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"substitute_callout"</literal></expr>,          <expr><name>MOD_PND</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL2_SUBSTITUTE_CALLOUT</name></expr>,    <macro><name>PO</name><argument_list>(<argument>control2</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"substitute_extended"</literal></expr>,         <expr><name>MOD_PND</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL2_SUBSTITUTE_EXTENDED</name></expr>,   <macro><name>PO</name><argument_list>(<argument>control2</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"substitute_literal"</literal></expr>,          <expr><name>MOD_PND</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL2_SUBSTITUTE_LITERAL</name></expr>,    <macro><name>PO</name><argument_list>(<argument>control2</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"substitute_matched"</literal></expr>,          <expr><name>MOD_PND</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL2_SUBSTITUTE_MATCHED</name></expr>,    <macro><name>PO</name><argument_list>(<argument>control2</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"substitute_overflow_length"</literal></expr>,  <expr><name>MOD_PND</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL2_SUBSTITUTE_OVERFLOW_LENGTH</name></expr>, <macro><name>PO</name><argument_list>(<argument>control2</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"substitute_replacement_only"</literal></expr>, <expr><name>MOD_PND</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL2_SUBSTITUTE_REPLACEMENT_ONLY</name></expr>, <macro><name>PO</name><argument_list>(<argument>control2</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"substitute_skip"</literal></expr>,             <expr><name>MOD_PND</name></expr>,  <expr><name>MOD_INT</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>PO</name><argument_list>(<argument>substitute_skip</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"substitute_stop"</literal></expr>,             <expr><name>MOD_PND</name></expr>,  <expr><name>MOD_INT</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>PO</name><argument_list>(<argument>substitute_stop</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"substitute_unknown_unset"</literal></expr>,    <expr><name>MOD_PND</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL2_SUBSTITUTE_UNKNOWN_UNSET</name></expr>, <macro><name>PO</name><argument_list>(<argument>control2</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"substitute_unset_empty"</literal></expr>,      <expr><name>MOD_PND</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL2_SUBSTITUTE_UNSET_EMPTY</name></expr>, <macro><name>PO</name><argument_list>(<argument>control2</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"tables"</literal></expr>,                      <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_INT</name></expr>, <expr><literal type="number">0</literal></expr>,                          <macro><name>PO</name><argument_list>(<argument>tables_id</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"ucp"</literal></expr>,                         <expr><name>MOD_PATP</name></expr>, <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_UCP</name></expr>,                  <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"ungreedy"</literal></expr>,                    <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_UNGREEDY</name></expr>,             <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"use_length"</literal></expr>,                  <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_USE_LENGTH</name></expr>,             <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"use_offset_limit"</literal></expr>,            <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_USE_OFFSET_LIMIT</name></expr>,     <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"utf"</literal></expr>,                         <expr><name>MOD_PATP</name></expr>, <expr><name>MOD_OPT</name></expr>, <expr><name>PCRE2_UTF</name></expr>,                  <macro><name>PO</name><argument_list>(<argument>options</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"utf8_input"</literal></expr>,                  <expr><name>MOD_PAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_UTF8_INPUT</name></expr>,             <macro><name>PO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"zero_terminate"</literal></expr>,              <expr><name>MOD_DAT</name></expr>,  <expr><name>MOD_CTL</name></expr>, <expr><name>CTL_ZERO_TERMINATE</name></expr>,         <macro><name>DO</name><argument_list>(<argument>control</argument>)</argument_list></macro> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODLISTCOUNT</name></cpp:macro> <cpp:value>sizeof(modlist)/sizeof(modstruct)</cpp:value></cpp:define>

<comment type="block">/* Controls and options that are supported for use with the POSIX interface. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POSIX_SUPPORTED_COMPILE_OPTIONS</name></cpp:macro> <cpp:value>( \
  PCRE2_CASELESS|PCRE2_DOTALL|PCRE2_LITERAL|PCRE2_MULTILINE|PCRE2_UCP| \
  PCRE2_UTF|PCRE2_UNGREEDY)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POSIX_SUPPORTED_COMPILE_EXTRA_OPTIONS</name></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POSIX_SUPPORTED_COMPILE_CONTROLS</name></cpp:macro> <cpp:value>( \
  CTL_AFTERTEXT|CTL_ALLAFTERTEXT|CTL_EXPAND|CTL_HEXPAT|CTL_POSIX| \
  CTL_POSIX_NOSUB|CTL_USE_LENGTH)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POSIX_SUPPORTED_COMPILE_CONTROLS2</name></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POSIX_SUPPORTED_MATCH_OPTIONS</name></cpp:macro> <cpp:value>( \
  PCRE2_NOTBOL|PCRE2_NOTEMPTY|PCRE2_NOTEOL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POSIX_SUPPORTED_MATCH_CONTROLS</name></cpp:macro>  <cpp:value>(CTL_AFTERTEXT|CTL_ALLAFTERTEXT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POSIX_SUPPORTED_MATCH_CONTROLS2</name></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>

<comment type="block">/* Control bits that are not ignored with 'push'. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUSH_SUPPORTED_COMPILE_CONTROLS</name></cpp:macro> <cpp:value>( \
  CTL_BINCODE|CTL_CALLOUT_INFO|CTL_FULLBINCODE|CTL_HEXPAT|CTL_INFO| \
  CTL_JITVERIFY|CTL_MEMORY|CTL_FRAMESIZE|CTL_PUSH|CTL_PUSHCOPY| \
  CTL_PUSHTABLESCOPY|CTL_USE_LENGTH)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUSH_SUPPORTED_COMPILE_CONTROLS2</name></cpp:macro> <cpp:value>(CTL2_BSR_SET|CTL2_NL_SET)</cpp:value></cpp:define>

<comment type="block">/* Controls that apply only at compile time with 'push'. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUSH_COMPILE_ONLY_CONTROLS</name></cpp:macro>   <cpp:value>CTL_JITVERIFY</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUSH_COMPILE_ONLY_CONTROLS2</name></cpp:macro>  <cpp:value>(0)</cpp:value></cpp:define>

<comment type="block">/* Controls that are forbidden with #pop or #popcopy. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOTPOP_CONTROLS</name></cpp:macro> <cpp:value>(CTL_HEXPAT|CTL_POSIX|CTL_POSIX_NOSUB|CTL_PUSH| \
  CTL_PUSHCOPY|CTL_PUSHTABLESCOPY|CTL_USE_LENGTH)</cpp:value></cpp:define>

<comment type="block">/* Pattern controls that are mutually exclusive. At present these are all in
the first control word. Note that CTL_POSIX_NOSUB is always accompanied by
CTL_POSIX, so it doesn't need its own entries. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name><name>exclusive_pat_controls</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>CTL_POSIX</name>    <operator>|</operator> <name>CTL_PUSH</name></expr>,
  <expr><name>CTL_POSIX</name>    <operator>|</operator> <name>CTL_PUSHCOPY</name></expr>,
  <expr><name>CTL_POSIX</name>    <operator>|</operator> <name>CTL_PUSHTABLESCOPY</name></expr>,
  <expr><name>CTL_PUSH</name>     <operator>|</operator> <name>CTL_PUSHCOPY</name></expr>,
  <expr><name>CTL_PUSH</name>     <operator>|</operator> <name>CTL_PUSHTABLESCOPY</name></expr>,
  <expr><name>CTL_PUSHCOPY</name> <operator>|</operator> <name>CTL_PUSHTABLESCOPY</name></expr>,
  <expr><name>CTL_EXPAND</name>   <operator>|</operator> <name>CTL_HEXPAT</name></expr> }</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Data controls that are mutually exclusive. At present these are all in the
first control word. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name><name>exclusive_dat_controls</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>CTL_ALLUSEDTEXT</name> <operator>|</operator> <name>CTL_STARTCHAR</name></expr>,
  <expr><name>CTL_FINDLIMITS</name>  <operator>|</operator> <name>CTL_NULLCONTEXT</name></expr> }</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Table of single-character abbreviated modifiers. The index field is
initialized to -1, but the first time the modifier is encountered, it is filled
in with the index of the full entry in modlist, to save repeated searching when
processing multiple test items. This short list is searched serially, so its
order does not matter. */</comment>

<typedef>typedef <type><struct>struct <name>c1modstruct</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fullname</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type>    <name>onechar</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type>         <name>index</name></decl>;</decl_stmt>
}</block></struct></type> <name>c1modstruct</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>c1modstruct</name></type> <name><name>c1modlist</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{ <expr><literal type="string">"bincode"</literal></expr>,         <expr><literal type="char">'B'</literal></expr>,           <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"info"</literal></expr>,            <expr><literal type="char">'I'</literal></expr>,           <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"global"</literal></expr>,          <expr><literal type="char">'g'</literal></expr>,           <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"caseless"</literal></expr>,        <expr><literal type="char">'i'</literal></expr>,           <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"multiline"</literal></expr>,       <expr><literal type="char">'m'</literal></expr>,           <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"no_auto_capture"</literal></expr>, <expr><literal type="char">'n'</literal></expr>,           <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"dotall"</literal></expr>,          <expr><literal type="char">'s'</literal></expr>,           <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"extended"</literal></expr>,        <expr><literal type="char">'x'</literal></expr>,           <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>C1MODLISTCOUNT</name></cpp:macro> <cpp:value>sizeof(c1modlist)/sizeof(c1modstruct)</cpp:value></cpp:define>

<comment type="block">/* Table of arguments for the -C command line option. Use macros to make the
table itself easier to read. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_PCRE2_8</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUPPORT_8</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_PCRE2_16</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUPPORT_16</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_PCRE2_32</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUPPORT_32</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SUPPORT_8</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUPPORT_8</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SUPPORT_16</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUPPORT_16</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SUPPORT_32</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUPPORT_32</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EBCDIC</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUPPORT_EBCDIC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EBCDIC_NL</name></cpp:macro> <cpp:value>CHAR_LF</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUPPORT_EBCDIC</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EBCDIC_NL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NEVER_BACKSLASH_C</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKSLASH_C</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKSLASH_C</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct <name>coptstruct</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type>    <name>type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type>    <name>value</name></decl>;</decl_stmt>
}</block></struct></type> <name>coptstruct</name>;</typedef>

<enum>enum <block>{ <decl><name>CONF_BSR</name></decl>,
       <decl><name>CONF_FIX</name></decl>,
       <decl><name>CONF_FIZ</name></decl>,
       <decl><name>CONF_INT</name></decl>,
       <decl><name>CONF_NL</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <name>coptstruct</name></type> <name><name>coptlist</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{ <expr><literal type="string">"backslash-C"</literal></expr>, <expr><name>CONF_FIX</name></expr>, <expr><name>BACKSLASH_C</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"bsr"</literal></expr>,         <expr><name>CONF_BSR</name></expr>, <expr><name>PCRE2_CONFIG_BSR</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"ebcdic"</literal></expr>,      <expr><name>CONF_FIX</name></expr>, <expr><name>SUPPORT_EBCDIC</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"ebcdic-nl"</literal></expr>,   <expr><name>CONF_FIZ</name></expr>, <expr><name>EBCDIC_NL</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"jit"</literal></expr>,         <expr><name>CONF_INT</name></expr>, <expr><name>PCRE2_CONFIG_JIT</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"linksize"</literal></expr>,    <expr><name>CONF_INT</name></expr>, <expr><name>PCRE2_CONFIG_LINKSIZE</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"newline"</literal></expr>,     <expr><name>CONF_NL</name></expr>,  <expr><name>PCRE2_CONFIG_NEWLINE</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"pcre2-16"</literal></expr>,    <expr><name>CONF_FIX</name></expr>, <expr><name>SUPPORT_16</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"pcre2-32"</literal></expr>,    <expr><name>CONF_FIX</name></expr>, <expr><name>SUPPORT_32</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"pcre2-8"</literal></expr>,     <expr><name>CONF_FIX</name></expr>, <expr><name>SUPPORT_8</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"unicode"</literal></expr>,     <expr><name>CONF_INT</name></expr>, <expr><name>PCRE2_CONFIG_UNICODE</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPTLISTCOUNT</name></cpp:macro> <cpp:value>sizeof(coptlist)/sizeof(coptstruct)</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SUPPORT_8</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SUPPORT_16</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SUPPORT_32</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SUPPORT_EBCDIC</name></cpp:undef>


<comment type="block">/* ----------------------- Static variables ------------------------ */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>infile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>outfile</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>last_callout_mark</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PCRE2_JIT_STACK</name> <modifier>*</modifier></type><name>jit_stack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>jit_stack_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>first_callout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>jit_was_used</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>restrict_for_perl_test</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>show_memory</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>code_unit_size</name></decl>;</decl_stmt>                    <comment type="block">/* Bytes */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>jitrc</name></decl>;</decl_stmt>                             <comment type="block">/* Return from JIT compile */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>test_mode</name> <init>= <expr><name>DEFAULT_TEST_MODE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>timeit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>timeitm</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>clock_t</name></type> <name>total_compile_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>clock_t</name></type> <name>total_jit_compile_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>clock_t</name></type> <name>total_match_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>dfa_matched</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>forbid_utf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>maxlookbehind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>max_oveccount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>callout_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>maxcapcount</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>uint16_t</name></type> <name>local_newline_default</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VERSION_TYPE</name></type> <name><name>jittarget</name><index>[<expr><name>VERSION_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>VERSION_TYPE</name></type> <name><name>version</name><index>[<expr><name>VERSION_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>VERSION_TYPE</name></type> <name><name>uversion</name><index>[<expr><name>VERSION_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>patctl</name></type> <name>def_patctl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>patctl</name></type> <name>pat_patctl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>datctl</name></type> <name>def_datctl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>datctl</name></type> <name>dat_datctl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name><name>patstack</name><index>[<expr><name>PATSTACKSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>patstacknext</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name><name>malloclist</name><index>[<expr><name>MALLOCLISTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PCRE2_SIZE</name></type> <name><name>malloclistlength</name><index>[<expr><name>MALLOCLISTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>malloclistptr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>regex_t</name></type> <name>preg</name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name> <modifier>*</modifier></type><name>dfa_workspace</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>locale_tables</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>use_tables</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint8_t</name></type> <name><name>locale_name</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>tables3</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>         <comment type="block">/* For binary-loaded tables */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>loadtables_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* We need buffers for building 16/32-bit strings; 8-bit strings don't need
rebuilding, but set up the same naming scheme for use in macros. The "buffer"
buffer is where all input lines are read. Its size is the same as pbuffer8.
Pattern lines are always copied to pbuffer8 for use in callouts, even if they
are actually compiled from pbuffer16 or pbuffer32. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type>    <name>pbuffer8_size</name>  <init>= <expr><literal type="number">50000</literal></expr></init></decl>;</decl_stmt>        <comment type="block">/* Initial size, bytes */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint8_t</name>  <modifier>*</modifier></type><name>pbuffer8</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint8_t</name>  <modifier>*</modifier></type><name>buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* The dbuffer is where all processed data lines are put. In non-8-bit modes it
is cast as needed. For long data lines it grows as necessary. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>dbuffer_size</name> <init>= <expr><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">14</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Initial size, bytes */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>dbuffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* ---------------- Mode-dependent variables -------------------*/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_code_8</name>             <modifier>*</modifier></type><name>compiled_code8</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_general_context_8</name>  <modifier>*</modifier></type><name>general_context8</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>general_context_copy8</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_compile_context_8</name>  <modifier>*</modifier></type><name>pat_context8</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>default_pat_context8</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_convert_context_8</name>  <modifier>*</modifier></type><name>con_context8</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>default_con_context8</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_match_context_8</name>    <modifier>*</modifier></type><name>dat_context8</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>default_dat_context8</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_match_data_8</name>       <modifier>*</modifier></type><name>match_data8</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_code_16</name>            <modifier>*</modifier></type><name>compiled_code16</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_general_context_16</name> <modifier>*</modifier></type><name>general_context16</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>general_context_copy16</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_compile_context_16</name> <modifier>*</modifier></type><name>pat_context16</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>default_pat_context16</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_convert_context_16</name> <modifier>*</modifier></type><name>con_context16</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>default_con_context16</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_match_context_16</name>   <modifier>*</modifier></type><name>dat_context16</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>default_dat_context16</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_match_data_16</name>      <modifier>*</modifier></type><name>match_data16</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PCRE2_SIZE</name></type> <name>pbuffer16_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Set only when needed */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>pbuffer16</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_code_32</name>            <modifier>*</modifier></type><name>compiled_code32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_general_context_32</name> <modifier>*</modifier></type><name>general_context32</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>general_context_copy32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_compile_context_32</name> <modifier>*</modifier></type><name>pat_context32</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>default_pat_context32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_convert_context_32</name> <modifier>*</modifier></type><name>con_context32</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>default_con_context32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_match_context_32</name>   <modifier>*</modifier></type><name>dat_context32</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>default_dat_context32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_match_data_32</name>      <modifier>*</modifier></type><name>match_data32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PCRE2_SIZE</name></type> <name>pbuffer32_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Set only when needed */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>pbuffer32</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* ---------------- Macros that work in all modes ----------------- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CAST8VAR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CASTVAR(uint8_t *, x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SETOP(x,y,=)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETPLUS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SETOP(x,y,+=)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strlen8</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>strlen((char *)x)</cpp:value></cpp:define>


<comment type="block">/* ---------------- Mode-dependent, runtime-testing macros ------------------*/</comment>

<comment type="block">/* Define macros for variables and functions that must be selected dynamically
depending on the mode setting (8, 16, 32). These are dependent on which modes
are supported. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name> <argument_list>(<argument><expr><name>SUPPORT_PCRE2_8</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>SUPPORT_PCRE2_16</name></expr></argument>)</argument_list></call> <operator>+</operator> \
     <call><name>defined</name> <argument_list>(<argument><expr><name>SUPPORT_PCRE2_32</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>

<comment type="block">/* ----- All three modes supported ----- */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_PCRE2_8</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_PCRE2_16</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_PCRE2_32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASTFLD</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((test_mode == PCRE8_MODE)? (t)(G(a,8)-&gt;b) : \
  (test_mode == PCRE16_MODE)? (t)(G(a,16)-&gt;b) : (t)(G(a,32)-&gt;b))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASTVAR</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( \
  (test_mode == PCRE8_MODE)? (t)G(x,8) : \
  (test_mode == PCRE16_MODE)? (t)G(x,16) : (t)G(x,32))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CODE_UNIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( \
  (test_mode == PCRE8_MODE)? (uint32_t)(((PCRE2_SPTR8)(a))[b]) : \
  (test_mode == PCRE16_MODE)? (uint32_t)(((PCRE2_SPTR16)(a))[b]) : \
  (uint32_t)(((PCRE2_SPTR32)(a))[b]))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONCTXCPY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    memcpy(G(a,8),G(b,8),sizeof(pcre2_convert_context_8)); \
  else if (test_mode == PCRE16_MODE) \
    memcpy(G(a,16),G(b,16),sizeof(pcre2_convert_context_16)); \
  else memcpy(G(a,32),G(b,32),sizeof(pcre2_convert_context_32))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONVERT_COPY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    memcpy(G(a,8),(char *)b,c); \
  else if (test_mode == PCRE16_MODE) \
    memcpy(G(a,16),(char *)b,(c)*2); \
  else if (test_mode == PCRE32_MODE) \
    memcpy(G(a,32),(char *)b,(c)*4)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATCTXCPY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    memcpy(G(a,8),G(b,8),sizeof(pcre2_match_context_8)); \
  else if (test_mode == PCRE16_MODE) \
    memcpy(G(a,16),G(b,16),sizeof(pcre2_match_context_16)); \
  else memcpy(G(a,32),G(b,32),sizeof(pcre2_match_context_32))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLD</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((test_mode == PCRE8_MODE)? G(a,8)-&gt;b : \
  (test_mode == PCRE16_MODE)? G(a,16)-&gt;b : G(a,32)-&gt;b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATCTXCPY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    memcpy(G(a,8),G(b,8),sizeof(pcre2_compile_context_8)); \
  else if (test_mode == PCRE16_MODE) \
    memcpy(G(a,16),G(b,16),sizeof(pcre2_compile_context_16)); \
  else memcpy(G(a,32),G(b,32),sizeof(pcre2_compile_context_32))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCHARS</name><parameter_list>(<parameter><type><name>lv</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>utf</name></type></parameter>, <parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE32_MODE) \
    lv = pchars32((PCRE2_SPTR32)(p)+offset, len, utf, f); \
  else if (test_mode == PCRE16_MODE) \
    lv = pchars16((PCRE2_SPTR16)(p)+offset, len, utf, f); \
  else \
    lv = pchars8((PCRE2_SPTR8)(p)+offset, len, utf, f)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCHARSV</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>utf</name></type></parameter>, <parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE32_MODE) \
    (void)pchars32((PCRE2_SPTR32)(p)+offset, len, utf, f); \
  else if (test_mode == PCRE16_MODE) \
    (void)pchars16((PCRE2_SPTR16)(p)+offset, len, utf, f); \
  else \
    (void)pchars8((PCRE2_SPTR8)(p)+offset, len, utf, f)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CALLOUT_ENUMERATE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
     a = pcre2_callout_enumerate_8(compiled_code8, \
       (int (*)(struct pcre2_callout_enumerate_block_8 *, void *))b,c); \
  else if (test_mode == PCRE16_MODE) \
     a = pcre2_callout_enumerate_16(compiled_code16, \
       (int(*)(struct pcre2_callout_enumerate_block_16 *, void *))b,c); \
  else \
     a = pcre2_callout_enumerate_32(compiled_code32, \
       (int (*)(struct pcre2_callout_enumerate_block_32 *, void *))b,c)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CODE_COPY_FROM_VOID</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    G(a,8) = pcre2_code_copy_8(b); \
  else if (test_mode == PCRE16_MODE) \
    G(a,16) = pcre2_code_copy_16(b); \
  else \
    G(a,32) = pcre2_code_copy_32(b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CODE_COPY_TO_VOID</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    a = (void *)pcre2_code_copy_8(G(b,8)); \
  else if (test_mode == PCRE16_MODE) \
    a = (void *)pcre2_code_copy_16(G(b,16)); \
  else \
    a = (void *)pcre2_code_copy_32(G(b,32))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CODE_COPY_WITH_TABLES_TO_VOID</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    a = (void *)pcre2_code_copy_with_tables_8(G(b,8)); \
  else if (test_mode == PCRE16_MODE) \
    a = (void *)pcre2_code_copy_with_tables_16(G(b,16)); \
  else \
    a = (void *)pcre2_code_copy_with_tables_32(G(b,32))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_COMPILE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    G(a,8) = pcre2_compile_8(G(b,8),c,d,e,f,g); \
  else if (test_mode == PCRE16_MODE) \
    G(a,16) = pcre2_compile_16(G(b,16),c,d,e,f,g); \
  else \
    G(a,32) = pcre2_compile_32(G(b,32),c,d,e,f,g)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CONVERTED_PATTERN_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) pcre2_converted_pattern_free_8((PCRE2_UCHAR8 *)a); \
  else if (test_mode == PCRE16_MODE) pcre2_converted_pattern_free_16((PCRE2_UCHAR16 *)a); \
  else pcre2_converted_pattern_free_32((PCRE2_UCHAR32 *)a)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_DFA_MATCH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    a = pcre2_dfa_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h,i,j); \
  else if (test_mode == PCRE16_MODE) \
    a = pcre2_dfa_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h,i,j); \
  else \
    a = pcre2_dfa_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h,i,j)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_GET_ERROR_MESSAGE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    r = pcre2_get_error_message_8(a,G(b,8),G(G(b,8),_size)); \
  else if (test_mode == PCRE16_MODE) \
    r = pcre2_get_error_message_16(a,G(b,16),G(G(b,16),_size/2)); \
  else \
    r = pcre2_get_error_message_32(a,G(b,32),G(G(b,32),_size/4))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_GET_OVECTOR_COUNT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    a = pcre2_get_ovector_count_8(G(b,8)); \
  else if (test_mode == PCRE16_MODE) \
    a = pcre2_get_ovector_count_16(G(b,16)); \
  else \
    a = pcre2_get_ovector_count_32(G(b,32))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_GET_STARTCHAR</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    a = pcre2_get_startchar_8(G(b,8)); \
  else if (test_mode == PCRE16_MODE) \
    a = pcre2_get_startchar_16(G(b,16)); \
  else \
    a = pcre2_get_startchar_32(G(b,32))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_COMPILE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) r = pcre2_jit_compile_8(G(a,8),b); \
  else if (test_mode == PCRE16_MODE) r = pcre2_jit_compile_16(G(a,16),b); \
  else r = pcre2_jit_compile_32(G(a,32),b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_FREE_UNUSED_MEMORY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) pcre2_jit_free_unused_memory_8(G(a,8)); \
  else if (test_mode == PCRE16_MODE) pcre2_jit_free_unused_memory_16(G(a,16)); \
  else pcre2_jit_free_unused_memory_32(G(a,32))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_MATCH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    a = pcre2_jit_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h); \
  else if (test_mode == PCRE16_MODE) \
    a = pcre2_jit_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h); \
  else \
    a = pcre2_jit_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_STACK_CREATE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_8(b,c,d); \
  else if (test_mode == PCRE16_MODE) \
    a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_16(b,c,d); \
  else \
    a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_32(b,c,d);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_STACK_ASSIGN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    pcre2_jit_stack_assign_8(G(a,8),(pcre2_jit_callback_8)b,c); \
  else if (test_mode == PCRE16_MODE) \
    pcre2_jit_stack_assign_16(G(a,16),(pcre2_jit_callback_16)b,c); \
  else \
    pcre2_jit_stack_assign_32(G(a,32),(pcre2_jit_callback_32)b,c);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_STACK_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    pcre2_jit_stack_free_8((pcre2_jit_stack_8 *)a); \
  else if (test_mode == PCRE16_MODE) \
    pcre2_jit_stack_free_16((pcre2_jit_stack_16 *)a); \
  else \
    pcre2_jit_stack_free_32((pcre2_jit_stack_32 *)a);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MAKETABLES</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) a = pcre2_maketables_8(NULL); \
  else if (test_mode == PCRE16_MODE) a = pcre2_maketables_16(NULL); \
  else a = pcre2_maketables_32(NULL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MATCH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    a = pcre2_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h); \
  else if (test_mode == PCRE16_MODE) \
    a = pcre2_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h); \
  else \
    a = pcre2_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MATCH_DATA_CREATE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    G(a,8) = pcre2_match_data_create_8(b,c); \
  else if (test_mode == PCRE16_MODE) \
    G(a,16) = pcre2_match_data_create_16(b,c); \
  else \
    G(a,32) = pcre2_match_data_create_32(b,c)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MATCH_DATA_CREATE_FROM_PATTERN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    G(a,8) = pcre2_match_data_create_from_pattern_8(G(b,8),c); \
  else if (test_mode == PCRE16_MODE) \
    G(a,16) = pcre2_match_data_create_from_pattern_16(G(b,16),c); \
  else \
    G(a,32) = pcre2_match_data_create_from_pattern_32(G(b,32),c)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MATCH_DATA_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    pcre2_match_data_free_8(G(a,8)); \
  else if (test_mode == PCRE16_MODE) \
    pcre2_match_data_free_16(G(a,16)); \
  else \
    pcre2_match_data_free_32(G(a,32))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_PATTERN_CONVERT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    a = pcre2_pattern_convert_8(G(b,8),c,d,(PCRE2_UCHAR8 **)e,f,G(g,8)); \
  else if (test_mode == PCRE16_MODE) \
    a = pcre2_pattern_convert_16(G(b,16),c,d,(PCRE2_UCHAR16 **)e,f,G(g,16)); \
  else \
    a = pcre2_pattern_convert_32(G(b,32),c,d,(PCRE2_UCHAR32 **)e,f,G(g,32))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_PATTERN_INFO</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    a = pcre2_pattern_info_8(G(b,8),c,d); \
  else if (test_mode == PCRE16_MODE) \
    a = pcre2_pattern_info_16(G(b,16),c,d); \
  else \
    a = pcre2_pattern_info_32(G(b,32),c,d)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_PRINTINT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    pcre2_printint_8(compiled_code8,outfile,a); \
  else if (test_mode == PCRE16_MODE) \
    pcre2_printint_16(compiled_code16,outfile,a); \
  else \
    pcre2_printint_32(compiled_code32,outfile,a)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SERIALIZE_DECODE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    r = pcre2_serialize_decode_8((pcre2_code_8 **)a,b,c,G(d,8)); \
  else if (test_mode == PCRE16_MODE) \
    r = pcre2_serialize_decode_16((pcre2_code_16 **)a,b,c,G(d,16)); \
  else \
    r = pcre2_serialize_decode_32((pcre2_code_32 **)a,b,c,G(d,32))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SERIALIZE_ENCODE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    r = pcre2_serialize_encode_8((const pcre2_code_8 **)a,b,c,d,G(e,8)); \
  else if (test_mode == PCRE16_MODE) \
    r = pcre2_serialize_encode_16((const pcre2_code_16 **)a,b,c,d,G(e,16)); \
  else \
    r = pcre2_serialize_encode_32((const pcre2_code_32 **)a,b,c,d,G(e,32))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SERIALIZE_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    pcre2_serialize_free_8(a); \
  else if (test_mode == PCRE16_MODE) \
    pcre2_serialize_free_16(a); \
  else \
    pcre2_serialize_free_32(a)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SERIALIZE_GET_NUMBER_OF_CODES</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    r = pcre2_serialize_get_number_of_codes_8(a); \
  else if (test_mode == PCRE16_MODE) \
    r = pcre2_serialize_get_number_of_codes_16(a); \
  else \
    r = pcre2_serialize_get_number_of_codes_32(a); \

#define PCRE2_SET_CALLOUT(a,b,c) \
  if (test_mode == PCRE8_MODE) \
    pcre2_set_callout_8(G(a,8),(int (*)(pcre2_callout_block_8 *, void *))b,c); \
  else if (test_mode == PCRE16_MODE) \
    pcre2_set_callout_16(G(a,16),(int (*)(pcre2_callout_block_16 *, void *))b,c); \
  else \
    pcre2_set_callout_32(G(a,32),(int (*)(pcre2_callout_block_32 *, void *))b,c);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_CHARACTER_TABLES</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    pcre2_set_character_tables_8(G(a,8),b); \
  else if (test_mode == PCRE16_MODE) \
    pcre2_set_character_tables_16(G(a,16),b); \
  else \
    pcre2_set_character_tables_32(G(a,32),b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_COMPILE_RECURSION_GUARD</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    pcre2_set_compile_recursion_guard_8(G(a,8),b,c); \
  else if (test_mode == PCRE16_MODE) \
    pcre2_set_compile_recursion_guard_16(G(a,16),b,c); \
  else \
    pcre2_set_compile_recursion_guard_32(G(a,32),b,c)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_DEPTH_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    pcre2_set_depth_limit_8(G(a,8),b); \
  else if (test_mode == PCRE16_MODE) \
    pcre2_set_depth_limit_16(G(a,16),b); \
  else \
    pcre2_set_depth_limit_32(G(a,32),b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_GLOB_SEPARATOR</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    r = pcre2_set_glob_separator_8(G(a,8),b); \
  else if (test_mode == PCRE16_MODE) \
    r = pcre2_set_glob_separator_16(G(a,16),b); \
  else \
    r = pcre2_set_glob_separator_32(G(a,32),b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_GLOB_ESCAPE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    r = pcre2_set_glob_escape_8(G(a,8),b); \
  else if (test_mode == PCRE16_MODE) \
    r = pcre2_set_glob_escape_16(G(a,16),b); \
  else \
    r = pcre2_set_glob_escape_32(G(a,32),b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_HEAP_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    pcre2_set_heap_limit_8(G(a,8),b); \
  else if (test_mode == PCRE16_MODE) \
    pcre2_set_heap_limit_16(G(a,16),b); \
  else \
    pcre2_set_heap_limit_32(G(a,32),b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_MATCH_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    pcre2_set_match_limit_8(G(a,8),b); \
  else if (test_mode == PCRE16_MODE) \
    pcre2_set_match_limit_16(G(a,16),b); \
  else \
    pcre2_set_match_limit_32(G(a,32),b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_MAX_PATTERN_LENGTH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    pcre2_set_max_pattern_length_8(G(a,8),b); \
  else if (test_mode == PCRE16_MODE) \
    pcre2_set_max_pattern_length_16(G(a,16),b); \
  else \
    pcre2_set_max_pattern_length_32(G(a,32),b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_OFFSET_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    pcre2_set_offset_limit_8(G(a,8),b); \
  else if (test_mode == PCRE16_MODE) \
    pcre2_set_offset_limit_16(G(a,16),b); \
  else \
    pcre2_set_offset_limit_32(G(a,32),b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_PARENS_NEST_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    pcre2_set_parens_nest_limit_8(G(a,8),b); \
  else if (test_mode == PCRE16_MODE) \
    pcre2_set_parens_nest_limit_16(G(a,16),b); \
  else \
    pcre2_set_parens_nest_limit_32(G(a,32),b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_SUBSTITUTE_CALLOUT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    pcre2_set_substitute_callout_8(G(a,8), \
      (int (*)(pcre2_substitute_callout_block_8 *, void *))b,c); \
  else if (test_mode == PCRE16_MODE) \
    pcre2_set_substitute_callout_16(G(a,16), \
      (int (*)(pcre2_substitute_callout_block_16 *, void *))b,c); \
  else \
    pcre2_set_substitute_callout_32(G(a,32), \
      (int (*)(pcre2_substitute_callout_block_32 *, void *))b,c)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTITUTE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>j</name></type></parameter>,<parameter><type><name>k</name></type></parameter>,<parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    a = pcre2_substitute_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h, \
      (PCRE2_SPTR8)i,j,(PCRE2_UCHAR8 *)k,l); \
  else if (test_mode == PCRE16_MODE) \
    a = pcre2_substitute_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h, \
      (PCRE2_SPTR16)i,j,(PCRE2_UCHAR16 *)k,l); \
  else \
    a = pcre2_substitute_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h, \
      (PCRE2_SPTR32)i,j,(PCRE2_UCHAR32 *)k,l)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_COPY_BYNAME</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    a = pcre2_substring_copy_byname_8(G(b,8),G(c,8),(PCRE2_UCHAR8 *)d,e); \
  else if (test_mode == PCRE16_MODE) \
    a = pcre2_substring_copy_byname_16(G(b,16),G(c,16),(PCRE2_UCHAR16 *)d,e); \
  else \
    a = pcre2_substring_copy_byname_32(G(b,32),G(c,32),(PCRE2_UCHAR32 *)d,e)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_COPY_BYNUMBER</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    a = pcre2_substring_copy_bynumber_8(G(b,8),c,(PCRE2_UCHAR8 *)d,e); \
  else if (test_mode == PCRE16_MODE) \
    a = pcre2_substring_copy_bynumber_16(G(b,16),c,(PCRE2_UCHAR16 *)d,e); \
  else \
    a = pcre2_substring_copy_bynumber_32(G(b,32),c,(PCRE2_UCHAR32 *)d,e)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) pcre2_substring_free_8((PCRE2_UCHAR8 *)a); \
  else if (test_mode == PCRE16_MODE) \
    pcre2_substring_free_16((PCRE2_UCHAR16 *)a); \
  else pcre2_substring_free_32((PCRE2_UCHAR32 *)a)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_GET_BYNAME</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    a = pcre2_substring_get_byname_8(G(b,8),G(c,8),(PCRE2_UCHAR8 **)d,e); \
  else if (test_mode == PCRE16_MODE) \
    a = pcre2_substring_get_byname_16(G(b,16),G(c,16),(PCRE2_UCHAR16 **)d,e); \
  else \
    a = pcre2_substring_get_byname_32(G(b,32),G(c,32),(PCRE2_UCHAR32 **)d,e)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_GET_BYNUMBER</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    a = pcre2_substring_get_bynumber_8(G(b,8),c,(PCRE2_UCHAR8 **)d,e); \
  else if (test_mode == PCRE16_MODE) \
    a = pcre2_substring_get_bynumber_16(G(b,16),c,(PCRE2_UCHAR16 **)d,e); \
  else \
    a = pcre2_substring_get_bynumber_32(G(b,32),c,(PCRE2_UCHAR32 **)d,e)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_LENGTH_BYNAME</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    a = pcre2_substring_length_byname_8(G(b,8),G(c,8),d); \
  else if (test_mode == PCRE16_MODE) \
    a = pcre2_substring_length_byname_16(G(b,16),G(c,16),d); \
  else \
    a = pcre2_substring_length_byname_32(G(b,32),G(c,32),d)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_LENGTH_BYNUMBER</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    a = pcre2_substring_length_bynumber_8(G(b,8),c,d); \
  else if (test_mode == PCRE16_MODE) \
    a = pcre2_substring_length_bynumber_16(G(b,16),c,d); \
  else \
    a = pcre2_substring_length_bynumber_32(G(b,32),c,d)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_LIST_GET</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    a = pcre2_substring_list_get_8(G(b,8),(PCRE2_UCHAR8 ***)c,d); \
  else if (test_mode == PCRE16_MODE) \
    a = pcre2_substring_list_get_16(G(b,16),(PCRE2_UCHAR16 ***)c,d); \
  else \
    a = pcre2_substring_list_get_32(G(b,32),(PCRE2_UCHAR32 ***)c,d)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_LIST_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    pcre2_substring_list_free_8((PCRE2_SPTR8 *)a); \
  else if (test_mode == PCRE16_MODE) \
    pcre2_substring_list_free_16((PCRE2_SPTR16 *)a); \
  else \
    pcre2_substring_list_free_32((PCRE2_SPTR32 *)a)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_NUMBER_FROM_NAME</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    a = pcre2_substring_number_from_name_8(G(b,8),G(c,8)); \
  else if (test_mode == PCRE16_MODE) \
    a = pcre2_substring_number_from_name_16(G(b,16),G(c,16)); \
  else \
    a = pcre2_substring_number_from_name_32(G(b,32),G(c,32))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PTR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( \
  (test_mode == PCRE8_MODE)? (void *)G(x,8) : \
  (test_mode == PCRE16_MODE)? (void *)G(x,16) : \
  (void *)G(x,32))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETFLD</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) G(x,8)-&gt;y = z; \
  else if (test_mode == PCRE16_MODE) G(x,16)-&gt;y = z; \
  else G(x,32)-&gt;y = z</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETFLDVEC</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>v</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) G(x,8)-&gt;y[v] = z; \
  else if (test_mode == PCRE16_MODE) G(x,16)-&gt;y[v] = z; \
  else G(x,32)-&gt;y[v] = z</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETOP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) G(x,8) z y; \
  else if (test_mode == PCRE16_MODE) G(x,16) z y; \
  else G(x,32) z y</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETCASTPTR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) \
    G(x,8) = (uint8_t *)(y); \
  else if (test_mode == PCRE16_MODE) \
    G(x,16) = (uint16_t *)(y); \
  else \
    G(x,32) = (uint32_t *)(y)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRLEN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((test_mode == PCRE8_MODE)? ((int)strlen((char *)p)) : \
  (test_mode == PCRE16_MODE)? ((int)strlen16((PCRE2_SPTR16)p)) : \
  ((int)strlen32((PCRE2_SPTR32)p)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUB1</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) G(a,8)(G(b,8)); \
  else if (test_mode == PCRE16_MODE) G(a,16)(G(b,16)); \
  else G(a,32)(G(b,32))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUB2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == PCRE8_MODE) G(a,8)(G(b,8),G(c,8)); \
  else if (test_mode == PCRE16_MODE) G(a,16)(G(b,16),G(c,16)); \
  else G(a,32)(G(b,32),G(c,32))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>r</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( \
  (test_mode == PCRE8_MODE &amp;&amp; G(x,8) r (y)) || \
  (test_mode == PCRE16_MODE &amp;&amp; G(x,16) r (y)) || \
  (test_mode == PCRE32_MODE &amp;&amp; G(x,32) r (y)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TESTFLD</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>r</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( \
  (test_mode == PCRE8_MODE &amp;&amp; G(x,8)-&gt;f r (y)) || \
  (test_mode == PCRE16_MODE &amp;&amp; G(x,16)-&gt;f r (y)) || \
  (test_mode == PCRE32_MODE &amp;&amp; G(x,32)-&gt;f r (y)))</cpp:value></cpp:define>


<comment type="block">/* ----- Two out of three modes are supported ----- */</comment>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<comment type="block">/* We can use some macro trickery to make a single set of definitions work in
the three different cases. */</comment>

<comment type="block">/* ----- 32-bit and 16-bit but not 8-bit supported ----- */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_PCRE2_32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_PCRE2_16</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITONE</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITTWO</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<comment type="block">/* ----- 32-bit and 8-bit but not 16-bit supported ----- */</comment>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_PCRE2_32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_PCRE2_8</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITONE</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITTWO</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<comment type="block">/* ----- 16-bit and 8-bit but not 32-bit supported ----- */</comment>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITONE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITTWO</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* ----- Common macros for two-mode cases ----- */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTEONE</name></cpp:macro> <cpp:value>(BITONE/8)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTETWO</name></cpp:macro> <cpp:value>(BITTWO/8)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASTFLD</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>((test_mode == G(G(PCRE,BITONE),_MODE))? (t)(G(a,BITONE)-&gt;b) : \
    (t)(G(a,BITTWO)-&gt;b))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASTVAR</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( \
  (test_mode == G(G(PCRE,BITONE),_MODE))? \
    (t)G(x,BITONE) : (t)G(x,BITTWO))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CODE_UNIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( \
  (test_mode == G(G(PCRE,BITONE),_MODE))? \
  (uint32_t)(((G(PCRE2_SPTR,BITONE))(a))[b]) : \
  (uint32_t)(((G(PCRE2_SPTR,BITTWO))(a))[b]))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONCTXCPY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    memcpy(G(a,BITONE),G(b,BITONE),sizeof(G(pcre2_convert_context_,BITONE))); \
  else \
    memcpy(G(a,BITTWO),G(b,BITTWO),sizeof(G(pcre2_convert_context_,BITTWO)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONVERT_COPY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>(test_mode == G(G(PCRE,BITONE),_MODE))? \
  memcpy(G(a,BITONE),(char *)b,(c)*BYTEONE) : \
  memcpy(G(a,BITTWO),(char *)b,(c)*BYTETWO)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATCTXCPY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    memcpy(G(a,BITONE),G(b,BITONE),sizeof(G(pcre2_match_context_,BITONE))); \
  else \
    memcpy(G(a,BITTWO),G(b,BITTWO),sizeof(G(pcre2_match_context_,BITTWO)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLD</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>((test_mode == G(G(PCRE,BITONE),_MODE))? G(a,BITONE)-&gt;b : G(a,BITTWO)-&gt;b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATCTXCPY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    memcpy(G(a,BITONE),G(b,BITONE),sizeof(G(pcre2_compile_context_,BITONE))); \
  else \
    memcpy(G(a,BITTWO),G(b,BITTWO),sizeof(G(pcre2_compile_context_,BITTWO)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCHARS</name><parameter_list>(<parameter><type><name>lv</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>utf</name></type></parameter>, <parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    lv = G(pchars,BITONE)((G(PCRE2_SPTR,BITONE))(p)+offset, len, utf, f); \
  else \
    lv = G(pchars,BITTWO)((G(PCRE2_SPTR,BITTWO))(p)+offset, len, utf, f)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCHARSV</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>utf</name></type></parameter>, <parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    (void)G(pchars,BITONE)((G(PCRE2_SPTR,BITONE))(p)+offset, len, utf, f); \
  else \
    (void)G(pchars,BITTWO)((G(PCRE2_SPTR,BITTWO))(p)+offset, len, utf, f)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CALLOUT_ENUMERATE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
     a = G(pcre2_callout_enumerate,BITONE)(G(compiled_code,BITONE), \
       (int (*)(struct G(pcre2_callout_enumerate_block_,BITONE) *, void *))b,c); \
  else \
     a = G(pcre2_callout_enumerate,BITTWO)(G(compiled_code,BITTWO), \
       (int (*)(struct G(pcre2_callout_enumerate_block_,BITTWO) *, void *))b,c)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CODE_COPY_FROM_VOID</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(a,BITONE) = G(pcre2_code_copy_,BITONE)(b); \
  else \
    G(a,BITTWO) = G(pcre2_code_copy_,BITTWO)(b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CODE_COPY_TO_VOID</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    a = (void *)G(pcre2_code_copy_,BITONE)(G(b,BITONE)); \
  else \
    a = (void *)G(pcre2_code_copy_,BITTWO)(G(b,BITTWO))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CODE_COPY_WITH_TABLES_TO_VOID</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    a = (void *)G(pcre2_code_copy_with_tables_,BITONE)(G(b,BITONE)); \
  else \
    a = (void *)G(pcre2_code_copy_with_tables_,BITTWO)(G(b,BITTWO))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_COMPILE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(a,BITONE) = G(pcre2_compile_,BITONE)(G(b,BITONE),c,d,e,f,g); \
  else \
    G(a,BITTWO) = G(pcre2_compile_,BITTWO)(G(b,BITTWO),c,d,e,f,g)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CONVERTED_PATTERN_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(pcre2_converted_pattern_free_,BITONE)((G(PCRE2_UCHAR,BITONE) *)a); \
  else \
    G(pcre2_converted_pattern_free_,BITTWO)((G(PCRE2_UCHAR,BITTWO) *)a)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_DFA_MATCH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    a = G(pcre2_dfa_match_,BITONE)(G(b,BITONE),(G(PCRE2_SPTR,BITONE))c,d,e,f, \
      G(g,BITONE),h,i,j); \
  else \
    a = G(pcre2_dfa_match_,BITTWO)(G(b,BITTWO),(G(PCRE2_SPTR,BITTWO))c,d,e,f, \
      G(g,BITTWO),h,i,j)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_GET_ERROR_MESSAGE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    r = G(pcre2_get_error_message_,BITONE)(a,G(b,BITONE),G(G(b,BITONE),_size/BYTEONE)); \
  else \
    r = G(pcre2_get_error_message_,BITTWO)(a,G(b,BITTWO),G(G(b,BITTWO),_size/BYTETWO))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_GET_OVECTOR_COUNT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    a = G(pcre2_get_ovector_count_,BITONE)(G(b,BITONE)); \
  else \
    a = G(pcre2_get_ovector_count_,BITTWO)(G(b,BITTWO))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_GET_STARTCHAR</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    a = G(pcre2_get_startchar_,BITONE)(G(b,BITONE)); \
  else \
    a = G(pcre2_get_startchar_,BITTWO)(G(b,BITTWO))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_COMPILE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    r = G(pcre2_jit_compile_,BITONE)(G(a,BITONE),b); \
  else \
    r = G(pcre2_jit_compile_,BITTWO)(G(a,BITTWO),b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_FREE_UNUSED_MEMORY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(pcre2_jit_free_unused_memory_,BITONE)(G(a,BITONE)); \
  else \
    G(pcre2_jit_free_unused_memory_,BITTWO)(G(a,BITTWO))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_MATCH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    a = G(pcre2_jit_match_,BITONE)(G(b,BITONE),(G(PCRE2_SPTR,BITONE))c,d,e,f, \
      G(g,BITONE),h); \
  else \
    a = G(pcre2_jit_match_,BITTWO)(G(b,BITTWO),(G(PCRE2_SPTR,BITTWO))c,d,e,f, \
      G(g,BITTWO),h)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_STACK_CREATE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    a = (PCRE2_JIT_STACK *)G(pcre2_jit_stack_create_,BITONE)(b,c,d); \
  else \
    a = (PCRE2_JIT_STACK *)G(pcre2_jit_stack_create_,BITTWO)(b,c,d); \

#define PCRE2_JIT_STACK_ASSIGN(a,b,c) \
  if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(pcre2_jit_stack_assign_,BITONE)(G(a,BITONE),(G(pcre2_jit_callback_,BITONE))b,c); \
  else \
    G(pcre2_jit_stack_assign_,BITTWO)(G(a,BITTWO),(G(pcre2_jit_callback_,BITTWO))b,c);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_STACK_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(pcre2_jit_stack_free_,BITONE)((G(pcre2_jit_stack_,BITONE) *)a); \
  else \
    G(pcre2_jit_stack_free_,BITTWO)((G(pcre2_jit_stack_,BITTWO) *)a);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MAKETABLES</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    a = G(pcre2_maketables_,BITONE)(NULL); \
  else \
    a = G(pcre2_maketables_,BITTWO)(NULL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MATCH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    a = G(pcre2_match_,BITONE)(G(b,BITONE),(G(PCRE2_SPTR,BITONE))c,d,e,f, \
      G(g,BITONE),h); \
  else \
    a = G(pcre2_match_,BITTWO)(G(b,BITTWO),(G(PCRE2_SPTR,BITTWO))c,d,e,f, \
      G(g,BITTWO),h)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MATCH_DATA_CREATE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(a,BITONE) = G(pcre2_match_data_create_,BITONE)(b,c); \
  else \
    G(a,BITTWO) = G(pcre2_match_data_create_,BITTWO)(b,c)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MATCH_DATA_CREATE_FROM_PATTERN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(a,BITONE) = G(pcre2_match_data_create_from_pattern_,BITONE)(G(b,BITONE),c); \
  else \
    G(a,BITTWO) = G(pcre2_match_data_create_from_pattern_,BITTWO)(G(b,BITTWO),c)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MATCH_DATA_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(pcre2_match_data_free_,BITONE)(G(a,BITONE)); \
  else \
    G(pcre2_match_data_free_,BITTWO)(G(a,BITTWO))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_PATTERN_CONVERT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    a = G(pcre2_pattern_convert_,BITONE)(G(b,BITONE),c,d,(G(PCRE2_UCHAR,BITONE) **)e,f,G(g,BITONE)); \
  else \
    a = G(pcre2_pattern_convert_,BITTWO)(G(b,BITTWO),c,d,(G(PCRE2_UCHAR,BITTWO) **)e,f,G(g,BITTWO))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_PATTERN_INFO</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    a = G(pcre2_pattern_info_,BITONE)(G(b,BITONE),c,d); \
  else \
    a = G(pcre2_pattern_info_,BITTWO)(G(b,BITTWO),c,d)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_PRINTINT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
 <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(pcre2_printint_,BITONE)(G(compiled_code,BITONE),outfile,a); \
  else \
    G(pcre2_printint_,BITTWO)(G(compiled_code,BITTWO),outfile,a)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SERIALIZE_DECODE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
 <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    r = G(pcre2_serialize_decode_,BITONE)((G(pcre2_code_,BITONE) **)a,b,c,G(d,BITONE)); \
  else \
    r = G(pcre2_serialize_decode_,BITTWO)((G(pcre2_code_,BITTWO) **)a,b,c,G(d,BITTWO))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SERIALIZE_ENCODE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
 <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    r = G(pcre2_serialize_encode_,BITONE)((G(const pcre2_code_,BITONE) **)a,b,c,d,G(e,BITONE)); \
  else \
    r = G(pcre2_serialize_encode_,BITTWO)((G(const pcre2_code_,BITTWO) **)a,b,c,d,G(e,BITTWO))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SERIALIZE_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
 <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(pcre2_serialize_free_,BITONE)(a); \
  else \
    G(pcre2_serialize_free_,BITTWO)(a)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SERIALIZE_GET_NUMBER_OF_CODES</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
 <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    r = G(pcre2_serialize_get_number_of_codes_,BITONE)(a); \
  else \
    r = G(pcre2_serialize_get_number_of_codes_,BITTWO)(a)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_CALLOUT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(pcre2_set_callout_,BITONE)(G(a,BITONE), \
      (int (*)(G(pcre2_callout_block_,BITONE) *, void *))b,c); \
  else \
    G(pcre2_set_callout_,BITTWO)(G(a,BITTWO), \
      (int (*)(G(pcre2_callout_block_,BITTWO) *, void *))b,c);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_CHARACTER_TABLES</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(pcre2_set_character_tables_,BITONE)(G(a,BITONE),b); \
  else \
    G(pcre2_set_character_tables_,BITTWO)(G(a,BITTWO),b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_COMPILE_RECURSION_GUARD</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(pcre2_set_compile_recursion_guard_,BITONE)(G(a,BITONE),b,c); \
  else \
    G(pcre2_set_compile_recursion_guard_,BITTWO)(G(a,BITTWO),b,c)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_DEPTH_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(pcre2_set_depth_limit_,BITONE)(G(a,BITONE),b); \
  else \
    G(pcre2_set_depth_limit_,BITTWO)(G(a,BITTWO),b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_GLOB_ESCAPE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    r = G(pcre2_set_glob_escape_,BITONE)(G(a,BITONE),b); \
  else \
    r = G(pcre2_set_glob_escape_,BITTWO)(G(a,BITTWO),b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_GLOB_SEPARATOR</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    r = G(pcre2_set_glob_separator_,BITONE)(G(a,BITONE),b); \
  else \
    r = G(pcre2_set_glob_separator_,BITTWO)(G(a,BITTWO),b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_HEAP_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(pcre2_set_heap_limit_,BITONE)(G(a,BITONE),b); \
  else \
    G(pcre2_set_heap_limit_,BITTWO)(G(a,BITTWO),b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_MATCH_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(pcre2_set_match_limit_,BITONE)(G(a,BITONE),b); \
  else \
    G(pcre2_set_match_limit_,BITTWO)(G(a,BITTWO),b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_MAX_PATTERN_LENGTH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(pcre2_set_max_pattern_length_,BITONE)(G(a,BITONE),b); \
  else \
    G(pcre2_set_max_pattern_length_,BITTWO)(G(a,BITTWO),b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_OFFSET_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(pcre2_set_offset_limit_,BITONE)(G(a,BITONE),b); \
  else \
    G(pcre2_set_offset_limit_,BITTWO)(G(a,BITTWO),b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_PARENS_NEST_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(pcre2_set_parens_nest_limit_,BITONE)(G(a,BITONE),b); \
  else \
    G(pcre2_set_parens_nest_limit_,BITTWO)(G(a,BITTWO),b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_SUBSTITUTE_CALLOUT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(pcre2_set_substitute_callout_,BITONE)(G(a,BITONE), \
      (int (*)(G(pcre2_substitute_callout_block_,BITONE) *, void *))b,c); \
  else \
    G(pcre2_set_substitute_callout_,BITTWO)(G(a,BITTWO), \
      (int (*)(G(pcre2_substitute_callout_block_,BITTWO) *, void *))b,c)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTITUTE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>j</name></type></parameter>,<parameter><type><name>k</name></type></parameter>,<parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    a = G(pcre2_substitute_,BITONE)(G(b,BITONE),(G(PCRE2_SPTR,BITONE))c,d,e,f, \
      G(g,BITONE),h,(G(PCRE2_SPTR,BITONE))i,j, \
      (G(PCRE2_UCHAR,BITONE) *)k,l); \
  else \
    a = G(pcre2_substitute_,BITTWO)(G(b,BITTWO),(G(PCRE2_SPTR,BITTWO))c,d,e,f, \
      G(g,BITTWO),h,(G(PCRE2_SPTR,BITTWO))i,j, \
      (G(PCRE2_UCHAR,BITTWO) *)k,l)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_COPY_BYNAME</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    a = G(pcre2_substring_copy_byname_,BITONE)(G(b,BITONE),G(c,BITONE),\
      (G(PCRE2_UCHAR,BITONE) *)d,e); \
  else \
    a = G(pcre2_substring_copy_byname_,BITTWO)(G(b,BITTWO),G(c,BITTWO),\
      (G(PCRE2_UCHAR,BITTWO) *)d,e)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_COPY_BYNUMBER</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    a = G(pcre2_substring_copy_bynumber_,BITONE)(G(b,BITONE),c,\
      (G(PCRE2_UCHAR,BITONE) *)d,e); \
  else \
    a = G(pcre2_substring_copy_bynumber_,BITTWO)(G(b,BITTWO),c,\
      (G(PCRE2_UCHAR,BITTWO) *)d,e)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(pcre2_substring_free_,BITONE)((G(PCRE2_UCHAR,BITONE) *)a); \
  else G(pcre2_substring_free_,BITTWO)((G(PCRE2_UCHAR,BITTWO) *)a)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_GET_BYNAME</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    a = G(pcre2_substring_get_byname_,BITONE)(G(b,BITONE),G(c,BITONE),\
      (G(PCRE2_UCHAR,BITONE) **)d,e); \
  else \
    a = G(pcre2_substring_get_byname_,BITTWO)(G(b,BITTWO),G(c,BITTWO),\
      (G(PCRE2_UCHAR,BITTWO) **)d,e)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_GET_BYNUMBER</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    a = G(pcre2_substring_get_bynumber_,BITONE)(G(b,BITONE),c,\
      (G(PCRE2_UCHAR,BITONE) **)d,e); \
  else \
    a = G(pcre2_substring_get_bynumber_,BITTWO)(G(b,BITTWO),c,\
      (G(PCRE2_UCHAR,BITTWO) **)d,e)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_LENGTH_BYNAME</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    a = G(pcre2_substring_length_byname_,BITONE)(G(b,BITONE),G(c,BITONE),d); \
  else \
    a = G(pcre2_substring_length_byname_,BITTWO)(G(b,BITTWO),G(c,BITTWO),d)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_LENGTH_BYNUMBER</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    a = G(pcre2_substring_length_bynumber_,BITONE)(G(b,BITONE),c,d); \
  else \
    a = G(pcre2_substring_length_bynumber_,BITTWO)(G(b,BITTWO),c,d)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_LIST_GET</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    a = G(pcre2_substring_list_get_,BITONE)(G(b,BITONE), \
      (G(PCRE2_UCHAR,BITONE) ***)c,d); \
  else \
    a = G(pcre2_substring_list_get_,BITTWO)(G(b,BITTWO), \
      (G(PCRE2_UCHAR,BITTWO) ***)c,d)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_LIST_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(pcre2_substring_list_free_,BITONE)((G(PCRE2_SPTR,BITONE) *)a); \
  else \
    G(pcre2_substring_list_free_,BITTWO)((G(PCRE2_SPTR,BITTWO) *)a)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_NUMBER_FROM_NAME</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    a = G(pcre2_substring_number_from_name_,BITONE)(G(b,BITONE),G(c,BITONE)); \
  else \
    a = G(pcre2_substring_number_from_name_,BITTWO)(G(b,BITTWO),G(c,BITTWO))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PTR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( \
  (test_mode == G(G(PCRE,BITONE),_MODE))? (void *)G(x,BITONE) : \
  (void *)G(x,BITTWO))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETFLD</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) G(x,BITONE)-&gt;y = z; \
  else G(x,BITTWO)-&gt;y = z</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETFLDVEC</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>v</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) G(x,BITONE)-&gt;y[v] = z; \
  else G(x,BITTWO)-&gt;y[v] = z</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETOP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) G(x,BITONE) z y; \
  else G(x,BITTWO) z y</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETCASTPTR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(x,BITONE) = (G(G(uint,BITONE),_t) *)(y); \
  else \
    G(x,BITTWO) = (G(G(uint,BITTWO),_t) *)(y)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRLEN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((test_mode == G(G(PCRE,BITONE),_MODE))? \
  G(strlen,BITONE)((G(PCRE2_SPTR,BITONE))p) : \
  G(strlen,BITTWO)((G(PCRE2_SPTR,BITTWO))p))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUB1</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(a,BITONE)(G(b,BITONE)); \
  else \
    G(a,BITTWO)(G(b,BITTWO))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUB2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (test_mode == G(G(PCRE,BITONE),_MODE)) \
    G(a,BITONE))(G(b,BITONE),G(c,BITONE)); \
  else \
    G(a,BITTWO))(G(b,BITTWO),G(c,BITTWO))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>r</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( \
  (test_mode == G(G(PCRE,BITONE),_MODE) &amp;&amp; G(x,BITONE) r (y)) || \
  (test_mode == G(G(PCRE,BITTWO),_MODE) &amp;&amp; G(x,BITTWO) r (y)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TESTFLD</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>r</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( \
  (test_mode == G(G(PCRE,BITONE),_MODE) &amp;&amp; G(x,BITONE)-&gt;f r (y)) || \
  (test_mode == G(G(PCRE,BITTWO),_MODE) &amp;&amp; G(x,BITTWO)-&gt;f r (y)))</cpp:value></cpp:define>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* Two out of three modes */</comment>

<comment type="block">/* ----- End of cases where more than one mode is supported ----- */</comment>


<comment type="block">/* ----- Only 8-bit mode is supported ----- */</comment>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>SUPPORT_PCRE2_8</name></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASTFLD</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(t)(G(a,8)-&gt;b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASTVAR</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(t)G(x,8)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CODE_UNIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(uint32_t)(((PCRE2_SPTR8)(a))[b])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONCTXCPY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy(G(a,8),G(b,8),sizeof(pcre2_convert_context_8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONVERT_COPY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy(G(a,8),(char *)b, c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATCTXCPY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy(G(a,8),G(b,8),sizeof(pcre2_match_context_8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLD</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(a,8)-&gt;b</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATCTXCPY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy(G(a,8),G(b,8),sizeof(pcre2_compile_context_8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCHARS</name><parameter_list>(<parameter><type><name>lv</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>utf</name></type></parameter>, <parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>lv = pchars8((PCRE2_SPTR8)(p)+offset, len, utf, f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCHARSV</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>utf</name></type></parameter>, <parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>(void)pchars8((PCRE2_SPTR8)(p)+offset, len, utf, f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CALLOUT_ENUMERATE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
   <cpp:value>a = pcre2_callout_enumerate_8(compiled_code8, \
     (int (*)(struct pcre2_callout_enumerate_block_8 *, void *))b,c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CODE_COPY_FROM_VOID</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(a,8) = pcre2_code_copy_8(b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CODE_COPY_TO_VOID</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = (void *)pcre2_code_copy_8(G(b,8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CODE_COPY_WITH_TABLES_TO_VOID</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = (void *)pcre2_code_copy_with_tables_8(G(b,8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_COMPILE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>G(a,8) = pcre2_compile_8(G(b,8),c,d,e,f,g)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CONVERTED_PATTERN_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>pcre2_converted_pattern_free_8((PCRE2_UCHAR8 *)a)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_DFA_MATCH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_dfa_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h,i,j)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_GET_ERROR_MESSAGE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>r = pcre2_get_error_message_8(a,G(b,8),G(G(b,8),_size))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_GET_OVECTOR_COUNT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = pcre2_get_ovector_count_8(G(b,8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_GET_STARTCHAR</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = pcre2_get_startchar_8(G(b,8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_COMPILE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r = pcre2_jit_compile_8(G(a,8),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_FREE_UNUSED_MEMORY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_jit_free_unused_memory_8(G(a,8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_MATCH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_jit_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_STACK_CREATE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_8(b,c,d);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_STACK_ASSIGN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>pcre2_jit_stack_assign_8(G(a,8),(pcre2_jit_callback_8)b,c);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_STACK_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_jit_stack_free_8((pcre2_jit_stack_8 *)a);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MAKETABLES</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = pcre2_maketables_8(NULL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MATCH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_match_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MATCH_DATA_CREATE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(a,8) = pcre2_match_data_create_8(b,c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MATCH_DATA_CREATE_FROM_PATTERN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>G(a,8) = pcre2_match_data_create_from_pattern_8(G(b,8),c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MATCH_DATA_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_match_data_free_8(G(a,8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_PATTERN_CONVERT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = pcre2_pattern_convert_8(G(b,8),c,d,(PCRE2_UCHAR8 **)e,f,G(g,8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_PATTERN_INFO</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = pcre2_pattern_info_8(G(b,8),c,d)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_PRINTINT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_printint_8(compiled_code8,outfile,a)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SERIALIZE_DECODE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>r = pcre2_serialize_decode_8((pcre2_code_8 **)a,b,c,G(d,8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SERIALIZE_ENCODE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>r = pcre2_serialize_encode_8((const pcre2_code_8 **)a,b,c,d,G(e,8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SERIALIZE_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_serialize_free_8(a)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SERIALIZE_GET_NUMBER_OF_CODES</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>r = pcre2_serialize_get_number_of_codes_8(a)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_CALLOUT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>pcre2_set_callout_8(G(a,8),(int (*)(pcre2_callout_block_8 *, void *))b,c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_CHARACTER_TABLES</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_character_tables_8(G(a,8),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_COMPILE_RECURSION_GUARD</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>pcre2_set_compile_recursion_guard_8(G(a,8),b,c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_DEPTH_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_depth_limit_8(G(a,8),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_GLOB_ESCAPE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r = pcre2_set_glob_escape_8(G(a,8),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_GLOB_SEPARATOR</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r = pcre2_set_glob_separator_8(G(a,8),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_HEAP_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_heap_limit_8(G(a,8),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_MATCH_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_match_limit_8(G(a,8),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_MAX_PATTERN_LENGTH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_max_pattern_length_8(G(a,8),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_OFFSET_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_offset_limit_8(G(a,8),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_PARENS_NEST_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_parens_nest_limit_8(G(a,8),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_SUBSTITUTE_CALLOUT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>pcre2_set_substitute_callout_8(G(a,8), \
    (int (*)(pcre2_substitute_callout_block_8 *, void *))b,c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTITUTE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>j</name></type></parameter>,<parameter><type><name>k</name></type></parameter>,<parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substitute_8(G(b,8),(PCRE2_SPTR8)c,d,e,f,G(g,8),h, \
    (PCRE2_SPTR8)i,j,(PCRE2_UCHAR8 *)k,l)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_COPY_BYNAME</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substring_copy_byname_8(G(b,8),G(c,8),(PCRE2_UCHAR8 *)d,e)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_COPY_BYNUMBER</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substring_copy_bynumber_8(G(b,8),c,(PCRE2_UCHAR8 *)d,e)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_substring_free_8((PCRE2_UCHAR8 *)a)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_GET_BYNAME</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substring_get_byname_8(G(b,8),G(c,8),(PCRE2_UCHAR8 **)d,e)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_GET_BYNUMBER</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substring_get_bynumber_8(G(b,8),c,(PCRE2_UCHAR8 **)d,e)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_LENGTH_BYNAME</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>a = pcre2_substring_length_byname_8(G(b,8),G(c,8),d)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_LENGTH_BYNUMBER</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>a = pcre2_substring_length_bynumber_8(G(b,8),c,d)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_LIST_GET</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substring_list_get_8(G(b,8),(PCRE2_UCHAR8 ***)c,d)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_LIST_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>pcre2_substring_list_free_8((PCRE2_SPTR8 *)a)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_NUMBER_FROM_NAME</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substring_number_from_name_8(G(b,8),G(c,8));</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PTR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void *)G(x,8)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETFLD</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(x,8)-&gt;y = z</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETFLDVEC</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>v</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(x,8)-&gt;y[v] = z</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETOP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(x,8) z y</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETCASTPTR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(x,8) = (uint8_t *)(y)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRLEN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(int)strlen((char *)p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUB1</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(a,8)(G(b,8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUB2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(a,8)(G(b,8),G(c,8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>r</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(G(x,8) r (y))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TESTFLD</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>r</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(G(x,8)-&gt;f r (y))</cpp:value></cpp:define>


<comment type="block">/* ----- Only 16-bit mode is supported ----- */</comment>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>SUPPORT_PCRE2_16</name></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASTFLD</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(t)(G(a,16)-&gt;b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASTVAR</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(t)G(x,16)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CODE_UNIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(uint32_t)(((PCRE2_SPTR16)(a))[b])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONCTXCPY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy(G(a,16),G(b,16),sizeof(pcre2_convert_context_16))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONVERT_COPY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy(G(a,16),(char *)b, (c)*2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATCTXCPY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy(G(a,16),G(b,16),sizeof(pcre2_match_context_16))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLD</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(a,16)-&gt;b</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATCTXCPY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy(G(a,16),G(b,16),sizeof(pcre2_compile_context_16))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCHARS</name><parameter_list>(<parameter><type><name>lv</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>utf</name></type></parameter>, <parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>lv = pchars16((PCRE2_SPTR16)(p)+offset, len, utf, f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCHARSV</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>utf</name></type></parameter>, <parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>(void)pchars16((PCRE2_SPTR16)(p)+offset, len, utf, f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CALLOUT_ENUMERATE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
   <cpp:value>a = pcre2_callout_enumerate_16(compiled_code16, \
     (int (*)(struct pcre2_callout_enumerate_block_16 *, void *))b,c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CODE_COPY_FROM_VOID</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(a,16) = pcre2_code_copy_16(b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CODE_COPY_TO_VOID</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = (void *)pcre2_code_copy_16(G(b,16))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CODE_COPY_WITH_TABLES_TO_VOID</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = (void *)pcre2_code_copy_with_tables_16(G(b,16))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_COMPILE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>G(a,16) = pcre2_compile_16(G(b,16),c,d,e,f,g)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CONVERTED_PATTERN_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>pcre2_converted_pattern_free_16((PCRE2_UCHAR16 *)a)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_DFA_MATCH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_dfa_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h,i,j)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_GET_ERROR_MESSAGE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>r = pcre2_get_error_message_16(a,G(b,16),G(G(b,16),_size/2))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_GET_OVECTOR_COUNT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = pcre2_get_ovector_count_16(G(b,16))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_GET_STARTCHAR</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = pcre2_get_startchar_16(G(b,16))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_COMPILE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r = pcre2_jit_compile_16(G(a,16),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_FREE_UNUSED_MEMORY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_jit_free_unused_memory_16(G(a,16))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_MATCH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_jit_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_STACK_CREATE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_16(b,c,d);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_STACK_ASSIGN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>pcre2_jit_stack_assign_16(G(a,16),(pcre2_jit_callback_16)b,c);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_STACK_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_jit_stack_free_16((pcre2_jit_stack_16 *)a);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MAKETABLES</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = pcre2_maketables_16(NULL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MATCH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_match_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MATCH_DATA_CREATE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(a,16) = pcre2_match_data_create_16(b,c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MATCH_DATA_CREATE_FROM_PATTERN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>G(a,16) = pcre2_match_data_create_from_pattern_16(G(b,16),c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MATCH_DATA_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_match_data_free_16(G(a,16))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_PATTERN_CONVERT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = pcre2_pattern_convert_16(G(b,16),c,d,(PCRE2_UCHAR16 **)e,f,G(g,16))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_PATTERN_INFO</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = pcre2_pattern_info_16(G(b,16),c,d)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_PRINTINT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_printint_16(compiled_code16,outfile,a)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SERIALIZE_DECODE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>r = pcre2_serialize_decode_16((pcre2_code_16 **)a,b,c,G(d,16))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SERIALIZE_ENCODE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>r = pcre2_serialize_encode_16((const pcre2_code_16 **)a,b,c,d,G(e,16))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SERIALIZE_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_serialize_free_16(a)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SERIALIZE_GET_NUMBER_OF_CODES</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>r = pcre2_serialize_get_number_of_codes_16(a)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_CALLOUT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>pcre2_set_callout_16(G(a,16),(int (*)(pcre2_callout_block_16 *, void *))b,c);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_CHARACTER_TABLES</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_character_tables_16(G(a,16),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_COMPILE_RECURSION_GUARD</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>pcre2_set_compile_recursion_guard_16(G(a,16),b,c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_DEPTH_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_depth_limit_16(G(a,16),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_GLOB_ESCAPE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r = pcre2_set_glob_escape_16(G(a,16),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_GLOB_SEPARATOR</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r = pcre2_set_glob_separator_16(G(a,16),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_HEAP_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_heap_limit_16(G(a,16),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_MATCH_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_match_limit_16(G(a,16),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_MAX_PATTERN_LENGTH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_max_pattern_length_16(G(a,16),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_OFFSET_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_offset_limit_16(G(a,16),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_PARENS_NEST_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_parens_nest_limit_16(G(a,16),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_SUBSTITUTE_CALLOUT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>pcre2_set_substitute_callout_16(G(a,16), \
    (int (*)(pcre2_substitute_callout_block_16 *, void *))b,c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTITUTE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>j</name></type></parameter>,<parameter><type><name>k</name></type></parameter>,<parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substitute_16(G(b,16),(PCRE2_SPTR16)c,d,e,f,G(g,16),h, \
    (PCRE2_SPTR16)i,j,(PCRE2_UCHAR16 *)k,l)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_COPY_BYNAME</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substring_copy_byname_16(G(b,16),G(c,16),(PCRE2_UCHAR16 *)d,e)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_COPY_BYNUMBER</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substring_copy_bynumber_16(G(b,16),c,(PCRE2_UCHAR16 *)d,e)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_substring_free_16((PCRE2_UCHAR16 *)a)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_GET_BYNAME</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substring_get_byname_16(G(b,16),G(c,16),(PCRE2_UCHAR16 **)d,e)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_GET_BYNUMBER</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substring_get_bynumber_16(G(b,16),c,(PCRE2_UCHAR16 **)d,e)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_LENGTH_BYNAME</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>a = pcre2_substring_length_byname_16(G(b,16),G(c,16),d)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_LENGTH_BYNUMBER</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>a = pcre2_substring_length_bynumber_16(G(b,16),c,d)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_LIST_GET</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substring_list_get_16(G(b,16),(PCRE2_UCHAR16 ***)c,d)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_LIST_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>pcre2_substring_list_free_16((PCRE2_SPTR16 *)a)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_NUMBER_FROM_NAME</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substring_number_from_name_16(G(b,16),G(c,16));</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PTR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void *)G(x,16)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETFLD</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(x,16)-&gt;y = z</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETFLDVEC</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>v</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(x,16)-&gt;y[v] = z</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETOP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(x,16) z y</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETCASTPTR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(x,16) = (uint16_t *)(y)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRLEN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(int)strlen16((PCRE2_SPTR16)p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUB1</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(a,16)(G(b,16))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUB2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(a,16)(G(b,16),G(c,16))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>r</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(G(x,16) r (y))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TESTFLD</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>r</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(G(x,16)-&gt;f r (y))</cpp:value></cpp:define>


<comment type="block">/* ----- Only 32-bit mode is supported ----- */</comment>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>SUPPORT_PCRE2_32</name></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASTFLD</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(t)(G(a,32)-&gt;b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASTVAR</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(t)G(x,32)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CODE_UNIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(uint32_t)(((PCRE2_SPTR32)(a))[b])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONCTXCPY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy(G(a,32),G(b,32),sizeof(pcre2_convert_context_32))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONVERT_COPY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy(G(a,32),(char *)b, (c)*4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATCTXCPY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy(G(a,32),G(b,32),sizeof(pcre2_match_context_32))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLD</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(a,32)-&gt;b</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATCTXCPY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcpy(G(a,32),G(b,32),sizeof(pcre2_compile_context_32))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCHARS</name><parameter_list>(<parameter><type><name>lv</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>utf</name></type></parameter>, <parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>lv = pchars32((PCRE2_SPTR32)(p)+offset, len, utf, f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCHARSV</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>utf</name></type></parameter>, <parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>(void)pchars32((PCRE2_SPTR32)(p)+offset, len, utf, f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CALLOUT_ENUMERATE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
   <cpp:value>a = pcre2_callout_enumerate_32(compiled_code32, \
     (int (*)(struct pcre2_callout_enumerate_block_32 *, void *))b,c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CODE_COPY_FROM_VOID</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(a,32) = pcre2_code_copy_32(b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CODE_COPY_TO_VOID</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = (void *)pcre2_code_copy_32(G(b,32))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CODE_COPY_WITH_TABLES_TO_VOID</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = (void *)pcre2_code_copy_with_tables_32(G(b,32))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_COMPILE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>G(a,32) = pcre2_compile_32(G(b,32),c,d,e,f,g)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CONVERTED_PATTERN_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>pcre2_converted_pattern_free_32((PCRE2_UCHAR32 *)a)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_DFA_MATCH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>j</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_dfa_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h,i,j)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_GET_ERROR_MESSAGE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>r = pcre2_get_error_message_32(a,G(b,32),G(G(b,32),_size/4))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_GET_OVECTOR_COUNT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = pcre2_get_ovector_count_32(G(b,32))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_GET_STARTCHAR</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = pcre2_get_startchar_32(G(b,32))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_COMPILE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r = pcre2_jit_compile_32(G(a,32),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_FREE_UNUSED_MEMORY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_jit_free_unused_memory_32(G(a,32))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_MATCH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_jit_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_STACK_CREATE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = (PCRE2_JIT_STACK *)pcre2_jit_stack_create_32(b,c,d);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_STACK_ASSIGN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>pcre2_jit_stack_assign_32(G(a,32),(pcre2_jit_callback_32)b,c);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_JIT_STACK_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_jit_stack_free_32((pcre2_jit_stack_32 *)a);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MAKETABLES</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = pcre2_maketables_32(NULL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MATCH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_match_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MATCH_DATA_CREATE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(a,32) = pcre2_match_data_create_32(b,c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MATCH_DATA_CREATE_FROM_PATTERN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>G(a,32) = pcre2_match_data_create_from_pattern_32(G(b,32),c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_MATCH_DATA_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_match_data_free_32(G(a,32))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_PATTERN_CONVERT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = pcre2_pattern_convert_32(G(b,32),c,d,(PCRE2_UCHAR32 **)e,f,G(g,32))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_PATTERN_INFO</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a = pcre2_pattern_info_32(G(b,32),c,d)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_PRINTINT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_printint_32(compiled_code32,outfile,a)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SERIALIZE_DECODE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>r = pcre2_serialize_decode_32((pcre2_code_32 **)a,b,c,G(d,32))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SERIALIZE_ENCODE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>r = pcre2_serialize_encode_32((const pcre2_code_32 **)a,b,c,d,G(e,32))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SERIALIZE_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_serialize_free_32(a)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SERIALIZE_GET_NUMBER_OF_CODES</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>r = pcre2_serialize_get_number_of_codes_32(a)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_CALLOUT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>pcre2_set_callout_32(G(a,32),(int (*)(pcre2_callout_block_32 *, void *))b,c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_CHARACTER_TABLES</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_character_tables_32(G(a,32),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_COMPILE_RECURSION_GUARD</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>pcre2_set_compile_recursion_guard_32(G(a,32),b,c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_DEPTH_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_depth_limit_32(G(a,32),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_GLOB_ESCAPE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r = pcre2_set_glob_escape_32(G(a,32),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_GLOB_SEPARATOR</name><parameter_list>(<parameter><type><name>r</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r = pcre2_set_glob_separator_32(G(a,32),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_HEAP_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_heap_limit_32(G(a,32),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_MATCH_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_match_limit_32(G(a,32),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_MAX_PATTERN_LENGTH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_max_pattern_length_32(G(a,32),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_OFFSET_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_offset_limit_32(G(a,32),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_PARENS_NEST_LIMIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_set_parens_nest_limit_32(G(a,32),b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SET_SUBSTITUTE_CALLOUT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>pcre2_set_substitute_callout_32(G(a,32), \
    (int (*)(pcre2_substitute_callout_block_32 *, void *))b,c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTITUTE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>g</name></type></parameter>,<parameter><type><name>h</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>j</name></type></parameter>,<parameter><type><name>k</name></type></parameter>,<parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substitute_32(G(b,32),(PCRE2_SPTR32)c,d,e,f,G(g,32),h, \
    (PCRE2_SPTR32)i,j,(PCRE2_UCHAR32 *)k,l)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_COPY_BYNAME</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substring_copy_byname_32(G(b,32),G(c,32),(PCRE2_UCHAR32 *)d,e)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_COPY_BYNUMBER</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substring_copy_bynumber_32(G(b,32),c,(PCRE2_UCHAR32 *)d,e);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pcre2_substring_free_32((PCRE2_UCHAR32 *)a)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_GET_BYNAME</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substring_get_byname_32(G(b,32),G(c,32),(PCRE2_UCHAR32 **)d,e)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_GET_BYNUMBER</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substring_get_bynumber_32(G(b,32),c,(PCRE2_UCHAR32 **)d,e)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_LENGTH_BYNAME</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>a = pcre2_substring_length_byname_32(G(b,32),G(c,32),d)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_LENGTH_BYNUMBER</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>a = pcre2_substring_length_bynumber_32(G(b,32),c,d)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_LIST_GET</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substring_list_get_32(G(b,32),(PCRE2_UCHAR32 ***)c,d)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_LIST_FREE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>pcre2_substring_list_free_32((PCRE2_SPTR32 *)a)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_SUBSTRING_NUMBER_FROM_NAME</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>a = pcre2_substring_number_from_name_32(G(b,32),G(c,32));</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PTR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void *)G(x,32)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETFLD</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(x,32)-&gt;y = z</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETFLDVEC</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>v</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(x,32)-&gt;y[v] = z</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETOP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(x,32) z y</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETCASTPTR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(x,32) = (uint32_t *)(y)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRLEN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(int)strlen32((PCRE2_SPTR32)p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUB1</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(a,32)(G(b,32))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUB2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>G(a,32)(G(b,32),G(c,32))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>r</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(G(x,32) r (y))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TESTFLD</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>f</name></type></parameter>,<parameter><type><name>r</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(G(x,32)-&gt;f r (y))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ----- End of mode-specific function call macros ----- */</comment>




<comment type="block" format="doxygen">/*************************************************
*         Alternate character tables             *
*************************************************/</comment>

<comment type="block">/* By default, the "tables" pointer in the compile context when calling
pcre2_compile() is not set (= NULL), thereby using the default tables of the
library. However, the tables modifier can be used to select alternate sets of
tables, for different kinds of testing. Note that the locale modifier also
adjusts the tables. */</comment>

<comment type="block">/* This is the set of tables distributed as default with PCRE2. It recognizes
only ASCII characters. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>tables1</name><index>[]</index></name> <init>= <expr><block>{

<comment type="block">/* This table is a lower casing table. */</comment>

    <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">7</literal></expr>,
    <expr><literal type="number">8</literal></expr>,  <expr><literal type="number">9</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">15</literal></expr>,
   <expr><literal type="number">16</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">23</literal></expr>,
   <expr><literal type="number">24</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">26</literal></expr>, <expr><literal type="number">27</literal></expr>, <expr><literal type="number">28</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>,
   <expr><literal type="number">32</literal></expr>, <expr><literal type="number">33</literal></expr>, <expr><literal type="number">34</literal></expr>, <expr><literal type="number">35</literal></expr>, <expr><literal type="number">36</literal></expr>, <expr><literal type="number">37</literal></expr>, <expr><literal type="number">38</literal></expr>, <expr><literal type="number">39</literal></expr>,
   <expr><literal type="number">40</literal></expr>, <expr><literal type="number">41</literal></expr>, <expr><literal type="number">42</literal></expr>, <expr><literal type="number">43</literal></expr>, <expr><literal type="number">44</literal></expr>, <expr><literal type="number">45</literal></expr>, <expr><literal type="number">46</literal></expr>, <expr><literal type="number">47</literal></expr>,
   <expr><literal type="number">48</literal></expr>, <expr><literal type="number">49</literal></expr>, <expr><literal type="number">50</literal></expr>, <expr><literal type="number">51</literal></expr>, <expr><literal type="number">52</literal></expr>, <expr><literal type="number">53</literal></expr>, <expr><literal type="number">54</literal></expr>, <expr><literal type="number">55</literal></expr>,
   <expr><literal type="number">56</literal></expr>, <expr><literal type="number">57</literal></expr>, <expr><literal type="number">58</literal></expr>, <expr><literal type="number">59</literal></expr>, <expr><literal type="number">60</literal></expr>, <expr><literal type="number">61</literal></expr>, <expr><literal type="number">62</literal></expr>, <expr><literal type="number">63</literal></expr>,
   <expr><literal type="number">64</literal></expr>, <expr><literal type="number">97</literal></expr>, <expr><literal type="number">98</literal></expr>, <expr><literal type="number">99</literal></expr>,<expr><literal type="number">100</literal></expr>,<expr><literal type="number">101</literal></expr>,<expr><literal type="number">102</literal></expr>,<expr><literal type="number">103</literal></expr>,
  <expr><literal type="number">104</literal></expr>,<expr><literal type="number">105</literal></expr>,<expr><literal type="number">106</literal></expr>,<expr><literal type="number">107</literal></expr>,<expr><literal type="number">108</literal></expr>,<expr><literal type="number">109</literal></expr>,<expr><literal type="number">110</literal></expr>,<expr><literal type="number">111</literal></expr>,
  <expr><literal type="number">112</literal></expr>,<expr><literal type="number">113</literal></expr>,<expr><literal type="number">114</literal></expr>,<expr><literal type="number">115</literal></expr>,<expr><literal type="number">116</literal></expr>,<expr><literal type="number">117</literal></expr>,<expr><literal type="number">118</literal></expr>,<expr><literal type="number">119</literal></expr>,
  <expr><literal type="number">120</literal></expr>,<expr><literal type="number">121</literal></expr>,<expr><literal type="number">122</literal></expr>, <expr><literal type="number">91</literal></expr>, <expr><literal type="number">92</literal></expr>, <expr><literal type="number">93</literal></expr>, <expr><literal type="number">94</literal></expr>, <expr><literal type="number">95</literal></expr>,
   <expr><literal type="number">96</literal></expr>, <expr><literal type="number">97</literal></expr>, <expr><literal type="number">98</literal></expr>, <expr><literal type="number">99</literal></expr>,<expr><literal type="number">100</literal></expr>,<expr><literal type="number">101</literal></expr>,<expr><literal type="number">102</literal></expr>,<expr><literal type="number">103</literal></expr>,
  <expr><literal type="number">104</literal></expr>,<expr><literal type="number">105</literal></expr>,<expr><literal type="number">106</literal></expr>,<expr><literal type="number">107</literal></expr>,<expr><literal type="number">108</literal></expr>,<expr><literal type="number">109</literal></expr>,<expr><literal type="number">110</literal></expr>,<expr><literal type="number">111</literal></expr>,
  <expr><literal type="number">112</literal></expr>,<expr><literal type="number">113</literal></expr>,<expr><literal type="number">114</literal></expr>,<expr><literal type="number">115</literal></expr>,<expr><literal type="number">116</literal></expr>,<expr><literal type="number">117</literal></expr>,<expr><literal type="number">118</literal></expr>,<expr><literal type="number">119</literal></expr>,
  <expr><literal type="number">120</literal></expr>,<expr><literal type="number">121</literal></expr>,<expr><literal type="number">122</literal></expr>,<expr><literal type="number">123</literal></expr>,<expr><literal type="number">124</literal></expr>,<expr><literal type="number">125</literal></expr>,<expr><literal type="number">126</literal></expr>,<expr><literal type="number">127</literal></expr>,
  <expr><literal type="number">128</literal></expr>,<expr><literal type="number">129</literal></expr>,<expr><literal type="number">130</literal></expr>,<expr><literal type="number">131</literal></expr>,<expr><literal type="number">132</literal></expr>,<expr><literal type="number">133</literal></expr>,<expr><literal type="number">134</literal></expr>,<expr><literal type="number">135</literal></expr>,
  <expr><literal type="number">136</literal></expr>,<expr><literal type="number">137</literal></expr>,<expr><literal type="number">138</literal></expr>,<expr><literal type="number">139</literal></expr>,<expr><literal type="number">140</literal></expr>,<expr><literal type="number">141</literal></expr>,<expr><literal type="number">142</literal></expr>,<expr><literal type="number">143</literal></expr>,
  <expr><literal type="number">144</literal></expr>,<expr><literal type="number">145</literal></expr>,<expr><literal type="number">146</literal></expr>,<expr><literal type="number">147</literal></expr>,<expr><literal type="number">148</literal></expr>,<expr><literal type="number">149</literal></expr>,<expr><literal type="number">150</literal></expr>,<expr><literal type="number">151</literal></expr>,
  <expr><literal type="number">152</literal></expr>,<expr><literal type="number">153</literal></expr>,<expr><literal type="number">154</literal></expr>,<expr><literal type="number">155</literal></expr>,<expr><literal type="number">156</literal></expr>,<expr><literal type="number">157</literal></expr>,<expr><literal type="number">158</literal></expr>,<expr><literal type="number">159</literal></expr>,
  <expr><literal type="number">160</literal></expr>,<expr><literal type="number">161</literal></expr>,<expr><literal type="number">162</literal></expr>,<expr><literal type="number">163</literal></expr>,<expr><literal type="number">164</literal></expr>,<expr><literal type="number">165</literal></expr>,<expr><literal type="number">166</literal></expr>,<expr><literal type="number">167</literal></expr>,
  <expr><literal type="number">168</literal></expr>,<expr><literal type="number">169</literal></expr>,<expr><literal type="number">170</literal></expr>,<expr><literal type="number">171</literal></expr>,<expr><literal type="number">172</literal></expr>,<expr><literal type="number">173</literal></expr>,<expr><literal type="number">174</literal></expr>,<expr><literal type="number">175</literal></expr>,
  <expr><literal type="number">176</literal></expr>,<expr><literal type="number">177</literal></expr>,<expr><literal type="number">178</literal></expr>,<expr><literal type="number">179</literal></expr>,<expr><literal type="number">180</literal></expr>,<expr><literal type="number">181</literal></expr>,<expr><literal type="number">182</literal></expr>,<expr><literal type="number">183</literal></expr>,
  <expr><literal type="number">184</literal></expr>,<expr><literal type="number">185</literal></expr>,<expr><literal type="number">186</literal></expr>,<expr><literal type="number">187</literal></expr>,<expr><literal type="number">188</literal></expr>,<expr><literal type="number">189</literal></expr>,<expr><literal type="number">190</literal></expr>,<expr><literal type="number">191</literal></expr>,
  <expr><literal type="number">192</literal></expr>,<expr><literal type="number">193</literal></expr>,<expr><literal type="number">194</literal></expr>,<expr><literal type="number">195</literal></expr>,<expr><literal type="number">196</literal></expr>,<expr><literal type="number">197</literal></expr>,<expr><literal type="number">198</literal></expr>,<expr><literal type="number">199</literal></expr>,
  <expr><literal type="number">200</literal></expr>,<expr><literal type="number">201</literal></expr>,<expr><literal type="number">202</literal></expr>,<expr><literal type="number">203</literal></expr>,<expr><literal type="number">204</literal></expr>,<expr><literal type="number">205</literal></expr>,<expr><literal type="number">206</literal></expr>,<expr><literal type="number">207</literal></expr>,
  <expr><literal type="number">208</literal></expr>,<expr><literal type="number">209</literal></expr>,<expr><literal type="number">210</literal></expr>,<expr><literal type="number">211</literal></expr>,<expr><literal type="number">212</literal></expr>,<expr><literal type="number">213</literal></expr>,<expr><literal type="number">214</literal></expr>,<expr><literal type="number">215</literal></expr>,
  <expr><literal type="number">216</literal></expr>,<expr><literal type="number">217</literal></expr>,<expr><literal type="number">218</literal></expr>,<expr><literal type="number">219</literal></expr>,<expr><literal type="number">220</literal></expr>,<expr><literal type="number">221</literal></expr>,<expr><literal type="number">222</literal></expr>,<expr><literal type="number">223</literal></expr>,
  <expr><literal type="number">224</literal></expr>,<expr><literal type="number">225</literal></expr>,<expr><literal type="number">226</literal></expr>,<expr><literal type="number">227</literal></expr>,<expr><literal type="number">228</literal></expr>,<expr><literal type="number">229</literal></expr>,<expr><literal type="number">230</literal></expr>,<expr><literal type="number">231</literal></expr>,
  <expr><literal type="number">232</literal></expr>,<expr><literal type="number">233</literal></expr>,<expr><literal type="number">234</literal></expr>,<expr><literal type="number">235</literal></expr>,<expr><literal type="number">236</literal></expr>,<expr><literal type="number">237</literal></expr>,<expr><literal type="number">238</literal></expr>,<expr><literal type="number">239</literal></expr>,
  <expr><literal type="number">240</literal></expr>,<expr><literal type="number">241</literal></expr>,<expr><literal type="number">242</literal></expr>,<expr><literal type="number">243</literal></expr>,<expr><literal type="number">244</literal></expr>,<expr><literal type="number">245</literal></expr>,<expr><literal type="number">246</literal></expr>,<expr><literal type="number">247</literal></expr>,
  <expr><literal type="number">248</literal></expr>,<expr><literal type="number">249</literal></expr>,<expr><literal type="number">250</literal></expr>,<expr><literal type="number">251</literal></expr>,<expr><literal type="number">252</literal></expr>,<expr><literal type="number">253</literal></expr>,<expr><literal type="number">254</literal></expr>,<expr><literal type="number">255</literal></expr>,

<comment type="block">/* This table is a case flipping table. */</comment>

    <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">6</literal></expr>,  <expr><literal type="number">7</literal></expr>,
    <expr><literal type="number">8</literal></expr>,  <expr><literal type="number">9</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">11</literal></expr>, <expr><literal type="number">12</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">14</literal></expr>, <expr><literal type="number">15</literal></expr>,
   <expr><literal type="number">16</literal></expr>, <expr><literal type="number">17</literal></expr>, <expr><literal type="number">18</literal></expr>, <expr><literal type="number">19</literal></expr>, <expr><literal type="number">20</literal></expr>, <expr><literal type="number">21</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">23</literal></expr>,
   <expr><literal type="number">24</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><literal type="number">26</literal></expr>, <expr><literal type="number">27</literal></expr>, <expr><literal type="number">28</literal></expr>, <expr><literal type="number">29</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">31</literal></expr>,
   <expr><literal type="number">32</literal></expr>, <expr><literal type="number">33</literal></expr>, <expr><literal type="number">34</literal></expr>, <expr><literal type="number">35</literal></expr>, <expr><literal type="number">36</literal></expr>, <expr><literal type="number">37</literal></expr>, <expr><literal type="number">38</literal></expr>, <expr><literal type="number">39</literal></expr>,
   <expr><literal type="number">40</literal></expr>, <expr><literal type="number">41</literal></expr>, <expr><literal type="number">42</literal></expr>, <expr><literal type="number">43</literal></expr>, <expr><literal type="number">44</literal></expr>, <expr><literal type="number">45</literal></expr>, <expr><literal type="number">46</literal></expr>, <expr><literal type="number">47</literal></expr>,
   <expr><literal type="number">48</literal></expr>, <expr><literal type="number">49</literal></expr>, <expr><literal type="number">50</literal></expr>, <expr><literal type="number">51</literal></expr>, <expr><literal type="number">52</literal></expr>, <expr><literal type="number">53</literal></expr>, <expr><literal type="number">54</literal></expr>, <expr><literal type="number">55</literal></expr>,
   <expr><literal type="number">56</literal></expr>, <expr><literal type="number">57</literal></expr>, <expr><literal type="number">58</literal></expr>, <expr><literal type="number">59</literal></expr>, <expr><literal type="number">60</literal></expr>, <expr><literal type="number">61</literal></expr>, <expr><literal type="number">62</literal></expr>, <expr><literal type="number">63</literal></expr>,
   <expr><literal type="number">64</literal></expr>, <expr><literal type="number">97</literal></expr>, <expr><literal type="number">98</literal></expr>, <expr><literal type="number">99</literal></expr>,<expr><literal type="number">100</literal></expr>,<expr><literal type="number">101</literal></expr>,<expr><literal type="number">102</literal></expr>,<expr><literal type="number">103</literal></expr>,
  <expr><literal type="number">104</literal></expr>,<expr><literal type="number">105</literal></expr>,<expr><literal type="number">106</literal></expr>,<expr><literal type="number">107</literal></expr>,<expr><literal type="number">108</literal></expr>,<expr><literal type="number">109</literal></expr>,<expr><literal type="number">110</literal></expr>,<expr><literal type="number">111</literal></expr>,
  <expr><literal type="number">112</literal></expr>,<expr><literal type="number">113</literal></expr>,<expr><literal type="number">114</literal></expr>,<expr><literal type="number">115</literal></expr>,<expr><literal type="number">116</literal></expr>,<expr><literal type="number">117</literal></expr>,<expr><literal type="number">118</literal></expr>,<expr><literal type="number">119</literal></expr>,
  <expr><literal type="number">120</literal></expr>,<expr><literal type="number">121</literal></expr>,<expr><literal type="number">122</literal></expr>, <expr><literal type="number">91</literal></expr>, <expr><literal type="number">92</literal></expr>, <expr><literal type="number">93</literal></expr>, <expr><literal type="number">94</literal></expr>, <expr><literal type="number">95</literal></expr>,
   <expr><literal type="number">96</literal></expr>, <expr><literal type="number">65</literal></expr>, <expr><literal type="number">66</literal></expr>, <expr><literal type="number">67</literal></expr>, <expr><literal type="number">68</literal></expr>, <expr><literal type="number">69</literal></expr>, <expr><literal type="number">70</literal></expr>, <expr><literal type="number">71</literal></expr>,
   <expr><literal type="number">72</literal></expr>, <expr><literal type="number">73</literal></expr>, <expr><literal type="number">74</literal></expr>, <expr><literal type="number">75</literal></expr>, <expr><literal type="number">76</literal></expr>, <expr><literal type="number">77</literal></expr>, <expr><literal type="number">78</literal></expr>, <expr><literal type="number">79</literal></expr>,
   <expr><literal type="number">80</literal></expr>, <expr><literal type="number">81</literal></expr>, <expr><literal type="number">82</literal></expr>, <expr><literal type="number">83</literal></expr>, <expr><literal type="number">84</literal></expr>, <expr><literal type="number">85</literal></expr>, <expr><literal type="number">86</literal></expr>, <expr><literal type="number">87</literal></expr>,
   <expr><literal type="number">88</literal></expr>, <expr><literal type="number">89</literal></expr>, <expr><literal type="number">90</literal></expr>,<expr><literal type="number">123</literal></expr>,<expr><literal type="number">124</literal></expr>,<expr><literal type="number">125</literal></expr>,<expr><literal type="number">126</literal></expr>,<expr><literal type="number">127</literal></expr>,
  <expr><literal type="number">128</literal></expr>,<expr><literal type="number">129</literal></expr>,<expr><literal type="number">130</literal></expr>,<expr><literal type="number">131</literal></expr>,<expr><literal type="number">132</literal></expr>,<expr><literal type="number">133</literal></expr>,<expr><literal type="number">134</literal></expr>,<expr><literal type="number">135</literal></expr>,
  <expr><literal type="number">136</literal></expr>,<expr><literal type="number">137</literal></expr>,<expr><literal type="number">138</literal></expr>,<expr><literal type="number">139</literal></expr>,<expr><literal type="number">140</literal></expr>,<expr><literal type="number">141</literal></expr>,<expr><literal type="number">142</literal></expr>,<expr><literal type="number">143</literal></expr>,
  <expr><literal type="number">144</literal></expr>,<expr><literal type="number">145</literal></expr>,<expr><literal type="number">146</literal></expr>,<expr><literal type="number">147</literal></expr>,<expr><literal type="number">148</literal></expr>,<expr><literal type="number">149</literal></expr>,<expr><literal type="number">150</literal></expr>,<expr><literal type="number">151</literal></expr>,
  <expr><literal type="number">152</literal></expr>,<expr><literal type="number">153</literal></expr>,<expr><literal type="number">154</literal></expr>,<expr><literal type="number">155</literal></expr>,<expr><literal type="number">156</literal></expr>,<expr><literal type="number">157</literal></expr>,<expr><literal type="number">158</literal></expr>,<expr><literal type="number">159</literal></expr>,
  <expr><literal type="number">160</literal></expr>,<expr><literal type="number">161</literal></expr>,<expr><literal type="number">162</literal></expr>,<expr><literal type="number">163</literal></expr>,<expr><literal type="number">164</literal></expr>,<expr><literal type="number">165</literal></expr>,<expr><literal type="number">166</literal></expr>,<expr><literal type="number">167</literal></expr>,
  <expr><literal type="number">168</literal></expr>,<expr><literal type="number">169</literal></expr>,<expr><literal type="number">170</literal></expr>,<expr><literal type="number">171</literal></expr>,<expr><literal type="number">172</literal></expr>,<expr><literal type="number">173</literal></expr>,<expr><literal type="number">174</literal></expr>,<expr><literal type="number">175</literal></expr>,
  <expr><literal type="number">176</literal></expr>,<expr><literal type="number">177</literal></expr>,<expr><literal type="number">178</literal></expr>,<expr><literal type="number">179</literal></expr>,<expr><literal type="number">180</literal></expr>,<expr><literal type="number">181</literal></expr>,<expr><literal type="number">182</literal></expr>,<expr><literal type="number">183</literal></expr>,
  <expr><literal type="number">184</literal></expr>,<expr><literal type="number">185</literal></expr>,<expr><literal type="number">186</literal></expr>,<expr><literal type="number">187</literal></expr>,<expr><literal type="number">188</literal></expr>,<expr><literal type="number">189</literal></expr>,<expr><literal type="number">190</literal></expr>,<expr><literal type="number">191</literal></expr>,
  <expr><literal type="number">192</literal></expr>,<expr><literal type="number">193</literal></expr>,<expr><literal type="number">194</literal></expr>,<expr><literal type="number">195</literal></expr>,<expr><literal type="number">196</literal></expr>,<expr><literal type="number">197</literal></expr>,<expr><literal type="number">198</literal></expr>,<expr><literal type="number">199</literal></expr>,
  <expr><literal type="number">200</literal></expr>,<expr><literal type="number">201</literal></expr>,<expr><literal type="number">202</literal></expr>,<expr><literal type="number">203</literal></expr>,<expr><literal type="number">204</literal></expr>,<expr><literal type="number">205</literal></expr>,<expr><literal type="number">206</literal></expr>,<expr><literal type="number">207</literal></expr>,
  <expr><literal type="number">208</literal></expr>,<expr><literal type="number">209</literal></expr>,<expr><literal type="number">210</literal></expr>,<expr><literal type="number">211</literal></expr>,<expr><literal type="number">212</literal></expr>,<expr><literal type="number">213</literal></expr>,<expr><literal type="number">214</literal></expr>,<expr><literal type="number">215</literal></expr>,
  <expr><literal type="number">216</literal></expr>,<expr><literal type="number">217</literal></expr>,<expr><literal type="number">218</literal></expr>,<expr><literal type="number">219</literal></expr>,<expr><literal type="number">220</literal></expr>,<expr><literal type="number">221</literal></expr>,<expr><literal type="number">222</literal></expr>,<expr><literal type="number">223</literal></expr>,
  <expr><literal type="number">224</literal></expr>,<expr><literal type="number">225</literal></expr>,<expr><literal type="number">226</literal></expr>,<expr><literal type="number">227</literal></expr>,<expr><literal type="number">228</literal></expr>,<expr><literal type="number">229</literal></expr>,<expr><literal type="number">230</literal></expr>,<expr><literal type="number">231</literal></expr>,
  <expr><literal type="number">232</literal></expr>,<expr><literal type="number">233</literal></expr>,<expr><literal type="number">234</literal></expr>,<expr><literal type="number">235</literal></expr>,<expr><literal type="number">236</literal></expr>,<expr><literal type="number">237</literal></expr>,<expr><literal type="number">238</literal></expr>,<expr><literal type="number">239</literal></expr>,
  <expr><literal type="number">240</literal></expr>,<expr><literal type="number">241</literal></expr>,<expr><literal type="number">242</literal></expr>,<expr><literal type="number">243</literal></expr>,<expr><literal type="number">244</literal></expr>,<expr><literal type="number">245</literal></expr>,<expr><literal type="number">246</literal></expr>,<expr><literal type="number">247</literal></expr>,
  <expr><literal type="number">248</literal></expr>,<expr><literal type="number">249</literal></expr>,<expr><literal type="number">250</literal></expr>,<expr><literal type="number">251</literal></expr>,<expr><literal type="number">252</literal></expr>,<expr><literal type="number">253</literal></expr>,<expr><literal type="number">254</literal></expr>,<expr><literal type="number">255</literal></expr>,

<comment type="block">/* This table contains bit maps for various character classes. Each map is 32
bytes long and the bits run from the least significant end of each byte. The
classes that have their own maps are: space, xdigit, digit, upper, lower, word,
graph, print, punct, and cntrl. Other classes are built from combinations. */</comment>

  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x3e</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,

  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0x03</literal></expr>,
  <expr><literal type="number">0x7e</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x7e</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,

  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0x03</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,

  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,
  <expr><literal type="number">0xfe</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0x07</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,

  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0xfe</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0x07</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,

  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0x03</literal></expr>,
  <expr><literal type="number">0xfe</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0x87</literal></expr>,<expr><literal type="number">0xfe</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0x07</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,

  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0xfe</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0x7f</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,

  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0x7f</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,

  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0xfe</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0xfc</literal></expr>,
  <expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0xf8</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x78</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,

  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x80</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,

<comment type="block">/* This table identifies various classes of character by individual bits:
  0x01   white space character
  0x02   letter
  0x04   decimal digit
  0x08   hexadecimal digit
  0x10   alphanumeric or '_'
  0x80   regular expression metacharacter or binary zero
*/</comment>

  <expr><literal type="number">0x80</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/*   0-  7 */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/*   8- 15 */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/*  16- 23 */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/*  24- 31 */</comment>
  <expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x80</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/*    - '  */</comment>
  <expr><literal type="number">0x80</literal></expr>,<expr><literal type="number">0x80</literal></expr>,<expr><literal type="number">0x80</literal></expr>,<expr><literal type="number">0x80</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x80</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/*  ( - /  */</comment>
  <expr><literal type="number">0x1c</literal></expr>,<expr><literal type="number">0x1c</literal></expr>,<expr><literal type="number">0x1c</literal></expr>,<expr><literal type="number">0x1c</literal></expr>,<expr><literal type="number">0x1c</literal></expr>,<expr><literal type="number">0x1c</literal></expr>,<expr><literal type="number">0x1c</literal></expr>,<expr><literal type="number">0x1c</literal></expr>, <comment type="block">/*  0 - 7  */</comment>
  <expr><literal type="number">0x1c</literal></expr>,<expr><literal type="number">0x1c</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x80</literal></expr>, <comment type="block">/*  8 - ?  */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x1a</literal></expr>,<expr><literal type="number">0x1a</literal></expr>,<expr><literal type="number">0x1a</literal></expr>,<expr><literal type="number">0x1a</literal></expr>,<expr><literal type="number">0x1a</literal></expr>,<expr><literal type="number">0x1a</literal></expr>,<expr><literal type="number">0x12</literal></expr>, <comment type="block">/*  @ - G  */</comment>
  <expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>, <comment type="block">/*  H - O  */</comment>
  <expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>, <comment type="block">/*  P - W  */</comment>
  <expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x80</literal></expr>,<expr><literal type="number">0x80</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x80</literal></expr>,<expr><literal type="number">0x10</literal></expr>, <comment type="block">/*  X - _  */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x1a</literal></expr>,<expr><literal type="number">0x1a</literal></expr>,<expr><literal type="number">0x1a</literal></expr>,<expr><literal type="number">0x1a</literal></expr>,<expr><literal type="number">0x1a</literal></expr>,<expr><literal type="number">0x1a</literal></expr>,<expr><literal type="number">0x12</literal></expr>, <comment type="block">/*  ` - g  */</comment>
  <expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>, <comment type="block">/*  h - o  */</comment>
  <expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>, <comment type="block">/*  p - w  */</comment>
  <expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x12</literal></expr>,<expr><literal type="number">0x80</literal></expr>,<expr><literal type="number">0x80</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/*  x -127 */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/* 128-135 */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/* 136-143 */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/* 144-151 */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/* 152-159 */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/* 160-167 */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/* 168-175 */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/* 176-183 */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/* 184-191 */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/* 192-199 */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/* 200-207 */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/* 208-215 */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/* 216-223 */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/* 224-231 */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/* 232-239 */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>, <comment type="block">/* 240-247 */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x00</literal></expr>}</block></expr></init></decl>;</decl_stmt><comment type="block">/* 248-255 */</comment>

<comment type="block">/* This is a set of tables that came originally from a Windows user. It seems
to be at least an approximation of ISO 8859. In particular, there are
characters greater than 128 that are marked as spaces, letters, etc. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>tables2</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">7</literal></expr>,
<expr><literal type="number">8</literal></expr>,<expr><literal type="number">9</literal></expr>,<expr><literal type="number">10</literal></expr>,<expr><literal type="number">11</literal></expr>,<expr><literal type="number">12</literal></expr>,<expr><literal type="number">13</literal></expr>,<expr><literal type="number">14</literal></expr>,<expr><literal type="number">15</literal></expr>,
<expr><literal type="number">16</literal></expr>,<expr><literal type="number">17</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">19</literal></expr>,<expr><literal type="number">20</literal></expr>,<expr><literal type="number">21</literal></expr>,<expr><literal type="number">22</literal></expr>,<expr><literal type="number">23</literal></expr>,
<expr><literal type="number">24</literal></expr>,<expr><literal type="number">25</literal></expr>,<expr><literal type="number">26</literal></expr>,<expr><literal type="number">27</literal></expr>,<expr><literal type="number">28</literal></expr>,<expr><literal type="number">29</literal></expr>,<expr><literal type="number">30</literal></expr>,<expr><literal type="number">31</literal></expr>,
<expr><literal type="number">32</literal></expr>,<expr><literal type="number">33</literal></expr>,<expr><literal type="number">34</literal></expr>,<expr><literal type="number">35</literal></expr>,<expr><literal type="number">36</literal></expr>,<expr><literal type="number">37</literal></expr>,<expr><literal type="number">38</literal></expr>,<expr><literal type="number">39</literal></expr>,
<expr><literal type="number">40</literal></expr>,<expr><literal type="number">41</literal></expr>,<expr><literal type="number">42</literal></expr>,<expr><literal type="number">43</literal></expr>,<expr><literal type="number">44</literal></expr>,<expr><literal type="number">45</literal></expr>,<expr><literal type="number">46</literal></expr>,<expr><literal type="number">47</literal></expr>,
<expr><literal type="number">48</literal></expr>,<expr><literal type="number">49</literal></expr>,<expr><literal type="number">50</literal></expr>,<expr><literal type="number">51</literal></expr>,<expr><literal type="number">52</literal></expr>,<expr><literal type="number">53</literal></expr>,<expr><literal type="number">54</literal></expr>,<expr><literal type="number">55</literal></expr>,
<expr><literal type="number">56</literal></expr>,<expr><literal type="number">57</literal></expr>,<expr><literal type="number">58</literal></expr>,<expr><literal type="number">59</literal></expr>,<expr><literal type="number">60</literal></expr>,<expr><literal type="number">61</literal></expr>,<expr><literal type="number">62</literal></expr>,<expr><literal type="number">63</literal></expr>,
<expr><literal type="number">64</literal></expr>,<expr><literal type="number">97</literal></expr>,<expr><literal type="number">98</literal></expr>,<expr><literal type="number">99</literal></expr>,<expr><literal type="number">100</literal></expr>,<expr><literal type="number">101</literal></expr>,<expr><literal type="number">102</literal></expr>,<expr><literal type="number">103</literal></expr>,
<expr><literal type="number">104</literal></expr>,<expr><literal type="number">105</literal></expr>,<expr><literal type="number">106</literal></expr>,<expr><literal type="number">107</literal></expr>,<expr><literal type="number">108</literal></expr>,<expr><literal type="number">109</literal></expr>,<expr><literal type="number">110</literal></expr>,<expr><literal type="number">111</literal></expr>,
<expr><literal type="number">112</literal></expr>,<expr><literal type="number">113</literal></expr>,<expr><literal type="number">114</literal></expr>,<expr><literal type="number">115</literal></expr>,<expr><literal type="number">116</literal></expr>,<expr><literal type="number">117</literal></expr>,<expr><literal type="number">118</literal></expr>,<expr><literal type="number">119</literal></expr>,
<expr><literal type="number">120</literal></expr>,<expr><literal type="number">121</literal></expr>,<expr><literal type="number">122</literal></expr>,<expr><literal type="number">91</literal></expr>,<expr><literal type="number">92</literal></expr>,<expr><literal type="number">93</literal></expr>,<expr><literal type="number">94</literal></expr>,<expr><literal type="number">95</literal></expr>,
<expr><literal type="number">96</literal></expr>,<expr><literal type="number">97</literal></expr>,<expr><literal type="number">98</literal></expr>,<expr><literal type="number">99</literal></expr>,<expr><literal type="number">100</literal></expr>,<expr><literal type="number">101</literal></expr>,<expr><literal type="number">102</literal></expr>,<expr><literal type="number">103</literal></expr>,
<expr><literal type="number">104</literal></expr>,<expr><literal type="number">105</literal></expr>,<expr><literal type="number">106</literal></expr>,<expr><literal type="number">107</literal></expr>,<expr><literal type="number">108</literal></expr>,<expr><literal type="number">109</literal></expr>,<expr><literal type="number">110</literal></expr>,<expr><literal type="number">111</literal></expr>,
<expr><literal type="number">112</literal></expr>,<expr><literal type="number">113</literal></expr>,<expr><literal type="number">114</literal></expr>,<expr><literal type="number">115</literal></expr>,<expr><literal type="number">116</literal></expr>,<expr><literal type="number">117</literal></expr>,<expr><literal type="number">118</literal></expr>,<expr><literal type="number">119</literal></expr>,
<expr><literal type="number">120</literal></expr>,<expr><literal type="number">121</literal></expr>,<expr><literal type="number">122</literal></expr>,<expr><literal type="number">123</literal></expr>,<expr><literal type="number">124</literal></expr>,<expr><literal type="number">125</literal></expr>,<expr><literal type="number">126</literal></expr>,<expr><literal type="number">127</literal></expr>,
<expr><literal type="number">128</literal></expr>,<expr><literal type="number">129</literal></expr>,<expr><literal type="number">130</literal></expr>,<expr><literal type="number">131</literal></expr>,<expr><literal type="number">132</literal></expr>,<expr><literal type="number">133</literal></expr>,<expr><literal type="number">134</literal></expr>,<expr><literal type="number">135</literal></expr>,
<expr><literal type="number">136</literal></expr>,<expr><literal type="number">137</literal></expr>,<expr><literal type="number">138</literal></expr>,<expr><literal type="number">139</literal></expr>,<expr><literal type="number">140</literal></expr>,<expr><literal type="number">141</literal></expr>,<expr><literal type="number">142</literal></expr>,<expr><literal type="number">143</literal></expr>,
<expr><literal type="number">144</literal></expr>,<expr><literal type="number">145</literal></expr>,<expr><literal type="number">146</literal></expr>,<expr><literal type="number">147</literal></expr>,<expr><literal type="number">148</literal></expr>,<expr><literal type="number">149</literal></expr>,<expr><literal type="number">150</literal></expr>,<expr><literal type="number">151</literal></expr>,
<expr><literal type="number">152</literal></expr>,<expr><literal type="number">153</literal></expr>,<expr><literal type="number">154</literal></expr>,<expr><literal type="number">155</literal></expr>,<expr><literal type="number">156</literal></expr>,<expr><literal type="number">157</literal></expr>,<expr><literal type="number">158</literal></expr>,<expr><literal type="number">159</literal></expr>,
<expr><literal type="number">160</literal></expr>,<expr><literal type="number">161</literal></expr>,<expr><literal type="number">162</literal></expr>,<expr><literal type="number">163</literal></expr>,<expr><literal type="number">164</literal></expr>,<expr><literal type="number">165</literal></expr>,<expr><literal type="number">166</literal></expr>,<expr><literal type="number">167</literal></expr>,
<expr><literal type="number">168</literal></expr>,<expr><literal type="number">169</literal></expr>,<expr><literal type="number">170</literal></expr>,<expr><literal type="number">171</literal></expr>,<expr><literal type="number">172</literal></expr>,<expr><literal type="number">173</literal></expr>,<expr><literal type="number">174</literal></expr>,<expr><literal type="number">175</literal></expr>,
<expr><literal type="number">176</literal></expr>,<expr><literal type="number">177</literal></expr>,<expr><literal type="number">178</literal></expr>,<expr><literal type="number">179</literal></expr>,<expr><literal type="number">180</literal></expr>,<expr><literal type="number">181</literal></expr>,<expr><literal type="number">182</literal></expr>,<expr><literal type="number">183</literal></expr>,
<expr><literal type="number">184</literal></expr>,<expr><literal type="number">185</literal></expr>,<expr><literal type="number">186</literal></expr>,<expr><literal type="number">187</literal></expr>,<expr><literal type="number">188</literal></expr>,<expr><literal type="number">189</literal></expr>,<expr><literal type="number">190</literal></expr>,<expr><literal type="number">191</literal></expr>,
<expr><literal type="number">224</literal></expr>,<expr><literal type="number">225</literal></expr>,<expr><literal type="number">226</literal></expr>,<expr><literal type="number">227</literal></expr>,<expr><literal type="number">228</literal></expr>,<expr><literal type="number">229</literal></expr>,<expr><literal type="number">230</literal></expr>,<expr><literal type="number">231</literal></expr>,
<expr><literal type="number">232</literal></expr>,<expr><literal type="number">233</literal></expr>,<expr><literal type="number">234</literal></expr>,<expr><literal type="number">235</literal></expr>,<expr><literal type="number">236</literal></expr>,<expr><literal type="number">237</literal></expr>,<expr><literal type="number">238</literal></expr>,<expr><literal type="number">239</literal></expr>,
<expr><literal type="number">240</literal></expr>,<expr><literal type="number">241</literal></expr>,<expr><literal type="number">242</literal></expr>,<expr><literal type="number">243</literal></expr>,<expr><literal type="number">244</literal></expr>,<expr><literal type="number">245</literal></expr>,<expr><literal type="number">246</literal></expr>,<expr><literal type="number">215</literal></expr>,
<expr><literal type="number">248</literal></expr>,<expr><literal type="number">249</literal></expr>,<expr><literal type="number">250</literal></expr>,<expr><literal type="number">251</literal></expr>,<expr><literal type="number">252</literal></expr>,<expr><literal type="number">253</literal></expr>,<expr><literal type="number">254</literal></expr>,<expr><literal type="number">223</literal></expr>,
<expr><literal type="number">224</literal></expr>,<expr><literal type="number">225</literal></expr>,<expr><literal type="number">226</literal></expr>,<expr><literal type="number">227</literal></expr>,<expr><literal type="number">228</literal></expr>,<expr><literal type="number">229</literal></expr>,<expr><literal type="number">230</literal></expr>,<expr><literal type="number">231</literal></expr>,
<expr><literal type="number">232</literal></expr>,<expr><literal type="number">233</literal></expr>,<expr><literal type="number">234</literal></expr>,<expr><literal type="number">235</literal></expr>,<expr><literal type="number">236</literal></expr>,<expr><literal type="number">237</literal></expr>,<expr><literal type="number">238</literal></expr>,<expr><literal type="number">239</literal></expr>,
<expr><literal type="number">240</literal></expr>,<expr><literal type="number">241</literal></expr>,<expr><literal type="number">242</literal></expr>,<expr><literal type="number">243</literal></expr>,<expr><literal type="number">244</literal></expr>,<expr><literal type="number">245</literal></expr>,<expr><literal type="number">246</literal></expr>,<expr><literal type="number">247</literal></expr>,
<expr><literal type="number">248</literal></expr>,<expr><literal type="number">249</literal></expr>,<expr><literal type="number">250</literal></expr>,<expr><literal type="number">251</literal></expr>,<expr><literal type="number">252</literal></expr>,<expr><literal type="number">253</literal></expr>,<expr><literal type="number">254</literal></expr>,<expr><literal type="number">255</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">7</literal></expr>,
<expr><literal type="number">8</literal></expr>,<expr><literal type="number">9</literal></expr>,<expr><literal type="number">10</literal></expr>,<expr><literal type="number">11</literal></expr>,<expr><literal type="number">12</literal></expr>,<expr><literal type="number">13</literal></expr>,<expr><literal type="number">14</literal></expr>,<expr><literal type="number">15</literal></expr>,
<expr><literal type="number">16</literal></expr>,<expr><literal type="number">17</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">19</literal></expr>,<expr><literal type="number">20</literal></expr>,<expr><literal type="number">21</literal></expr>,<expr><literal type="number">22</literal></expr>,<expr><literal type="number">23</literal></expr>,
<expr><literal type="number">24</literal></expr>,<expr><literal type="number">25</literal></expr>,<expr><literal type="number">26</literal></expr>,<expr><literal type="number">27</literal></expr>,<expr><literal type="number">28</literal></expr>,<expr><literal type="number">29</literal></expr>,<expr><literal type="number">30</literal></expr>,<expr><literal type="number">31</literal></expr>,
<expr><literal type="number">32</literal></expr>,<expr><literal type="number">33</literal></expr>,<expr><literal type="number">34</literal></expr>,<expr><literal type="number">35</literal></expr>,<expr><literal type="number">36</literal></expr>,<expr><literal type="number">37</literal></expr>,<expr><literal type="number">38</literal></expr>,<expr><literal type="number">39</literal></expr>,
<expr><literal type="number">40</literal></expr>,<expr><literal type="number">41</literal></expr>,<expr><literal type="number">42</literal></expr>,<expr><literal type="number">43</literal></expr>,<expr><literal type="number">44</literal></expr>,<expr><literal type="number">45</literal></expr>,<expr><literal type="number">46</literal></expr>,<expr><literal type="number">47</literal></expr>,
<expr><literal type="number">48</literal></expr>,<expr><literal type="number">49</literal></expr>,<expr><literal type="number">50</literal></expr>,<expr><literal type="number">51</literal></expr>,<expr><literal type="number">52</literal></expr>,<expr><literal type="number">53</literal></expr>,<expr><literal type="number">54</literal></expr>,<expr><literal type="number">55</literal></expr>,
<expr><literal type="number">56</literal></expr>,<expr><literal type="number">57</literal></expr>,<expr><literal type="number">58</literal></expr>,<expr><literal type="number">59</literal></expr>,<expr><literal type="number">60</literal></expr>,<expr><literal type="number">61</literal></expr>,<expr><literal type="number">62</literal></expr>,<expr><literal type="number">63</literal></expr>,
<expr><literal type="number">64</literal></expr>,<expr><literal type="number">97</literal></expr>,<expr><literal type="number">98</literal></expr>,<expr><literal type="number">99</literal></expr>,<expr><literal type="number">100</literal></expr>,<expr><literal type="number">101</literal></expr>,<expr><literal type="number">102</literal></expr>,<expr><literal type="number">103</literal></expr>,
<expr><literal type="number">104</literal></expr>,<expr><literal type="number">105</literal></expr>,<expr><literal type="number">106</literal></expr>,<expr><literal type="number">107</literal></expr>,<expr><literal type="number">108</literal></expr>,<expr><literal type="number">109</literal></expr>,<expr><literal type="number">110</literal></expr>,<expr><literal type="number">111</literal></expr>,
<expr><literal type="number">112</literal></expr>,<expr><literal type="number">113</literal></expr>,<expr><literal type="number">114</literal></expr>,<expr><literal type="number">115</literal></expr>,<expr><literal type="number">116</literal></expr>,<expr><literal type="number">117</literal></expr>,<expr><literal type="number">118</literal></expr>,<expr><literal type="number">119</literal></expr>,
<expr><literal type="number">120</literal></expr>,<expr><literal type="number">121</literal></expr>,<expr><literal type="number">122</literal></expr>,<expr><literal type="number">91</literal></expr>,<expr><literal type="number">92</literal></expr>,<expr><literal type="number">93</literal></expr>,<expr><literal type="number">94</literal></expr>,<expr><literal type="number">95</literal></expr>,
<expr><literal type="number">96</literal></expr>,<expr><literal type="number">65</literal></expr>,<expr><literal type="number">66</literal></expr>,<expr><literal type="number">67</literal></expr>,<expr><literal type="number">68</literal></expr>,<expr><literal type="number">69</literal></expr>,<expr><literal type="number">70</literal></expr>,<expr><literal type="number">71</literal></expr>,
<expr><literal type="number">72</literal></expr>,<expr><literal type="number">73</literal></expr>,<expr><literal type="number">74</literal></expr>,<expr><literal type="number">75</literal></expr>,<expr><literal type="number">76</literal></expr>,<expr><literal type="number">77</literal></expr>,<expr><literal type="number">78</literal></expr>,<expr><literal type="number">79</literal></expr>,
<expr><literal type="number">80</literal></expr>,<expr><literal type="number">81</literal></expr>,<expr><literal type="number">82</literal></expr>,<expr><literal type="number">83</literal></expr>,<expr><literal type="number">84</literal></expr>,<expr><literal type="number">85</literal></expr>,<expr><literal type="number">86</literal></expr>,<expr><literal type="number">87</literal></expr>,
<expr><literal type="number">88</literal></expr>,<expr><literal type="number">89</literal></expr>,<expr><literal type="number">90</literal></expr>,<expr><literal type="number">123</literal></expr>,<expr><literal type="number">124</literal></expr>,<expr><literal type="number">125</literal></expr>,<expr><literal type="number">126</literal></expr>,<expr><literal type="number">127</literal></expr>,
<expr><literal type="number">128</literal></expr>,<expr><literal type="number">129</literal></expr>,<expr><literal type="number">130</literal></expr>,<expr><literal type="number">131</literal></expr>,<expr><literal type="number">132</literal></expr>,<expr><literal type="number">133</literal></expr>,<expr><literal type="number">134</literal></expr>,<expr><literal type="number">135</literal></expr>,
<expr><literal type="number">136</literal></expr>,<expr><literal type="number">137</literal></expr>,<expr><literal type="number">138</literal></expr>,<expr><literal type="number">139</literal></expr>,<expr><literal type="number">140</literal></expr>,<expr><literal type="number">141</literal></expr>,<expr><literal type="number">142</literal></expr>,<expr><literal type="number">143</literal></expr>,
<expr><literal type="number">144</literal></expr>,<expr><literal type="number">145</literal></expr>,<expr><literal type="number">146</literal></expr>,<expr><literal type="number">147</literal></expr>,<expr><literal type="number">148</literal></expr>,<expr><literal type="number">149</literal></expr>,<expr><literal type="number">150</literal></expr>,<expr><literal type="number">151</literal></expr>,
<expr><literal type="number">152</literal></expr>,<expr><literal type="number">153</literal></expr>,<expr><literal type="number">154</literal></expr>,<expr><literal type="number">155</literal></expr>,<expr><literal type="number">156</literal></expr>,<expr><literal type="number">157</literal></expr>,<expr><literal type="number">158</literal></expr>,<expr><literal type="number">159</literal></expr>,
<expr><literal type="number">160</literal></expr>,<expr><literal type="number">161</literal></expr>,<expr><literal type="number">162</literal></expr>,<expr><literal type="number">163</literal></expr>,<expr><literal type="number">164</literal></expr>,<expr><literal type="number">165</literal></expr>,<expr><literal type="number">166</literal></expr>,<expr><literal type="number">167</literal></expr>,
<expr><literal type="number">168</literal></expr>,<expr><literal type="number">169</literal></expr>,<expr><literal type="number">170</literal></expr>,<expr><literal type="number">171</literal></expr>,<expr><literal type="number">172</literal></expr>,<expr><literal type="number">173</literal></expr>,<expr><literal type="number">174</literal></expr>,<expr><literal type="number">175</literal></expr>,
<expr><literal type="number">176</literal></expr>,<expr><literal type="number">177</literal></expr>,<expr><literal type="number">178</literal></expr>,<expr><literal type="number">179</literal></expr>,<expr><literal type="number">180</literal></expr>,<expr><literal type="number">181</literal></expr>,<expr><literal type="number">182</literal></expr>,<expr><literal type="number">183</literal></expr>,
<expr><literal type="number">184</literal></expr>,<expr><literal type="number">185</literal></expr>,<expr><literal type="number">186</literal></expr>,<expr><literal type="number">187</literal></expr>,<expr><literal type="number">188</literal></expr>,<expr><literal type="number">189</literal></expr>,<expr><literal type="number">190</literal></expr>,<expr><literal type="number">191</literal></expr>,
<expr><literal type="number">224</literal></expr>,<expr><literal type="number">225</literal></expr>,<expr><literal type="number">226</literal></expr>,<expr><literal type="number">227</literal></expr>,<expr><literal type="number">228</literal></expr>,<expr><literal type="number">229</literal></expr>,<expr><literal type="number">230</literal></expr>,<expr><literal type="number">231</literal></expr>,
<expr><literal type="number">232</literal></expr>,<expr><literal type="number">233</literal></expr>,<expr><literal type="number">234</literal></expr>,<expr><literal type="number">235</literal></expr>,<expr><literal type="number">236</literal></expr>,<expr><literal type="number">237</literal></expr>,<expr><literal type="number">238</literal></expr>,<expr><literal type="number">239</literal></expr>,
<expr><literal type="number">240</literal></expr>,<expr><literal type="number">241</literal></expr>,<expr><literal type="number">242</literal></expr>,<expr><literal type="number">243</literal></expr>,<expr><literal type="number">244</literal></expr>,<expr><literal type="number">245</literal></expr>,<expr><literal type="number">246</literal></expr>,<expr><literal type="number">215</literal></expr>,
<expr><literal type="number">248</literal></expr>,<expr><literal type="number">249</literal></expr>,<expr><literal type="number">250</literal></expr>,<expr><literal type="number">251</literal></expr>,<expr><literal type="number">252</literal></expr>,<expr><literal type="number">253</literal></expr>,<expr><literal type="number">254</literal></expr>,<expr><literal type="number">223</literal></expr>,
<expr><literal type="number">192</literal></expr>,<expr><literal type="number">193</literal></expr>,<expr><literal type="number">194</literal></expr>,<expr><literal type="number">195</literal></expr>,<expr><literal type="number">196</literal></expr>,<expr><literal type="number">197</literal></expr>,<expr><literal type="number">198</literal></expr>,<expr><literal type="number">199</literal></expr>,
<expr><literal type="number">200</literal></expr>,<expr><literal type="number">201</literal></expr>,<expr><literal type="number">202</literal></expr>,<expr><literal type="number">203</literal></expr>,<expr><literal type="number">204</literal></expr>,<expr><literal type="number">205</literal></expr>,<expr><literal type="number">206</literal></expr>,<expr><literal type="number">207</literal></expr>,
<expr><literal type="number">208</literal></expr>,<expr><literal type="number">209</literal></expr>,<expr><literal type="number">210</literal></expr>,<expr><literal type="number">211</literal></expr>,<expr><literal type="number">212</literal></expr>,<expr><literal type="number">213</literal></expr>,<expr><literal type="number">214</literal></expr>,<expr><literal type="number">247</literal></expr>,
<expr><literal type="number">216</literal></expr>,<expr><literal type="number">217</literal></expr>,<expr><literal type="number">218</literal></expr>,<expr><literal type="number">219</literal></expr>,<expr><literal type="number">220</literal></expr>,<expr><literal type="number">221</literal></expr>,<expr><literal type="number">222</literal></expr>,<expr><literal type="number">255</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">62</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">32</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">3</literal></expr>,
<expr><literal type="number">126</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">126</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">3</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">12</literal></expr>,<expr><literal type="number">2</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">254</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">127</literal></expr>,<expr><literal type="number">127</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">254</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">7</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">32</literal></expr>,<expr><literal type="number">4</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">128</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">127</literal></expr>,<expr><literal type="number">255</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">3</literal></expr>,
<expr><literal type="number">254</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">135</literal></expr>,<expr><literal type="number">254</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">7</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">44</literal></expr>,<expr><literal type="number">6</literal></expr>,
<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">127</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">127</literal></expr>,<expr><literal type="number">255</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">254</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,
<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">127</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">254</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,
<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,
<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">127</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,
<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">254</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">252</literal></expr>,
<expr><literal type="number">1</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">248</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">120</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">254</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">128</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">128</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">128</literal></expr>,
<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">255</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">128</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">1</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">128</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">128</literal></expr>,<expr><literal type="number">128</literal></expr>,<expr><literal type="number">128</literal></expr>,<expr><literal type="number">128</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">128</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">28</literal></expr>,<expr><literal type="number">28</literal></expr>,<expr><literal type="number">28</literal></expr>,<expr><literal type="number">28</literal></expr>,<expr><literal type="number">28</literal></expr>,<expr><literal type="number">28</literal></expr>,<expr><literal type="number">28</literal></expr>,<expr><literal type="number">28</literal></expr>,
<expr><literal type="number">28</literal></expr>,<expr><literal type="number">28</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">128</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">26</literal></expr>,<expr><literal type="number">26</literal></expr>,<expr><literal type="number">26</literal></expr>,<expr><literal type="number">26</literal></expr>,<expr><literal type="number">26</literal></expr>,<expr><literal type="number">26</literal></expr>,<expr><literal type="number">18</literal></expr>,
<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,
<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,
<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">128</literal></expr>,<expr><literal type="number">128</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">128</literal></expr>,<expr><literal type="number">16</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">26</literal></expr>,<expr><literal type="number">26</literal></expr>,<expr><literal type="number">26</literal></expr>,<expr><literal type="number">26</literal></expr>,<expr><literal type="number">26</literal></expr>,<expr><literal type="number">26</literal></expr>,<expr><literal type="number">18</literal></expr>,
<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,
<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,
<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">128</literal></expr>,<expr><literal type="number">128</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">1</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">20</literal></expr>,<expr><literal type="number">20</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,<expr><literal type="number">20</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,
<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,
<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,
<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,
<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,
<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>,<expr><literal type="number">18</literal></expr>
}</block></expr></init></decl>;</decl_stmt>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>VPCOMPAT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MEMMOVE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block" format="doxygen">/*************************************************
*    Emulated memmove() for systems without it   *
*************************************************/</comment>

<comment type="block">/* This function can make use of bcopy() if it is available. Otherwise do it by
steam, as there are some non-Unix environments that lack both memmove() and
bcopy(). */</comment>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>emulated_memmove</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BCOPY</name></cpp:ifdef>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>d</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>dest</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>d</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dest</name> <operator>&gt;</operator> <name>src</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>dest</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>src</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>dest</name><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>--</operator><name>src</name><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
  <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>dest</name></expr>;</return>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>dest</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>src</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
  <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>dest</name> <operator>-</operator> <name>n</name><operator>)</operator></expr>;</return>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* not HAVE_BCOPY */</comment>
</block_content>}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>memmove</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>memmove</name><parameter_list>(<parameter><type><name>d</name></type></parameter>,<parameter><type><name>s</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>emulated_memmove(d,s,n)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* not VPCOMPAT &amp;&amp; not HAVE_MEMMOVE */</comment>



<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_STRERROR</name></cpp:ifndef>
<comment type="block" format="doxygen">/*************************************************
*     Provide strerror() for non-ANSI libraries  *
*************************************************/</comment>

<comment type="block">/* Some old-fashioned systems (e.g. SunOS4) didn't have strerror() in their
libraries. They may no longer be around, but just in case, we can try to
provide the same facility by this simple alternative function. */</comment>

<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type>   <name>sys_nerr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name><name>sys_errlist</name><index>[]</index></name></decl>;</decl_stmt>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>strerror</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>&gt;=</operator> <name>sys_nerr</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"unknown error number"</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name><name>sys_errlist</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_STRERROR */</comment>



<comment type="block" format="doxygen">/*************************************************
*            Local memory functions              *
*************************************************/</comment>

<comment type="block">/* Alternative memory functions, to test functionality. */</comment>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>my_malloc</name><parameter_list>(<parameter><decl><type><name>PCRE2_SIZE</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>block</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>data</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>show_memory</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>block</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <macro><name>fprintf</name><argument_list>(<argument>outfile</argument>, <argument><literal type="string">"** malloc() failed for %"</literal> SIZ_FORM <literal type="string">"\n"</literal></argument>, <argument>SIZ_CAST size</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <macro><name>fprintf</name><argument_list>(<argument>outfile</argument>, <argument><literal type="string">"malloc  %5"</literal> SIZ_FORM</argument>, <argument>SIZ_CAST size</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SHOW_MALLOC_ADDRESSES</name></cpp:ifdef>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" %p"</literal></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Not portable */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>malloclistptr</name> <operator>&lt;</operator> <name>MALLOCLISTSIZE</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>malloclist</name><index>[<expr><name>malloclistptr</name></expr>]</index></name> <operator>=</operator> <name>block</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>malloclistlength</name><index>[<expr><name>malloclistptr</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" (not remembered)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<return>return <expr><name>block</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>my_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>block</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>data</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>show_memory</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>found</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"free"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>malloclistptr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>block</name> <operator>==</operator> <name><name>malloclist</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
      <block>{<block_content>
      <macro><name>fprintf</name><argument_list>(<argument>outfile</argument>, <argument><literal type="string">"    %5"</literal> SIZ_FORM</argument>, <argument>SIZ_CAST malloclistlength[i]</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
      <expr_stmt><expr><name>malloclistptr</name><operator>--</operator></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>malloclistptr</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <expr_stmt><expr><name><name>malloclist</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>malloclist</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>malloclistlength</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>malloclistlength</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></for>
      <expr_stmt><expr><name>found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" unremembered block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SHOW_MALLOC_ADDRESSES</name></cpp:ifdef>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" %p"</literal></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Not portable */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*       Callback function for stack guard        *
*************************************************/</comment>

<comment type="block">/* This is set up to be called from pcre2_compile() when the stackguard=n
modifier sets a value greater than zero. The test we do is whether the
parenthesis nesting depth is greater than the value set by the modifier.

Argument:  the current parenthesis nesting depth
Returns:   non-zero to kill the compilation
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>stack_guard</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>user_data</name></expr>;</expr_stmt>
<return>return <expr><name>depth</name> <operator>&gt;</operator> <name><name>pat_patctl</name><operator>.</operator><name>stackguard_test</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*         JIT memory callback                    *
*************************************************/</comment>

<function><type><specifier>static</specifier> <name>PCRE2_JIT_STACK</name><modifier>*</modifier></type>
<name>jit_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>jit_was_used</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>PCRE2_JIT_STACK</name> <operator>*</operator><operator>)</operator><name>arg</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*      Convert UTF-8 character to code point     *
*************************************************/</comment>

<comment type="block">/* This function reads one or more bytes that represent a UTF-8 character,
and returns the codepoint of that character. Note that the function supports
the original UTF-8 definition of RFC 2279, allowing for values in the range 0
to 0x7fffffff, up to 6 bytes long. This makes it possible to generate
codepoints greater than 0x10ffff which are useful for testing PCRE2's error
checking, and also for generating 32-bit non-UTF data values above the UTF
limit.

Argument:
  utf8bytes   a pointer to the byte vector
  vptr        a pointer to an int to receive the value

Returns:      &gt;  0 =&gt; the number of bytes consumed
              -6 to 0 =&gt; malformed UTF-8 character at offset = (-return)
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>utf82ord</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR8</name></type> <name>utf8bytes</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>vptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>utf8bytes</name><operator>++</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>d</name> <init>= <expr><name>c</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">6</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>               <comment type="block">/* i is number of additional bytes */</comment>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>d</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><operator>*</operator><name>vptr</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt> <return>return <expr><literal type="number">1</literal></expr>;</return> </block_content>}</block></if></if_stmt>  <comment type="block">/* ascii character */</comment>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>i</name> <operator>==</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>        <comment type="block">/* invalid UTF-8 */</comment>

<comment type="block">/* i now has a value in the range 1-5 */</comment>

<expr_stmt><expr><name>s</name> <operator>=</operator> <literal type="number">6</literal><operator>*</operator><name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <name><name>utf8_table3</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <name>s</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>utf8bytes</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><operator>(</operator><name>j</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>s</name> <operator>-=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>d</name> <operator>|=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>s</name></expr>;</expr_stmt>
  </block_content>}</block></for>

<comment type="block">/* Check that encoding was the correct unique one */</comment>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>utf8_table1_size</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
  <if_stmt><if>if <condition>(<expr><name>d</name> <operator>&lt;=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>utf8_table1</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>!=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><operator>(</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* Valid value */</comment>

<expr_stmt><expr><operator>*</operator><name>vptr</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
<return>return <expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*             Print one character                *
*************************************************/</comment>

<comment type="block">/* Print a single character either literally, or as a hex escape, and count how
many printed characters are used.

Arguments:
  c            the character
  utf          TRUE in UTF mode
  f            the FILE to print to, or NULL just to count characters

Returns:       number of characters written
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pchar</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>utf</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>tempbuffer</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>PRINTOK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>f</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0x100</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>f</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\\x{%02x}"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">6</literal></expr>;</return>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>f</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\\x%02x"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">4</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>f</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\\x{%02x}"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>tempbuffer</name></expr></argument>, <argument><expr><literal type="string">"\\x{%02x}"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><ternary><condition><expr><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>n</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>



<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
<comment type="block" format="doxygen">/*************************************************
*    Find length of 0-terminated 16-bit string   *
*************************************************/</comment>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>strlen16</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR16</name></type> <name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SPTR16</name></type> <name>pp</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>*</operator><name>pp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pp</name> <operator>-</operator> <name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_PCRE2_16 */</comment>



<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
<comment type="block" format="doxygen">/*************************************************
*    Find length of 0-terminated 32-bit string   *
*************************************************/</comment>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>strlen32</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR32</name></type> <name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SPTR32</name></type> <name>pp</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>*</operator><name>pp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pp</name> <operator>-</operator> <name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_PCRE2_32 */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
<comment type="block" format="doxygen">/*************************************************
*         Print 8-bit character string           *
*************************************************/</comment>

<comment type="block">/* Must handle UTF-8 strings in utf8 mode. Yields number of characters printed.
For printing *MARK strings, a negative length is given, indicating that the
length is in the first code unit. If handed a NULL file, this function just
counts chars without printing (because pchar() does that). */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pchars8</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR8</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>utf</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yield</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>length</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>utf82ord</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name> <operator>&lt;=</operator> <name>length</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>   <comment type="block">/* Mustn't run over the end */</comment>
      <block>{<block_content>
      <expr_stmt><expr><name>length</name> <operator>-=</operator> <name>rc</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>rc</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>yield</name> <operator>+=</operator> <call><name>pchar</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>yield</name> <operator>+=</operator> <call><name>pchar</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

<return>return <expr><name>yield</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
<comment type="block" format="doxygen">/*************************************************
*           Print 16-bit character string        *
*************************************************/</comment>

<comment type="block">/* Must handle UTF-16 strings in utf mode. Yields number of characters printed.
For printing *MARK strings, a negative length is given, indicating that the
length is in the first code unit. If handed a NULL file, just counts chars
without printing. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pchars16</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR16</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>utf</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>yield</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>length</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>p</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;=</operator> <literal type="number">0xD800</literal> <operator>&amp;&amp;</operator> <name><name>c</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0xDC00</literal> <operator>&amp;&amp;</operator> <name>length</name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><operator>*</operator><name>p</name> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>d</name> <operator>&gt;=</operator> <literal type="number">0xDC00</literal> <operator>&amp;&amp;</operator> <name>d</name> <operator>&lt;=</operator> <literal type="number">0xDFFF</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3ff</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">10</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>d</name> <operator>&amp;</operator> <literal type="number">0x3ff</literal><operator>)</operator> <operator>+</operator> <literal type="number">0x10000</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>length</name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>yield</name> <operator>+=</operator> <call><name>pchar</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
<return>return <expr><name>yield</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_PCRE2_16 */</comment>



<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
<comment type="block" format="doxygen">/*************************************************
*           Print 32-bit character string        *
*************************************************/</comment>

<comment type="block">/* Must handle UTF-32 strings in utf mode. Yields number of characters printed.
For printing *MARK strings, a negative length is given, indicating that the
length is in the first code unit. If handed a NULL file, just counts chars
without printing. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pchars32</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR32</name></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>utf</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>yield</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>utf</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Avoid compiler warning */</comment>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>length</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>p</name><operator>++</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>yield</name> <operator>+=</operator> <call><name>pchar</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
<return>return <expr><name>yield</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_PCRE2_32 */</comment>




<comment type="block" format="doxygen">/*************************************************
*       Convert character value to UTF-8         *
*************************************************/</comment>

<comment type="block">/* This function takes an integer value in the range 0 - 0x7fffffff
and encodes it as a UTF-8 character in 0 to 6 bytes. It is needed even when the
8-bit library is not supported, to generate UTF-8 output for non-ASCII
characters.

Arguments:
  cvalue     the character value
  utf8bytes  pointer to buffer for result - at least 6 bytes long

Returns:     number of characters placed in the buffer
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ord2utf8</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>cvalue</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>utf8bytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cvalue</name> <operator>&gt;</operator> <literal type="number">0x7fffffffu</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>utf8_table1_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
  <if_stmt><if>if <condition>(<expr><name>cvalue</name> <operator>&lt;=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>utf8_table1</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
<expr_stmt><expr><name>utf8bytes</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
 <block>{<block_content>
 <expr_stmt><expr><operator>*</operator><name>utf8bytes</name><operator>--</operator> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>cvalue</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
 <expr_stmt><expr><name>cvalue</name> <operator>&gt;&gt;=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
 </block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>utf8bytes</name> <operator>=</operator> <name><name>utf8_table2</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|</operator> <name>cvalue</name></expr>;</expr_stmt>
<return>return <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>



<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
<comment type="block" format="doxygen">/*************************************************
*           Convert string to 16-bit             *
*************************************************/</comment>

<comment type="block">/* In UTF mode the input is always interpreted as a string of UTF-8 bytes using
the original UTF-8 definition of RFC 2279, which allows for up to 6 bytes, and
code values from 0 to 0x7fffffff. However, values greater than the later UTF
limit of 0x10ffff cause an error. In non-UTF mode the input is interpreted as
UTF-8 if the utf8_input modifier is set, but an error is generated for values
greater than 0xffff.

If all the input bytes are ASCII, the space needed for a 16-bit string is
exactly double the 8-bit size. Otherwise, the size needed for a 16-bit string
is no more than double, because up to 0xffff uses no more than 3 bytes in UTF-8
but possibly 4 in UTF-16. Higher values use 4 bytes in UTF-8 and up to 4 bytes
in UTF-16. The result is always left in pbuffer16. Impose a minimum size to
save repeated re-sizing.

Note that this function does not object to surrogate values. This is
deliberate; it makes it possible to construct UTF-16 strings that are invalid,
for the purpose of testing that they are correctly faulted.

Arguments:
  p          points to a byte string
  utf        true in UTF mode
  lenptr     points to number of bytes in the string (excluding trailing zero)

Returns:     0 on success, with the length updated to the number of 16-bit
               data items used (excluding the trailing zero)
             OR -1 if a UTF-8 string is malformed
             OR -2 if a value &gt; 0x10ffff is encountered in UTF mode
             OR -3 if a value &gt; 0xffff is encountered when not in UTF mode
*/</comment>

<function><type><specifier>static</specifier> <name>PCRE2_SIZE</name></type>
<name>to16</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>utf</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>lenptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>len</name> <init>= <expr><operator>*</operator><name>lenptr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pbuffer16_size</name> <operator>&lt;</operator> <literal type="number">2</literal><operator>*</operator><name>len</name> <operator>+</operator> <literal type="number">2</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>pbuffer16</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pbuffer16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pbuffer16_size</name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name>len</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>pbuffer16_size</name> <operator>&lt;</operator> <literal type="number">4096</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pbuffer16_size</name> <operator>=</operator> <literal type="number">4096</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pbuffer16</name> <operator>=</operator> <operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>pbuffer16_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>pbuffer16</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <macro><name>fprintf</name><argument_list>(<argument>stderr</argument>, <argument><literal type="string">"pcre2test: malloc(%"</literal> SIZ_FORM <literal type="string">") failed for pbuffer16\n"</literal></argument>,
      <argument>SIZ_CAST pbuffer16_size</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pp</name> <operator>=</operator> <name>pbuffer16</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>utf</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_UTF8_INPUT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <for>for <control>(<init>;</init> <condition><expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>len</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>chlen</name> <init>= <expr><call><name>utf82ord</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>chlen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>utf</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;</operator> <literal type="number">0xffff</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">3</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0x10ffff</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>chlen</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>len</name> <operator>-=</operator> <name>chlen</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0x10000</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pp</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if> <else>else
    <block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>-=</operator> <literal type="number">0x10000</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pp</name><operator>++</operator> <operator>=</operator> <literal type="number">0xD800</literal> <operator>|</operator> <operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">10</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pp</name><operator>++</operator> <operator>=</operator> <literal type="number">0xDC00</literal> <operator>|</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3ff</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while></block_content></block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>lenptr</name> <operator>=</operator> <name>pp</name> <operator>-</operator> <name>pbuffer16</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
<comment type="block" format="doxygen">/*************************************************
*           Convert string to 32-bit             *
*************************************************/</comment>

<comment type="block">/* In UTF mode the input is always interpreted as a string of UTF-8 bytes using
the original UTF-8 definition of RFC 2279, which allows for up to 6 bytes, and
code values from 0 to 0x7fffffff. However, values greater than the later UTF
limit of 0x10ffff cause an error.

In non-UTF mode the input is interpreted as UTF-8 if the utf8_input modifier
is set, and no limit is imposed. There is special interpretation of the 0xff
byte (which is illegal in UTF-8) in this case: it causes the top bit of the
next character to be set. This provides a way of generating 32-bit characters
greater than 0x7fffffff.

If all the input bytes are ASCII, the space needed for a 32-bit string is
exactly four times the 8-bit size. Otherwise, the size needed for a 32-bit
string is no more than four times, because the number of characters must be
less than the number of bytes. The result is always left in pbuffer32. Impose a
minimum size to save repeated re-sizing.

Note that this function does not object to surrogate values. This is
deliberate; it makes it possible to construct UTF-32 strings that are invalid,
for the purpose of testing that they are correctly faulted.

Arguments:
  p          points to a byte string
  utf        true in UTF mode
  lenptr     points to number of bytes in the string (excluding trailing zero)

Returns:     0 on success, with the length updated to the number of 32-bit
               data items used (excluding the trailing zero)
             OR -1 if a UTF-8 string is malformed
             OR -2 if a value &gt; 0x10ffff is encountered in UTF mode
*/</comment>

<function><type><specifier>static</specifier> <name>PCRE2_SIZE</name></type>
<name>to32</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>utf</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>lenptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>len</name> <init>= <expr><operator>*</operator><name>lenptr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pbuffer32_size</name> <operator>&lt;</operator> <literal type="number">4</literal><operator>*</operator><name>len</name> <operator>+</operator> <literal type="number">4</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>pbuffer32</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pbuffer32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pbuffer32_size</name> <operator>=</operator> <literal type="number">4</literal><operator>*</operator><name>len</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>pbuffer32_size</name> <operator>&lt;</operator> <literal type="number">8192</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pbuffer32_size</name> <operator>=</operator> <literal type="number">8192</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pbuffer32</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>pbuffer32_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>pbuffer32</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <macro><name>fprintf</name><argument_list>(<argument>stderr</argument>, <argument><literal type="string">"pcre2test: malloc(%"</literal> SIZ_FORM <literal type="string">") failed for pbuffer32\n"</literal></argument>,
      <argument>SIZ_CAST pbuffer32_size</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pp</name> <operator>=</operator> <name>pbuffer32</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>utf</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_UTF8_INPUT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <for>for <control>(<init>;</init> <condition><expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>len</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if>

<else>else<block type="pseudo"><block_content> <while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>chlen</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>topbit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>utf</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="number">0xff</literal> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>topbit</name> <operator>=</operator> <literal type="number">0x80000000u</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>chlen</name> <operator>=</operator> <call><name>utf82ord</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>chlen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;</operator> <literal type="number">0x10ffff</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>chlen</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>len</name> <operator>-=</operator> <name>chlen</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pp</name><operator>++</operator> <operator>=</operator> <name>c</name> <operator>|</operator> <name>topbit</name></expr>;</expr_stmt>
  </block_content>}</block></while></block_content></block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>lenptr</name> <operator>=</operator> <name>pp</name> <operator>-</operator> <name>pbuffer32</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_PCRE2_32 */</comment>



<comment type="block">/* This function is no longer used. Keep it around for a while, just in case it
needs to be re-instated. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NEVERNEVERNEVER</name></cpp:ifdef>

<comment type="block" format="doxygen">/*************************************************
*         Move back by so many characters        *
*************************************************/</comment>

<comment type="block">/* Given a code unit offset in a subject string, move backwards by a number of
characters, and return the resulting offset.

Arguments:
  subject   pointer to the string
  offset    start offset
  count     count to move back by
  utf       TRUE if in UTF mode

Returns:   a possibly changed offset
*/</comment>

<function><type><specifier>static</specifier> <name>PCRE2_SIZE</name></type>
<name>backchars</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>subject</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>utf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>utf</name> <operator>||</operator> <name>test_mode</name> <operator>==</operator> <name>PCRE32_MODE</name></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name>count</name> <operator>&gt;=</operator> <name>offset</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>offset</name> <operator>-</operator> <name>count</name><operator>)</operator></expr></else></ternary></expr>;</return></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE8_MODE</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>PCRE2_SPTR8</name></type> <name>pp</name> <init>= <expr><operator>(</operator><name>PCRE2_SPTR8</name><operator>)</operator><name>subject</name> <operator>+</operator> <name>offset</name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pp</name> <operator>&gt;</operator> <operator>(</operator><name>PCRE2_SPTR8</name><operator>)</operator><name>subject</name></expr>;</condition> <incr><expr><name>count</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
    <expr_stmt><expr><name>pp</name><operator>--</operator></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><operator>*</operator><name>pp</name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pp</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></for>
  <return>return <expr><name>pp</name> <operator>-</operator> <operator>(</operator><name>PCRE2_SPTR8</name><operator>)</operator><name>subject</name></expr>;</return>
  </block_content>}</block></if>

<else>else  <comment type="block">/* 16-bit mode */</comment>
  <block>{<block_content>
  <decl_stmt><decl><type><name>PCRE2_SPTR16</name></type> <name>pp</name> <init>= <expr><operator>(</operator><name>PCRE2_SPTR16</name><operator>)</operator><name>subject</name> <operator>+</operator> <name>offset</name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pp</name> <operator>&gt;</operator> <operator>(</operator><name>PCRE2_SPTR16</name><operator>)</operator><name>subject</name></expr>;</condition> <incr><expr><name>count</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
    <expr_stmt><expr><name>pp</name><operator>--</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>pp</name> <operator>&amp;</operator> <literal type="number">0xfc00</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xdc00</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pp</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  <return>return <expr><name>pp</name> <operator>-</operator> <operator>(</operator><name>PCRE2_SPTR16</name><operator>)</operator><name>subject</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* NEVERNEVERNEVER */</comment>



<comment type="block" format="doxygen">/*************************************************
*           Expand input buffers                 *
*************************************************/</comment>

<comment type="block">/* This function doubles the size of the input buffer and the buffer for
keeping an 8-bit copy of patterns (pbuffer8), and copies the current buffers to
the new ones.

Arguments: none
Returns:   nothing (aborts if malloc() fails)
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>expand_input_buffers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>new_pbuffer8_size</name> <init>= <expr><literal type="number">2</literal><operator>*</operator><name>pbuffer8_size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>new_buffer</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>new_pbuffer8_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>new_pbuffer8</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>new_pbuffer8_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>new_buffer</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>new_pbuffer8</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2test: malloc(%d) failed\n"</literal></expr></argument>, <argument><expr><name>new_pbuffer8_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_buffer</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>pbuffer8_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_pbuffer8</name></expr></argument>, <argument><expr><name>pbuffer8</name></expr></argument>, <argument><expr><name>pbuffer8_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pbuffer8_size</name> <operator>=</operator> <name>new_pbuffer8_size</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pbuffer8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>new_buffer</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pbuffer8</name> <operator>=</operator> <name>new_pbuffer8</name></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*        Read or extend an input line            *
*************************************************/</comment>

<comment type="block">/* Input lines are read into buffer, but both patterns and data lines can be
continued over multiple input lines. In addition, if the buffer fills up, we
want to automatically expand it so as to be able to handle extremely large
lines that are needed for certain stress tests, although this is less likely
now that there are repetition features for both patterns and data. When the
input buffer is expanded, the other two buffers must also be expanded likewise,
and the contents of pbuffer, which are a copy of the input for callouts, must
be preserved (for when expansion happens for a data line). This is not the most
optimal way of handling this, but hey, this is just a test program!

Arguments:
  f            the file to read
  start        where in buffer to start (this *must* be within buffer)
  prompt       for stdin or readline()

Returns:       pointer to the start of new data
               could be a copy of start, or could be moved
               NULL if no data read and EOF reached
*/</comment>

<function><type><specifier>static</specifier> <name>uint8_t</name> <modifier>*</modifier></type>
<name>extend_inputline</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prompt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>here</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>rlen</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>pbuffer8_size</name> <operator>-</operator> <operator>(</operator><name>here</name> <operator>-</operator> <name>buffer</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>rlen</name> <operator>&gt;</operator> <literal type="number">1000</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>dlen</name></decl>;</decl_stmt>

    <comment type="block">/* If libreadline or libedit support is required, use readline() to read a
    line if the input is a terminal. Note that readline() removes the trailing
    newline, so we must put it back again, to be compatible with fgets(). */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_LIBREADLINE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_LIBEDIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><call><name>INTERACTIVE</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>readline</name><argument_list>(<argument><expr><name>prompt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><ternary><condition><expr><operator>(</operator><name>here</name> <operator>==</operator> <name>start</name><operator>)</operator></expr>?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>start</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>add_history</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>rlen</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <name>rlen</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>here</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>here</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>here</name><index>[<expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Read the next line by normal means, prompting if the file is a tty. */</comment>

      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>INTERACTIVE</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>prompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>here</name></expr></argument>, <argument><expr><name>rlen</name></expr></argument>,  <argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><ternary><condition><expr><operator>(</operator><name>here</name> <operator>==</operator> <name>start</name><operator>)</operator></expr>?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>start</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>dlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>here</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>here</name> <operator>+=</operator> <name>dlen</name></expr>;</expr_stmt>

    <comment type="block">/* Check for end of line reached. Take care not to read data from before
    start (dlen will be zero for a file starting with a binary zero). */</comment>

    <if_stmt><if>if <condition>(<expr><name>here</name> <operator>&gt;</operator> <name>start</name> <operator>&amp;&amp;</operator> <name><name>here</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>start</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If we have not read a newline when reading a file, we have either filled
    the buffer or reached the end of the file. We can detect the former by
    checking that the string fills the buffer, and the latter by feof(). If
    neither of these is true, it means we read a binary zero which has caused
    strlen() to give a short length. This is a hard error because pcre2test
    expects to work with C strings. */</comment>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>INTERACTIVE</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>dlen</name> <operator>&lt;</operator> <name>rlen</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>feof</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Binary zero encountered in input\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** pcre2test run abandoned\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>

  <else>else
    <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>start_offset</name> <init>= <expr><name>start</name> <operator>-</operator> <name>buffer</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>here_offset</name> <init>= <expr><name>here</name> <operator>-</operator> <name>buffer</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>expand_input_buffers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>start</name> <operator>=</operator> <name>buffer</name> <operator>+</operator> <name>start_offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>here</name> <operator>=</operator> <name>buffer</name> <operator>+</operator> <name>here_offset</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

<comment type="block">/* Control never gets here */</comment>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*         Case-independent strncmp() function    *
*************************************************/</comment>

<comment type="block">/*
Arguments:
  s         first string
  t         second string
  n         number of characters to compare

Returns:    &lt; 0, = 0, or &gt; 0, according to the comparison
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>strncmpic</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name>n</name><operator>--</operator></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>tolower</name><argument_list>(<argument><expr><operator>*</operator><name>s</name><operator>++</operator></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>tolower</name><argument_list>(<argument><expr><operator>*</operator><name>t</name><operator>++</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>c</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></while>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*          Scan the main modifier list           *
*************************************************/</comment>

<comment type="block">/* This function searches the modifier list for a long modifier name.

Argument:
  p         start of the name
  lenp      length of the name

Returns:    an index in the modifier list, or -1 on failure
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>scan_modifiers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>bot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>top</name> <init>= <expr><name>MODLISTCOUNT</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>top</name> <operator>&gt;</operator> <name>bot</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>mid</name> <init>= <expr><operator>(</operator><name>bot</name> <operator>+</operator> <name>top</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>mlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>modlist</name><index>[<expr><name>mid</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>, <argument><expr><name><name>modlist</name><index>[<expr><name>mid</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>len</name> <operator>&lt;</operator> <name>mlen</name><operator>)</operator></expr>?</condition><then> <expr><name>len</name></expr> </then><else>: <expr><name>mlen</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>mlen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>mid</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>len</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><name>mlen</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bot</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>top</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></while>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*        Check a modifer and find its field      *
*************************************************/</comment>

<comment type="block">/* This function is called when a modifier has been identified. We check that
it is allowed here and find the field that is to be changed.

Arguments:
  m          the modifier list entry
  ctx        CTX_PAT     =&gt; pattern context
             CTX_POPPAT  =&gt; pattern context for popped pattern
             CTX_DEFPAT  =&gt; default pattern context
             CTX_DAT     =&gt; data context
             CTX_DEFDAT  =&gt; default data context
  pctl       point to pattern control block
  dctl       point to data control block
  c          a single character or 0

Returns:     a field pointer or NULL
*/</comment>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>check_modifier</name><parameter_list>(<parameter><decl><type><name>modstruct</name> <modifier>*</modifier></type><name>m</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ctx</name></decl></parameter>, <parameter><decl><type><name>patctl</name> <modifier>*</modifier></type><name>pctl</name></decl></parameter>, <parameter><decl><type><name>datctl</name> <modifier>*</modifier></type><name>dctl</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>field</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>offset</name> <init>= <expr><name><name>m</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>restrict_for_perl_test</name></expr>)</condition><block type="pseudo"><block_content> <switch>switch<condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>which</name></name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><name>MOD_PNDP</name></expr>:</case>
  <case>case <expr><name>MOD_PATP</name></expr>:</case>
  <case>case <expr><name>MOD_PDP</name></expr>:</case>
  <break>break;</break>

  <default>default:</default>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** '%s' is not allowed in a Perl-compatible test\n"</literal></expr></argument>,
    <argument><expr><name><name>m</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></switch></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>which</name></name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><name>MOD_CTC</name></expr>:</case>  <comment type="block">/* Compile context modifier */</comment>
  <if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>==</operator> <name>CTX_DEFPAT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>PTR</name><argument_list>(<argument><expr><name>default_pat_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>ctx</name> <operator>==</operator> <name>CTX_PAT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>PTR</name><argument_list>(<argument><expr><name>pat_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <break>break;</break>

  <case>case <expr><name>MOD_CTM</name></expr>:</case>  <comment type="block">/* Match context modifier */</comment>
  <if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>==</operator> <name>CTX_DEFDAT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>PTR</name><argument_list>(<argument><expr><name>default_dat_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>ctx</name> <operator>==</operator> <name>CTX_DAT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>PTR</name><argument_list>(<argument><expr><name>dat_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <break>break;</break>

  <case>case <expr><name>MOD_DAT</name></expr>:</case>  <comment type="block">/* Data line modifier */</comment>
  <if_stmt><if>if <condition>(<expr><name>dctl</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>field</name> <operator>=</operator> <name>dctl</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <break>break;</break>

  <case>case <expr><name>MOD_PAT</name></expr>:</case>    <comment type="block">/* Pattern modifier */</comment>
  <case>case <expr><name>MOD_PATP</name></expr>:</case>   <comment type="block">/* Allowed for Perl test */</comment>
  <if_stmt><if>if <condition>(<expr><name>pctl</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>field</name> <operator>=</operator> <name>pctl</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <break>break;</break>

  <case>case <expr><name>MOD_PD</name></expr>:</case>   <comment type="block">/* Pattern or data line modifier */</comment>
  <case>case <expr><name>MOD_PDP</name></expr>:</case>  <comment type="block">/* Ditto, allowed for Perl test */</comment>
  <case>case <expr><name>MOD_PND</name></expr>:</case>  <comment type="block">/* Ditto, but not default pattern */</comment>
  <case>case <expr><name>MOD_PNDP</name></expr>:</case> <comment type="block">/* Ditto, allowed for Perl test */</comment>
  <if_stmt><if>if <condition>(<expr><name>dctl</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>field</name> <operator>=</operator> <name>dctl</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>pctl</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>which</name></name> <operator>==</operator> <name>MOD_PD</name> <operator>||</operator> <name><name>m</name><operator>-&gt;</operator><name>which</name></name> <operator>==</operator> <name>MOD_PDP</name> <operator>||</operator>
             <name>ctx</name> <operator>!=</operator> <name>CTX_DEFPAT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>field</name> <operator>=</operator> <name>pctl</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <break>break;</break>
  </block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>field</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** '%s' is not valid here\n"</literal></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** /%c is not valid here\n"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>field</name> <operator>+</operator> <name>offset</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*            Decode a modifier list              *
*************************************************/</comment>

<comment type="block">/* A pointer to a control block is NULL when called in cases when that block is
not relevant. They are never all relevant in one call. At least one of patctl
and datctl is NULL. The second argument specifies which context to use for
modifiers that apply to contexts.

Arguments:
  p          point to modifier string
  ctx        CTX_PAT     =&gt; pattern context
             CTX_POPPAT  =&gt; pattern context for popped pattern
             CTX_DEFPAT  =&gt; default pattern context
             CTX_DAT     =&gt; data context
             CTX_DEFDAT  =&gt; default data context
  pctl       point to pattern control block
  dctl       point to data control block

Returns: TRUE if successful decode, FALSE otherwise
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>decode_modifiers</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ctx</name></decl></parameter>, <parameter><decl><type><name>patctl</name> <modifier>*</modifier></type><name>pctl</name></decl></parameter>, <parameter><decl><type><name>datctl</name> <modifier>*</modifier></type><name>dctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>ep</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>li</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>uli</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>first</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>field</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>modstruct</name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>off</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

  <comment type="block">/* Skip white space and commas. */</comment>

  <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

  <comment type="block">/* Find the end of the item; lose trailing whitespace at end of line. */</comment>

  <for>for <control>(<init><expr><name>ep</name> <operator>=</operator> <name>p</name></expr>;</init> <condition><expr><operator>*</operator><name>ep</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ep</name> <operator>!=</operator> <literal type="char">','</literal></expr>;</condition> <incr><expr><name>ep</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ep</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <while>while <condition>(<expr><name>ep</name> <operator>&gt;</operator> <name>p</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><name><name>ep</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ep</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><operator>*</operator><name>ep</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Remember if the first character is '-'. */</comment>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>off</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Find the length of a full-length modifier name, and scan for it. */</comment>

  <expr_stmt><expr><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>pp</name> <operator>&lt;</operator> <name>ep</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pp</name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>scan_modifiers</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pp</name> <operator>-</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the first modifier is unrecognized, try to interpret it as a sequence
  of single-character abbreviated modifiers. None of these modifiers have any
  associated data. They just set options or control bits. */</comment>

  <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>cc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>mp</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Unrecognized modifier '%.*s'\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ep</name><operator>-</operator><name>p</name><operator>)</operator></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>ep</name> <operator>-</operator> <name>p</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Single-character modifiers must come first\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>cc</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</init> <condition><expr><name>cc</name> <operator>!=</operator> <literal type="char">','</literal> <operator>&amp;&amp;</operator> <name>cc</name> <operator>!=</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name>cc</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>cc</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>++</operator><name>p</name><operator>)</operator></expr></incr>)</control>
      <block>{<block_content>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>C1MODLISTCOUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>==</operator> <name><name>c1modlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>onechar</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>C1MODLISTCOUNT</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Unrecognized modifier '%c' in '%.*s'\n"</literal></expr></argument>,
          <argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ep</name><operator>-</operator><name>mp</name><operator>)</operator></expr></argument>, <argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>FALSE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>c1modlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>c1modlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>index</name></expr>;</expr_stmt>
        </block_content>}</block></if>

      <else>else
        <block>{<block_content>
        <expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>scan_modifiers</name><argument_list>(<argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>c1modlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fullname</name><operator>)</operator></expr></argument>,
          <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>c1modlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fullname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Internal error: single-character equivalent "</literal>
            <literal type="string">"modifier '%s' not found\n"</literal></expr></argument>, <argument><expr><name><name>c1modlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>FALSE</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>c1modlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>index</name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>     <comment type="block">/* Cache for next time */</comment>
        </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>check_modifier</name><argument_list>(<argument><expr><name>modlist</name> <operator>+</operator> <name>index</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pctl</name></expr></argument>, <argument><expr><name>dctl</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>field</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

      <comment type="block">/* /x is a special case; a second appearance changes PCRE2_EXTENDED to
      PCRE2_EXTENDED_MORE. */</comment>

      <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>==</operator> <literal type="char">'x'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>&amp;</operator> <name>PCRE2_EXTENDED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>&amp;=</operator> <operator>~</operator><name>PCRE2_EXTENDED</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>|=</operator> <name>PCRE2_EXTENDED_MORE</name></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>|=</operator> <name><name>modlist</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></for>

    <continue>continue;</continue>    <comment type="block">/* With tne next (fullname) modifier */</comment>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* We have a match on a full-name modifier. Check for the existence of data
  when needed. */</comment>

  <expr_stmt><expr><name>m</name> <operator>=</operator> <name>modlist</name> <operator>+</operator> <name>index</name></expr>;</expr_stmt>      <comment type="block">/* Save typing */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>MOD_CTL</name> <operator>&amp;&amp;</operator> <name><name>m</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>MOD_OPT</name> <operator>&amp;&amp;</operator>
      <operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>MOD_IND</name> <operator>||</operator> <operator>*</operator><name>pp</name> <operator>==</operator> <literal type="char">'='</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pp</name><operator>++</operator> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** '=' expected after '%s'\n"</literal></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>off</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** '-' is not valid for '%s'\n"</literal></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>

  <comment type="block">/* These on/off types have no data. */</comment>

  <if type="elseif">else if <condition>(<expr><operator>*</operator><name>pp</name> <operator>!=</operator> <literal type="char">','</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>pp</name> <operator>!=</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>pp</name> <operator>!=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>pp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Unrecognized modifier '%.*s'\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ep</name><operator>-</operator><name>p</name><operator>)</operator></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Set the data length for those types that have data. Then find the field
  that is to be set. If check_modifier() returns NULL, it has already output an
  error message. */</comment>

  <expr_stmt><expr><name>len</name> <operator>=</operator> <name>ep</name> <operator>-</operator> <name>pp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>check_modifier</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pctl</name></expr></argument>, <argument><expr><name>dctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>field</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Process according to data type. */</comment>

  <switch>switch <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>MOD_CTL</name></expr>:</case>
    <case>case <expr><name>MOD_OPT</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>off</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>&amp;=</operator> <operator>~</operator><name><name>m</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>|=</operator> <name><name>m</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <break>break;</break>

    <case>case <expr><name>MOD_BSR</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator> <call><name>strncmpic</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><literal type="string">"default"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BSR_ANYCRLF</name></cpp:ifdef>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>=</operator> <name>PCRE2_BSR_ANYCRLF</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>=</operator> <name>PCRE2_BSR_UNICODE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>==</operator> <name>CTX_PAT</name> <operator>||</operator> <name>ctx</name> <operator>==</operator> <name>CTX_DEFPAT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pctl</name><operator>-&gt;</operator><name>control2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CTL2_BSR_SET</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>dctl</name><operator>-&gt;</operator><name>control2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CTL2_BSR_SET</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator> <call><name>strncmpic</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><literal type="string">"anycrlf"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>=</operator> <name>PCRE2_BSR_ANYCRLF</name></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator> <call><name>strncmpic</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><literal type="string">"unicode"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>=</operator> <name>PCRE2_BSR_UNICODE</name></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content> <goto>goto <name>INVALID_VALUE</name>;</goto></block_content></block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>==</operator> <name>CTX_PAT</name> <operator>||</operator> <name>ctx</name> <operator>==</operator> <name>CTX_DEFPAT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pctl</name><operator>-&gt;</operator><name>control2</name></name> <operator>|=</operator> <name>CTL2_BSR_SET</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>dctl</name><operator>-&gt;</operator><name>control2</name></name> <operator>|=</operator> <name>CTL2_BSR_SET</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>pp</name> <operator>=</operator> <name>ep</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>MOD_CHR</name></expr>:</case>  <comment type="block">/* A single character */</comment>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>=</operator> <operator>*</operator><name>pp</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>MOD_CON</name></expr>:</case>  <comment type="block">/* A convert type/options list */</comment>
    <for>for <control>(<init>;</init><condition>;</condition> <incr><expr><name>pp</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>colon</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>strchr</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pp</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>colon</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>colon</name> <operator>&lt;</operator> <name>ep</name><operator>)</operator></expr>?</condition><then> <expr><name>colon</name></expr></then><else>:<expr><name>ep</name></expr></else></ternary><operator>)</operator> <operator>-</operator> <name>pp</name></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>convertlistcount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strncmpic</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>convertlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>==</operator> <name>CONVERT_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>=</operator> <name><name>convertlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>option</name></expr>;</expr_stmt></block_content></block></if>
          <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>|=</operator> <name><name>convertlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>option</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
          <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>convertlistcount</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>INVALID_VALUE</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pp</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pp</name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    <break>break;</break>

    <case>case <expr><name>MOD_IN2</name></expr>:</case>    <comment type="block">/* One or two unsigned integers */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>INVALID_VALUE</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>uli</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>U32OVERFLOW</name><argument_list>(<argument><expr><name>uli</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>INVALID_VALUE</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>uli</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>uli</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>endptr</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>U32OVERFLOW</name><argument_list>(<argument><expr><name>uli</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>INVALID_VALUE</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>uli</name></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name>pp</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>endptr</name></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* PCRE2_SIZE_MAX is usually SIZE_MAX, which may be greater, equal to, or
    less than ULONG_MAX. So first test for overflowing the long int, and then
    test for overflowing PCRE2_SIZE_MAX if it is smaller than ULONG_MAX. */</comment>

    <case>case <expr><name>MOD_SIZ</name></expr>:</case>    <comment type="block">/* PCRE2_SIZE value */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>INVALID_VALUE</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>uli</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>uli</name> <operator>==</operator> <name>ULONG_MAX</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>INVALID_VALUE</name>;</goto></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ULONG_MAX</name> <operator>&gt;</operator> <name>PCRE2_SIZE_MAX</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>uli</name> <operator>&gt;</operator> <name>PCRE2_SIZE_MAX</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>INVALID_VALUE</name>;</goto></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>PCRE2_SIZE</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><name>uli</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pp</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>endptr</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>MOD_IND</name></expr>:</case>    <comment type="block">/* Unsigned integer with default */</comment>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>value</name></name><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if></if_stmt>
    <comment type="block">/* Fall through */</comment>

    <case>case <expr><name>MOD_INT</name></expr>:</case>    <comment type="block">/* Unsigned integer */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>INVALID_VALUE</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>uli</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>U32OVERFLOW</name><argument_list>(<argument><expr><name>uli</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>INVALID_VALUE</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>uli</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pp</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>endptr</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>MOD_INS</name></expr>:</case>   <comment type="block">/* Signed integer */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><name>pp</name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>INVALID_VALUE</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>li</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>S32OVERFLOW</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>INVALID_VALUE</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name>li</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pp</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>endptr</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>MOD_NL</name></expr>:</case>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>newlines</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>newlines</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>strncmpic</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>newlines</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>newlines</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>INVALID_VALUE</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>=</operator> <name>NEWLINE_DEFAULT</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>==</operator> <name>CTX_PAT</name> <operator>||</operator> <name>ctx</name> <operator>==</operator> <name>CTX_DEFPAT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pctl</name><operator>-&gt;</operator><name>control2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CTL2_NL_SET</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>dctl</name><operator>-&gt;</operator><name>control2</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CTL2_NL_SET</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>==</operator> <name>CTX_PAT</name> <operator>||</operator> <name>ctx</name> <operator>==</operator> <name>CTX_DEFPAT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pctl</name><operator>-&gt;</operator><name>control2</name></name> <operator>|=</operator> <name>CTL2_NL_SET</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>dctl</name><operator>-&gt;</operator><name>control2</name></name> <operator>|=</operator> <name>CTL2_NL_SET</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>pp</name> <operator>=</operator> <name>ep</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>MOD_NN</name></expr>:</case>              <comment type="block">/* Name or (signed) number; may be several */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>pp</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>ct</name> <init>= <expr><name>MAXCPYGET</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>value</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>li</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>S32OVERFLOW</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>INVALID_VALUE</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name>li</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>field</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>field</name> <operator>-</operator> <name><name>m</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name><name>m</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>      <comment type="block">/* Adjust field ptr */</comment>
      <if_stmt><if>if <condition>(<expr><name>value</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>                                    <comment type="block">/* Add new number */</comment>
        <block>{<block_content>
        <while>while <condition>(<expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ct</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>   <comment type="block">/* Skip previous */</comment>
          <expr_stmt><expr><name>field</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>field</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></while>
        <if_stmt><if>if <condition>(<expr><name>ct</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Too many numeric '%s' modifiers\n"</literal></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>FALSE</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>ct</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>pp</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>endptr</name></expr>;</expr_stmt>
      </block_content>}</block></if>

    <comment type="block">/* Multiple strings are put end to end. */</comment>

    <else>else
      <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nn</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>field</name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>                    <comment type="block">/* Add new name */</comment>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>MAX_NAME_SIZE</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Group name in '%s' is too long\n"</literal></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>FALSE</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        <while>while <condition>(<expr><operator>*</operator><name>nn</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nn</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>nn</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>
        <if_stmt><if>if <condition>(<expr><name>nn</name> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">2</literal> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>field</name> <operator>&gt;</operator> <name>LENCPYGET</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Too many characters in named '%s' modifiers\n"</literal></expr></argument>,
            <argument><expr><name><name>m</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>FALSE</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>nn</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>nn</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr> ;</expr_stmt>
      <expr_stmt><expr><name><name>nn</name><index>[<expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>pp</name> <operator>=</operator> <name>ep</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <break>break;</break>

    <case>case <expr><name>MOD_STR</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name><name>m</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Overlong value for '%s' (max %d code units)\n"</literal></expr></argument>,
        <argument><expr><name><name>m</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>value</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>field</name><operator>)</operator><index>[<expr><name>len</name></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pp</name> <operator>=</operator> <name>ep</name></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pp</name> <operator>!=</operator> <literal type="char">','</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>pp</name> <operator>!=</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>pp</name> <operator>!=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>pp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Comma expected after modifier item '%s'\n"</literal></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pp</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>first</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>==</operator> <name>CTX_POPPAT</name> <operator>&amp;&amp;</operator>
     <operator>(</operator><name><name>pctl</name><operator>-&gt;</operator><name>options</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
      <name><name>pctl</name><operator>-&gt;</operator><name>tables_id</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
      <name><name>pctl</name><operator>-&gt;</operator><name>locale</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
      <operator>(</operator><name><name>pctl</name><operator>-&gt;</operator><name>control</name></name> <operator>&amp;</operator> <name>NOTPOP_CONTROLS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** '%s' is not valid here\n"</literal></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

<return>return <expr><name>TRUE</name></expr>;</return>

<label><name>INVALID_VALUE</name>:</label>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Invalid value in '%.*s'\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ep</name><operator>-</operator><name>p</name><operator>)</operator></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*             Get info from a pattern            *
*************************************************/</comment>

<comment type="block">/* A wrapped call to pcre2_pattern_info(), applied to the current compiled
pattern.

Arguments:
  what        code for the required information
  where       where to put the answer
  unsetok     PCRE2_ERROR_UNSET is an "expected" result

Returns:      the return from pcre2_pattern_info()
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pattern_info</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>where</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>unsetok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PCRE2_PATTERN_INFO</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Exercise the code */</comment>
<expr_stmt><expr><call><name>PCRE2_PATTERN_INFO</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><name>where</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PCRE2_ERROR_UNSET</name> <operator>||</operator> <operator>!</operator><name>unsetok</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Error %d from pcre2_pattern_info_%d(%d)\n"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>test_mode</name></expr></argument>,
    <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PCRE2_ERROR_BADMODE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Running in %d-bit mode but pattern was compiled in "</literal>
      <literal type="string">"%d-bit mode\n"</literal></expr></argument>, <argument><expr><name>test_mode</name></expr></argument>,
      <argument><expr><literal type="number">8</literal> <operator>*</operator> <operator>(</operator><call><name>FLD</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>PCRE2_MODE_MASK</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>



<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
<comment type="block" format="doxygen">/*************************************************
*             Show something in a list           *
*************************************************/</comment>

<comment type="block">/* This function just helps to keep the code that uses it tidier. It's used for
various lists of things where there needs to be introductory text before the
first item. As these calls are all in the POSIX-support code, they happen only
when 8-bit mode is supported. */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prmsg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><operator>*</operator><name>msg</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>msg</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_PCRE2_8 */</comment>



<comment type="block" format="doxygen">/*************************************************
*                Show control bits               *
*************************************************/</comment>

<comment type="block">/* Called for mutually exclusive controls and for unsupported POSIX controls.
Because the bits are unique, this can be used for both pattern and data control
words.

Arguments:
  controls    control bits
  controls2   more control bits
  before      text to print before

Returns:      nothing
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_controls</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>controls</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>controls2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>before</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s"</literal></expr></argument>,
  <argument><expr><name>before</name></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_AFTERTEXT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" aftertext"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_ALLAFTERTEXT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" allaftertext"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_ALLCAPTURES</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" allcaptures"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_ALLUSEDTEXT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" allusedtext"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls2</name> <operator>&amp;</operator> <name>CTL2_ALLVECTOR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" allvector"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_ALTGLOBAL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" altglobal"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_BINCODE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" bincode"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls2</name> <operator>&amp;</operator> <name>CTL2_BSR_SET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" bsr"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_CALLOUT_CAPTURE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" callout_capture"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls2</name> <operator>&amp;</operator> <name>CTL2_CALLOUT_EXTRA</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" callout_extra"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_CALLOUT_INFO</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" callout_info"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_CALLOUT_NONE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" callout_none"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls2</name> <operator>&amp;</operator> <name>CTL2_CALLOUT_NO_WHERE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" callout_no_where"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_DFA</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" dfa"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_EXPAND</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" expand"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_FINDLIMITS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" find_limits"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_FRAMESIZE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" framesize"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_FULLBINCODE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" fullbincode"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_GETALL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" getall"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_GLOBAL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" global"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_HEXPAT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" hex"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_INFO</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" info"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_JITFAST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" jitfast"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_JITVERIFY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" jitverify"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_MARK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" mark"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_MEMORY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" memory"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls2</name> <operator>&amp;</operator> <name>CTL2_NL_SET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" newline"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_NULLCONTEXT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" null_context"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_POSIX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" posix"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_POSIX_NOSUB</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" posix_nosub"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_PUSH</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" push"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_PUSHCOPY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" pushcopy"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_PUSHTABLESCOPY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" pushtablescopy"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_STARTCHAR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" startchar"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls2</name> <operator>&amp;</operator> <name>CTL2_SUBSTITUTE_CALLOUT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" substitute_callout"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls2</name> <operator>&amp;</operator> <name>CTL2_SUBSTITUTE_EXTENDED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" substitute_extended"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls2</name> <operator>&amp;</operator> <name>CTL2_SUBSTITUTE_LITERAL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" substitute_literal"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls2</name> <operator>&amp;</operator> <name>CTL2_SUBSTITUTE_MATCHED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" substitute_matched"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls2</name> <operator>&amp;</operator> <name>CTL2_SUBSTITUTE_OVERFLOW_LENGTH</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" substitute_overflow_length"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls2</name> <operator>&amp;</operator> <name>CTL2_SUBSTITUTE_REPLACEMENT_ONLY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" substitute_replacement_only"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls2</name> <operator>&amp;</operator> <name>CTL2_SUBSTITUTE_UNKNOWN_UNSET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" substitute_unknown_unset"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls2</name> <operator>&amp;</operator> <name>CTL2_SUBSTITUTE_UNSET_EMPTY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" substitute_unset_empty"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_USE_LENGTH</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" use_length"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_UTF8_INPUT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" utf8_input"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>controls</name> <operator>&amp;</operator> <name>CTL_ZERO_TERMINATE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" zero_terminate"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*                Show compile options            *
*************************************************/</comment>

<comment type="block">/* Called from show_pattern_info() and for unsupported POSIX options.

Arguments:
  options     an options word
  before      text to print before
  after       text to print after

Returns:      nothing
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_compile_options</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>before</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>after</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>options</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%s &lt;none&gt;%s"</literal></expr></argument>, <argument><expr><name>before</name></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s"</literal></expr></argument>,
  <argument><expr><name>before</name></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_ALT_BSUX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" alt_bsux"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_ALT_CIRCUMFLEX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" alt_circumflex"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_ALT_VERBNAMES</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" alt_verbnames"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_ALLOW_EMPTY_CLASS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" allow_empty_class"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_ANCHORED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" anchored"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_AUTO_CALLOUT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" auto_callout"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_CASELESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" caseless"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_DOLLAR_ENDONLY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" dollar_endonly"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_DOTALL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" dotall"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_DUPNAMES</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" dupnames"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_ENDANCHORED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" endanchored"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_EXTENDED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" extended"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_EXTENDED_MORE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" extended_more"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_FIRSTLINE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" firstline"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_LITERAL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" literal"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_MATCH_INVALID_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" match_invalid_utf"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_MATCH_UNSET_BACKREF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" match_unset_backref"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_MULTILINE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" multiline"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NEVER_BACKSLASH_C</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" never_backslash_c"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NEVER_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" never_ucp"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NEVER_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" never_utf"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NO_AUTO_CAPTURE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" no_auto_capture"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NO_AUTO_POSSESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" no_auto_possess"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NO_DOTSTAR_ANCHOR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" no_dotstar_anchor"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NO_UTF_CHECK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" no_utf_check"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NO_START_OPTIMIZE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" no_start_optimize"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" ucp"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_UNGREEDY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" ungreedy"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_USE_OFFSET_LIMIT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" use_offset_limit"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" utf"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*           Show compile extra options           *
*************************************************/</comment>

<comment type="block">/* Called from show_pattern_info() and for unsupported POSIX options.

Arguments:
  options     an options word
  before      text to print before
  after       text to print after

Returns:      nothing
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_compile_extra_options</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>before</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>after</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>options</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%s &lt;none&gt;%s"</literal></expr></argument>, <argument><expr><name>before</name></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s%s%s%s%s%s"</literal></expr></argument>,
  <argument><expr><name>before</name></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" allow_surrogate_escapes"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" bad_escape_is_literal"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_EXTRA_ALT_BSUX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" extra_alt_bsux"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_EXTRA_MATCH_WORD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" match_word"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_EXTRA_MATCH_LINE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" match_line"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_EXTRA_ESCAPED_CR_IS_LF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" escaped_cr_is_lf"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>



<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
<comment type="block" format="doxygen">/*************************************************
*                Show match options              *
*************************************************/</comment>

<comment type="block">/* Called for unsupported POSIX options. */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_match_options</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s%s%s%s%s%s%s%s%s%s%s"</literal></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_ANCHORED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" anchored"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_COPY_MATCHED_SUBJECT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" copy_matched_subject"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_DFA_RESTART</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" dfa_restart"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_DFA_SHORTEST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" dfa_shortest"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_ENDANCHORED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" endanchored"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NO_JIT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" no_jit"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NO_UTF_CHECK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" no_utf_check"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NOTBOL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" notbol"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NOTEMPTY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" notempty"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NOTEMPTY_ATSTART</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" notempty_atstart"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NOTEOL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" noteol"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_PARTIAL_HARD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" partial_hard"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_PARTIAL_SOFT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" partial_soft"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_PCRE2_8 */</comment>



<comment type="block" format="doxygen">/*************************************************
*      Show memory usage info for a pattern      *
*************************************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_memory_info</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>name_count</name></decl>, <decl><type ref="prev"/><name>name_entry_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>cblock_size</name></decl>;</decl_stmt>

<comment type="block">/* One of the test_mode values will always be true, but to stop a compiler
warning we must initialize cblock_size. */</comment>

<expr_stmt><expr><name>cblock_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE8_MODE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cblock_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pcre2_real_code_8</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE16_MODE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cblock_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pcre2_real_code_16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE32_MODE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cblock_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pcre2_real_code_32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_NAMECOUNT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_count</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_NAMEENTRYSIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_entry_size</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Memory allocation (code space): %d\n"</literal></expr></argument>,
  <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>size</name> <operator>-</operator> <name>name_count</name><operator>*</operator><name>name_entry_size</name><operator>*</operator><name>code_unit_size</name> <operator>-</operator> <name>cblock_size</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>jit</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_JITSIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Memory allocation (JIT code): %d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*       Show frame size info for a pattern       *
*************************************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_framesize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>frame_size</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_FRAMESIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>frame_size</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Frame size for pcre2_match(): %d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>frame_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*         Get and output an error message        *
*************************************************/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>print_error_message</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>errorcode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>before</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>after</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PCRE2_GET_ERROR_MESSAGE</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>errorcode</name></expr></argument>, <argument><expr><name>pbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n** pcre2test internal error: cannot interpret error "</literal>
    <literal type="string">"number\n** Unexpected return (%d) from pcre2_get_error_message()\n"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><call><name>CASTVAR</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><name>pbuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
<return>return <expr><name>len</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*     Callback function for callout enumeration  *
*************************************************/</comment>

<comment type="block">/* The only differences in the callout emumeration block for different code
unit widths are that the pointers to the subject, the most recent MARK, and a
callout argument string point to strings of the appropriate width. Casts can be
used to deal with this.

Argument:
  cb            pointer to enumerate block
  callout_data  user data

Returns:    0
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>callout_callback</name><parameter_list>(<parameter><decl><type><name>pcre2_callout_enumerate_block_8</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callout_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><operator>(</operator><call><name>FLD</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>overall_options</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>callout_data</name></expr>;</expr_stmt>  <comment type="block">/* Not currently displayed */</comment>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Callout "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>delimiter</name> <init>= <expr><call><name>CODE_UNIT</name><argument_list>(<argument><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
    <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string_length</name></name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>callout_start_delims</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><name>delimiter</name> <operator>==</operator> <name><name>callout_start_delims</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>delimiter</name> <operator>=</operator> <name><name>callout_end_delims</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if></if_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%c  "</literal></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%d  "</literal></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%.*s\n"</literal></expr></argument>,
  <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>next_item_length</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name><name>cb</name><operator>-&gt;</operator><name>next_item_length</name></name></expr></else></ternary><operator>)</operator></expr></argument>,
  <argument><expr><name>pbuffer8</name> <operator>+</operator> <name><name>cb</name><operator>-&gt;</operator><name>pattern_position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*        Show information about a pattern        *
*************************************************/</comment>

<comment type="block">/* This function is called after a pattern has been compiled if any of the
information-requesting controls have been set.

Arguments:  none

Returns:    PR_OK     continue processing next line
            PR_SKIP   skip to a blank line
            PR_ABEND  abort the pcre2test run
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>show_pattern_info</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>compile_options</name></decl>, <decl><type ref="prev"/><name>overall_options</name></decl>, <decl><type ref="prev"/><name>extra_options</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><operator>(</operator><call><name>FLD</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>overall_options</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <operator>(</operator><name>CTL_BINCODE</name><operator>|</operator><name>CTL_FULLBINCODE</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"------------------------------------------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PCRE2_PRINTINT</name><argument_list>(<argument><expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_FULLBINCODE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_INFO</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>nametable</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>start_bits</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>heap_limit_set</name></decl>, <decl><type ref="prev"/><name>match_limit_set</name></decl>, <decl><type ref="prev"/><name>depth_limit_set</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>backrefmax</name></decl>, <decl><type ref="prev"/><name>bsr_convention</name></decl>, <decl><type ref="prev"/><name>capture_count</name></decl>, <decl><type ref="prev"/><name>first_ctype</name></decl>, <decl><type ref="prev"/><name>first_cunit</name></decl>,
    <decl><type ref="prev"/><name>hasbackslashc</name></decl>, <decl><type ref="prev"/><name>hascrorlf</name></decl>, <decl><type ref="prev"/><name>jchanged</name></decl>, <decl><type ref="prev"/><name>last_ctype</name></decl>, <decl><type ref="prev"/><name>last_cunit</name></decl>, <decl><type ref="prev"/><name>match_empty</name></decl>,
    <decl><type ref="prev"/><name>depth_limit</name></decl>, <decl><type ref="prev"/><name>heap_limit</name></decl>, <decl><type ref="prev"/><name>match_limit</name></decl>, <decl><type ref="prev"/><name>minlength</name></decl>, <decl><type ref="prev"/><name>nameentrysize</name></decl>, <decl><type ref="prev"/><name>namecount</name></decl>,
    <decl><type ref="prev"/><name>newline_convention</name></decl>;</decl_stmt>

  <comment type="block">/* Exercise the error route. */</comment>

  <expr_stmt><expr><call><name>PCRE2_PATTERN_INFO</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><literal type="number">999</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>rc</name></expr>;</expr_stmt>

  <comment type="block">/* These info requests may return PCRE2_ERROR_UNSET. */</comment>

  <switch>switch<condition>(<expr><call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_HEAPLIMIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>heap_limit</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><literal type="number">0</literal></expr>:</case>
    <expr_stmt><expr><name>heap_limit_set</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>PCRE2_ERROR_UNSET</name></expr>:</case>
    <expr_stmt><expr><name>heap_limit_set</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <break>break;</break>

    <default>default:</default>
    <return>return <expr><name>PR_ABEND</name></expr>;</return>
    </block_content>}</block></switch>

  <switch>switch<condition>(<expr><call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_MATCHLIMIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>match_limit</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><literal type="number">0</literal></expr>:</case>
    <expr_stmt><expr><name>match_limit_set</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>PCRE2_ERROR_UNSET</name></expr>:</case>
    <expr_stmt><expr><name>match_limit_set</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <break>break;</break>

    <default>default:</default>
    <return>return <expr><name>PR_ABEND</name></expr>;</return>
    </block_content>}</block></switch>

  <switch>switch<condition>(<expr><call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_DEPTHLIMIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>depth_limit</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><literal type="number">0</literal></expr>:</case>
    <expr_stmt><expr><name>depth_limit_set</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>PCRE2_ERROR_UNSET</name></expr>:</case>
    <expr_stmt><expr><name>depth_limit_set</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <break>break;</break>

    <default>default:</default>
    <return>return <expr><name>PR_ABEND</name></expr>;</return>
    </block_content>}</block></switch>

  <comment type="block">/* These info requests should always succeed. */</comment>

  <if_stmt><if>if <condition>(<expr><call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_BACKREFMAX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>backrefmax</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>+</operator>
      <call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_BSR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bsr_convention</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>+</operator>
      <call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_CAPTURECOUNT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>capture_count</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>+</operator>
      <call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_FIRSTBITMAP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_bits</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>+</operator>
      <call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_FIRSTCODEUNIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>first_cunit</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>+</operator>
      <call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_FIRSTCODETYPE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>first_ctype</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>+</operator>
      <call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_HASBACKSLASHC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hasbackslashc</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>+</operator>
      <call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_HASCRORLF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hascrorlf</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>+</operator>
      <call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_JCHANGED</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jchanged</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>+</operator>
      <call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_LASTCODEUNIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>last_cunit</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>+</operator>
      <call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_LASTCODETYPE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>last_ctype</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>+</operator>
      <call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_MATCHEMPTY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>match_empty</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>+</operator>
      <call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_MINLENGTH</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minlength</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>+</operator>
      <call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_NAMECOUNT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>namecount</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>+</operator>
      <call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_NAMEENTRYSIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nameentrysize</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>+</operator>
      <call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_NAMETABLE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nametable</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>+</operator>
      <call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_NEWLINE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newline_convention</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call>
      <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>PR_ABEND</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Capture group count = %d\n"</literal></expr></argument>, <argument><expr><name>capture_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>backrefmax</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Max back reference = %d\n"</literal></expr></argument>, <argument><expr><name>backrefmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>maxlookbehind</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Max lookbehind = %d\n"</literal></expr></argument>, <argument><expr><name>maxlookbehind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>heap_limit_set</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Heap limit = %u\n"</literal></expr></argument>, <argument><expr><name>heap_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>match_limit_set</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Match limit = %u\n"</literal></expr></argument>, <argument><expr><name>match_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>depth_limit_set</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Depth limit = %u\n"</literal></expr></argument>, <argument><expr><name>depth_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>namecount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Named capture groups:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init> <condition><expr><name>namecount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>namecount</name><operator>--</operator></expr></incr>)</control>
      <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>imm2_size</name> <init>= <expr><ternary><condition><expr><name>test_mode</name> <operator>==</operator> <name>PCRE8_MODE</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>length</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>nametable</name> <operator>+</operator> <name>imm2_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* In UTF mode the name may be a UTF string containing non-ASCII
      letters and digits. We must output it as a UTF-8 string. In non-UTF mode,
      use the normal string printing functions, which use escapes for all
      non-ASCII characters. */</comment>

      <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE32_MODE</name></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>PCRE2_SPTR32</name></type> <name>nameptr</name> <init>= <expr><operator>(</operator><name>PCRE2_SPTR32</name><operator>)</operator><name>nametable</name> <operator>+</operator> <name>imm2_size</name></expr></init></decl>;</decl_stmt>
          <while>while <condition>(<expr><operator>*</operator><name>nameptr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>u8buff</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>ord2utf8</name><argument_list>(<argument><expr><operator>*</operator><name>nameptr</name><operator>++</operator></expr></argument>, <argument><expr><name>u8buff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>u8buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
          </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE16_MODE</name></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>PCRE2_SPTR16</name></type> <name>nameptr</name> <init>= <expr><operator>(</operator><name>PCRE2_SPTR16</name><operator>)</operator><name>nametable</name> <operator>+</operator> <name>imm2_size</name></expr></init></decl>;</decl_stmt>
          <while>while <condition>(<expr><operator>*</operator><name>nameptr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>u8buff</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>nameptr</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">0xD800</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;</operator> <literal type="number">0xDC00</literal></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3ff</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">10</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>*</operator><name>nameptr</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x3ff</literal><operator>)</operator> <operator>+</operator> <literal type="number">0x10000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ord2utf8</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>u8buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>u8buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
          </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE8_MODE</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>PCRE2_SPTR8</name><operator>)</operator><name>nametable</name> <operator>+</operator> <name>imm2_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
      <else>else  <comment type="block">/* Not UTF mode */</comment>
        <block>{<block_content>
        <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name>nametable</name></expr></argument>, <argument><expr><name>imm2_size</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

      <while>while <condition>(<expr><name>length</name><operator>++</operator> <operator>&lt;</operator> <name>nameentrysize</name> <operator>-</operator> <name>imm2_size</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE32_MODE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%3d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>PCRE2_SPTR32</name><operator>)</operator><name>nametable</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE16_MODE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%3d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>PCRE2_SPTR16</name><operator>)</operator><name>nametable</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE8_MODE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%3d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator>
        <operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>PCRE2_SPTR8</name><operator>)</operator><name>nametable</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>PCRE2_SPTR8</name><operator>)</operator><name>nametable</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <expr_stmt><expr><name>nametable</name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>PCRE2_SPTR8</name><operator>)</operator><name>nametable</name> <operator>+</operator> <name>nameentrysize</name> <operator>*</operator> <name>code_unit_size</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>hascrorlf</name></expr>)</condition><block type="pseudo"><block_content>     <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Contains explicit CR or LF match\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>hasbackslashc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Contains \\C\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>match_empty</name></expr>)</condition><block type="pseudo"><block_content>   <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"May match empty string\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_ARGOPTIONS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>compile_options</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_ALLOPTIONS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>overall_options</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_EXTRAOPTIONS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra_options</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Remove UTF/UCP if they were there only because of forbid_utf. This saves
  cluttering up the verification output of non-UTF test files. */</comment>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>PCRE2_NEVER_UTF</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>compile_options</name> <operator>&amp;=</operator> <operator>~</operator><name>PCRE2_NEVER_UTF</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>overall_options</name> <operator>&amp;=</operator> <operator>~</operator><name>PCRE2_NEVER_UTF</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>PCRE2_NEVER_UCP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>compile_options</name> <operator>&amp;=</operator> <operator>~</operator><name>PCRE2_NEVER_UCP</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>overall_options</name> <operator>&amp;=</operator> <operator>~</operator><name>PCRE2_NEVER_UCP</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>compile_options</name><operator>|</operator><name>overall_options</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>compile_options</name> <operator>==</operator> <name>overall_options</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>show_compile_options</name><argument_list>(<argument><expr><name>compile_options</name></expr></argument>, <argument><expr><literal type="string">"Options:"</literal></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>show_compile_options</name><argument_list>(<argument><expr><name>compile_options</name></expr></argument>, <argument><expr><literal type="string">"Compile options:"</literal></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>show_compile_options</name><argument_list>(<argument><expr><name>overall_options</name></expr></argument>, <argument><expr><literal type="string">"Overall options:"</literal></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>extra_options</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>show_compile_extra_options</name><argument_list>(<argument><expr><name>extra_options</name></expr></argument>, <argument><expr><literal type="string">"Extra options:"</literal></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>jchanged</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Duplicate name status changes\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>CTL2_BSR_SET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
      <operator>(</operator><call><name>FLD</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>PCRE2_BSR_SET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\\R matches %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>bsr_convention</name> <operator>==</operator> <name>PCRE2_BSR_UNICODE</name><operator>)</operator></expr>?</condition><then>
      <expr><literal type="string">"any Unicode newline"</literal></expr> </then><else>: <expr><literal type="string">"CR, LF, or CRLF"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>FLD</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>PCRE2_NL_SET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <switch>switch <condition>(<expr><name>newline_convention</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>PCRE2_NEWLINE_CR</name></expr>:</case>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Forced newline is CR\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>PCRE2_NEWLINE_LF</name></expr>:</case>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Forced newline is LF\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>PCRE2_NEWLINE_CRLF</name></expr>:</case>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Forced newline is CRLF\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>PCRE2_NEWLINE_ANYCRLF</name></expr>:</case>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Forced newline is CR, LF, or CRLF\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>PCRE2_NEWLINE_ANY</name></expr>:</case>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Forced newline is any Unicode newline\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>PCRE2_NEWLINE_NUL</name></expr>:</case>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Forced newline is NUL\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <default>default:</default>
      <break>break;</break>
      </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>first_ctype</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"First code unit at start or follows newline\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>first_ctype</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>caseless</name> <init>=
      <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><call><name>FLD</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>PCRE2_FIRSTCASELESS</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then>
      <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" (caseless)"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>PRINTOK</name><argument_list>(<argument><expr><name>first_cunit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"First code unit = \'%c\'%s\n"</literal></expr></argument>, <argument><expr><name>first_cunit</name></expr></argument>, <argument><expr><name>caseless</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"First code unit = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pchar</name><argument_list>(<argument><expr><name>first_cunit</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>caseless</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>start_bits</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><literal type="number">24</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Starting code units: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>start_bits</name><index>[<expr><name>i</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>i</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">75</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n  "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>PRINTOK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>i</name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%c "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>c</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
          </block_content>}</block></if>
        <else>else
          <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\\x%02x "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>c</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>last_ctype</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>caseless</name> <init>=
      <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><call><name>FLD</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>PCRE2_LASTCASELESS</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then>
      <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" (caseless)"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>PRINTOK</name><argument_list>(<argument><expr><name>last_cunit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Last code unit = \'%c\'%s\n"</literal></expr></argument>, <argument><expr><name>last_cunit</name></expr></argument>, <argument><expr><name>caseless</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Last code unit = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pchar</name><argument_list>(<argument><expr><name>last_cunit</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>caseless</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>FLD</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>overall_options</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>PCRE2_NO_START_OPTIMIZE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Subject length lower bound = %d\n"</literal></expr></argument>, <argument><expr><name>minlength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>jit</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_JITVERIFY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>FLD</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>executable_jit</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"JIT compilation was successful\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
      <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_JIT</name></cpp:ifdef>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"JIT compilation was not successful"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>jitrc</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>print_error_message</name><argument_list>(<argument><expr><name>jitrc</name></expr></argument>, <argument><expr><literal type="string">" ("</literal></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>PR_ABEND</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"JIT support is not available in this version of PCRE2\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_CALLOUT_INFO</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>errorcode</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>PCRE2_CALLOUT_ENUMERATE</name><argument_list>(<argument><expr><name>errorcode</name></expr></argument>, <argument><expr><name>callout_callback</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>errorcode</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Callout enumerate failed: error %d: "</literal></expr></argument>, <argument><expr><name>errorcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>errorcode</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>print_error_message</name><argument_list>(<argument><expr><name>errorcode</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>PR_ABEND</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><name>PR_SKIP</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<return>return <expr><name>PR_OK</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*              Handle serialization error        *
*************************************************/</comment>

<comment type="block">/* Print an error message after a serialization failure.

Arguments:
  rc         the error code
  msg        an initial message for what failed

Returns:     FALSE if print_error_message() fails
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>serial_error</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%s failed: error %d: "</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>print_error_message</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*        Open file for save/load commands        *
*************************************************/</comment>

<comment type="block">/* This function decodes the file name and opens the file.

Arguments:
  buffptr     point after the #command
  mode        open mode
  fptr        points to the FILE variable
  name        name of # command

Returns:      PR_OK or PR_ABEND
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>open_file</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buffptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier><modifier>*</modifier></type><name>fptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buffptr</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>filename</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name>endf</name> <operator>=</operator> <name>filename</name> <operator>+</operator> <call><name>strlen8</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>endf</name> <operator>&gt;</operator> <name>filename</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><name><name>endf</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>endf</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>endf</name> <operator>==</operator> <name>filename</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** File name expected after %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_ABEND</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>endf</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>fptr</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>filename</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Failed to open '%s': %s\n"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_ABEND</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<return>return <expr><name>PR_OK</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*               Process command line             *
*************************************************/</comment>

<comment type="block">/* This function is called for lines beginning with # and a character that is
not ! or whitespace, when encountered between tests, which means that there is
no compiled pattern (compiled_code is NULL). The line is in buffer.

Arguments:  none

Returns:    PR_OK     continue processing next line
            PR_SKIP   skip to a blank line
            PR_ABEND  abort the pcre2test run
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>process_command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>serial_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>, <decl><type ref="prev"/><name>cmd</name></decl>, <decl><type ref="prev"/><name>cmdlen</name></decl>, <decl><type ref="prev"/><name>yield</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>first_listed_newline</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>argptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>serial</name></decl>;</decl_stmt>

<expr_stmt><expr><name>yield</name> <operator>=</operator> <name>PR_OK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <name>CMD_UNKNOWN</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cmdlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cmdlistcount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <expr_stmt><expr><name>cmdname</name> <operator>=</operator> <name><name>cmdlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cmdlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cmdname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>cmdname</name></expr></argument>, <argument><expr><name>cmdlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
      <call><name>isspace</name><argument_list>(<argument><expr><name><name>buffer</name><index>[<expr><name>cmdlen</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>cmd</name> <operator>=</operator> <name><name>cmdlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

<expr_stmt><expr><name>argptr</name> <operator>=</operator> <name>buffer</name> <operator>+</operator> <name>cmdlen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>restrict_for_perl_test</name> <operator>&amp;&amp;</operator> <name>cmd</name> <operator>!=</operator> <name>CMD_PATTERN</name> <operator>&amp;&amp;</operator> <name>cmd</name> <operator>!=</operator> <name>CMD_SUBJECT</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** #%s is not allowed after #perltest\n"</literal></expr></argument>, <argument><expr><name>cmdname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_ABEND</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<switch>switch<condition>(<expr><name>cmd</name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><name>CMD_UNKNOWN</name></expr>:</case>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Unknown command: %s"</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>CMD_FORBID_UTF</name></expr>:</case>
  <expr_stmt><expr><name>forbid_utf</name> <operator>=</operator> <name>PCRE2_NEVER_UTF</name><operator>|</operator><name>PCRE2_NEVER_UCP</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>CMD_PERLTEST</name></expr>:</case>
  <expr_stmt><expr><name>restrict_for_perl_test</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <break>break;</break>

  <comment type="block">/* Set default pattern modifiers */</comment>

  <case>case <expr><name>CMD_PATTERN</name></expr>:</case>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>decode_modifiers</name><argument_list>(<argument><expr><name>argptr</name></expr></argument>, <argument><expr><name>CTX_DEFPAT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>def_patctl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>def_patctl</name><operator>.</operator><name>jit</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>def_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_JITVERIFY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>def_patctl</name><operator>.</operator><name>jit</name></name> <operator>=</operator> <name>JIT_DEFAULT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <break>break;</break>

  <comment type="block">/* Set default subject modifiers */</comment>

  <case>case <expr><name>CMD_SUBJECT</name></expr>:</case>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>decode_modifiers</name><argument_list>(<argument><expr><name>argptr</name></expr></argument>, <argument><expr><name>CTX_DEFDAT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>def_datctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>

  <comment type="block">/* Check the default newline, and if not one of those listed, set up the
  first one to be forced. An empty list unsets. */</comment>

  <case>case <expr><name>CMD_NEWLINE_DEFAULT</name></expr>:</case>
  <expr_stmt><expr><name>local_newline_default</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <comment type="block">/* Unset */</comment>
  <expr_stmt><expr><name>first_listed_newline</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
    <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>argptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>argptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>argptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>newlines</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
      <decl_stmt><decl><type><name>size_t</name></type> <name>nlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>newlines</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>strncmpic</name><argument_list>(<argument><expr><name>argptr</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>newlines</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>nlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
          <call><name>isspace</name><argument_list>(<argument><expr><name><name>argptr</name><index>[<expr><name>nlen</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>NEWLINE_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PR_OK</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Default is valid */</comment>
        <if_stmt><if>if <condition>(<expr><name>first_listed_newline</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>first_listed_newline</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    <while>while <condition>(<expr><operator>*</operator><name>argptr</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>argptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>argptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></for>
  <expr_stmt><expr><name>local_newline_default</name> <operator>=</operator> <name>first_listed_newline</name></expr>;</expr_stmt>
  <break>break;</break>

  <comment type="block">/* Pop or copy a compiled pattern off the stack. Modifiers that do not affect
  the compiled pattern (e.g. to give information) are permitted. The default
  pattern modifiers are ignored. */</comment>

  <case>case <expr><name>CMD_POP</name></expr>:</case>
  <case>case <expr><name>CMD_POPCOPY</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>patstacknext</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Can't pop off an empty stack\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_SKIP</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pat_patctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>patctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Completely unset */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>decode_modifiers</name><argument_list>(<argument><expr><name>argptr</name></expr></argument>, <argument><expr><name>CTX_POPPAT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pat_patctl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>PR_SKIP</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>==</operator> <name>CMD_POP</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name><name>patstack</name><index>[<expr><operator>--</operator><name>patstacknext</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>PCRE2_CODE_COPY_FROM_VOID</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name><name>patstack</name><index>[<expr><name>patstacknext</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>jit</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>PCRE2_JIT_COMPILE</name><argument_list>(<argument><expr><name>jitrc</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name><name>pat_patctl</name><operator>.</operator><name>jit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_MEMORY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>show_memory_info</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_FRAMESIZE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>show_framesize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_ANYINFO</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>show_pattern_info</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PR_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  <break>break;</break>

  <comment type="block">/* Save the stack of compiled patterns to a file, then empty the stack. */</comment>

  <case>case <expr><name>CMD_SAVE</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>patstacknext</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** No stacked patterns to save\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>open_file</name><argument_list>(<argument><expr><name>argptr</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>BINARY_OUTPUT_MODE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><literal type="string">"#save"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PR_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>PCRE2_SERIALIZE_ENCODE</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>patstack</name></expr></argument>, <argument><expr><name>patstacknext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>serial</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>serial_size</name></expr></argument>,
    <argument><expr><name>general_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>serial_error</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">"Serialization"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PR_ABEND</name></expr>;</return></block_content></block></if></if_stmt>
    <break>break;</break>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Write the length at the start of the file to make it straightforward to
  get the right memory when re-loading. This saves having to read the file size
  in different operating systems. To allow for different endianness (even
  though reloading with the opposite endianness does not work), write the
  length byte-by-byte. */</comment>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><operator>(</operator><name>serial_size</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>i</name><operator>*</operator><literal type="number">8</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">255</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name>serial</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>serial_size</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>serial_size</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Wrong return from fwrite()\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_ABEND</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PCRE2_SERIALIZE_FREE</name><argument_list>(<argument><expr><name>serial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>(<expr><name>patstacknext</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name><name>patstack</name><index>[<expr><operator>--</operator><name>patstacknext</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SUB1</name><argument_list>(<argument><expr><name>pcre2_code_free</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
  <expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>

  <comment type="block">/* Load a set of compiled patterns from a file onto the stack */</comment>

  <case>case <expr><name>CMD_LOAD</name></expr>:</case>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>open_file</name><argument_list>(<argument><expr><name>argptr</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>BINARY_INPUT_MODE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><literal type="string">"#load"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PR_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>serial_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>serial_size</name> <operator>|=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <operator>(</operator><name>i</name><operator>*</operator><literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>

  <expr_stmt><expr><name>serial</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>serial_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>serial</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <macro><name>fprintf</name><argument_list>(<argument>outfile</argument>, <argument><literal type="string">"** Failed to get memory (size %"</literal> SIZ_FORM <literal type="string">") for #load\n"</literal></argument>,
      <argument>SIZ_CAST serial_size</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_ABEND</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>serial</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>serial_size</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>serial_size</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Wrong return from fread()\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>yield</name> <operator>=</operator> <name>PR_ABEND</name></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>PCRE2_SERIALIZE_GET_NUMBER_OF_CODES</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>serial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>serial_error</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">"Get number of codes"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>yield</name> <operator>=</operator> <name>PR_ABEND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>+</operator> <name>patstacknext</name> <operator>&gt;</operator> <name>PATSTACKSIZE</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Not enough space on pattern stack for %d pattern%s\n"</literal></expr></argument>,
          <argument><expr><name>rc</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>rc</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"s"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PATSTACKSIZE</name> <operator>-</operator> <name>patstacknext</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Decoding %d pattern%s\n"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>,
          <argument><expr><ternary><condition><expr><operator>(</operator><name>rc</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"s"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>PCRE2_SERIALIZE_DECODE</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>patstack</name> <operator>+</operator> <name>patstacknext</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>serial</name></expr></argument>,
        <argument><expr><name>general_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>serial_error</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">"Deserialization"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>yield</name> <operator>=</operator> <name>PR_ABEND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>patstacknext</name> <operator>+=</operator> <name>rc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>serial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>

  <comment type="block">/* Load a set of binary tables into tables3. */</comment>

  <case>case <expr><name>CMD_LOADTABLES</name></expr>:</case>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>open_file</name><argument_list>(<argument><expr><name>argptr</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>BINARY_INPUT_MODE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><literal type="string">"#loadtables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PR_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>tables3</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_TABLES_LENGTH</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loadtables_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tables3</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>loadtables_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>tables3</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Failed: malloc failed for #loadtables\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>yield</name> <operator>=</operator> <name>PR_ABEND</name></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>tables3</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>loadtables_length</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>loadtables_length</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Wrong return from fread()\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>yield</name> <operator>=</operator> <name>PR_ABEND</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
  </block_content>}</block></switch>

<return>return <expr><name>yield</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*               Process pattern line             *
*************************************************/</comment>

<comment type="block">/* This function is called when the input buffer contains the start of a
pattern. The first character is known to be a valid delimiter. The pattern is
read, modifiers are interpreted, and a suitable local context is set up for
this test. The pattern is then compiled.

Arguments:  none

Returns:    PR_OK     continue processing next line
            PR_SKIP   skip to a blank line
            PR_ABEND  abort the pcre2test run
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>process_pattern</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>delimiter</name> <init>= <expr><operator>*</operator><name>p</name><operator>++</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>errorcode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>use_pat_context</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>use_forbid_utf</name> <init>= <expr><name>forbid_utf</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>patlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>valgrind_access_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>erroroffset</name></decl>;</decl_stmt>

<comment type="block">/* The perltest.sh script supports only / as a delimiter. */</comment>

<if_stmt><if>if <condition>(<expr><name>restrict_for_perl_test</name> <operator>&amp;&amp;</operator> <name>delimiter</name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** The only allowed delimiter after #perltest is '/'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_ABEND</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Initialize the context and pattern/data controls for this test from the
defaults. */</comment>

<expr_stmt><expr><call><name>PATCTXCPY</name><argument_list>(<argument><expr><name>pat_context</name></expr></argument>, <argument><expr><name>default_pat_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pat_patctl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>def_patctl</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>patctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Find the end of the pattern, reading more lines if necessary. */</comment>

<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>delimiter</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>extend_inputline</name><argument_list>(<argument><expr><name>infile</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"    &gt; "</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Unexpected EOF\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_ABEND</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>INTERACTIVE</name><argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>

<comment type="block">/* If the first character after the delimiter is backslash, make the pattern
end with backslash. This is purely to provide a way of testing for the error
message when a pattern ends with backslash. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* Terminate the pattern at the delimiter, and compute the length. */</comment>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>patlen</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>buffer</name> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<comment type="block">/* Look for modifiers and options after the final delimiter. */</comment>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>decode_modifiers</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>CTX_PAT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pat_patctl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PR_SKIP</name></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* Note that the match_invalid_utf option also sets utf when passed to
pcre2_compile(). */</comment>

<expr_stmt><expr><name>utf</name> <operator>=</operator> <operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_UTF</name><operator>|</operator><name>PCRE2_MATCH_INVALID_UTF</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<comment type="block">/* The utf8_input modifier is not allowed in 8-bit mode, and is mutually
exclusive with the utf modifier. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_UTF8_INPUT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE8_MODE</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** The utf8_input modifier is not allowed in 8-bit mode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_SKIP</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** The utf and utf8_input modifiers are mutually exclusive\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_SKIP</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* The convert and posix modifiers are mutually exclusive. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>convert_type</name></name> <operator>!=</operator> <name>CONVERT_UNSET</name> <operator>&amp;&amp;</operator>
    <operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_POSIX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** The convert and posix modifiers are mutually exclusive\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_SKIP</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Check for mutually exclusive control modifiers. At present, these are all in
the first control word. */</comment>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>exclusive_pat_controls</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name> <init>= <expr><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name><name>exclusive_pat_controls</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><name>c</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>show_controls</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"** Not allowed together:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_SKIP</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

<comment type="block">/* Assume full JIT compile for jitverify and/or jitfast if nothing else was
specified. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>jit</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
    <operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <operator>(</operator><name>CTL_JITVERIFY</name><operator>|</operator><name>CTL_JITFAST</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>pat_patctl</name><operator>.</operator><name>jit</name></name> <operator>=</operator> <name>JIT_DEFAULT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* Now copy the pattern to pbuffer8 for use in 8-bit testing and for reflecting
in callouts. Convert from hex if requested (literal strings in quotes may be
present within the hexadecimal pairs). The result must necessarily be fewer
characters so will always fit in pbuffer8. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_HEXPAT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pt</name> <operator>=</operator> <name>pbuffer8</name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>pp</name> <operator>=</operator> <name>buffer</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>*</operator><name>pp</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>pp</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>pp</name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Handle a literal substring */</comment>

    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\''</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pq</name> <init>= <expr><name>pp</name></expr></init></decl>;</decl_stmt>
      <for>for <control>(<init>;</init><condition>;</condition> <incr><expr><name>pp</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <operator>*</operator><name>pp</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Missing closing quote in hex pattern: "</literal>
            <literal type="string">"opening quote is at offset %"</literal> <name>PTR_FORM</name> <literal type="string">".\n"</literal></expr></argument>, <argument><expr><name>pq</name> <operator>-</operator> <name>buffer</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>PR_SKIP</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>pt</name><operator>++</operator> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if>

    <comment type="block">/* Expect a hex pair */</comment>

    <else>else
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isxdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Unexpected non-hex-digit '%c' at offset %"</literal>
          <name>PTR_FORM</name> <literal type="string">" in hex pattern: quote missing?\n"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>pp</name> <operator>-</operator> <name>buffer</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_SKIP</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Odd number of digits in hex pattern\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_SKIP</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>d</name> <operator>=</operator> <operator>*</operator><name>pp</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isxdigit</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Unexpected non-hex-digit '%c' at offset %"</literal>
          <name>PTR_FORM</name> <literal type="string">" in hex pattern: quote missing?\n"</literal></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>pp</name> <operator>-</operator> <name>buffer</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_SKIP</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>toupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>toupper</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>pt</name><operator>++</operator> <operator>=</operator> <operator>(</operator><operator>(</operator><ternary><condition><expr><call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>?</condition><then> <expr><operator>(</operator><name>c</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>c</name> <operator>-</operator> <literal type="char">'A'</literal> <operator>+</operator> <literal type="number">10</literal><operator>)</operator></expr></else></ternary><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator>
               <operator>(</operator><ternary><condition><expr><call><name>isdigit</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>?</condition><then> <expr><operator>(</operator><name>d</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>d</name> <operator>-</operator> <literal type="char">'A'</literal> <operator>+</operator> <literal type="number">10</literal><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>pt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>patlen</name> <operator>=</operator> <name>pt</name> <operator>-</operator> <name>pbuffer8</name></expr>;</expr_stmt>
  </block_content>}</block></if>

<comment type="block">/* If not a hex string, process for repetition expansion if requested. */</comment>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_EXPAND</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pt</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pt</name> <operator>=</operator> <name>pbuffer8</name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>pp</name> <operator>=</operator> <name>buffer</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>*</operator><name>pp</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>pp</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
    <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><name>pp</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>count</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>length</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Check for replication syntax; if not found, the defaults just set will
    prevail and one character will be copied. */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>pp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>pp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pe</name></decl>;</decl_stmt>
      <for>for <control>(<init><expr><name>pe</name> <operator>=</operator> <name>pp</name> <operator>+</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><operator>*</operator><name>pe</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>pe</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>pe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">']'</literal> <operator>&amp;&amp;</operator> <name><name>pe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>uint32_t</name></type> <name>clen</name> <init>= <expr><name>pe</name> <operator>-</operator> <name>pc</name> <operator>-</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>uli</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

          <expr_stmt><expr><name>pe</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>uli</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pe</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><call><name>U32OVERFLOW</name><argument_list>(<argument><expr><name>uli</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Pattern repeat count too large\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>PR_SKIP</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

          <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>uli</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pe</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>endptr</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pe</name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Zero repeat not allowed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><name>PR_SKIP</name></expr>;</return>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>pc</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>length</name> <operator>=</operator> <name>clen</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>pp</name> <operator>=</operator> <name>pe</name></expr>;</expr_stmt>
            <break>break;</break>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Add to output. If the buffer is too small expand it. The function for
    expanding buffers always keeps buffer and pbuffer8 in step as far as their
    size goes. */</comment>

    <while>while <condition>(<expr><name>pt</name> <operator>+</operator> <name>count</name> <operator>*</operator> <name>length</name> <operator>&gt;</operator> <name>pbuffer8</name> <operator>+</operator> <name>pbuffer8_size</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>size_t</name></type> <name>pc_offset</name> <init>= <expr><name>pc</name> <operator>-</operator> <name>buffer</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name></type> <name>pp_offset</name> <init>= <expr><name>pp</name> <operator>-</operator> <name>buffer</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name></type> <name>pt_offset</name> <init>= <expr><name>pt</name> <operator>-</operator> <name>pbuffer8</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>expand_input_buffers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pc</name> <operator>=</operator> <name>buffer</name> <operator>+</operator> <name>pc_offset</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pp</name> <operator>=</operator> <name>buffer</name> <operator>+</operator> <name>pp_offset</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pt</name> <operator>=</operator> <name>pbuffer8</name> <operator>+</operator> <name>pt_offset</name></expr>;</expr_stmt>
      </block_content>}</block></while>

    <for>for <control>(<init>;</init> <condition><expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>count</name><operator>--</operator></expr></incr>)</control>
      <block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pt</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></for>

  <expr_stmt><expr><operator>*</operator><name>pt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>patlen</name> <operator>=</operator> <name>pt</name> <operator>-</operator> <name>pbuffer8</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_INFO</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Expanded: %s\n"</literal></expr></argument>, <argument><expr><name>pbuffer8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if>

<comment type="block">/* Neither hex nor expanded, just copy the input verbatim. */</comment>

<else>else
  <block>{<block_content>
  <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pbuffer8</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>buffer</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>patlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<comment type="block">/* Sort out character tables */</comment>

<if_stmt><if>if <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>locale</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>tables_id</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** 'Locale' and 'tables' must not both be set\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_SKIP</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>pat_patctl</name><operator>.</operator><name>locale</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Failed to set locale '%s'\n"</literal></expr></argument>, <argument><expr><name><name>pat_patctl</name><operator>.</operator><name>locale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_SKIP</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>pat_patctl</name><operator>.</operator><name>locale</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>locale_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>locale_name</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>pat_patctl</name><operator>.</operator><name>locale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>locale_tables</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>locale_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>PCRE2_MAKETABLES</name><argument_list>(<argument><expr><name>locale_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>use_tables</name> <operator>=</operator> <name>locale_tables</name></expr>;</expr_stmt>
  </block_content>}</block></if>

<else>else<block type="pseudo"><block_content> <switch>switch <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>tables_id</name></name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>use_tables</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>use_tables</name> <operator>=</operator> <name>tables1</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>use_tables</name> <operator>=</operator> <name>tables2</name></expr>;</expr_stmt> <break>break;</break>

  <case>case <expr><literal type="number">3</literal></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>tables3</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** 'Tables = 3' is invalid: binary tables have not "</literal>
      <literal type="string">"been loaded\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_SKIP</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>use_tables</name> <operator>=</operator> <name>tables3</name></expr>;</expr_stmt>
  <break>break;</break>

  <default>default:</default>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** 'Tables' must specify 0, 1, 2, or 3.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_SKIP</name></expr>;</return>
  </block_content>}</block></switch></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>PCRE2_SET_CHARACTER_TABLES</name><argument_list>(<argument><expr><name>pat_context</name></expr></argument>, <argument><expr><name>use_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Set up for the stackguard test. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>stackguard_test</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>PCRE2_SET_COMPILE_RECURSION_GUARD</name><argument_list>(<argument><expr><name>pat_context</name></expr></argument>, <argument><expr><name>stack_guard</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Handle compiling via the POSIX interface, which doesn't support the
timing, showing, or debugging options, nor the ability to pass over
local character tables. Neither does it have 16-bit or 32-bit support. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_POSIX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>cflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><literal type="string">"** Ignored with POSIX interface:"</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>!=</operator> <name>PCRE8_MODE</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** The POSIX interface is available only in 8-bit mode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_SKIP</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
  <comment type="block">/* Check for features that the POSIX interface does not support. */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>locale</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>prmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="string">"locale"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>replacement</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>prmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="string">"replace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>tables_id</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>prmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="string">"tables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>stackguard_test</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>prmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="string">"stackguard"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>timeit</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>prmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="string">"timing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>jit</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>prmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="string">"JIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <operator>~</operator><name>POSIX_SUPPORTED_COMPILE_OPTIONS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>show_compile_options</name><argument_list>(
      <argument><expr><name><name>pat_patctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <operator>~</operator><name>POSIX_SUPPORTED_COMPILE_OPTIONS</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>FLD</name><argument_list>(<argument><expr><name>pat_context</name></expr></argument>, <argument><expr><name>extra_options</name></expr></argument>)</argument_list></call> <operator>&amp;</operator>
       <operator>~</operator><name>POSIX_SUPPORTED_COMPILE_EXTRA_OPTIONS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>show_compile_extra_options</name><argument_list>(
      <argument><expr><call><name>FLD</name><argument_list>(<argument><expr><name>pat_context</name></expr></argument>, <argument><expr><name>extra_options</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>POSIX_SUPPORTED_COMPILE_EXTRA_OPTIONS</name></expr></argument>,
        <argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <operator>~</operator><name>POSIX_SUPPORTED_COMPILE_CONTROLS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
      <operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <operator>~</operator><name>POSIX_SUPPORTED_COMPILE_CONTROLS2</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>show_controls</name><argument_list>(<argument><expr><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <operator>~</operator><name>POSIX_SUPPORTED_COMPILE_CONTROLS</name></expr></argument>,
      <argument><expr><name><name>pat_patctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <operator>~</operator><name>POSIX_SUPPORTED_COMPILE_CONTROLS2</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>local_newline_default</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>prmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="string">"#newline_default"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>FLD</name><argument_list>(<argument><expr><name>pat_context</name></expr></argument>, <argument><expr><name>max_pattern_length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PCRE2_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>prmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="string">"max_pattern_length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>FLD</name><argument_list>(<argument><expr><name>pat_context</name></expr></argument>, <argument><expr><name>parens_nest_limit</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PARENS_NEST_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>prmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="string">"parens_nest_limit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>msg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Translate PCRE2 options to POSIX options and then compile. */</comment>

  <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cflags</name> <operator>|=</operator> <name>REG_UTF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_POSIX_NOSUB</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cflags</name> <operator>|=</operator> <name>REG_NOSUB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cflags</name> <operator>|=</operator> <name>REG_UCP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>PCRE2_CASELESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cflags</name> <operator>|=</operator> <name>REG_ICASE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>PCRE2_LITERAL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cflags</name> <operator>|=</operator> <name>REG_NOSPEC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>PCRE2_MULTILINE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cflags</name> <operator>|=</operator> <name>REG_NEWLINE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>PCRE2_DOTALL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cflags</name> <operator>|=</operator> <name>REG_DOTALL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>PCRE2_UNGREEDY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cflags</name> <operator>|=</operator> <name>REG_UNGREEDY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <operator>(</operator><name>CTL_HEXPAT</name><operator>|</operator><name>CTL_USE_LENGTH</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name><name>preg</name><operator>.</operator><name>re_endp</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pbuffer8</name> <operator>+</operator> <name>patlen</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cflags</name> <operator>|=</operator> <name>REG_PEND</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>regcomp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preg</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pbuffer8</name></expr></argument>, <argument><expr><name>cflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Compiling failed */</comment>

  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>bsize</name></decl>, <decl><type ref="prev"/><name>usize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>psize</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>preg</name><operator>.</operator><name>re_pcre2_code</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>     <comment type="block">/* In case something was left in there */</comment>
    <expr_stmt><expr><name><name>preg</name><operator>.</operator><name>re_match_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>bsize</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>regerror_buffsize</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then>
      <expr><name><name>pat_patctl</name><operator>.</operator><name>regerror_buffsize</name></name></expr> </then><else>: <expr><name>pbuffer8_size</name></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>bsize</name> <operator>+</operator> <literal type="number">8</literal> <operator>&lt;</operator> <name>pbuffer8_size</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pbuffer8</name> <operator>+</operator> <name>bsize</name></expr></argument>, <argument><expr><literal type="string">"DEADBEEF"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>usize</name> <operator>=</operator> <call><name>regerror</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>preg</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pbuffer8</name></expr></argument>, <argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Inside regerror(), snprintf() is used. If the buffer is too small, some
    versions of snprintf() put a zero byte at the end, but others do not.
    Therefore, we print a maximum of one less than the size of the buffer. */</comment>

    <expr_stmt><expr><name>psize</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>bsize</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Failed: POSIX code %d: %.*s\n"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>, <argument><expr><name>pbuffer8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>usize</name> <operator>&gt;</operator> <name>bsize</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** regerror() message truncated\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>pbuffer8</name> <operator>+</operator> <name>bsize</name></expr></argument>, <argument><expr><literal type="string">"DEADBEEF"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** regerror() buffer overflow\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    <return>return <expr><name>PR_SKIP</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Compiling succeeded. Check that the values in the preg block are sensible.
  It can happen that pcre2test is accidentally linked with a different POSIX
  library which succeeds, but of course puts different things into preg. In
  this situation, calling regfree() may cause a segfault (or invalid free() in
  valgrind), so ensure that preg.re_pcre2_code is NULL, which suppresses the
  calling of regfree() on exit. */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>preg</name><operator>.</operator><name>re_pcre2_code</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
      <operator>(</operator><operator>(</operator><name>pcre2_real_code_8</name> <operator>*</operator><operator>)</operator><name><name>preg</name><operator>.</operator><name>re_pcre2_code</name></name><operator>)</operator><operator>-&gt;</operator><name>magic_number</name> <operator>!=</operator> <name>MAGIC_NUMBER</name> <operator>||</operator>
      <operator>(</operator><operator>(</operator><name>pcre2_real_code_8</name> <operator>*</operator><operator>)</operator><name><name>preg</name><operator>.</operator><name>re_pcre2_code</name></name><operator>)</operator><operator>-&gt;</operator><name>top_bracket</name> <operator>!=</operator> <name><name>preg</name><operator>.</operator><name>re_nsub</name></name> <operator>||</operator>
      <name><name>preg</name><operator>.</operator><name>re_match_data</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
      <name><name>preg</name><operator>.</operator><name>re_cflags</name></name> <operator>!=</operator> <name>cflags</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>,
      <argument><expr><literal type="string">"** The regcomp() function returned zero (success), but the values set\n"</literal>
      <literal type="string">"** in the preg block are not valid for PCRE2. Check that pcre2test is\n"</literal>
      <literal type="string">"** linked with PCRE2's pcre2posix module (-lpcre2-posix) and not with\n"</literal>
      <literal type="string">"** some other POSIX regex library.\n**\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>preg</name><operator>.</operator><name>re_pcre2_code</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>PR_ABEND</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <return>return <expr><name>PR_OK</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_PCRE2_8 */</comment>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Handle compiling via the native interface. Controls that act later are
ignored with "push". Replacements are locked out. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <operator>(</operator><name>CTL_PUSH</name><operator>|</operator><name>CTL_PUSHCOPY</name><operator>|</operator><name>CTL_PUSHTABLESCOPY</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>replacement</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Replacement text is not supported with 'push'.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <operator>~</operator><name>PUSH_SUPPORTED_COMPILE_CONTROLS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
      <operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <operator>~</operator><name>PUSH_SUPPORTED_COMPILE_CONTROLS2</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>show_controls</name><argument_list>(<argument><expr><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <operator>~</operator><name>PUSH_SUPPORTED_COMPILE_CONTROLS</name></expr></argument>,
                  <argument><expr><name><name>pat_patctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <operator>~</operator><name>PUSH_SUPPORTED_COMPILE_CONTROLS2</name></expr></argument>,
      <argument><expr><literal type="string">"** Ignored when compiled pattern is stacked with 'push':"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>PUSH_COMPILE_ONLY_CONTROLS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
      <operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>PUSH_COMPILE_ONLY_CONTROLS2</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>show_controls</name><argument_list>(<argument><expr><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>PUSH_COMPILE_ONLY_CONTROLS</name></expr></argument>,
                  <argument><expr><name><name>pat_patctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>PUSH_COMPILE_ONLY_CONTROLS2</name></expr></argument>,
      <argument><expr><literal type="string">"** Applies only to compile when pattern is stacked with 'push':"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Convert the input in non-8-bit modes. */</comment>

<expr_stmt><expr><name>errorcode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE16_MODE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <call><name>to16</name><argument_list>(<argument><expr><name>pbuffer8</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>patlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE32_MODE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <call><name>to32</name><argument_list>(<argument><expr><name>pbuffer8</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>patlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<switch>switch<condition>(<expr><name>errorcode</name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Failed: invalid UTF-8 string cannot be "</literal>
    <literal type="string">"converted to %d-bit string\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>test_mode</name> <operator>==</operator> <name>PCRE16_MODE</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">16</literal></expr></then><else>:<expr><literal type="number">32</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_SKIP</name></expr>;</return>

  <case>case <expr><operator>-</operator><literal type="number">2</literal></expr>:</case>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Failed: character value greater than 0x10ffff "</literal>
    <literal type="string">"cannot be converted to UTF\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_SKIP</name></expr>;</return>

  <case>case <expr><operator>-</operator><literal type="number">3</literal></expr>:</case>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Failed: character value greater than 0xffff "</literal>
    <literal type="string">"cannot be converted to 16-bit in non-UTF mode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_SKIP</name></expr>;</return>

  <default>default:</default>
  <break>break;</break>
  </block_content>}</block></switch>

<comment type="block">/* The pattern is now in pbuffer[8|16|32], with the length in code units in
patlen. If it is to be converted, copy the result back afterwards so that it
ends up back in the usual place. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>convert_type</name></name> <operator>!=</operator> <name>CONVERT_UNSET</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>convert_return</name> <init>= <expr><name>PR_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>convert_options</name> <init>= <expr><name><name>pat_patctl</name><operator>.</operator><name>convert_type</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>converted_pattern</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>converted_length</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>convert_length</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>converted_length</name> <operator>=</operator> <name><name>pat_patctl</name><operator>.</operator><name>convert_length</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>converted_pattern</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>converted_length</name> <operator>*</operator> <name>code_unit_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>converted_pattern</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Failed: malloc failed for converted pattern\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_SKIP</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>converted_pattern</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* Let the library allocate */</comment>

  <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>convert_options</name> <operator>|=</operator> <name>PCRE2_CONVERT_UTF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>PCRE2_NO_UTF_CHECK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>convert_options</name> <operator>|=</operator> <name>PCRE2_CONVERT_NO_UTF_CHECK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>CONCTXCPY</name><argument_list>(<argument><expr><name>con_context</name></expr></argument>, <argument><expr><name>default_con_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>convert_glob_escape</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>escape</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>convert_glob_escape</name></name> <operator>==</operator> <literal type="char">'0'</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
      <expr><name><name>pat_patctl</name><operator>.</operator><name>convert_glob_escape</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>PCRE2_SET_GLOB_ESCAPE</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>con_context</name></expr></argument>, <argument><expr><name>escape</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Invalid glob escape '%c'\n"</literal></expr></argument>,
        <argument><expr><name><name>pat_patctl</name><operator>.</operator><name>convert_glob_escape</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>convert_return</name> <operator>=</operator> <name>PR_SKIP</name></expr>;</expr_stmt>
      <goto>goto <name>CONVERT_FINISH</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>convert_glob_separator</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>PCRE2_SET_GLOB_SEPARATOR</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>con_context</name></expr></argument>, <argument><expr><name><name>pat_patctl</name><operator>.</operator><name>convert_glob_separator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Invalid glob separator '%c'\n"</literal></expr></argument>,
        <argument><expr><name><name>pat_patctl</name><operator>.</operator><name>convert_glob_separator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>convert_return</name> <operator>=</operator> <name>PR_SKIP</name></expr>;</expr_stmt>
      <goto>goto <name>CONVERT_FINISH</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>PCRE2_PATTERN_CONVERT</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>pbuffer</name></expr></argument>, <argument><expr><name>patlen</name></expr></argument>, <argument><expr><name>convert_options</name></expr></argument>,
    <argument><expr><operator>&amp;</operator><name>converted_pattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>converted_length</name></expr></argument>, <argument><expr><name>con_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <macro><name>fprintf</name><argument_list>(<argument>outfile</argument>, <argument><literal type="string">"** Pattern conversion error at offset %"</literal> SIZ_FORM <literal type="string">": "</literal></argument>,
      <argument>SIZ_CAST converted_length</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <expr_stmt><expr><name>convert_return</name> <operator>=</operator> <ternary><condition><expr><call><name>print_error_message</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>?</condition><then> <expr><name>PR_SKIP</name></expr></then><else>:<expr><name>PR_ABEND</name></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if>

  <comment type="block">/* Output the converted pattern, then copy it. */</comment>

  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name>converted_pattern</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>converted_length</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>patlen</name> <operator>=</operator> <name>converted_length</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CONVERT_COPY</name><argument_list>(<argument><expr><name>pbuffer</name></expr></argument>, <argument><expr><name>converted_pattern</name></expr></argument>, <argument><expr><name>converted_length</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

  <comment type="block">/* Free the converted pattern. */</comment>

  <label><name>CONVERT_FINISH</name>:</label>
  <if_stmt><if>if <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>convert_length</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>converted_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>PCRE2_CONVERTED_PATTERN_FREE</name><argument_list>(<argument><expr><name>converted_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <comment type="block">/* Return if conversion was unsuccessful. */</comment>

  <if_stmt><if>if <condition>(<expr><name>convert_return</name> <operator>!=</operator> <name>PR_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>convert_return</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* By default we pass a zero-terminated pattern, but a length is passed if
"use_length" was specified or this is a hex pattern (which might contain binary
zeros). When valgrind is supported, arrange for the unused part of the buffer
to be marked as no access. */</comment>

<expr_stmt><expr><name>valgrind_access_length</name> <operator>=</operator> <name>patlen</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <operator>(</operator><name>CTL_HEXPAT</name><operator>|</operator><name>CTL_USE_LENGTH</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>patlen</name> <operator>=</operator> <name>PCRE2_ZERO_TERMINATED</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>valgrind_access_length</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* For the terminating zero */</comment>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_VALGRIND</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE8_MODE</name> <operator>&amp;&amp;</operator> <name>pbuffer8</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_NOACCESS</name><argument_list>(<argument><expr><name>pbuffer8</name> <operator>+</operator> <name>valgrind_access_length</name></expr></argument>,
    <argument><expr><name>pbuffer8_size</name> <operator>-</operator> <name>valgrind_access_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE16_MODE</name> <operator>&amp;&amp;</operator> <name>pbuffer16</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_NOACCESS</name><argument_list>(<argument><expr><name>pbuffer16</name> <operator>+</operator> <name>valgrind_access_length</name></expr></argument>,
    <argument><expr><name>pbuffer16_size</name> <operator>-</operator> <name>valgrind_access_length</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE32_MODE</name> <operator>&amp;&amp;</operator> <name>pbuffer32</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_NOACCESS</name><argument_list>(<argument><expr><name>pbuffer32</name> <operator>+</operator> <name>valgrind_access_length</name></expr></argument>,
    <argument><expr><name>pbuffer32_size</name> <operator>-</operator> <name>valgrind_access_length</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* Valgrind not supported */</comment>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>valgrind_access_length</name></expr>;</expr_stmt>  <comment type="block">/* Avoid compiler warning */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* If #newline_default has been used and the library was not compiled with an
appropriate default newline setting, local_newline_default will be non-zero. We
use this if there is no explicit newline modifier. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>CTL2_NL_SET</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>local_newline_default</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SETFLD</name><argument_list>(<argument><expr><name>pat_context</name></expr></argument>, <argument><expr><name>newline_convention</name></expr></argument>, <argument><expr><name>local_newline_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* The null_context modifier is used to test calling pcre2_compile() with a
NULL context. */</comment>

<expr_stmt><expr><name>use_pat_context</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_NULLCONTEXT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then>
  <expr><name>NULL</name></expr> </then><else>: <expr><call><name>PTR</name><argument_list>(<argument><expr><name>pat_context</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<comment type="block">/* If PCRE2_LITERAL is set, set use_forbid_utf zero because PCRE2_NEVER_UTF
and PCRE2_NEVER_UCP are invalid with it. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>PCRE2_LITERAL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>use_forbid_utf</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* Compile many times when timing. */</comment>

<if_stmt><if>if <condition>(<expr><name>timeit</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>clock_t</name></type> <name>time_taken</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>timeit</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
    <decl_stmt><decl><type><name>clock_t</name></type> <name>start_time</name> <init>= <expr><call><name>clock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>PCRE2_COMPILE</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>pbuffer</name></expr></argument>, <argument><expr><name>patlen</name></expr></argument>,
      <argument><expr><name><name>pat_patctl</name><operator>.</operator><name>options</name></name><operator>|</operator><name>use_forbid_utf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>erroroffset</name></expr></argument>,
        <argument><expr><name>use_pat_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>time_taken</name> <operator>+=</operator> <call><name>clock</name><argument_list>()</argument_list></call> <operator>-</operator> <name>start_time</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>TEST</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><operator>!=</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content> <expr_stmt><expr><call><name>SUB1</name><argument_list>(<argument><expr><name>pcre2_code_free</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  <expr_stmt><expr><name>total_compile_time</name> <operator>+=</operator> <name>time_taken</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Compile time %.4f milliseconds\n"</literal></expr></argument>,
    <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name>time_taken</name> <operator>*</operator> <literal type="number">1000.0</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>timeit</name><operator>)</operator> <operator>/</operator>
      <operator>(</operator><name>double</name><operator>)</operator><name>CLOCKS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* A final compile that is used "for real". */</comment>

<expr_stmt><expr><call><name>PCRE2_COMPILE</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>pbuffer</name></expr></argument>, <argument><expr><name>patlen</name></expr></argument>, <argument><expr><name><name>pat_patctl</name><operator>.</operator><name>options</name></name><operator>|</operator><name>use_forbid_utf</name></expr></argument>,
  <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>erroroffset</name></expr></argument>, <argument><expr><name>use_pat_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Call the JIT compiler if requested. When timing, we must free and recompile
the pattern each time because that is the only way to free the JIT compiled
code. We know that compilation will always succeed. */</comment>

<if_stmt><if>if <condition>(<expr><call><name>TEST</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><operator>!=</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>pat_patctl</name><operator>.</operator><name>jit</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>timeit</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clock_t</name></type> <name>time_taken</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>timeit</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
      <decl_stmt><decl><type><name>clock_t</name></type> <name>start_time</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SUB1</name><argument_list>(<argument><expr><name>pcre2_code_free</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PCRE2_COMPILE</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>pbuffer</name></expr></argument>, <argument><expr><name>patlen</name></expr></argument>,
        <argument><expr><name><name>pat_patctl</name><operator>.</operator><name>options</name></name><operator>|</operator><name>use_forbid_utf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>erroroffset</name></expr></argument>,
        <argument><expr><name>use_pat_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>start_time</name> <operator>=</operator> <call><name>clock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PCRE2_JIT_COMPILE</name><argument_list>(<argument><expr><name>jitrc</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name><name>pat_patctl</name><operator>.</operator><name>jit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>time_taken</name> <operator>+=</operator> <call><name>clock</name><argument_list>()</argument_list></call> <operator>-</operator> <name>start_time</name></expr>;</expr_stmt>
      </block_content>}</block></for>
    <expr_stmt><expr><name>total_jit_compile_time</name> <operator>+=</operator> <name>time_taken</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"JIT compile  %.4f milliseconds\n"</literal></expr></argument>,
      <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name>time_taken</name> <operator>*</operator> <literal type="number">1000.0</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>timeit</name><operator>)</operator> <operator>/</operator>
        <operator>(</operator><name>double</name><operator>)</operator><name>CLOCKS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>PCRE2_JIT_COMPILE</name><argument_list>(<argument><expr><name>jitrc</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name><name>pat_patctl</name><operator>.</operator><name>jit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* If valgrind is supported, mark the pbuffer as accessible again. The 16-bit
and 32-bit buffers can be marked completely undefined, but we must leave the
pattern in the 8-bit buffer defined because it may be read from a callout
during matching. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_VALGRIND</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE8_MODE</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_UNDEFINED</name><argument_list>(<argument><expr><name>pbuffer8</name> <operator>+</operator> <name>valgrind_access_length</name></expr></argument>,
    <argument><expr><name>pbuffer8_size</name> <operator>-</operator> <name>valgrind_access_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE16_MODE</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_UNDEFINED</name><argument_list>(<argument><expr><name>pbuffer16</name></expr></argument>, <argument><expr><name>pbuffer16_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE32_MODE</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_UNDEFINED</name><argument_list>(<argument><expr><name>pbuffer32</name></expr></argument>, <argument><expr><name>pbuffer32_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Compilation failed; go back for another re, skipping to blank line
if non-interactive. */</comment>

<if_stmt><if>if <condition>(<expr><call><name>TEST</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Failed: error %d at offset %d: "</literal></expr></argument>, <argument><expr><name>errorcode</name></expr></argument>,
    <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>erroroffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>print_error_message</name><argument_list>(<argument><expr><name>errorcode</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PR_ABEND</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>PR_SKIP</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* If forbid_utf is non-zero, we are running a non-UTF test. UTF and UCP are
locked out at compile time, but we must also check for occurrences of \P, \p,
and \X, which are only supported when Unicode is supported. */</comment>

<if_stmt><if>if <condition>(<expr><name>forbid_utf</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>FLD</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>PCRE2_HASBKPORX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** \\P, \\p, and \\X are not allowed after the "</literal>
      <literal type="string">"#forbid_utf command\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_SKIP</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Remember the maximum lookbehind, for partial matching. */</comment>

<if_stmt><if>if <condition>(<expr><call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_MAXLOOKBEHIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxlookbehind</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>PR_ABEND</name></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* Remember the number of captures. */</comment>

<if_stmt><if>if <condition>(<expr><call><name>pattern_info</name><argument_list>(<argument><expr><name>PCRE2_INFO_CAPTURECOUNT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxcapcount</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>PR_ABEND</name></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* If an explicit newline modifier was given, set the information flag in the
pattern so that it is preserved over push/pop. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>CTL2_NL_SET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SETFLD</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><call><name>FLD</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>|</operator> <name>PCRE2_NL_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Output code size and other information if requested. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_MEMORY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>show_memory_info</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_FRAMESIZE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>show_framesize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_ANYINFO</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>show_pattern_info</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PR_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* The "push" control requests that the compiled pattern be remembered on a
stack. This is mainly for testing the serialization functionality. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_PUSH</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>patstacknext</name> <operator>&gt;=</operator> <name>PATSTACKSIZE</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Too many pushed patterns (max %d)\n"</literal></expr></argument>, <argument><expr><name>PATSTACKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_ABEND</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>patstack</name><index>[<expr><name>patstacknext</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PTR</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* The "pushcopy" and "pushtablescopy" controls are similar, but push a
copy of the pattern, the latter with a copy of its character tables. This tests
the pcre2_code_copy() and pcre2_code_copy_with_tables() functions. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <operator>(</operator><name>CTL_PUSHCOPY</name><operator>|</operator><name>CTL_PUSHTABLESCOPY</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>patstacknext</name> <operator>&gt;=</operator> <name>PATSTACKSIZE</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Too many pushed patterns (max %d)\n"</literal></expr></argument>, <argument><expr><name>PATSTACKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_ABEND</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_PUSHCOPY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>PCRE2_CODE_COPY_TO_VOID</name><argument_list>(<argument><expr><name><name>patstack</name><index>[<expr><name>patstacknext</name><operator>++</operator></expr>]</index></name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>PCRE2_CODE_COPY_WITH_TABLES_TO_VOID</name><argument_list>(<argument><expr><name><name>patstack</name><index>[<expr><name>patstacknext</name><operator>++</operator></expr>]</index></name></expr></argument>,
      <argument><expr><name>compiled_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

<return>return <expr><name>PR_OK</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*          Check heap, match or depth limit      *
*************************************************/</comment>

<comment type="block">/* This is used for DFA, normal, and JIT fast matching. For DFA matching it
should only be called with the third argument set to PCRE2_ERROR_DEPTHLIMIT.

Arguments:
  pp        the subject string
  ulen      length of subject or PCRE2_ZERO_TERMINATED
  errnumber defines which limit to test
  msg       string to include in final message

Returns:    the return from the final match function call
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_match_limit</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>ulen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errnumber</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>capcount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>min</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>mid</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>max</name> <init>= <expr><name>UINT32_MAX</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PCRE2_SET_MATCH_LIMIT</name><argument_list>(<argument><expr><name>dat_context</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PCRE2_SET_DEPTH_LIMIT</name><argument_list>(<argument><expr><name>dat_context</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PCRE2_SET_HEAP_LIMIT</name><argument_list>(<argument><expr><name>dat_context</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>stack_start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>errnumber</name> <operator>==</operator> <name>PCRE2_ERROR_HEAPLIMIT</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>PCRE2_SET_HEAP_LIMIT</name><argument_list>(<argument><expr><name>dat_context</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>errnumber</name> <operator>==</operator> <name>PCRE2_ERROR_MATCHLIMIT</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>PCRE2_SET_MATCH_LIMIT</name><argument_list>(<argument><expr><name>dat_context</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>PCRE2_SET_DEPTH_LIMIT</name><argument_list>(<argument><expr><name>dat_context</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_DFA</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>stack_start</name> <operator>=</operator> <name>DFA_START_RWS_SIZE</name><operator>/</operator><literal type="number">1024</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dfa_workspace</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>dfa_workspace</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>DFA_WS_DIMENSION</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dfa_matched</name><operator>++</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>dfa_workspace</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* To catch bad restart */</comment>
    <expr_stmt><expr><call><name>PCRE2_DFA_MATCH</name><argument_list>(<argument><expr><name>capcount</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ulen</name></expr></argument>, <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>offset</name></name></expr></argument>,
      <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>options</name></name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>,
      <argument><expr><call><name>PTR</name><argument_list>(<argument><expr><name>dat_context</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dfa_workspace</name></expr></argument>, <argument><expr><name>DFA_WS_DIMENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>

  <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_JITFAST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>PCRE2_JIT_MATCH</name><argument_list>(<argument><expr><name>capcount</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ulen</name></expr></argument>, <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>offset</name></name></expr></argument>,
      <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>options</name></name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><call><name>PTR</name><argument_list>(<argument><expr><name>dat_context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

  <else>else
    <block>{<block_content>
    <expr_stmt><expr><name>stack_start</name> <operator>=</operator> <name>START_FRAMES_SIZE</name><operator>/</operator><literal type="number">1024</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PCRE2_MATCH</name><argument_list>(<argument><expr><name>capcount</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ulen</name></expr></argument>, <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>offset</name></name></expr></argument>,
      <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>options</name></name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><call><name>PTR</name><argument_list>(<argument><expr><name>dat_context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>capcount</name> <operator>==</operator> <name>errnumber</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>mid</name> <operator>&amp;</operator> <literal type="number">0x80000000u</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Can't find minimum %s limit: check pattern for "</literal>
        <literal type="string">"restriction\n"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>min</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mid</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>mid</name> <operator>==</operator> <name>max</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>?</condition><then> <expr><name>max</name></expr> </then><else>: <expr><ternary><condition><expr><operator>(</operator><name>max</name> <operator>!=</operator> <name>UINT32_MAX</name><operator>)</operator></expr>?</condition><then> <expr><operator>(</operator><name>min</name> <operator>+</operator> <name>max</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr> </then><else>: <expr><name>mid</name><operator>*</operator><literal type="number">2</literal></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>capcount</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator>
           <name>capcount</name> <operator>==</operator> <name>PCRE2_ERROR_NOMATCH</name> <operator>||</operator>
           <name>capcount</name> <operator>==</operator> <name>PCRE2_ERROR_PARTIAL</name></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* If we've not hit the error with a heap limit less than the size of the
    initial stack frame vector (for pcre2_match()) or the initial stack
    workspace vector (for pcre2_dfa_match()), the heap is not being used, so
    the minimum limit is zero; there's no need to go on. The other limits are
    always greater than zero. */</comment>

    <if_stmt><if>if <condition>(<expr><name>errnumber</name> <operator>==</operator> <name>PCRE2_ERROR_HEAPLIMIT</name> <operator>&amp;&amp;</operator> <name>mid</name> <operator>&lt;</operator> <name>stack_start</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Minimum %s limit = 0\n"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>mid</name> <operator>==</operator> <name>min</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Minimum %s limit = %d\n"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>max</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>mid</name> <operator>=</operator> <operator>(</operator><name>min</name> <operator>+</operator> <name>max</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt>    <comment type="block">/* Some other error */</comment>
  </block_content>}</block></for>

<return>return <expr><name>capcount</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*        Substitute callout function             *
*************************************************/</comment>

<comment type="block">/* Called from pcre2_substitute() when the substitute_callout modifier is set.
Print out the data that is passed back. The substitute callout block is
identical for all code unit widths, so we just pick one.

Arguments:
  scb         pointer to substitute callout block
  data_ptr    callout data

Returns:      nothing
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>substitute_callout_function</name><parameter_list>(<parameter><decl><type><name>pcre2_substitute_callout_block_8</name> <modifier>*</modifier></type><name>scb</name></decl></parameter>,
  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>yield</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><operator>(</operator><call><name>FLD</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>overall_options</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>data_ptr</name></expr>;</expr_stmt>   <comment type="block">/* Not used */</comment>

<macro><name>fprintf</name><argument_list>(<argument>outfile</argument>, <argument><literal type="string">"%2d(%d) Old %"</literal> SIZ_FORM <literal type="string">" %"</literal> SIZ_FORM <literal type="string">" \""</literal></argument>,
  <argument>scb-&gt;subscount</argument>, <argument>scb-&gt;oveccount</argument>,
  <argument>SIZ_CAST scb-&gt;ovector[<literal type="number">0</literal>]</argument>, <argument>SIZ_CAST scb-&gt;ovector[<literal type="number">1</literal>]</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name><name>scb</name><operator>-&gt;</operator><name>input</name></name></expr></argument>, <argument><expr><name><name>scb</name><operator>-&gt;</operator><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>scb</name><operator>-&gt;</operator><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>scb</name><operator>-&gt;</operator><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
  <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>fprintf</name><argument_list>(<argument>outfile</argument>, <argument><literal type="string">"\" New %"</literal> SIZ_FORM <literal type="string">" %"</literal> SIZ_FORM <literal type="string">" \""</literal></argument>,
  <argument>SIZ_CAST scb-&gt;output_offsets[<literal type="number">0</literal>]</argument>, <argument>SIZ_CAST scb-&gt;output_offsets[<literal type="number">1</literal>]</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name><name>scb</name><operator>-&gt;</operator><name>output</name></name></expr></argument>, <argument><expr><name><name>scb</name><operator>-&gt;</operator><name>output_offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
  <argument><expr><name><name>scb</name><operator>-&gt;</operator><name>output_offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>scb</name><operator>-&gt;</operator><name>output_offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>scb</name><operator>-&gt;</operator><name>subscount</name></name> <operator>==</operator> <name><name>dat_datctl</name><operator>.</operator><name>substitute_stop</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>yield</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" STOPPED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>scb</name><operator>-&gt;</operator><name>subscount</name></name> <operator>==</operator> <name><name>dat_datctl</name><operator>.</operator><name>substitute_skip</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>yield</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" SKIPPED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>yield</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*              Callout function                  *
*************************************************/</comment>

<comment type="block">/* Called from a PCRE2 library as a result of the (?C) item. We print out where
we are in the match (unless suppressed). Yield zero unless more callouts than
the fail count, or the callout data is not zero. The only differences in the
callout block for different code unit widths are that the pointers to the
subject, the most recent MARK, and a callout argument string point to strings
of the appropriate width. Casts can be used to deal with this.

Arguments:
  cb                a pointer to a callout block
  callout_data_ptr  the provided callout data

Returns:            0 or 1 or an error, as determined by settings
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>callout_function</name><parameter_list>(<parameter><decl><type><name>pcre2_callout_block_8</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callout_data_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>fdefault</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>pre_start</name></decl>, <decl><type ref="prev"/><name>post_start</name></decl>, <decl><type ref="prev"/><name>subject_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>current_position</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><operator>(</operator><call><name>FLD</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>overall_options</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>callout_capture</name> <init>= <expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_CALLOUT_CAPTURE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>callout_where</name> <init>= <expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>CTL2_CALLOUT_NO_WHERE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* The FILE f is used for echoing the subject string if it is non-NULL. This
happens only once in simple cases, but we want to repeat after any additional
output caused by CALLOUT_EXTRA. */</comment>

<expr_stmt><expr><name>fdefault</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>!</operator><name>first_callout</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>callout_capture</name> <operator>&amp;&amp;</operator> <name><name>cb</name><operator>-&gt;</operator><name>callout_string</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then>
  <expr><name>NULL</name></expr> </then><else>: <expr><name>outfile</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>CTL2_CALLOUT_EXTRA</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>f</name> <operator>=</operator> <name>outfile</name></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>callout_flags</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>PCRE2_CALLOUT_BACKTRACK</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"Backtrack\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>PCRE2_CALLOUT_STARTMATCH</name><operator>|</operator><name>PCRE2_CALLOUT_BACKTRACK</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"Backtrack\nNo other matching paths\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>

    <case>case <expr><name>PCRE2_CALLOUT_STARTMATCH</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"New match attempt\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <default>default:</default>
    <expr_stmt><expr><name>f</name> <operator>=</operator> <name>fdefault</name></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>f</name> <operator>=</operator> <name>fdefault</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<comment type="block">/* For a callout with a string argument, show the string first because there
isn't a tidy way to fit it in the rest of the data. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>delimiter</name> <init>= <expr><call><name>CODE_UNIT</name><argument_list>(<argument><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <macro><name>fprintf</name><argument_list>(<argument>outfile</argument>, <argument><literal type="string">"Callout (%"</literal> SIZ_FORM <literal type="string">"): %c"</literal></argument>,
    <argument>SIZ_CAST cb-&gt;callout_string_offset</argument>, <argument>delimiter</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
    <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string_length</name></name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>callout_start_delims</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><name>delimiter</name> <operator>==</operator> <name><name>callout_start_delims</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>delimiter</name> <operator>=</operator> <name><name>callout_end_delims</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if></if_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>callout_capture</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Show captured strings if required */</comment>

<if_stmt><if>if <condition>(<expr><name>callout_capture</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Callout %d:"</literal></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" last capture = %d\n"</literal></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>capture_last</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>capture_top</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%2d: "</literal></expr></argument>, <argument><expr><name>i</name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>offset_vector</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PCRE2_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"&lt;unset&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name><name>cb</name><operator>-&gt;</operator><name>subject</name></name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>offset_vector</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
        <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>offset_vector</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>cb</name><operator>-&gt;</operator><name>offset_vector</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Unless suppressed, re-print the subject in canonical form (with escapes for
non-printing characters), the first time, or if giving full details. On
subsequent calls in the same match, we use PCHARS() just to find the printed
lengths of the substrings. */</comment>

<if_stmt><if>if <condition>(<expr><name>callout_where</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>f</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"---&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* The subject before the match start. */</comment>

  <expr_stmt><expr><call><name>PCHARS</name><argument_list>(<argument><expr><name>pre_start</name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>subject</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>start_match</name></name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If a lookbehind is involved, the current position may be earlier than the
  match start. If so, use the match start instead. */</comment>

  <expr_stmt><expr><name>current_position</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>current_position</name></name> <operator>&gt;=</operator> <name><name>cb</name><operator>-&gt;</operator><name>start_match</name></name><operator>)</operator></expr>?</condition><then>
    <expr><name><name>cb</name><operator>-&gt;</operator><name>current_position</name></name></expr> </then><else>: <expr><name><name>cb</name><operator>-&gt;</operator><name>start_match</name></name></expr></else></ternary></expr>;</expr_stmt>

  <comment type="block">/* The subject between the match start and the current position. */</comment>

  <expr_stmt><expr><call><name>PCHARS</name><argument_list>(<argument><expr><name>post_start</name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>subject</name></name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>start_match</name></name></expr></argument>,
    <argument><expr><name>current_position</name> <operator>-</operator> <name><name>cb</name><operator>-&gt;</operator><name>start_match</name></name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Print from the current position to the end. */</comment>

  <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name><name>cb</name><operator>-&gt;</operator><name>subject</name></name></expr></argument>, <argument><expr><name>current_position</name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>subject_length</name></name> <operator>-</operator> <name>current_position</name></expr></argument>,
    <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Calculate the total subject printed length (no print). */</comment>

  <expr_stmt><expr><call><name>PCHARS</name><argument_list>(<argument><expr><name>subject_length</name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>subject</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>subject_length</name></name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>f</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* For automatic callouts, show the pattern offset. Otherwise, for a
  numerical callout whose number has not already been shown with captured
  strings, show the number here. A callout with a string argument has been
  displayed above. */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>callout_number</name></name> <operator>==</operator> <literal type="number">255</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%+3d "</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>cb</name><operator>-&gt;</operator><name>pattern_position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>pattern_position</name></name> <operator>&gt;</operator> <literal type="number">99</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>callout_capture</name> <operator>||</operator> <name><name>cb</name><operator>-&gt;</operator><name>callout_string</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%3d "</literal></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

  <comment type="block">/* Now show position indicators */</comment>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pre_start</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"^"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>post_start</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>post_start</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"^"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>subject_length</name> <operator>-</operator> <name>pre_start</name> <operator>-</operator> <name>post_start</name> <operator>+</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

  <if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>next_item_length</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>next_item_length</name></name><operator>)</operator></expr></argument>,
      <argument><expr><name>pbuffer8</name> <operator>+</operator> <name><name>cb</name><operator>-&gt;</operator><name>pattern_position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"End of pattern"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>first_callout</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<comment type="block">/* Show any mark info */</comment>

<if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>mark</name></name> <operator>!=</operator> <name>last_callout_mark</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>mark</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Latest Mark: &lt;unset&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Latest Mark: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name><name>cb</name><operator>-&gt;</operator><name>mark</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>last_callout_mark</name> <operator>=</operator> <name><name>cb</name><operator>-&gt;</operator><name>mark</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Show callout data */</comment>

<if_stmt><if>if <condition>(<expr><name>callout_data_ptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>callout_data</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>callout_data_ptr</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>callout_data</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Callout data = %d\n"</literal></expr></argument>, <argument><expr><name>callout_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>callout_data</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Keep count and give the appropriate return code */</comment>

<expr_stmt><expr><name>callout_count</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>callout_number</name></name> <operator>==</operator> <name><name>dat_datctl</name><operator>.</operator><name>cerror</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
    <name>callout_count</name> <operator>&gt;=</operator> <name><name>dat_datctl</name><operator>.</operator><name>cerror</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>PCRE2_ERROR_CALLOUT</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>callout_number</name></name> <operator>==</operator> <name><name>dat_datctl</name><operator>.</operator><name>cfail</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
    <name>callout_count</name> <operator>&gt;=</operator> <name><name>dat_datctl</name><operator>.</operator><name>cfail</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*       Handle *MARK and copy/get tests          *
*************************************************/</comment>

<comment type="block">/* This function is called after complete and partial matches. It runs the
tests for substring extraction.

Arguments:
  utf       TRUE for utf
  capcount  return from pcre2_match()

Returns:    FALSE if print_error_message() fails
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>copy_and_get</name><parameter_list>(<parameter><decl><type><name>BOOL</name></type> <name>utf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>capcount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>nptr</name></decl>;</decl_stmt>

<comment type="block">/* Test copy strings by number */</comment>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAXCPYGET</name> <operator>&amp;&amp;</operator> <name><name>dat_datctl</name><operator>.</operator><name>copy_numbers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>length</name></decl>, <decl><type ref="prev"/><name>length2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name><name>copybuffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>copy_numbers</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>length</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>copybuffer</name></expr></argument>)</argument_list></sizeof><operator>/</operator><name>code_unit_size</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PCRE2_SUBSTRING_COPY_BYNUMBER</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>copybuffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Copy substring %d failed (%d): "</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>print_error_message</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>PCRE2_SUBSTRING_LENGTH_BYNUMBER</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>length2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Get substring %d length failed (%d): "</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>print_error_message</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>length2</name> <operator>!=</operator> <name>length</name></expr>)</condition>
      <block>{<block_content>
      <macro><name>fprintf</name><argument_list>(<argument>outfile</argument>, <argument><literal type="string">"Mismatched substring lengths: %"</literal>
        SIZ_FORM <literal type="string">" %"</literal> SIZ_FORM <literal type="string">"\n"</literal></argument>, <argument>SIZ_CAST length</argument>, <argument>SIZ_CAST length2</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%2dC "</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name>copybuffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>fprintf</name><argument_list>(<argument>outfile</argument>, <argument><literal type="string">" (%"</literal> SIZ_FORM <literal type="string">")\n"</literal></argument>, <argument>SIZ_CAST length</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

<comment type="block">/* Test copy strings by name */</comment>

<expr_stmt><expr><name>nptr</name> <operator>=</operator> <name><name>dat_datctl</name><operator>.</operator><name>copy_names</name></name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>groupnumber</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>length</name></decl>, <decl><type ref="prev"/><name>length2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name><name>copybuffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>namelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>nptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_PCRE2_16</name> <operator>||</operator> <name>defined</name> <name>SUPPORT_PCRE2_32</name></expr></cpp:if>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>cnl</name> <init>= <expr><name>namelen</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if <condition>(<expr><name>namelen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE8_MODE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pbuffer8</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>nptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE16_MODE</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>to16</name><argument_list>(<argument><expr><name>nptr</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cnl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE32_MODE</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>to32</name><argument_list>(<argument><expr><name>nptr</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cnl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>PCRE2_SUBSTRING_NUMBER_FROM_NAME</name><argument_list>(<argument><expr><name>groupnumber</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>pbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>groupnumber</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>groupnumber</name> <operator>!=</operator> <name>PCRE2_ERROR_NOUNIQUESUBSTRING</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Number not found for group '%s'\n"</literal></expr></argument>, <argument><expr><name>nptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>length</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>copybuffer</name></expr></argument>)</argument_list></sizeof><operator>/</operator><name>code_unit_size</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PCRE2_SUBSTRING_COPY_BYNAME</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>pbuffer</name></expr></argument>, <argument><expr><name>copybuffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Copy substring '%s' failed (%d): "</literal></expr></argument>, <argument><expr><name>nptr</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>print_error_message</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>PCRE2_SUBSTRING_LENGTH_BYNAME</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>pbuffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>length2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Get substring '%s' length failed (%d): "</literal></expr></argument>, <argument><expr><name>nptr</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>print_error_message</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>length2</name> <operator>!=</operator> <name>length</name></expr>)</condition>
      <block>{<block_content>
      <macro><name>fprintf</name><argument_list>(<argument>outfile</argument>, <argument><literal type="string">"Mismatched substring lengths: %"</literal>
        SIZ_FORM <literal type="string">" %"</literal> SIZ_FORM <literal type="string">"\n"</literal></argument>, <argument>SIZ_CAST length</argument>, <argument>SIZ_CAST length2</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"  C "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name>copybuffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>fprintf</name><argument_list>(<argument>outfile</argument>, <argument><literal type="string">" (%"</literal> SIZ_FORM <literal type="string">") %s"</literal></argument>, <argument>SIZ_CAST length</argument>, <argument>nptr</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <if_stmt><if>if <condition>(<expr><name>groupnumber</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" (group %d)\n"</literal></expr></argument>, <argument><expr><name>groupnumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" (non-unique)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>nptr</name> <operator>+=</operator> <name>namelen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></for>

<comment type="block">/* Test get strings by number */</comment>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAXCPYGET</name> <operator>&amp;&amp;</operator> <name><name>dat_datctl</name><operator>.</operator><name>get_numbers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>length</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>gotbuffer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>get_numbers</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>PCRE2_SUBSTRING_GET_BYNUMBER</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gotbuffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Get substring %d failed (%d): "</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>print_error_message</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%2dG "</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name>gotbuffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>fprintf</name><argument_list>(<argument>outfile</argument>, <argument><literal type="string">" (%"</literal> SIZ_FORM <literal type="string">")\n"</literal></argument>, <argument>SIZ_CAST length</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <expr_stmt><expr><call><name>PCRE2_SUBSTRING_FREE</name><argument_list>(<argument><expr><name>gotbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

<comment type="block">/* Test get strings by name */</comment>

<expr_stmt><expr><name>nptr</name> <operator>=</operator> <name><name>dat_datctl</name><operator>.</operator><name>get_names</name></name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>length</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>gotbuffer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>groupnumber</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>namelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>nptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_PCRE2_16</name> <operator>||</operator> <name>defined</name> <name>SUPPORT_PCRE2_32</name></expr></cpp:if>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>cnl</name> <init>= <expr><name>namelen</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if <condition>(<expr><name>namelen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE8_MODE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pbuffer8</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>nptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE16_MODE</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>to16</name><argument_list>(<argument><expr><name>nptr</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cnl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE32_MODE</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>to32</name><argument_list>(<argument><expr><name>nptr</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cnl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>PCRE2_SUBSTRING_NUMBER_FROM_NAME</name><argument_list>(<argument><expr><name>groupnumber</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>pbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>groupnumber</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>groupnumber</name> <operator>!=</operator> <name>PCRE2_ERROR_NOUNIQUESUBSTRING</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Number not found for group '%s'\n"</literal></expr></argument>, <argument><expr><name>nptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>PCRE2_SUBSTRING_GET_BYNAME</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>pbuffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gotbuffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Get substring '%s' failed (%d): "</literal></expr></argument>, <argument><expr><name>nptr</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>print_error_message</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"  G "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name>gotbuffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>fprintf</name><argument_list>(<argument>outfile</argument>, <argument><literal type="string">" (%"</literal> SIZ_FORM <literal type="string">") %s"</literal></argument>, <argument>SIZ_CAST length</argument>, <argument>nptr</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    <if_stmt><if>if <condition>(<expr><name>groupnumber</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" (group %d)\n"</literal></expr></argument>, <argument><expr><name>groupnumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" (non-unique)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>PCRE2_SUBSTRING_FREE</name><argument_list>(<argument><expr><name>gotbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>nptr</name> <operator>+=</operator> <name>namelen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></for>

<comment type="block">/* Test getting the complete list of captured strings. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_GETALL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>stringlist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>lengths</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>PCRE2_SUBSTRING_LIST_GET</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stringlist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lengths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"get substring list failed (%d): "</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>print_error_message</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>capcount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%2dL "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name><name>stringlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>lengths</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name><name>stringlist</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"string list not terminated by NULL\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>PCRE2_SUBSTRING_LIST_FREE</name><argument_list>(<argument><expr><name>stringlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*            Show an entire ovector              *
*************************************************/</comment>

<comment type="block">/* This function is called after partial matching or match failure, when the
"allvector" modifier is set. It is a means of checking the contents of the
entire ovector, to ensure no modification of fields that should be unchanged.

Arguments:
  ovector      points to the ovector
  oveccount    number of pairs

Returns:       nothing
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_ovector</name><parameter_list>(<parameter><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>ovector</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>oveccount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal><operator>*</operator><name>oveccount</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>start</name> <init>= <expr><name><name>ovector</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>end</name> <init>= <expr><name><name>ovector</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%2d: "</literal></expr></argument>, <argument><expr><name>i</name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <name>PCRE2_UNSET</name> <operator>&amp;&amp;</operator> <name>end</name> <operator>==</operator> <name>PCRE2_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"&lt;unset&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>start</name> <operator>==</operator> <name>JUNK_OFFSET</name> <operator>&amp;&amp;</operator> <name>end</name> <operator>==</operator> <name>JUNK_OFFSET</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"&lt;unchanged&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%ld %ld\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>int</name><operator>)</operator><name>start</name></expr></argument>,
      <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>int</name><operator>)</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*               Process a data line              *
*************************************************/</comment>

<comment type="block">/* The line is in buffer; it will not be empty.

Arguments:  none

Returns:    PR_OK     continue processing next line
            PR_SKIP   skip to a blank line
            PR_ABEND  abort the pcre2test run
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>process_data</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>ulen</name></decl>, <decl><type ref="prev"/><name>arg_ulen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>gmatched</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>g_notempty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>start_rep</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>needlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>use_dat_context</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>subject_literal</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>ovector</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name><name>ovecsave</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>oveccount</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>q8</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>q16</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>q32</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>subject_literal</name> <operator>=</operator> <operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>CTL2_SUBJECT_LITERAL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<comment type="block">/* Copy the default context and data control blocks to the active ones. Then
copy from the pattern the controls that can be set in either the pattern or the
data. This allows them to be overridden in the data line. We do not do this for
options because those that are common apply separately to compiling and
matching. */</comment>

<expr_stmt><expr><call><name>DATCTXCPY</name><argument_list>(<argument><expr><name>dat_context</name></expr></argument>, <argument><expr><name>default_dat_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dat_datctl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>def_datctl</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>datctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>|=</operator> <operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_ALLPD</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dat_datctl</name><operator>.</operator><name>control2</name></name> <operator>|=</operator> <operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>CTL2_ALLPD</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>dat_datctl</name><operator>.</operator><name>replacement</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>pat_patctl</name><operator>.</operator><name>replacement</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dat_datctl</name><operator>.</operator><name>jitstack</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>dat_datctl</name><operator>.</operator><name>jitstack</name></name> <operator>=</operator> <name><name>pat_patctl</name><operator>.</operator><name>jitstack</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dat_datctl</name><operator>.</operator><name>substitute_skip</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>dat_datctl</name><operator>.</operator><name>substitute_skip</name></name> <operator>=</operator> <name><name>pat_patctl</name><operator>.</operator><name>substitute_skip</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dat_datctl</name><operator>.</operator><name>substitute_stop</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>dat_datctl</name><operator>.</operator><name>substitute_stop</name></name> <operator>=</operator> <name><name>pat_patctl</name><operator>.</operator><name>substitute_stop</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* Initialize for scanning the data line. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
<expr_stmt><expr><name>utf</name> <operator>=</operator> <operator>(</operator><operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_POSIX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then>
  <expr><operator>(</operator><operator>(</operator><name>pcre2_real_code_8</name> <operator>*</operator><operator>)</operator><name><name>preg</name><operator>.</operator><name>re_pcre2_code</name></name><operator>)</operator><operator>-&gt;</operator><name>overall_options</name></expr> </then><else>:
  <expr><call><name>FLD</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>overall_options</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>utf</name> <operator>=</operator> <operator>(</operator><call><name>FLD</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>overall_options</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>start_rep</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><name><name>buffer</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<comment type="block">/* Check that the data is well-formed UTF-8 if we're in UTF mode. To create
invalid input to pcre2_match(), you must use \x?? or \x{} sequences. */</comment>

<if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>cc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>q</name> <operator>=</operator> <name>p</name></expr>;</init> <condition><expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>q</name></expr>;</condition> <incr><expr><name>q</name> <operator>+=</operator> <name>n</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>utf82ord</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Failed: invalid UTF-8 string cannot be used as input "</literal>
      <literal type="string">"in UTF mode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_VALGRIND</name></cpp:ifdef>
<comment type="block">/* Mark the dbuffer as addressable but undefined again. */</comment>
<if_stmt><if>if <condition>(<expr><name>dbuffer</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_UNDEFINED</name><argument_list>(<argument><expr><name>dbuffer</name></expr></argument>, <argument><expr><name>dbuffer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Allocate a buffer to hold the data line; len+1 is an upper bound on
the number of code units that will be needed (though the buffer may have to be
extended if replication is involved). */</comment>

<expr_stmt><expr><name>needlen</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>len</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>code_unit_size</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dbuffer</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>needlen</name> <operator>&gt;=</operator> <name>dbuffer_size</name></expr>)</condition>
  <block>{<block_content>
  <while>while <condition>(<expr><name>needlen</name> <operator>&gt;=</operator> <name>dbuffer_size</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dbuffer_size</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><name>dbuffer</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>realloc</name><argument_list>(<argument><expr><name>dbuffer</name></expr></argument>, <argument><expr><name>dbuffer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>dbuffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2test: realloc(%d) failed\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>dbuffer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>SETCASTPTR</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>dbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Sets q8, q16, or q32, as appropriate. */</comment>

<comment type="block">/* Scan the data line, interpreting data escapes, and put the result into a
buffer of the appropriate width. In UTF mode, input is always UTF-8; otherwise,
in 16- and 32-bit modes, it can be forced to UTF-8 by the utf8_input modifier.
*/</comment>

<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>replen</name></decl>;</decl_stmt>

  <comment type="block">/* ] may mark the end of a replicated sequence */</comment>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">']'</literal> <operator>&amp;&amp;</operator> <name>start_rep</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>long</name></type> <name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>qoffset</name> <init>= <expr><call><name>CAST8VAR</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>dbuffer</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>rep_offset</name> <init>= <expr><name>start_rep</name> <operator>-</operator> <name>dbuffer</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator> <operator>!=</operator> <literal type="char">'{'</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Expected '{' after \\[....]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>li</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>S32OVERFLOW</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Repeat count too large\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>endptr</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Expected '}' after \\[...]{...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name>li</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>i</name><operator>--</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Zero repeat not allowed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>replen</name> <operator>=</operator> <call><name>CAST8VAR</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>start_rep</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>needlen</name> <operator>+=</operator> <name>replen</name> <operator>*</operator> <name>i</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>needlen</name> <operator>&gt;=</operator> <name>dbuffer_size</name></expr>)</condition>
      <block>{<block_content>
      <while>while <condition>(<expr><name>needlen</name> <operator>&gt;=</operator> <name>dbuffer_size</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dbuffer_size</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></while>
      <expr_stmt><expr><name>dbuffer</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>realloc</name><argument_list>(<argument><expr><name>dbuffer</name></expr></argument>, <argument><expr><name>dbuffer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>dbuffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2test: realloc(%d) failed\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>dbuffer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>SETCASTPTR</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>dbuffer</name> <operator>+</operator> <name>qoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>start_rep</name> <operator>=</operator> <name>dbuffer</name> <operator>+</operator> <name>rep_offset</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <while>while <condition>(<expr><name>i</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>CAST8VAR</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>start_rep</name></expr></argument>, <argument><expr><name>replen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SETPLUS</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>replen</name><operator>/</operator><name>code_unit_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>

    <expr_stmt><expr><name>start_rep</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Handle a non-escaped character. In non-UTF 32-bit mode with utf8_input
  set, do the fudge for setting the top bit. */</comment>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'\\'</literal> <operator>||</operator> <name>subject_literal</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>topbit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE32_MODE</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <literal type="number">0xff</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>topbit</name> <operator>=</operator> <literal type="number">0x80000000</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>utf</name> <operator>||</operator> <operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_UTF8_INPUT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
      <call><name>HASUTF8EXTRALEN</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>GETUTF8INC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>c</name> <operator>|=</operator> <name>topbit</name></expr>;</expr_stmt>
    </block_content>}</block></if>

  <comment type="block">/* Handle backslash escapes */</comment>

  <else>else<block type="pseudo"><block_content> <switch>switch <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><literal type="char">'\\'</literal></expr>:</case> <break>break;</break>
    <case>case <expr><literal type="char">'a'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <name>CHAR_BEL</name></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'b'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\b'</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'e'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <name>CHAR_ESC</name></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'f'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\f'</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'n'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'r'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'t'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\t'</literal></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">'v'</literal></expr>:</case> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\v'</literal></expr>;</expr_stmt> <break>break;</break>

    <case>case <expr><literal type="char">'0'</literal></expr>:</case> <case>case <expr><literal type="char">'1'</literal></expr>:</case> <case>case <expr><literal type="char">'2'</literal></expr>:</case> <case>case <expr><literal type="char">'3'</literal></expr>:</case>
    <case>case <expr><literal type="char">'4'</literal></expr>:</case> <case>case <expr><literal type="char">'5'</literal></expr>:</case> <case>case <expr><literal type="char">'6'</literal></expr>:</case> <case>case <expr><literal type="char">'7'</literal></expr>:</case>
    <expr_stmt><expr><name>c</name> <operator>-=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>i</name><operator>++</operator> <operator>&lt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'8'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <name>c</name> <operator>*</operator> <literal type="number">8</literal> <operator>+</operator> <operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></while>
    <break>break;</break>

    <case>case <expr><literal type="char">'o'</literal></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pt</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>pt</name><operator>++</operator></expr>;</init> <condition><expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>pt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><name>pt</name> <operator>!=</operator> <literal type="char">'8'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>pt</name> <operator>!=</operator> <literal type="char">'9'</literal></expr>;</condition> <incr><expr><name>pt</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>++</operator><name>i</name> <operator>==</operator> <literal type="number">12</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Too many octal digits in \\o{...} item; "</literal>
                           <literal type="string">"using only the first twelve.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <name>c</name> <operator>*</operator> <literal type="number">8</literal> <operator>+</operator> <operator>*</operator><name>pt</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></for>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pt</name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pt</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Missing } after \\o{ (assumed)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    <break>break;</break>

    <case>case <expr><literal type="char">'x'</literal></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pt</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <comment type="block">/* We used to have "while (isxdigit(*(++pt)))" here, but it fails
      when isxdigit() is a macro that refers to its argument more than
      once. This is banned by the C Standard, but apparently happens in at
      least one MacOS environment. */</comment>

      <for>for <control>(<init><expr><name>pt</name><operator>++</operator></expr>;</init> <condition><expr><call><name>isxdigit</name><argument_list>(<argument><expr><operator>*</operator><name>pt</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>pt</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>++</operator><name>i</name> <operator>==</operator> <literal type="number">9</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Too many hex digits in \\x{...} item; "</literal>
                           <literal type="string">"using only the first eight.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <name>c</name> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>tolower</name><argument_list>(<argument><expr><operator>*</operator><name>pt</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>pt</name></expr></argument>)</argument_list></call><operator>)</operator></expr>?</condition><then> <expr><literal type="char">'0'</literal></expr> </then><else>: <expr><literal type="char">'a'</literal> <operator>-</operator> <literal type="number">10</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></for>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pt</name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pt</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
        </block_content>}</block></if></if_stmt>
      <comment type="block">/* Not correct form for \x{...}; fall through */</comment>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* \x without {} always defines just one byte in 8-bit mode. This
    allows UTF-8 characters to be constructed byte by byte, and also allows
    invalid UTF-8 sequences to be made. Just copy the byte in UTF-8 mode.
    Otherwise, pass it down as data. */</comment>

    <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>i</name><operator>++</operator> <operator>&lt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>isxdigit</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <name>c</name> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>tolower</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr>?</condition><then> <expr><literal type="char">'0'</literal></expr> </then><else>: <expr><literal type="char">'a'</literal> <operator>-</operator> <literal type="number">10</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_PCRE2_8</name></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>test_mode</name> <operator>==</operator> <name>PCRE8_MODE</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>q8</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
      <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>

    <case>case <expr><literal type="number">0</literal></expr>:</case>     <comment type="block">/* \ followed by EOF allows for an empty line */</comment>
    <expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt>
    <continue>continue;</continue>

    <case>case <expr><literal type="char">'='</literal></expr>:</case>   <comment type="block">/* \= terminates the data, starts modifiers */</comment>
    <goto>goto <name>ENDSTRING</name>;</goto>

    <case>case <expr><literal type="char">'['</literal></expr>:</case>   <comment type="block">/* \[ introduces a replicated character sequence */</comment>
    <if_stmt><if>if <condition>(<expr><name>start_rep</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Nested replication is not supported\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>start_rep</name> <operator>=</operator> <call><name>CAST8VAR</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <continue>continue;</continue>

    <default>default:</default>
    <if_stmt><if>if <condition>(<expr><call><name>isalnum</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Unrecognized escape sequence \"\\%c\"\n"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></switch></block_content></block></else></if_stmt>

  <comment type="block">/* We now have a character value in c that may be greater than 255.
  In 8-bit mode we convert to UTF-8 if we are in UTF mode. Values greater
  than 127 in UTF mode must have come from \x{...} or octal constructs
  because values from \x.. get this far only in non-UTF mode. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE8_MODE</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0x7fffffff</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Character \\x{%x} is greater than 0x7fffffff "</literal>
          <literal type="string">"and so cannot be converted to UTF-8\n"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_OK</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>q8</name> <operator>+=</operator> <call><name>ord2utf8</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>q8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0xffu</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Character \\x{%x} is greater than 255 "</literal>
          <literal type="string">"and UTF-8 mode is not enabled.\n"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Truncation will probably give the wrong "</literal>
          <literal type="string">"result.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>q8</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE16_MODE</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0x10ffffu</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Failed: character \\x{%x} is greater than "</literal>
          <literal type="string">"0x10ffff and so cannot be converted to UTF-16\n"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_OK</name></expr>;</return>
        </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">0x10000u</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>c</name><operator>-=</operator> <literal type="number">0x10000u</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>q16</name><operator>++</operator> <operator>=</operator> <literal type="number">0xD800</literal> <operator>|</operator> <operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">10</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>q16</name><operator>++</operator> <operator>=</operator> <literal type="number">0xDC00</literal> <operator>|</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3ff</literal><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>q16</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0xffffu</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Character \\x{%x} is greater than 0xffff "</literal>
          <literal type="string">"and UTF-16 mode is not enabled.\n"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Truncation will probably give the wrong "</literal>
          <literal type="string">"result.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><operator>*</operator><name>q16</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE32_MODE</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>q32</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></while>

<label><name>ENDSTRING</name>:</label>
<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><operator>*</operator><name>q</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>CASTVAR</name><argument_list>(<argument><expr><name>uint8_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>dbuffer</name></expr>;</expr_stmt>    <comment type="block">/* Length in bytes */</comment>
<expr_stmt><expr><name>ulen</name> <operator>=</operator> <name>len</name><operator>/</operator><name>code_unit_size</name></expr>;</expr_stmt>                <comment type="block">/* Length in code units */</comment>
<expr_stmt><expr><name>arg_ulen</name> <operator>=</operator> <name>ulen</name></expr>;</expr_stmt>                          <comment type="block">/* Value to use in match arg */</comment>

<comment type="block">/* If the string was terminated by \= we must now interpret modifiers. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>decode_modifiers</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>CTX_DAT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dat_datctl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>PR_OK</name></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* Setting substitute_{skip,fail} implies a substitute callout. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>dat_datctl</name><operator>.</operator><name>substitute_skip</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>dat_datctl</name><operator>.</operator><name>substitute_stop</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>dat_datctl</name><operator>.</operator><name>control2</name></name> <operator>|=</operator> <name>CTL2_SUBSTITUTE_CALLOUT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* Check for mutually exclusive modifiers. At present, these are all in the
first control word. */</comment>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>exclusive_dat_controls</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name><name>exclusive_dat_controls</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><name>c</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>show_controls</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"** Not allowed together:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>pat_patctl</name><operator>.</operator><name>replacement</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>CTL2_SUBSTITUTE_CALLOUT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
      <operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_NULLCONTEXT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Replacement callouts are not supported with null_context.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>PR_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_ALLCAPTURES</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Ignored with replacement text: allcaptures\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Warn for modifiers that are ignored for DFA. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_DFA</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_ALLCAPTURES</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Ignored after DFA matching: allcaptures\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* We now have the subject in dbuffer, with len containing the byte length, and
ulen containing the code unit length, with a copy in arg_ulen for use in match
function arguments (this gets changed to PCRE2_ZERO_TERMINATED when the
zero_terminate modifier is present).

Move the data to the end of the buffer so that a read over the end can be
caught by valgrind or other means. If we have explicit valgrind support, mark
the unused start of the buffer unaddressable. If we are using the POSIX
interface, or testing zero-termination, we must include the terminating zero in
the usable data. */</comment>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name>code_unit_size</name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_POSIX</name><operator>)</operator> <operator>+</operator>
                       <operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_ZERO_TERMINATE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>pp</name> <operator>=</operator> <call><name>memmove</name><argument_list>(<argument><expr><name>dbuffer</name> <operator>+</operator> <name>dbuffer_size</name> <operator>-</operator> <name>len</name> <operator>-</operator> <name>c</name></expr></argument>, <argument><expr><name>dbuffer</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_VALGRIND</name></cpp:ifdef>
  <expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_NOACCESS</name><argument_list>(<argument><expr><name>dbuffer</name></expr></argument>, <argument><expr><name>dbuffer_size</name> <operator>-</operator> <operator>(</operator><name>len</name> <operator>+</operator> <name>c</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Now pp points to the subject string. POSIX matching is only possible in
8-bit mode, and it does not support timing or other fancy features. Some were
checked at compile time, but we need to check the match-time settings here. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_POSIX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>eflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>regmatch_t</name> <modifier>*</modifier></type><name>pmatch</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><literal type="string">"** Ignored with POSIX interface:"</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>dat_datctl</name><operator>.</operator><name>cerror</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>CFORE_UNSET</name> <operator>||</operator> <name><name>dat_datctl</name><operator>.</operator><name>cerror</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>CFORE_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>prmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="string">"callout_error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>dat_datctl</name><operator>.</operator><name>cfail</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>CFORE_UNSET</name> <operator>||</operator> <name><name>dat_datctl</name><operator>.</operator><name>cfail</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>CFORE_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>prmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="string">"callout_fail"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>dat_datctl</name><operator>.</operator><name>copy_numbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>dat_datctl</name><operator>.</operator><name>copy_names</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>prmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="string">"copy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>dat_datctl</name><operator>.</operator><name>get_numbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>dat_datctl</name><operator>.</operator><name>get_names</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>prmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="string">"get"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>dat_datctl</name><operator>.</operator><name>jitstack</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>prmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="string">"jitstack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>dat_datctl</name><operator>.</operator><name>offset</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>prmsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <operator>~</operator><name>POSIX_SUPPORTED_MATCH_OPTIONS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>show_match_options</name><argument_list>(<argument><expr><name><name>dat_datctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <operator>~</operator><name>POSIX_SUPPORTED_MATCH_OPTIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <operator>~</operator><name>POSIX_SUPPORTED_MATCH_CONTROLS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
      <operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <operator>~</operator><name>POSIX_SUPPORTED_MATCH_CONTROLS2</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>show_controls</name><argument_list>(<argument><expr><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <operator>~</operator><name>POSIX_SUPPORTED_MATCH_CONTROLS</name></expr></argument>,
                  <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <operator>~</operator><name>POSIX_SUPPORTED_MATCH_CONTROLS2</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>msg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>dat_datctl</name><operator>.</operator><name>oveccount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>pmatch</name> <operator>=</operator> <operator>(</operator><name>regmatch_t</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>regmatch_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>dat_datctl</name><operator>.</operator><name>oveccount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>pmatch</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Failed to get memory for recording matching "</literal>
        <literal type="string">"information (size set = %du)\n"</literal></expr></argument>, <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>oveccount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>dat_datctl</name><operator>.</operator><name>startend</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>CFORE_UNSET</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name> <operator>=</operator> <name><name>dat_datctl</name><operator>.</operator><name>startend</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>startend</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then>
      <expr><name><name>dat_datctl</name><operator>.</operator><name>startend</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><name>len</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>eflags</name> <operator>|=</operator> <name>REG_STARTEND</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>PCRE2_NOTBOL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>eflags</name> <operator>|=</operator> <name>REG_NOTBOL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>PCRE2_NOTEOL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>eflags</name> <operator>|=</operator> <name>REG_NOTEOL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>PCRE2_NOTEMPTY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>eflags</name> <operator>|=</operator> <name>REG_NOTEMPTY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>regexec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preg</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pp</name></expr></argument>, <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>oveccount</name></name></expr></argument>, <argument><expr><name>pmatch</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>regerror</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>preg</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pbuffer8</name></expr></argument>, <argument><expr><name>pbuffer8_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"No match: POSIX code %d: %s\n"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>pbuffer8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_POSIX_NOSUB</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Matched with REG_NOSUB\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name><name>dat_datctl</name><operator>.</operator><name>oveccount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Matched without capture\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>last_printed</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>dat_datctl</name><operator>.</operator><name>oveccount</name></name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>dat_datctl</name><operator>.</operator><name>oveccount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>pmatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rm_so</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>start</name> <init>= <expr><name><name>pmatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rm_so</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>end</name> <init>= <expr><name><name>pmatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>last_printed</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%2d: &lt;unset&gt;\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <expr_stmt><expr><name>last_printed</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <name>end</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>start</name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rm_so</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Start of matched string is beyond its end - "</literal>
            <literal type="string">"displaying from end to start.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%2d: "</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>start</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_AFTERTEXT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_ALLAFTERTEXT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%2d+ "</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="block">/* Note: don't use the start/end variables here because we want to
          show the text from what is reported as the end. */</comment>
          <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name><name>pmatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name><name>pmatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pmatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>PR_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_PCRE2_8 */</comment>

 <comment type="block">/* Handle matching via the native interface. Check for consistency of
modifiers. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>dat_datctl</name><operator>.</operator><name>startend</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>CFORE_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** \\=posix_startend ignored for non-POSIX matching\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* ALLUSEDTEXT is not supported with JIT, but JIT is not used with DFA
matching, even if the JIT compiler was used. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <operator>(</operator><name>CTL_ALLUSEDTEXT</name><operator>|</operator><name>CTL_DFA</name><operator>)</operator><operator>)</operator> <operator>==</operator> <name>CTL_ALLUSEDTEXT</name> <operator>&amp;&amp;</operator>
    <call><name>FLD</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>executable_jit</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Showing all consulted text is not supported by JIT: ignored\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CTL_ALLUSEDTEXT</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Handle passing the subject as zero-terminated. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_ZERO_TERMINATE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>arg_ulen</name> <operator>=</operator> <name>PCRE2_ZERO_TERMINATED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* The nullcontext modifier is used to test calling pcre2_[jit_]match() with a
NULL context. */</comment>

<expr_stmt><expr><name>use_dat_context</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_NULLCONTEXT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then>
  <expr><name>NULL</name></expr> </then><else>: <expr><call><name>PTR</name><argument_list>(<argument><expr><name>dat_context</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<comment type="block">/* Enable display of malloc/free if wanted. We can do this only if either the
pattern or the subject is processed with a context. */</comment>

<expr_stmt><expr><name>show_memory</name> <operator>=</operator> <operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_MEMORY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>show_memory</name> <operator>&amp;&amp;</operator>
    <operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_NULLCONTEXT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** \\=memory requires either a pattern or a subject "</literal>
    <literal type="string">"context: ignored\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* Create and assign a JIT stack if requested. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>dat_datctl</name><operator>.</operator><name>jitstack</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>dat_datctl</name><operator>.</operator><name>jitstack</name></name> <operator>!=</operator> <name>jit_stack_size</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>PCRE2_JIT_STACK_FREE</name><argument_list>(<argument><expr><name>jit_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PCRE2_JIT_STACK_CREATE</name><argument_list>(<argument><expr><name>jit_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>jitstack</name></name> <operator>*</operator> <literal type="number">1024</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jit_stack_size</name> <operator>=</operator> <name><name>dat_datctl</name><operator>.</operator><name>jitstack</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>PCRE2_JIT_STACK_ASSIGN</name><argument_list>(<argument><expr><name>dat_context</name></expr></argument>, <argument><expr><name>jit_callback</name></expr></argument>, <argument><expr><name>jit_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>

<comment type="block">/* Or de-assign */</comment>

<if type="elseif">else if <condition>(<expr><name>jit_stack</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>PCRE2_JIT_STACK_ASSIGN</name><argument_list>(<argument><expr><name>dat_context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PCRE2_JIT_STACK_FREE</name><argument_list>(<argument><expr><name>jit_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>jit_stack</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>jit_stack_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* When no JIT stack is assigned, we must ensure that there is a JIT callback
if we want to verify that JIT was actually used. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_JITVERIFY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>jit_stack</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
   <block>{<block_content>
   <expr_stmt><expr><call><name>PCRE2_JIT_STACK_ASSIGN</name><argument_list>(<argument><expr><name>dat_context</name></expr></argument>, <argument><expr><name>jit_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block></if></if_stmt>

<comment type="block">/* Adjust match_data according to size of offsets required. A size of zero
causes a new match data block to be obtained that exactly fits the pattern. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>dat_datctl</name><operator>.</operator><name>oveccount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>PCRE2_MATCH_DATA_FREE</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PCRE2_MATCH_DATA_CREATE_FROM_PATTERN</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PCRE2_GET_OVECTOR_COUNT</name><argument_list>(<argument><expr><name>max_oveccount</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>dat_datctl</name><operator>.</operator><name>oveccount</name></name> <operator>&lt;=</operator> <name>max_oveccount</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SETFLD</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>oveccount</name></expr></argument>, <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>oveccount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><name>max_oveccount</name> <operator>=</operator> <name><name>dat_datctl</name><operator>.</operator><name>oveccount</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PCRE2_MATCH_DATA_FREE</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PCRE2_MATCH_DATA_CREATE</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>max_oveccount</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>CASTVAR</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><name>match_data</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Failed to get memory for recording matching "</literal>
    <literal type="string">"information (size requested: %d)\n"</literal></expr></argument>, <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>oveccount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>max_oveccount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>PR_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ovector</name> <operator>=</operator> <call><name>FLD</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>ovector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PCRE2_GET_OVECTOR_COUNT</name><argument_list>(<argument><expr><name>oveccount</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Replacement processing is ignored for DFA matching. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>dat_datctl</name><operator>.</operator><name>replacement</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_DFA</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Ignored for DFA matching: replace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dat_datctl</name><operator>.</operator><name>replacement</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* If a replacement string is provided, call pcre2_substitute() instead of one
of the matching functions. First we have to convert the replacement string to
the appropriate width. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>dat_datctl</name><operator>.</operator><name>replacement</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>rbuffer</name><index>[<expr><name>REPLACE_BUFFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>nbuffer</name><index>[<expr><name>REPLACE_BUFFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>xoptions</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>emoption</name></decl>;</decl_stmt>  <comment type="block">/* External match option */</comment>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>rlen</name></decl>, <decl><type ref="prev"/><name>nsize</name></decl>, <decl><type ref="prev"/><name>erroroffset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>badutf</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>r8</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
  <decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>r16</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
  <decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>r32</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Fill the ovector with junk to detect elements that do not get set
  when they should be (relevant only when "allvector" is specified). */</comment>

  <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">2</literal><operator>*</operator><name>oveccount</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ovector</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>JUNK_OFFSET</name></expr>;</expr_stmt></block_content></block></for>

  <if_stmt><if>if <condition>(<expr><name>timeitm</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Timing is not supported with replace: ignored\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_ALTGLOBAL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Altglobal is not supported with replace: ignored\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Check for a test that does substitution after an initial external match.
  If this is set, we run the external match, but leave the interpretation of
  its output to pcre2_substitute(). */</comment>

  <expr_stmt><expr><name>emoption</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>CTL2_SUBSTITUTE_MATCHED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
    <expr><name>PCRE2_SUBSTITUTE_MATCHED</name></expr></else></ternary></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>emoption</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>PCRE2_MATCH</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>arg_ulen</name></expr></argument>, <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>offset</name></name></expr></argument>,
      <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>options</name></name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>use_dat_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>xoptions</name> <operator>=</operator> <name>emoption</name> <operator>|</operator>
             <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_GLOBAL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
                <expr><name>PCRE2_SUBSTITUTE_GLOBAL</name></expr></else></ternary><operator>)</operator> <operator>|</operator>
             <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>CTL2_SUBSTITUTE_EXTENDED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
                <expr><name>PCRE2_SUBSTITUTE_EXTENDED</name></expr></else></ternary><operator>)</operator> <operator>|</operator>
             <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>CTL2_SUBSTITUTE_LITERAL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
                <expr><name>PCRE2_SUBSTITUTE_LITERAL</name></expr></else></ternary><operator>)</operator> <operator>|</operator>
             <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>CTL2_SUBSTITUTE_OVERFLOW_LENGTH</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
                <expr><name>PCRE2_SUBSTITUTE_OVERFLOW_LENGTH</name></expr></else></ternary><operator>)</operator> <operator>|</operator>
             <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>CTL2_SUBSTITUTE_REPLACEMENT_ONLY</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
                <expr><name>PCRE2_SUBSTITUTE_REPLACEMENT_ONLY</name></expr></else></ternary><operator>)</operator> <operator>|</operator>
             <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>CTL2_SUBSTITUTE_UNKNOWN_UNSET</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
                <expr><name>PCRE2_SUBSTITUTE_UNKNOWN_UNSET</name></expr></else></ternary><operator>)</operator> <operator>|</operator>
             <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>CTL2_SUBSTITUTE_UNSET_EMPTY</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
                <expr><name>PCRE2_SUBSTITUTE_UNSET_EMPTY</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SETCASTPTR</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>rbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Sets r8, r16, or r32, as appropriate. */</comment>
  <expr_stmt><expr><name>pr</name> <operator>=</operator> <name><name>dat_datctl</name><operator>.</operator><name>replacement</name></name></expr>;</expr_stmt>

  <comment type="block">/* If the replacement starts with '[&lt;number&gt;]' we interpret that as length
  value for the replacement buffer. */</comment>

  <expr_stmt><expr><name>nsize</name> <operator>=</operator> <name>REPLACE_BUFFSIZE</name><operator>/</operator><name>code_unit_size</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pr</name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>++</operator><name>pr</name><operator>)</operator><operator>)</operator> <operator>&gt;=</operator> <name>CHAR_0</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <name>CHAR_9</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <name>n</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <name>c</name> <operator>-</operator> <name>CHAR_0</name></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pr</name><operator>++</operator> <operator>!=</operator> <literal type="char">']'</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Bad buffer size in replacement string\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>PR_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>nsize</name></expr>)</condition>
      <block>{<block_content>
      <macro><name>fprintf</name><argument_list>(<argument>outfile</argument>, <argument><literal type="string">"Replacement buffer setting (%"</literal> SIZ_FORM <literal type="string">") is too "</literal>
        <literal type="string">"large (max %"</literal> SIZ_FORM <literal type="string">")\n"</literal></argument>, <argument>SIZ_CAST n</argument>, <argument>SIZ_CAST nsize</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
      <return>return <expr><name>PR_OK</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nsize</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Now copy the replacement string to a buffer of the appropriate width. No
  escape processing is done for replacements. In UTF mode, check for an invalid
  UTF-8 input string, and if it is invalid, just copy its code units without
  UTF interpretation. This provides a means of checking that an invalid string
  is detected. Otherwise, UTF-8 can be used to include wide characters in a
  replacement. */</comment>

  <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>badutf</name> <operator>=</operator> <call><name>valid_utf</name><argument_list>(<argument><expr><name>pr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>pr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>erroroffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Not UTF or invalid UTF-8: just copy the code units. */</comment>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>utf</name> <operator>||</operator> <name>badutf</name></expr>)</condition>
    <block>{<block_content>
    <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>pr</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE8_MODE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>r8</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE16_MODE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>r16</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE32_MODE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>r32</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></while>
    </block_content>}</block></if>

  <comment type="block">/* Valid UTF-8 replacement string */</comment>

  <else>else<block type="pseudo"><block_content> <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>pr</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>HASUTF8EXTRALEN</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>GETUTF8INC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>pr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE8_MODE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r8</name> <operator>+=</operator> <call><name>ord2utf8</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>r8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE16_MODE</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">0x10000u</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>c</name><operator>-=</operator> <literal type="number">0x10000u</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>r16</name><operator>++</operator> <operator>=</operator> <literal type="number">0xD800</literal> <operator>|</operator> <operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">10</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>r16</name><operator>++</operator> <operator>=</operator> <literal type="number">0xDC00</literal> <operator>|</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3ff</literal><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>r16</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE32_MODE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>r32</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></while></block_content></block></else></if_stmt>

  <expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><operator>*</operator><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_ZERO_TERMINATE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>rlen</name> <operator>=</operator> <name>PCRE2_ZERO_TERMINATED</name></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>rlen</name> <operator>=</operator> <operator>(</operator><call><name>CASTVAR</name><argument_list>(<argument><expr><name>uint8_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>rbuffer</name><operator>)</operator><operator>/</operator><name>code_unit_size</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>CTL2_SUBSTITUTE_CALLOUT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>PCRE2_SET_SUBSTITUTE_CALLOUT</name><argument_list>(<argument><expr><name>dat_context</name></expr></argument>, <argument><expr><name>substitute_callout_function</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>PCRE2_SET_SUBSTITUTE_CALLOUT</name><argument_list>(<argument><expr><name>dat_context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* No callout */</comment>
    </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>PCRE2_SUBSTITUTE</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>arg_ulen</name></expr></argument>, <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>offset</name></name></expr></argument>,
    <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>options</name></name><operator>|</operator><name>xoptions</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>use_dat_context</name></expr></argument>,
    <argument><expr><name>rbuffer</name></expr></argument>, <argument><expr><name>rlen</name></expr></argument>, <argument><expr><name>nbuffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Failed: error %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PCRE2_ERROR_NOMEMORY</name> <operator>&amp;&amp;</operator> <name>nsize</name> <operator>!=</operator> <name>PCRE2_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" at offset %ld in replacement"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>int</name><operator>)</operator><name>nsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>print_error_message</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PR_ABEND</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PCRE2_ERROR_NOMEMORY</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>xoptions</name> <operator>&amp;</operator> <name>PCRE2_SUBSTITUTE_OVERFLOW_LENGTH</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">": %ld code units are needed"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>int</name><operator>)</operator><name>nsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%2d: "</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name>nbuffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nsize</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>show_memory</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

  <comment type="block">/* Show final ovector contents if requested. */</comment>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>CTL2_ALLVECTOR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>show_ovector</name><argument_list>(<argument><expr><name>ovector</name></expr></argument>, <argument><expr><name>oveccount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><name>PR_OK</name></expr>;</return>
  </block_content>}</block></if></if_stmt>   <comment type="block">/* End of substitution handling */</comment>

<comment type="block">/* When a replacement string is not provided, run a loop for global matching
with one of the basic matching functions. For altglobal (or first time round
the loop), set an "unset" value for the previous match info. */</comment>

<expr_stmt><expr><name><name>ovecsave</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ovecsave</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>ovecsave</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>PCRE2_UNSET</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>gmatched</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>gmatched</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>capcount</name></decl>;</decl_stmt>

  <comment type="block">/* Fill the ovector with junk to detect elements that do not get set
  when they should be. */</comment>

  <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">2</literal><operator>*</operator><name>oveccount</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ovector</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>JUNK_OFFSET</name></expr>;</expr_stmt></block_content></block></for>

  <comment type="block">/* When matching is via pcre2_match(), we will detect the use of JIT via the
  stack callback function. */</comment>

  <expr_stmt><expr><name>jit_was_used</name> <operator>=</operator> <operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_JITFAST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Do timing if required. */</comment>

  <if_stmt><if>if <condition>(<expr><name>timeitm</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>clock_t</name></type> <name>start_time</name></decl>, <decl><type ref="prev"/><name>time_taken</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_DFA</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>PCRE2_DFA_RESTART</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Timing DFA restarts is not supported\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>PR_OK</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>dfa_workspace</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>dfa_workspace</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>DFA_WS_DIMENSION</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>start_time</name> <operator>=</operator> <call><name>clock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>timeitm</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <expr_stmt><expr><call><name>PCRE2_DFA_MATCH</name><argument_list>(<argument><expr><name>capcount</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>arg_ulen</name></expr></argument>,
          <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>options</name></name> <operator>|</operator> <name>g_notempty</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>,
          <argument><expr><name>use_dat_context</name></expr></argument>, <argument><expr><name>dfa_workspace</name></expr></argument>, <argument><expr><name>DFA_WS_DIMENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if>

    <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_JITFAST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>start_time</name> <operator>=</operator> <call><name>clock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>timeitm</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <expr_stmt><expr><call><name>PCRE2_JIT_MATCH</name><argument_list>(<argument><expr><name>capcount</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>arg_ulen</name></expr></argument>,
          <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>options</name></name> <operator>|</operator> <name>g_notempty</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>,
          <argument><expr><name>use_dat_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if>

    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name>start_time</name> <operator>=</operator> <call><name>clock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>timeitm</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <expr_stmt><expr><call><name>PCRE2_MATCH</name><argument_list>(<argument><expr><name>capcount</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>arg_ulen</name></expr></argument>,
          <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>options</name></name> <operator>|</operator> <name>g_notempty</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>,
          <argument><expr><name>use_dat_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>total_match_time</name> <operator>+=</operator> <operator>(</operator><name>time_taken</name> <operator>=</operator> <call><name>clock</name><argument_list>()</argument_list></call> <operator>-</operator> <name>start_time</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Match time %.4f milliseconds\n"</literal></expr></argument>,
      <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name>time_taken</name> <operator>*</operator> <literal type="number">1000.0</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>timeitm</name><operator>)</operator> <operator>/</operator>
        <operator>(</operator><name>double</name><operator>)</operator><name>CLOCKS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Find the heap, match and depth limits if requested. The depth and heap
  limits are not relevant for JIT. The return from check_match_limit() is the
  return from the final call to pcre2_match() or pcre2_dfa_match(). */</comment>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_FINDLIMITS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>capcount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* This stops compiler warnings */</comment>

    <if_stmt><if>if <condition>(<expr><call><name>FLD</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>executable_jit</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>||</operator>
          <operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>PCRE2_NO_JIT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>check_match_limit</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>arg_ulen</name></expr></argument>, <argument><expr><name>PCRE2_ERROR_HEAPLIMIT</name></expr></argument>, <argument><expr><literal type="string">"heap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>capcount</name> <operator>=</operator> <call><name>check_match_limit</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>arg_ulen</name></expr></argument>, <argument><expr><name>PCRE2_ERROR_MATCHLIMIT</name></expr></argument>,
      <argument><expr><literal type="string">"match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>FLD</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>executable_jit</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>PCRE2_NO_JIT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_DFA</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>capcount</name> <operator>=</operator> <call><name>check_match_limit</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>arg_ulen</name></expr></argument>, <argument><expr><name>PCRE2_ERROR_DEPTHLIMIT</name></expr></argument>,
        <argument><expr><literal type="string">"depth"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>capcount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Matched, but offsets vector is too small to show all matches\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>capcount</name> <operator>=</operator> <name><name>dat_datctl</name><operator>.</operator><name>oveccount</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>

  <comment type="block">/* Otherwise just run a single match, setting up a callout if required (the
  default). There is a copy of the pattern in pbuffer8 for use by callouts. */</comment>

  <else>else
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_CALLOUT_NONE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>PCRE2_SET_CALLOUT</name><argument_list>(<argument><expr><name>dat_context</name></expr></argument>, <argument><expr><name>callout_function</name></expr></argument>,
        <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>dat_datctl</name><operator>.</operator><name>callout_data</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>first_callout</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>last_callout_mark</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>callout_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>PCRE2_SET_CALLOUT</name><argument_list>(<argument><expr><name>dat_context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* No callout */</comment>
      </block_content>}</block></else></if_stmt>

    <comment type="block">/* Run a single DFA or NFA match. */</comment>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_DFA</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>dfa_workspace</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>dfa_workspace</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>DFA_WS_DIMENSION</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>dfa_matched</name><operator>++</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>dfa_workspace</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* To catch bad restart */</comment>
      <expr_stmt><expr><call><name>PCRE2_DFA_MATCH</name><argument_list>(<argument><expr><name>capcount</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>arg_ulen</name></expr></argument>,
        <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>options</name></name> <operator>|</operator> <name>g_notempty</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>,
        <argument><expr><name>use_dat_context</name></expr></argument>, <argument><expr><name>dfa_workspace</name></expr></argument>, <argument><expr><name>DFA_WS_DIMENSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>capcount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Matched, but offsets vector is too small to show all matches\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>capcount</name> <operator>=</operator> <name><name>dat_datctl</name><operator>.</operator><name>oveccount</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_JITFAST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PCRE2_JIT_MATCH</name><argument_list>(<argument><expr><name>capcount</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>arg_ulen</name></expr></argument>, <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>offset</name></name></expr></argument>,
          <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>options</name></name> <operator>|</operator> <name>g_notempty</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>use_dat_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PCRE2_MATCH</name><argument_list>(<argument><expr><name>capcount</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>arg_ulen</name></expr></argument>, <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>offset</name></name></expr></argument>,
          <argument><expr><name><name>dat_datctl</name><operator>.</operator><name>options</name></name> <operator>|</operator> <name>g_notempty</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>use_dat_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>capcount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Matched, but too many substrings\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>capcount</name> <operator>=</operator> <name><name>dat_datctl</name><operator>.</operator><name>oveccount</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

  <comment type="block">/* The result of the match is now in capcount. First handle a successful
  match. */</comment>

  <if_stmt><if>if <condition>(<expr><name>capcount</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>capcount</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>oveccount</name></expr>)</condition>   <comment type="block">/* Check for lunatic return value */</comment>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>,
        <argument><expr><literal type="string">"** PCRE2 error: returned count %d is too big for ovector count %d\n"</literal></expr></argument>,
        <argument><expr><name>capcount</name></expr></argument>, <argument><expr><name>oveccount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>capcount</name> <operator>=</operator> <name>oveccount</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_ANYGLOB</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Global loop abandoned\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CTL_ANYGLOB</name></expr>;</expr_stmt>        <comment type="block">/* Break g/G loop */</comment>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* If PCRE2_COPY_MATCHED_SUBJECT was set, check that things are as they
    should be, but not for fast JIT, where it isn't supported. */</comment>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>PCRE2_COPY_MATCHED_SUBJECT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_JITFAST</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>FLD</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>PCRE2_MD_COPIED_SUBJECT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>,
          <argument><expr><literal type="string">"** PCRE2 error: flag not set after copy_matched_subject\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><call><name>CASTFLD</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>subject</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>pp</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>,
          <argument><expr><literal type="string">"** PCRE2 error: copy_matched_subject has not copied\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><call><name>CASTFLD</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>subject</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ulen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>,
          <argument><expr><literal type="string">"** PCRE2 error: copy_matched_subject mismatch\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* If this is not the first time round a global loop, check that the
    returned string has changed. If it has not, check for an empty string match
    at different starting offset from the previous match. This is a failed test
    retry for null-matching patterns that don't match at their starting offset,
    for example /(?&lt;=\G.)/. A repeated match at the same point is not such a
    pattern, and must be discarded, and we then proceed to seek a non-null
    match at the current point. For any other repeated match, there is a bug
    somewhere and we must break the loop because it will go on for ever. We
    know that there are always at least two elements in the ovector. */</comment>

    <if_stmt><if>if <condition>(<expr><name>gmatched</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>ovecsave</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>ovecsave</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>ovecsave</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <name><name>dat_datctl</name><operator>.</operator><name>offset</name></name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>g_notempty</name> <operator>=</operator> <name>PCRE2_NOTEMPTY_ATSTART</name> <operator>|</operator> <name>PCRE2_ANCHORED</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ovecsave</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>dat_datctl</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>
        <continue>continue;</continue>    <comment type="block">/* Back to the top of the loop */</comment>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>,
        <argument><expr><literal type="string">"** PCRE2 error: global repeat returned the same string as previous\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Global loop abandoned\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CTL_ANYGLOB</name></expr>;</expr_stmt>        <comment type="block">/* Break g/G loop */</comment>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* "allcaptures" requests showing of all captures in the pattern, to check
    unset ones at the end. It may be set on the pattern or the data. Implement
    by setting capcount to the maximum. This is not relevant for DFA matching,
    so ignore it (warning given above). */</comment>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <operator>(</operator><name>CTL_ALLCAPTURES</name><operator>|</operator><name>CTL_DFA</name><operator>)</operator><operator>)</operator> <operator>==</operator> <name>CTL_ALLCAPTURES</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>capcount</name> <operator>=</operator> <name>maxcapcount</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>   <comment type="block">/* Allow for full match */</comment>
      <if_stmt><if>if <condition>(<expr><name>capcount</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>oveccount</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>capcount</name> <operator>=</operator> <name>oveccount</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* "allvector" request showing the entire ovector. */</comment>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>CTL2_ALLVECTOR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>capcount</name> <operator>=</operator> <name>oveccount</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Output the captured substrings. Note that, for the matched string,
    the use of \K in an assertion can make the start later than the end. */</comment>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal><operator>*</operator><name>capcount</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control>
      <block>{<block_content>
      <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>lleft</name></decl>, <decl><type ref="prev"/><name>lmiddle</name></decl>, <decl><type ref="prev"/><name>lright</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>start</name> <init>= <expr><name><name>ovector</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>end</name> <init>= <expr><name><name>ovector</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <name>end</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>start</name> <operator>=</operator> <name><name>ovector</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>ovector</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Start of matched string is beyond its end - "</literal>
          <literal type="string">"displaying from end to start.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%2d: "</literal></expr></argument>, <argument><expr><name>i</name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Check for an unset group */</comment>

      <if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <name>PCRE2_UNSET</name> <operator>&amp;&amp;</operator> <name>end</name> <operator>==</operator> <name>PCRE2_UNSET</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"&lt;unset&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Check for silly offsets, in particular, values that have not been
      set when they should have been. However, if we are past the end of the
      captures for this pattern ("allvector" causes this), or if we are DFA
      matching, it isn't an error if the entry is unchanged. */</comment>

      <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <name>ulen</name> <operator>||</operator> <name>end</name> <operator>&gt;</operator> <name>ulen</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_DFA</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
              <name>i</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><literal type="number">2</literal><operator>*</operator><name>maxcapcount</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
            <name>start</name> <operator>==</operator> <name>JUNK_OFFSET</name> <operator>&amp;&amp;</operator> <name>end</name> <operator>==</operator> <name>JUNK_OFFSET</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"&lt;unchanged&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"ERROR: bad value(s) for offset(s): 0x%lx 0x%lx\n"</literal></expr></argument>,
            <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>int</name><operator>)</operator><name>start</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>int</name><operator>)</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* When JIT is not being used, ALLUSEDTEXT may be set. (It if is set with
      JIT, it is disabled above, with a comment.) When the match is done by the
      interpreter, leftchar and rightchar are available, and if ALLUSEDTEXT is
      set, and if the leftmost consulted character is before the start of the
      match or the rightmost consulted character is past the end of the match,
      we want to show all consulted characters for the main matched string, and
      indicate which were lookarounds. */</comment>

      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>showallused</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>leftchar</name></decl>, <decl><type ref="prev"/><name>rightchar</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_ALLUSEDTEXT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>leftchar</name> <operator>=</operator> <call><name>FLD</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>leftchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rightchar</name> <operator>=</operator> <call><name>FLD</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>rightchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>showallused</name> <operator>=</operator> <name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>leftchar</name> <argument_list type="generic">&lt; <argument><expr><name>start</name> <operator>||</operator> <name>rightchar</name></expr></argument> &gt;</argument_list></name> <name>end</name><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>showallused</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>showallused</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>PCHARS</name><argument_list>(<argument><expr><name>lleft</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>leftchar</name></expr></argument>, <argument><expr><name>start</name> <operator>-</operator> <name>leftchar</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>PCHARS</name><argument_list>(<argument><expr><name>lmiddle</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>start</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>PCHARS</name><argument_list>(<argument><expr><name>lright</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>rightchar</name> <operator>-</operator> <name>end</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_JITVERIFY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>jit_was_used</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" (JIT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>lleft</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"&lt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
          <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>lmiddle</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
          <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>lright</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
          </block_content>}</block></if>

        <comment type="block">/* When a pattern contains \K, the start of match position may be
        different to the start of the matched string. When this is the case,
        show it when requested. */</comment>

        <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_STARTCHAR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>startchar</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>PCRE2_GET_STARTCHAR</name><argument_list>(<argument><expr><name>startchar</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>PCHARS</name><argument_list>(<argument><expr><name>lleft</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>startchar</name></expr></argument>, <argument><expr><name>start</name> <operator>-</operator> <name>startchar</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>start</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_JITVERIFY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>jit_was_used</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" (JIT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>startchar</name> <operator>!=</operator> <name>start</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>lleft</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"^"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if>

        <comment type="block">/* Otherwise, just show the matched string. */</comment>

        <else>else
          <block>{<block_content>
          <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>start</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_JITVERIFY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>jit_was_used</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" (JIT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>

      <comment type="block">/* Not the main matched string. Just show it unadorned. */</comment>

      <else>else
        <block>{<block_content>
        <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>start</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Note: don't use the start/end variables here because we want to
      show the text from what is reported as the end. */</comment>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_ALLAFTERTEXT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
          <operator>(</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_AFTERTEXT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%2d+ "</literal></expr></argument>, <argument><expr><name>i</name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name><name>ovector</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ulen</name> <operator>-</operator> <name><name>ovector</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>

    <comment type="block">/* Output (*MARK) data if requested */</comment>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_MARK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
         <call><name>TESTFLD</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>, <argument><expr><operator>!=</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"MK: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><call><name>CASTFLD</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process copy/get strings */</comment>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>copy_and_get</name><argument_list>(<argument><expr><name>utf</name></expr></argument>, <argument><expr><name>capcount</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PR_ABEND</name></expr>;</return></block_content></block></if></if_stmt>

    </block_content>}</block></if>    <comment type="block">/* End of handling a successful match */</comment>

  <comment type="block">/* There was a partial match. The value of ovector[0] is the bumpalong point,
  that is, startchar, not any \K point that might have been passed. When JIT is
  not in use, "allusedtext" may be set, in which case we indicate the leftmost
  consulted character. */</comment>

  <if type="elseif">else if <condition>(<expr><name>capcount</name> <operator>==</operator> <name>PCRE2_ERROR_PARTIAL</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>leftchar</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>backlength</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rubriclength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_ALLUSEDTEXT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>leftchar</name> <operator>=</operator> <call><name>FLD</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>leftchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>leftchar</name> <operator>=</operator> <name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Partial match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_MARK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
         <call><name>TESTFLD</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>, <argument><expr><operator>!=</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">", mark="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PCHARS</name><argument_list>(<argument><expr><name>rubriclength</name></expr></argument>, <argument><expr><call><name>CASTFLD</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>utf</name></expr></argument>,
        <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rubriclength</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rubriclength</name> <operator>+=</operator> <literal type="number">15</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PCHARS</name><argument_list>(<argument><expr><name>backlength</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>leftchar</name></expr></argument>, <argument><expr><name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>leftchar</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ulen</name> <operator>-</operator> <name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_JITVERIFY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>jit_was_used</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" (JIT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>backlength</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>rubriclength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>backlength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"&lt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>ulen</name> <operator>!=</operator> <name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** ovector[1] is not equal to the subject length: "</literal>
        <literal type="string">"%ld != %ld\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>int</name><operator>)</operator><name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>int</name><operator>)</operator><name>ulen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Process copy/get strings */</comment>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>copy_and_get</name><argument_list>(<argument><expr><name>utf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PR_ABEND</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* "allvector" outputs the entire vector */</comment>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>CTL2_ALLVECTOR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>show_ovector</name><argument_list>(<argument><expr><name>ovector</name></expr></argument>, <argument><expr><name>oveccount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <break>break;</break>  <comment type="block">/* Out of the /g loop */</comment>
    </block_content>}</block></if>       <comment type="block">/* End of handling partial match */</comment>

  <comment type="block">/* Failed to match. If this is a /g or /G loop, we might previously have
  set g_notempty (to PCRE2_NOTEMPTY_ATSTART|PCRE2_ANCHORED) after a null match.
  If that is the case, this is not necessarily the end. We want to advance the
  start offset, and continue. We won't be at the end of the string - that was
  checked before setting g_notempty. We achieve the effect by pretending that a
  single character was matched.

  Complication arises in the case when the newline convention is "any", "crlf",
  or "anycrlf". If the previous match was at the end of a line terminated by
  CRLF, an advance of one character just passes the CR, whereas we should
  prefer the longer newline sequence, as does the code in pcre2_match().

  Otherwise, in the case of UTF-8 or UTF-16 matching, the advance must be one
  character, not one byte. */</comment>

  <if type="elseif">else if <condition>(<expr><name>g_notempty</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>   <comment type="block">/* There was a previous null match */</comment>
    <block>{<block_content>
    <decl_stmt><decl><type><name>uint16_t</name></type> <name>nl</name> <init>= <expr><call><name>FLD</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>newline_convention</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>start_offset</name> <init>= <expr><name><name>dat_datctl</name><operator>.</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>    <comment type="block">/* Where the match was */</comment>
    <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>end_offset</name> <init>= <expr><name>start_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>nl</name> <operator>==</operator> <name>PCRE2_NEWLINE_CRLF</name> <operator>||</operator> <name>nl</name> <operator>==</operator> <name>PCRE2_NEWLINE_ANY</name> <operator>||</operator>
         <name>nl</name> <operator>==</operator> <name>PCRE2_NEWLINE_ANYCRLF</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <name>start_offset</name> <operator>&lt;</operator> <name>ulen</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
        <call><name>CODE_UNIT</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>start_offset</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'\r'</literal> <operator>&amp;&amp;</operator>
        <call><name>CODE_UNIT</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>end_offset</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>end_offset</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>

    <if type="elseif">else if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <name>test_mode</name> <operator>!=</operator> <name>PCRE32_MODE</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE8_MODE</name></expr>)</condition>
        <block>{<block_content>
        <for>for <control>(<init>;</init> <condition><expr><name>end_offset</name> <operator>&lt;</operator> <name>ulen</name></expr>;</condition> <incr><expr><name>end_offset</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>(</operator><name>PCRE2_SPTR8</name><operator>)</operator><name>pp</name><operator>)</operator><index>[<expr><name>end_offset</name></expr>]</index> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
        </block_content>}</block></if>
      <else>else  <comment type="block">/* 16-bit mode */</comment>
        <block>{<block_content>
        <for>for <control>(<init>;</init> <condition><expr><name>end_offset</name> <operator>&lt;</operator> <name>ulen</name></expr>;</condition> <incr><expr><name>end_offset</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>(</operator><name>PCRE2_SPTR16</name><operator>)</operator><name>pp</name><operator>)</operator><index>[<expr><name>end_offset</name></expr>]</index> <operator>&amp;</operator> <literal type="number">0xfc00</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0xdc00</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>SETFLDVEC</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>ovector</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>start_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SETFLDVEC</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>ovector</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>end_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>  <comment type="block">/* End of handling null match in a global loop */</comment>

  <comment type="block">/* A "normal" match failure. There will be a negative error number in
  capcount. */</comment>

  <else>else
    <block>{<block_content>
    <switch>switch<condition>(<expr><name>capcount</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>PCRE2_ERROR_NOMATCH</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>gmatched</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"No match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_MARK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
             <call><name>TESTFLD</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>, <argument><expr><operator>!=</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">", mark = "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><call><name>CASTFLD</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>mark</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pat_patctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_JITVERIFY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>jit_was_used</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">" (JIT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* "allvector" outputs the entire vector */</comment>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control2</name></name> <operator>&amp;</operator> <name>CTL2_ALLVECTOR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>show_ovector</name><argument_list>(<argument><expr><name>ovector</name></expr></argument>, <argument><expr><name>oveccount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <case>case <expr><name>PCRE2_ERROR_BADUTFOFFSET</name></expr>:</case>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Error %d (bad UTF-%d offset)\n"</literal></expr></argument>, <argument><expr><name>capcount</name></expr></argument>, <argument><expr><name>test_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <default>default:</default>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Failed: error %d: "</literal></expr></argument>, <argument><expr><name>capcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>print_error_message</name><argument_list>(<argument><expr><name>capcount</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PR_ABEND</name></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>capcount</name> <operator>&lt;=</operator> <name>PCRE2_ERROR_UTF8_ERR1</name> <operator>&amp;&amp;</operator>
          <name>capcount</name> <operator>&gt;=</operator> <name>PCRE2_ERROR_UTF32_ERR2</name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>startchar</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>PCRE2_GET_STARTCHAR</name><argument_list>(<argument><expr><name>startchar</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>fprintf</name><argument_list>(<argument>outfile</argument>, <argument><literal type="string">" at offset %"</literal> SIZ_FORM</argument>, <argument>SIZ_CAST startchar</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></switch>

    <break>break;</break>  <comment type="block">/* Out of the /g loop */</comment>
    </block_content>}</block></else></if_stmt>       <comment type="block">/* End of failed match handling */</comment>

  <comment type="block">/* Control reaches here in two circumstances: (a) after a match, and (b)
  after a non-match that immediately followed a match on an empty string when
  doing a global search. Such a match is done with PCRE2_NOTEMPTY_ATSTART and
  PCRE2_ANCHORED set in g_notempty. The code above turns it into a fake match
  of one character. So effectively we get here only after a match. If we
  are not doing a global search, we are done. */</comment>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_ANYGLOB</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if> <else>else
    <block>{<block_content>
    <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>match_offset</name> <init>= <expr><call><name>FLD</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>ovector</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>end_offset</name> <init>= <expr><call><name>FLD</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>ovector</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">1</literal></expr>]</index></expr></init></decl>;</decl_stmt>

    <comment type="block">/* We must now set up for the next iteration of a global search. If we have
    matched an empty string, first check to see if we are at the end of the
    subject. If so, the loop is over. Otherwise, mimic what Perl's /g option
    does. Set PCRE2_NOTEMPTY_ATSTART and PCRE2_ANCHORED and try the match again
    at the same point. If this fails it will be picked up above, where a fake
    match is set up so that at this point we advance to the next character.

    However, in order to cope with patterns that never match at their starting
    offset (e.g. /(?&lt;=\G.)/) we don't do this when the match offset is greater
    than the starting offset. This means there will be a retry with the
    starting offset at the match offset. If this returns the same match again,
    it is picked up above and ignored, and the special action is then taken. */</comment>

    <if_stmt><if>if <condition>(<expr><name>match_offset</name> <operator>==</operator> <name>end_offset</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>end_offset</name> <operator>==</operator> <name>ulen</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>           <comment type="block">/* End of subject */</comment>
      <if_stmt><if>if <condition>(<expr><name>match_offset</name> <operator>&lt;=</operator> <name><name>dat_datctl</name><operator>.</operator><name>offset</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>g_notempty</name> <operator>=</operator> <name>PCRE2_NOTEMPTY_ATSTART</name> <operator>|</operator> <name>PCRE2_ANCHORED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if>

    <comment type="block">/* However, even after matching a non-empty string, there is still one
    tricky case. If a pattern contains \K within a lookbehind assertion at the
    start, the end of the matched string can be at the offset where the match
    started. In the case of a normal /g iteration without special action, this
    leads to a loop that keeps on returning the same substring. The loop would
    be caught above, but we really want to move on to the next match. */</comment>

    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name>g_notempty</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <comment type="block">/* Set for a "normal" repeat */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_GLOBAL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>startchar</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>PCRE2_GET_STARTCHAR</name><argument_list>(<argument><expr><name>startchar</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>end_offset</name> <operator>&lt;=</operator> <name>startchar</name></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>startchar</name> <operator>&gt;=</operator> <name>ulen</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>       <comment type="block">/* End of subject */</comment>
          <expr_stmt><expr><name>end_offset</name> <operator>=</operator> <name>startchar</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <name>test_mode</name> <operator>!=</operator> <name>PCRE32_MODE</name></expr>)</condition>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE8_MODE</name></expr>)</condition>
              <block>{<block_content>
              <for>for <control>(<init>;</init> <condition><expr><name>end_offset</name> <operator>&lt;</operator> <name>ulen</name></expr>;</condition> <incr><expr><name>end_offset</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>(</operator><name>PCRE2_SPTR8</name><operator>)</operator><name>pp</name><operator>)</operator><index>[<expr><name>end_offset</name></expr>]</index> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
              </block_content>}</block></if>
            <else>else  <comment type="block">/* 16-bit mode */</comment>
              <block>{<block_content>
              <for>for <control>(<init>;</init> <condition><expr><name>end_offset</name> <operator>&lt;</operator> <name>ulen</name></expr>;</condition> <incr><expr><name>end_offset</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>(</operator><name>PCRE2_SPTR16</name><operator>)</operator><name>pp</name><operator>)</operator><index>[<expr><name>end_offset</name></expr>]</index> <operator>&amp;</operator> <literal type="number">0xfc00</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0xdc00</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>

    <comment type="block">/* For a normal global (/g) iteration, save the current ovector[0,1] and
    the starting offset so that we can check that they do change each time.
    Otherwise a matching bug that returns the same string causes an infinite
    loop. It has happened! Then update the start offset, leaving other
    parameters alone. */</comment>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dat_datctl</name><operator>.</operator><name>control</name></name> <operator>&amp;</operator> <name>CTL_GLOBAL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>ovecsave</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ovecsave</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ovecsave</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>dat_datctl</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>dat_datctl</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name>end_offset</name></expr>;</expr_stmt>
      </block_content>}</block></if>

    <comment type="block">/* For altglobal, just update the pointer and length. */</comment>

    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name>pp</name> <operator>+=</operator> <name>end_offset</name> <operator>*</operator> <name>code_unit_size</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>len</name> <operator>-=</operator> <name>end_offset</name> <operator>*</operator> <name>code_unit_size</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ulen</name> <operator>-=</operator> <name>end_offset</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>arg_ulen</name> <operator>!=</operator> <name>PCRE2_ZERO_TERMINATED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>arg_ulen</name> <operator>-=</operator> <name>end_offset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>  <comment type="block">/* End of global loop */</comment>

<expr_stmt><expr><name>show_memory</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<return>return <expr><name>PR_OK</name></expr>;</return>
</block_content>}</block></function>




<comment type="block" format="doxygen">/*************************************************
*               Print PCRE2 version              *
*************************************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_version</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VERSION_TYPE</name> <modifier>*</modifier></type><name>vp</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"PCRE2 version "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>vp</name> <operator>=</operator> <name>version</name></expr>;</init> <condition><expr><operator>*</operator><name>vp</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>vp</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><operator>*</operator><name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*               Print Unicode version            *
*************************************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_unicode_version</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VERSION_TYPE</name> <modifier>*</modifier></type><name>vp</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"Unicode version "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>vp</name> <operator>=</operator> <name>uversion</name></expr>;</init> <condition><expr><operator>*</operator><name>vp</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>vp</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><operator>*</operator><name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*               Print JIT target                 *
*************************************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_jit_target</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VERSION_TYPE</name> <modifier>*</modifier></type><name>vp</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>vp</name> <operator>=</operator> <name>jittarget</name></expr>;</init> <condition><expr><operator>*</operator><name>vp</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>vp</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><operator>*</operator><name>vp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*       Print newline configuration              *
*************************************************/</comment>

<comment type="block">/* Output is always to stdout.

Arguments:
  rc         the return code from PCRE2_CONFIG_NEWLINE
  isc        TRUE if called from "-C newline"
Returns:     nothing
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_newline_config</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>optval</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>isc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  Default newline sequence is "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>optval</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>newlines</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>newlines</name><index>[<expr><name>optval</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"a non-standard value: %d\n"</literal></expr></argument>, <argument><expr><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*             Usage function                     *
*************************************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Usage:     pcre2test [options] [&lt;input file&gt; [&lt;output file&gt;]]\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Input and output default to stdin and stdout.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_LIBREADLINE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_LIBEDIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"If input is a terminal, readline() is used to read from it.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"This version of pcre2test is not linked with readline().\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nOptions:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -8            use the 8-bit library\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -16           use the 16-bit library\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -32           use the 32-bit library\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -ac           set default pattern modifier PCRE2_AUTO_CALLOUT\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -AC           as -ac, but also set subject 'callout_extra' modifier\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -b            set default pattern modifier 'fullbincode'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -C            show PCRE2 compile-time options and exit\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -C arg        show a specific compile-time option and exit with its\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"                  value if numeric (else 0). The arg can be:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"     backslash-C    use of \\C is enabled [0, 1]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"     bsr            \\R type [ANYCRLF, ANY]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"     ebcdic         compiled for EBCDIC character code [0,1]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"     ebcdic-nl      NL code if compiled for EBCDIC\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"     jit            just-in-time compiler supported [0, 1]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"     linksize       internal link size [2, 3, 4]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"     newline        newline type [CR, LF, CRLF, ANYCRLF, ANY, NUL]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"     pcre2-8        8 bit library support enabled [0, 1]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"     pcre2-16       16 bit library support enabled [0, 1]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"     pcre2-32       32 bit library support enabled [0, 1]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"     unicode        Unicode and UTF support enabled [0, 1]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -d            set default pattern modifier 'debug'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -dfa          set default subject modifier 'dfa'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -error &lt;n,m,..&gt;  show messages for error numbers, then exit\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -help         show usage information\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -i            set default pattern modifier 'info'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -jit          set default pattern modifier 'jit'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -jitfast      set default pattern modifier 'jitfast'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -jitverify    set default pattern modifier 'jitverify'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -LM           list pattern and subject modifiers, then exit\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -q            quiet: do not output PCRE2 version number at start\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -pattern &lt;s&gt;  set default pattern modifier fields\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -subject &lt;s&gt;  set default subject modifier fields\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -S &lt;n&gt;        set stack size to &lt;n&gt; mebibytes\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -t [&lt;n&gt;]      time compilation and execution, repeating &lt;n&gt; times\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -tm [&lt;n&gt;]     time execution (matching) only, repeating &lt;n&gt; times\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -T            same as -t, but show total times at the end\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -TM           same as -tm, but show total time at the end\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -version      show PCRE2 version and exit\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*             Handle -C option                   *
*************************************************/</comment>

<comment type="block">/* This option outputs configuration options and sets an appropriate return
code when asked for a single option. The code is abstracted into a separate
function because of its size. Use whichever pcre2_config() function is
available.

Argument:   an option name or NULL
Returns:    the return code
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>c_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>optval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><name>COPTLISTCOUNT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yield</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>CHAR_MINUS</name></expr>)</condition>
  <block>{<block_content>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>COPTLISTCOUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>coptlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

  <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>COPTLISTCOUNT</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"** Unknown -C option '%s'\n"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <switch>switch <condition>(<expr><name><name>coptlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>CONF_BSR</name></expr>:</case>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name><name>coptlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>optval</name> <operator>==</operator> <name>PCRE2_BSR_ANYCRLF</name><operator>)</operator></expr>?</condition><then> <expr><literal type="string">"ANYCRLF"</literal></expr> </then><else>: <expr><literal type="string">"ANY"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>CONF_FIX</name></expr>:</case>
    <expr_stmt><expr><name>yield</name> <operator>=</operator> <name><name>coptlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name>yield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>CONF_FIZ</name></expr>:</case>
    <expr_stmt><expr><name>optval</name> <operator>=</operator> <name><name>coptlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>CONF_INT</name></expr>:</case>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name><name>coptlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name>yield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>CONF_NL</name></expr>:</case>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name><name>coptlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>print_newline_config</name><argument_list>(<argument><expr><name>optval</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch>

<comment type="block">/* For VMS, return the value by setting a symbol, for certain values only. This
is contributed code which the PCRE2 developers have no means of testing. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>

<comment type="block">/* This is the original code provided by the first VMS contributor. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NEVER</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name><name>copytlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>CONF_FIX</name> <operator>||</operator> <name><name>coptlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>CONF_INT</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>ucname</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>ucname</name></expr></argument>, <argument><expr><name><name>coptlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ucname</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ucname</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>toupper</name><index>[<expr><name><name>ucname</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>vms_setsymbol</name><argument_list>(<argument><expr><name>ucname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* This is the new code, provided by a second VMS contributor. */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>coptlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>CONF_FIX</name> <operator>||</operator> <name><name>coptlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>CONF_INT</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>nam_buf</name><index>[<expr><literal type="number">22</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>val_buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>$DESCRIPTOR</name><argument_list>(<argument><expr><name>nam</name></expr></argument>, <argument><expr><name>nam_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>$DESCRIPTOR</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>val_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>nam_buf</name></expr></argument>, <argument><expr><name><name>coptlist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nam</name><operator>.</operator><name>dsc$w_length</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>nam_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>val_buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>yield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>val</name><operator>.</operator><name>dsc$w_length</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>val_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lib$set_symbol</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nam</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* __VMS */</comment>

  <return>return <expr><name>yield</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* No argument for -C: output all configuration information. */</comment>

<expr_stmt><expr><call><name>print_version</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Compiled with\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EBCDIC</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  EBCDIC code support: LF is 0x%02x\n"</literal></expr></argument>, <argument><expr><name>CHAR_LF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NATIVE_ZOS</name></expr></cpp:if>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  EBCDIC code page %s or similar\n"</literal></expr></argument>, <argument><expr><call><name>pcrz_cpversion</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_COMPILED_WIDTHS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>optval</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  8-bit support\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>optval</name> <operator>&amp;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  16-bit support\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>optval</name> <operator>&amp;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  32-bit support\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_VALGRIND</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  Valgrind support\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_UNICODE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>optval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  UTF and UCP support ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>print_unicode_version</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  No Unicode support\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_JIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>optval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  Just-in-time compiler support: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>print_jit_target</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  No just-in-time compiler support\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_NEWLINE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_newline_config</name><argument_list>(<argument><expr><name>optval</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_BSR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  \\R matches %s\n"</literal></expr></argument>,
  <argument><expr><ternary><condition><expr><operator>(</operator><name>optval</name> <operator>==</operator> <name>PCRE2_BSR_ANYCRLF</name><operator>)</operator></expr>?</condition><then> <expr><literal type="string">"CR, LF, or CRLF only"</literal></expr> </then><else>:
                                 <expr><literal type="string">"all Unicode newlines"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_NEVER_BACKSLASH_C</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  \\C is %ssupported\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>optval</name></expr>?</condition><then> <expr><literal type="string">"not "</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_LINKSIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  Internal link size = %d\n"</literal></expr></argument>, <argument><expr><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_PARENSLIMIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  Parentheses nest limit = %d\n"</literal></expr></argument>, <argument><expr><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_HEAPLIMIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  Default heap limit = %d kibibytes\n"</literal></expr></argument>, <argument><expr><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_MATCHLIMIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  Default match limit = %d\n"</literal></expr></argument>, <argument><expr><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_DEPTHLIMIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  Default depth limit = %d\n"</literal></expr></argument>, <argument><expr><name>optval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_LIBREADLINE</name></expr></cpp:if>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  pcre2test has libreadline support\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>SUPPORT_LIBEDIT</name></expr></cpp:elif>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  pcre2test has libedit support\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  pcre2test has neither libreadline nor libedit support\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*              Display one modifier              *
*************************************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>display_one_modifier</name><parameter_list>(<parameter><decl><type><name>modstruct</name> <modifier>*</modifier></type><name>m</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>for_pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>!</operator><name>for_pattern</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>which</name></name> <operator>==</operator> <name>MOD_PND</name> <operator>||</operator> <name><name>m</name><operator>-&gt;</operator><name>which</name></name> <operator>==</operator> <name>MOD_PNDP</name><operator>)</operator><operator>)</operator></expr>?</condition><then>
  <expr><literal type="char">'*'</literal></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%c%s"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*       Display pattern or subject modifiers     *
*************************************************/</comment>

<comment type="block">/* In order to print in two columns, first scan without printing to get a list
of the modifiers that are required.

Arguments:
  for_pattern   TRUE for pattern modifiers, FALSE for subject modifiers
  title         string to be used in title

Returns:        nothing
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>display_selected_modifiers</name><parameter_list>(<parameter><decl><type><name>BOOL</name></type> <name>for_pattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>title</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>list</name><index>[<expr><name>MODLISTCOUNT</name></expr>]</index></name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MODLISTCOUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>is_pattern</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>modstruct</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><name>modlist</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>which</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>MOD_CTC</name></expr>:</case>       <comment type="block">/* Compile context */</comment>
    <case>case <expr><name>MOD_PAT</name></expr>:</case>       <comment type="block">/* Pattern */</comment>
    <case>case <expr><name>MOD_PATP</name></expr>:</case>      <comment type="block">/* Pattern, OK for Perl-compatible test */</comment>
    <break>break;</break>

    <comment type="block">/* The MOD_PND and MOD_PNDP modifiers are precisely those that affect
    subjects, but can be given with a pattern. We list them as subject
    modifiers, but marked with an asterisk.*/</comment>

    <case>case <expr><name>MOD_CTM</name></expr>:</case>       <comment type="block">/* Match context */</comment>
    <case>case <expr><name>MOD_DAT</name></expr>:</case>       <comment type="block">/* Subject line */</comment>
    <case>case <expr><name>MOD_PND</name></expr>:</case>       <comment type="block">/* As PD, but not default pattern */</comment>
    <case>case <expr><name>MOD_PNDP</name></expr>:</case>      <comment type="block">/* As PND, OK for Perl-compatible test */</comment>
    <expr_stmt><expr><name>is_pattern</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <break>break;</break>

    <default>default:</default> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"** Unknown type for modifier '%s'\n"</literal></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>
    <case>case <expr><name>MOD_PD</name></expr>:</case>        <comment type="block">/* Pattern or subject */</comment>
    <case>case <expr><name>MOD_PDP</name></expr>:</case>       <comment type="block">/* As PD, OK for Perl-compatible test */</comment>
    <expr_stmt><expr><name>is_pattern</name> <operator>=</operator> <name>for_pattern</name></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch>

  <if_stmt><if>if <condition>(<expr><name>for_pattern</name> <operator>==</operator> <name>is_pattern</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>list</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>

<comment type="block">/* Now print from the list in two columns. */</comment>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"-------------- %s MODIFIERS --------------\n"</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <operator>(</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>modstruct</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><name>modlist</name> <operator>+</operator> <name><name>list</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>display_one_modifier</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>for_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>n</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>k</name> <init>= <expr><literal type="number">27</literal> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>k</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><call><name>display_one_modifier</name><argument_list>(<argument><expr><name>modlist</name> <operator>+</operator> <name><name>list</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>for_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*          Display the list of modifiers         *
*************************************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>display_modifiers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(
  <argument><expr><literal type="string">"An asterisk on a subject modifier means that it may be given on a pattern\n"</literal>
  <literal type="string">"line, in order to apply to all subjects matched by that pattern. Modifiers\n"</literal>
  <literal type="string">"that are listed for both patterns and subjects have different effects in\n"</literal>
  <literal type="string">"each case.\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>display_selected_modifiers</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>, <argument><expr><literal type="string">"PATTERN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>display_selected_modifiers</name><argument_list>(<argument><expr><name>FALSE</name></expr></argument>, <argument><expr><literal type="string">"SUBJECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*                Main Program                    *
*************************************************/</comment>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>yield</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>op</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>notdone</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>quiet</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>showtotaltimes</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>skipping</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_subject</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_pattern</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_error</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* The offsets to the options and control bits fields of the pattern and data
control blocks must be the same so that common options and controls such as
"anchored" or "memory" can work for either of them from a single table entry.
We cannot test this till runtime because "offsetof" does not work in the
preprocessor. */</comment>

<if_stmt><if>if <condition>(<expr><call><name>PO</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>DO</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PO</name><argument_list>(<argument><expr><name>control</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>DO</name><argument_list>(<argument><expr><name>control</name></expr></argument>)</argument_list></call> <operator>||</operator>
    <call><name>PO</name><argument_list>(<argument><expr><name>control2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>DO</name><argument_list>(<argument><expr><name>control2</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"** Coding error: "</literal>
    <literal type="string">"options and control offsets for pattern and data must be the same.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Get the PCRE2 and Unicode version number and JIT target information, at the
same time checking that a request for the length gives the same answer. Also
check lengths for non-string items. */</comment>

<if_stmt><if>if <condition>(<expr><call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_VERSION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator>
    <call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_VERSION</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call> <operator>||</operator>

    <call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_UNICODE_VERSION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator>
    <call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_UNICODE_VERSION</name></expr></argument>, <argument><expr><name>uversion</name></expr></argument>)</argument_list></call> <operator>||</operator>

    <call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_JITTARGET</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator>
    <call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_JITTARGET</name></expr></argument>, <argument><expr><name>jittarget</name></expr></argument>)</argument_list></call> <operator>||</operator>

    <call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_UNICODE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof> <operator>||</operator>
    <call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_MATCHLIMIT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"** Error in pcre2_config(): bad length\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Check that bad options are diagnosed. */</comment>

<if_stmt><if>if <condition>(<expr><call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><literal type="number">999</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PCRE2_ERROR_BADOPTION</name> <operator>||</operator>
    <call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><literal type="number">999</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PCRE2_ERROR_BADOPTION</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"** Error in pcre2_config(): bad option not diagnosed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* This configuration option is now obsolete, but running a quick check ensures
that its code is covered. */</comment>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>PCRE2_CONFIG</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_STACKRECURSE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Get buffers from malloc() so that valgrind will check their misuse when
debugging. They grow automatically when very long lines are read. The 16-
and 32-bit buffers (pbuffer16, pbuffer32) are obtained only if needed. */</comment>

<expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>pbuffer8_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pbuffer8</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>pbuffer8_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* The following  _setmode() stuff is some Windows magic that tells its runtime
library to translate CRLF into a single LF character. At least, that's what
I've been told: never having used Windows I take this all on trust. Originally
it set 0x8000, but then I was advised that _O_BINARY was better. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>_setmode</name><argument_list>( <argument><expr><call><name>_fileno</name><argument_list>( <argument><expr><name>stdout</name></expr></argument> )</argument_list></call></expr></argument>, <argument><expr><name>_O_BINARY</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Initialization that does not depend on the running mode. */</comment>

<expr_stmt><expr><name><name>locale_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>def_patctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>patctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>def_patctl</name><operator>.</operator><name>convert_type</name></name> <operator>=</operator> <name>CONVERT_UNSET</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>def_datctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>datctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>def_datctl</name><operator>.</operator><name>oveccount</name></name> <operator>=</operator> <name>DEFAULT_OVECCOUNT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>def_datctl</name><operator>.</operator><name>copy_numbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>def_datctl</name><operator>.</operator><name>get_numbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>def_datctl</name><operator>.</operator><name>startend</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>def_datctl</name><operator>.</operator><name>startend</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CFORE_UNSET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>def_datctl</name><operator>.</operator><name>cerror</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>def_datctl</name><operator>.</operator><name>cerror</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CFORE_UNSET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>def_datctl</name><operator>.</operator><name>cfail</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>def_datctl</name><operator>.</operator><name>cfail</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CFORE_UNSET</name></expr>;</expr_stmt>

<comment type="block">/* Scan command line options. */</comment>

<while>while <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>argv</name><index>[<expr><name>op</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>argv</name><index>[<expr><name>op</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><name>op</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>uli</name></decl>;</decl_stmt>

  <comment type="block">/* List modifiers and exit. */</comment>

  <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-LM"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>display_modifiers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>EXIT</name>;</goto>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Display and/or set return code for configuration options. */</comment>

  <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-C"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>yield</name> <operator>=</operator> <call><name>c_option</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>op</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>EXIT</name>;</goto>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Select operating mode. Ensure that pcre2_config() is called in 16-bit
  and 32-bit modes because that won't happen naturally when 8-bit is also
  configured. Also call some other functions that are not otherwise used. This
  means that a coverage report won't claim there are uncalled functions. */</comment>

  <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-8"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
    <expr_stmt><expr><name>test_mode</name> <operator>=</operator> <name>PCRE8_MODE</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_set_bsr_8</name><argument_list>(<argument><expr><name>pat_context8</name></expr></argument>, <argument><expr><literal type="number">999</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_set_newline_8</name><argument_list>(<argument><expr><name>pat_context8</name></expr></argument>, <argument><expr><literal type="number">999</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
      <argument><expr><literal type="string">"** This version of PCRE2 was built without 8-bit support\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>

  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-16"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
    <expr_stmt><expr><name>test_mode</name> <operator>=</operator> <name>PCRE16_MODE</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_config_16</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_VERSION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_set_bsr_16</name><argument_list>(<argument><expr><name>pat_context16</name></expr></argument>, <argument><expr><literal type="number">999</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_set_newline_16</name><argument_list>(<argument><expr><name>pat_context16</name></expr></argument>, <argument><expr><literal type="number">999</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
      <argument><expr><literal type="string">"** This version of PCRE2 was built without 16-bit support\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>

  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-32"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
    <expr_stmt><expr><name>test_mode</name> <operator>=</operator> <name>PCRE32_MODE</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_config_32</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_VERSION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_set_bsr_32</name><argument_list>(<argument><expr><name>pat_context32</name></expr></argument>, <argument><expr><literal type="number">999</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_set_newline_32</name><argument_list>(<argument><expr><name>pat_context32</name></expr></argument>, <argument><expr><literal type="number">999</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
      <argument><expr><literal type="string">"** This version of PCRE2 was built without 32-bit support\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>

  <comment type="block">/* Set quiet (no version verification) */</comment>

  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-q"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>quiet</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>

  <comment type="block">/* Set system stack size */</comment>

  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-S"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>argc</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
      <operator>(</operator><operator>(</operator><name>uli</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>op</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>,</operator> <operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__minix</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>NATIVE_ZOS</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2test: -S is not supported on this OS\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>stack_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>rlimit</name></name></type> <name>rlim</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>U32OVERFLOW</name><argument_list>(<argument><expr><name>uli</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"** Argument for -S is too big\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>stack_size</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>uli</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_STACK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rlim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rlim</name><operator>.</operator><name>rlim_cur</name></name> <operator>=</operator> <name>stack_size</name> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>rlim</name><operator>.</operator><name>rlim_cur</name></name> <operator>&gt;</operator> <name><name>rlim</name><operator>.</operator><name>rlim_max</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
        <argument><expr><literal type="string">"pcre2test: requested stack size %luMiB is greater than hard limit "</literal>
          <literal type="string">"%luMiB\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>int</name><operator>)</operator><name>stack_size</name></expr></argument>,
          <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>int</name><operator>)</operator><operator>(</operator><name><name>rlim</name><operator>.</operator><name>rlim_max</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>setrlimit</name><argument_list>(<argument><expr><name>RLIMIT_STACK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rlim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2test: setting stack size %luMiB failed: %s\n"</literal></expr></argument>,
        <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>int</name><operator>)</operator><name>stack_size</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>op</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>argc</name><operator>--</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>

  <comment type="block">/* Set some common pattern and subject controls */</comment>

  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-AC"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name><name>def_patctl</name><operator>.</operator><name>options</name></name> <operator>|=</operator> <name>PCRE2_AUTO_CALLOUT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>def_datctl</name><operator>.</operator><name>control2</name></name> <operator>|=</operator> <name>CTL2_CALLOUT_EXTRA</name></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-ac"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <expr_stmt><expr><name><name>def_patctl</name><operator>.</operator><name>options</name></name> <operator>|=</operator> <name>PCRE2_AUTO_CALLOUT</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-b"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>   <expr_stmt><expr><name><name>def_patctl</name><operator>.</operator><name>control</name></name> <operator>|=</operator> <name>CTL_FULLBINCODE</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-d"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>   <expr_stmt><expr><name><name>def_patctl</name><operator>.</operator><name>control</name></name> <operator>|=</operator> <name>CTL_DEBUG</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-dfa"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>def_datctl</name><operator>.</operator><name>control</name></name> <operator>|=</operator> <name>CTL_DFA</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-i"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>   <expr_stmt><expr><name><name>def_patctl</name><operator>.</operator><name>control</name></name> <operator>|=</operator> <name>CTL_INFO</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-jit"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-jitverify"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
           <call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-jitfast"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'v'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>def_patctl</name><operator>.</operator><name>control</name></name> <operator>|=</operator> <name>CTL_JITVERIFY</name></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>def_patctl</name><operator>.</operator><name>control</name></name> <operator>|=</operator> <name>CTL_JITFAST</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>def_patctl</name><operator>.</operator><name>jit</name></name> <operator>=</operator> <name>JIT_DEFAULT</name></expr>;</expr_stmt>  <comment type="block">/* full &amp; partial */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SUPPORT_JIT</name></cpp:ifndef>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"** Warning: JIT support is not available: "</literal>
                    <literal type="string">"-jit[fast|verify] calls functions that do nothing.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>

  <comment type="block">/* Set timing parameters */</comment>

  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-t"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-tm"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
           <call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-T"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-TM"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>both</name> <init>= <expr><name><name>arg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>showtotaltimes</name> <operator>=</operator> <name><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'T'</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>uli</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>op</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call><operator>,</operator> <operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>uli</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"** Argument for %s must not be zero\n"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>U32OVERFLOW</name><argument_list>(<argument><expr><name>uli</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"** Argument for %s is too big\n"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>timeitm</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>uli</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>op</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>argc</name><operator>--</operator></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>timeitm</name> <operator>=</operator> <name>LOOPREPEAT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>both</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>timeit</name> <operator>=</operator> <name>timeitm</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>

  <comment type="block">/* Give help */</comment>

  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
           <call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>EXIT</name>;</goto>
    </block_content>}</block></if>

  <comment type="block">/* Show version */</comment>

  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
           <call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>print_version</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>EXIT</name>;</goto>
    </block_content>}</block></if>

  <comment type="block">/* The following options save their data for processing once we know what
  the running mode is. */</comment>

  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-error"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>arg_error</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>op</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <goto>goto <name>CHECK_VALUE_EXISTS</name>;</goto>
    </block_content>}</block></if>

  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-subject"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>arg_subject</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>op</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <goto>goto <name>CHECK_VALUE_EXISTS</name>;</goto>
    </block_content>}</block></if>

  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-pattern"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>arg_pattern</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>op</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <label><name>CHECK_VALUE_EXISTS</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"** Missing value for %s\n"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>yield</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <goto>goto <name>EXIT</name>;</goto>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>op</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>argc</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></if>

  <comment type="block">/* Unrecognized option */</comment>

  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"** Unknown or malformed option '%s'\n"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>yield</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <goto>goto <name>EXIT</name>;</goto>
    </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>op</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>argc</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

<comment type="block">/* If -error was present, get the error numbers, show the messages, and exit.
We wait to do this until we know which mode we are in. */</comment>

<if_stmt><if>if <condition>(<expr><name>arg_error</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>errcode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

<comment type="block">/* Ensure the relevant non-8-bit buffer is available. Ensure that it is at
least 128 code units, because it is used for retrieving error messages. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE16_MODE</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>pbuffer16_size</name> <operator>=</operator> <literal type="number">256</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pbuffer16</name> <operator>=</operator> <operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>pbuffer16_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>pbuffer16</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
      <macro><name>fprintf</name><argument_list>(<argument>stderr</argument>, <argument><literal type="string">"pcre2test: malloc(%"</literal> SIZ_FORM <literal type="string">") failed for pbuffer16\n"</literal></argument>,
        <argument>SIZ_CAST pbuffer16_size</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
      <expr_stmt><expr><name>yield</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <goto>goto <name>EXIT</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE32_MODE</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>pbuffer32_size</name> <operator>=</operator> <literal type="number">512</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pbuffer32</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>pbuffer32_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>pbuffer32</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
      <macro><name>fprintf</name><argument_list>(<argument>stderr</argument>, <argument><literal type="string">"pcre2test: malloc(%"</literal> SIZ_FORM <literal type="string">") failed for pbuffer32\n"</literal></argument>,
        <argument>SIZ_CAST pbuffer32_size</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
      <expr_stmt><expr><name>yield</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <goto>goto <name>EXIT</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Loop along a list of error numbers. */</comment>

  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
    <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>arg_error</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>endptr</name> <operator>!=</operator> <name>CHAR_COMMA</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"** '%s' is not a valid error number list\n"</literal></expr></argument>, <argument><expr><name>arg_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>yield</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <goto>goto <name>EXIT</name>;</goto>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Error %d: "</literal></expr></argument>, <argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PCRE2_GET_ERROR_MESSAGE</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>, <argument><expr><name>pbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <switch>switch <condition>(<expr><name>len</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>PCRE2_ERROR_BADDATA</name></expr>:</case>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"PCRE2_ERROR_BADDATA (unknown error number)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>:</case>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"PCRE2_ERROR_NOMEMORY (buffer too small)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

        <default>default:</default>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Unexpected return (%d) from pcre2_get_error_message()"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
        </block_content>}</block></switch>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>PCHARSV</name><argument_list>(<argument><expr><call><name>CASTVAR</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><name>pbuffer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>EXIT</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>arg_error</name> <operator>=</operator> <name>endptr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
  <comment type="block">/* Control never reaches here */</comment>
  </block_content>}</block></if></if_stmt>  <comment type="block">/* End of -error handling */</comment>

<comment type="block">/* Initialize things that cannot be done until we know which test mode we are
running in. Exercise the general context copying and match data size functions,
which are not otherwise used. */</comment>

<expr_stmt><expr><name>code_unit_size</name> <operator>=</operator> <name>test_mode</name><operator>/</operator><literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>max_oveccount</name> <operator>=</operator> <name>DEFAULT_OVECCOUNT</name></expr>;</expr_stmt>

<comment type="block">/* Use macros to save a lot of duplication. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CREATECONTEXTS</name></cpp:macro> \
  <cpp:value>G(general_context,BITS) = G(pcre2_general_context_create_,BITS)(&amp;my_malloc, &amp;my_free, NULL); \
  G(general_context_copy,BITS) = G(pcre2_general_context_copy_,BITS)(G(general_context,BITS)); \
  G(default_pat_context,BITS) = G(pcre2_compile_context_create_,BITS)(G(general_context,BITS)); \
  G(pat_context,BITS) = G(pcre2_compile_context_copy_,BITS)(G(default_pat_context,BITS)); \
  G(default_dat_context,BITS) = G(pcre2_match_context_create_,BITS)(G(general_context,BITS)); \
  G(dat_context,BITS) = G(pcre2_match_context_copy_,BITS)(G(default_dat_context,BITS)); \
  G(default_con_context,BITS) = G(pcre2_convert_context_create_,BITS)(G(general_context,BITS)); \
  G(con_context,BITS) = G(pcre2_convert_context_copy_,BITS)(G(default_con_context,BITS)); \
  G(match_data,BITS) = G(pcre2_match_data_create_,BITS)(max_oveccount, G(general_context,BITS))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONTEXTTESTS</name></cpp:macro> \
  <cpp:value>(void)G(pcre2_set_compile_extra_options_,BITS)(G(pat_context,BITS), 0); \
  (void)G(pcre2_set_max_pattern_length_,BITS)(G(pat_context,BITS), 0); \
  (void)G(pcre2_set_offset_limit_,BITS)(G(dat_context,BITS), 0); \
  (void)G(pcre2_set_recursion_memory_management_,BITS)(G(dat_context,BITS), my_malloc, my_free, NULL); \
  (void)G(pcre2_get_match_data_size_,BITS)(G(match_data,BITS))</cpp:value></cpp:define>


<comment type="block">/* Call the appropriate functions for the current mode, and exercise some
functions that are not otherwise called. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BITS</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITS</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE8_MODE</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>CREATECONTEXTS</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>CONTEXTTESTS</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BITS</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITS</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE16_MODE</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>CREATECONTEXTS</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>CONTEXTTESTS</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BITS</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITS</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<if_stmt><if>if <condition>(<expr><name>test_mode</name> <operator>==</operator> <name>PCRE32_MODE</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>CREATECONTEXTS</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>CONTEXTTESTS</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Set a default parentheses nest limit that is large enough to run the
standard tests (this also exercises the function). */</comment>

<expr_stmt><expr><call><name>PCRE2_SET_PARENS_NEST_LIMIT</name><argument_list>(<argument><expr><name>default_pat_context</name></expr></argument>, <argument><expr><name>PARENS_NEST_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Handle command line modifier settings, sending any error messages to
stderr. We need to know the mode before modifying the context, and it is tidier
to do them all in the same way. */</comment>

<expr_stmt><expr><name>outfile</name> <operator>=</operator> <name>stderr</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>arg_pattern</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
    <operator>!</operator><call><name>decode_modifiers</name><argument_list>(<argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>arg_pattern</name></expr></argument>, <argument><expr><name>CTX_DEFPAT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>def_patctl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
    <operator>(</operator><name>arg_subject</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
    <operator>!</operator><call><name>decode_modifiers</name><argument_list>(<argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>arg_subject</name></expr></argument>, <argument><expr><name>CTX_DEFDAT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>def_datctl</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>yield</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <goto>goto <name>EXIT</name>;</goto>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Sort out the input and output files, defaulting to stdin/stdout. */</comment>

<expr_stmt><expr><name>infile</name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt>
<expr_stmt><expr><name>outfile</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>infile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>, <argument><expr><name>INPUT_MODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>infile</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"** Failed to open '%s': %s\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>yield</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <goto>goto <name>EXIT</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_LIBREADLINE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_LIBEDIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>INTERACTIVE</name><argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>using_history</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>outfile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>op</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>OUTPUT_MODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>outfile</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"** Failed to open '%s': %s\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>op</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>yield</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <goto>goto <name>EXIT</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Output a heading line unless quiet, then process input lines. */</comment>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>quiet</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>print_version</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
<expr_stmt><expr><name><name>preg</name><operator>.</operator><name>re_pcre2_code</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>preg</name><operator>.</operator><name>re_match_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<while>while <condition>(<expr><name>notdone</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>PR_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>expectdata</name> <init>= <expr><call><name>TEST</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><operator>!=</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
  <expr_stmt><expr><name>expectdata</name> <operator>|=</operator> <name><name>preg</name><operator>.</operator><name>re_pcre2_code</name></name> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if <condition>(<expr><call><name>extend_inputline</name><argument_list>(<argument><expr><name>infile</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><ternary><condition><expr><name>expectdata</name></expr>?</condition><then> <expr><literal type="string">"data&gt; "</literal></expr> </then><else>: <expr><literal type="string">"  re&gt; "</literal></expr></else></ternary></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <break>break;</break></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>INTERACTIVE</name><argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>

  <comment type="block">/* If we have a pattern set up for testing, or we are skipping after a
  compile failure, a blank line terminates this test. */</comment>

  <if_stmt><if>if <condition>(<expr><name>expectdata</name> <operator>||</operator> <name>skipping</name></expr>)</condition>
    <block>{<block_content>
    <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name><name>preg</name><operator>.</operator><name>re_pcre2_code</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>regfree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>preg</name><operator>.</operator><name>re_pcre2_code</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>preg</name><operator>.</operator><name>re_match_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_PCRE2_8 */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>TEST</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><operator>!=</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>SUB1</name><argument_list>(<argument><expr><name>pcre2_code_free</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>skipping</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><literal type="string">"C"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>

    <comment type="block">/* Otherwise, if we are not skipping, and the line is not a data comment
    line starting with "\=", process a data line. */</comment>

    <if type="elseif">else if <condition>(<expr><operator>!</operator><name>skipping</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>process_data</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>

  <comment type="block">/* We do not have a pattern set up for testing. Lines starting with # are
  either comments or special commands. Blank lines are ignored. Otherwise, the
  line must start with a valid delimiter. It is then processed as a pattern
  line. A copy of the pattern is left in pbuffer8 for use by callouts. Under
  valgrind, make the unused part of the buffer undefined, to catch overruns. */</comment>

  <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'!'</literal> <operator>||</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>process_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>

  <if type="elseif">else if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"/!\"'`%&amp;-=_:;,@~"</literal></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>process_pattern</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dfa_matched</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>

  <else>else
    <block>{<block_content>
    <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** Invalid pattern delimiter '%c' (x%x).\n"</literal></expr></argument>, <argument><expr><operator>*</operator><name>buffer</name></expr></argument>,
        <argument><expr><operator>*</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PR_SKIP</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PR_SKIP</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>INTERACTIVE</name><argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>skipping</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PR_ABEND</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"** pcre2test run abandoned\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>yield</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <goto>goto <name>EXIT</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

<comment type="block">/* Finish off a normal run. */</comment>

<if_stmt><if>if <condition>(<expr><call><name>INTERACTIVE</name><argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>showtotaltimes</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pad</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"--------------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>timeit</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Total compile time %.4f milliseconds\n"</literal></expr></argument>,
      <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name>total_compile_time</name> <operator>*</operator> <literal type="number">1000.0</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>timeit</name><operator>)</operator> <operator>/</operator>
        <operator>(</operator><name>double</name><operator>)</operator><name>CLOCKS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>total_jit_compile_time</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Total JIT compile  %.4f milliseconds\n"</literal></expr></argument>,
        <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name>total_jit_compile_time</name> <operator>*</operator> <literal type="number">1000.0</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>timeit</name><operator>)</operator> <operator>/</operator>
          <operator>(</operator><name>double</name><operator>)</operator><name>CLOCKS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pad</name> <operator>=</operator> <literal type="string">"  "</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><literal type="string">"Total match time %s%.4f milliseconds\n"</literal></expr></argument>, <argument><expr><name>pad</name></expr></argument>,
    <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name>total_match_time</name> <operator>*</operator> <literal type="number">1000.0</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><name>timeitm</name><operator>)</operator> <operator>/</operator>
      <operator>(</operator><name>double</name><operator>)</operator><name>CLOCKS_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>


<label><name>EXIT</name>:</label>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_LIBREADLINE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_LIBEDIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>infile</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>INTERACTIVE</name><argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>clear_history</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>infile</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>infile</name> <operator>!=</operator> <name>stdin</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>outfile</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>outfile</name> <operator>!=</operator> <name>stdout</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pbuffer8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dfa_workspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>locale_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tables3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PCRE2_MATCH_DATA_FREE</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SUB1</name><argument_list>(<argument><expr><name>pcre2_code_free</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while<condition>(<expr><name>patstacknext</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>compiled_code</name></expr></argument>, <argument><expr><name><name>patstack</name><index>[<expr><name>patstacknext</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SUB1</name><argument_list>(<argument><expr><name>pcre2_code_free</name></expr></argument>, <argument><expr><name>compiled_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

<expr_stmt><expr><call><name>PCRE2_JIT_FREE_UNUSED_MEMORY</name><argument_list>(<argument><expr><name>general_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>jit_stack</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>PCRE2_JIT_STACK_FREE</name><argument_list>(<argument><expr><name>jit_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREECONTEXTS</name></cpp:macro> \
  <cpp:value>G(pcre2_general_context_free_,BITS)(G(general_context,BITS)); \
  G(pcre2_general_context_free_,BITS)(G(general_context_copy,BITS)); \
  G(pcre2_compile_context_free_,BITS)(G(pat_context,BITS)); \
  G(pcre2_compile_context_free_,BITS)(G(default_pat_context,BITS)); \
  G(pcre2_match_context_free_,BITS)(G(dat_context,BITS)); \
  G(pcre2_match_context_free_,BITS)(G(default_dat_context,BITS)); \
  G(pcre2_convert_context_free_,BITS)(G(default_con_context,BITS)); \
  G(pcre2_convert_context_free_,BITS)(G(con_context,BITS));</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_8</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BITS</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITS</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<if_stmt><if>if <condition>(<expr><name><name>preg</name><operator>.</operator><name>re_pcre2_code</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>regfree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>preg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>FREECONTEXTS</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_16</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BITS</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITS</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pbuffer16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>FREECONTEXTS</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2_32</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BITS</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITS</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pbuffer32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>FREECONTEXTS</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name>yield</name> <operator>=</operator> <name>SS$_NORMAL</name></expr>;</expr_stmt>  <comment type="block">/* Return values via DCL symbols */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>yield</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* End of pcre2test.c */</comment>
</unit>
