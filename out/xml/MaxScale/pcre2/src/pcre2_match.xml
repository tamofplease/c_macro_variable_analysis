<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/pcre2/src/pcre2_match.c"><comment type="block" format="doxygen">/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/</comment>

<comment type="block">/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
     Original API code Copyright (c) 1997-2012 University of Cambridge
          New API code Copyright (c) 2015-2020 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* These defines enable debugging code */</comment>

<comment type="block">/* #define DEBUG_FRAMES_DISPLAY */</comment>
<comment type="block">/* #define DEBUG_SHOW_OPS */</comment>
<comment type="block">/* #define DEBUG_SHOW_RMATCH */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_FRAME_DISPLAY</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* These defines identify the name of the block containing "static"
information, and fields within it. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NLBLOCK</name></cpp:macro> <cpp:value>mb</cpp:value></cpp:define>              <comment type="block">/* Block containing newline information */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSSTART</name></cpp:macro> <cpp:value>start_subject</cpp:value></cpp:define>   <comment type="block">/* Field containing processed string start */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSEND</name></cpp:macro>   <cpp:value>end_subject</cpp:value></cpp:define>     <comment type="block">/* Field containing processed string end */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_internal.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECURSE_UNSET</name></cpp:macro> <cpp:value>0xffffffffu</cpp:value></cpp:define>  <comment type="block">/* Bigger than max group number */</comment>

<comment type="block">/* Masks for identifying the public options that are permitted at match time. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUBLIC_MATCH_OPTIONS</name></cpp:macro> \
  <cpp:value>(PCRE2_ANCHORED|PCRE2_ENDANCHORED|PCRE2_NOTBOL|PCRE2_NOTEOL|PCRE2_NOTEMPTY| \
   PCRE2_NOTEMPTY_ATSTART|PCRE2_NO_UTF_CHECK|PCRE2_PARTIAL_HARD| \
   PCRE2_PARTIAL_SOFT|PCRE2_NO_JIT|PCRE2_COPY_MATCHED_SUBJECT)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUBLIC_JIT_MATCH_OPTIONS</name></cpp:macro> \
   <cpp:value>(PCRE2_NO_UTF_CHECK|PCRE2_NOTBOL|PCRE2_NOTEOL|PCRE2_NOTEMPTY|\
    PCRE2_NOTEMPTY_ATSTART|PCRE2_PARTIAL_SOFT|PCRE2_PARTIAL_HARD|\
    PCRE2_COPY_MATCHED_SUBJECT)</cpp:value></cpp:define>

<comment type="block">/* Non-error returns from and within the match() function. Error returns are
externally defined PCRE2_ERROR_xxx codes, which are all negative. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCH_MATCH</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCH_NOMATCH</name></cpp:macro>      <cpp:value>0</cpp:value></cpp:define>

<comment type="block">/* Special internal returns used in the match() function. Make them
sufficiently negative to avoid the external error codes. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCH_ACCEPT</name></cpp:macro>       <cpp:value>(-999)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCH_KETRPOS</name></cpp:macro>      <cpp:value>(-998)</cpp:value></cpp:define>
<comment type="block">/* The next 5 must be kept together and in sequence so that a test that checks
for any one of them can use a range. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCH_COMMIT</name></cpp:macro>       <cpp:value>(-997)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCH_PRUNE</name></cpp:macro>        <cpp:value>(-996)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCH_SKIP</name></cpp:macro>         <cpp:value>(-995)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCH_SKIP_ARG</name></cpp:macro>     <cpp:value>(-994)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCH_THEN</name></cpp:macro>         <cpp:value>(-993)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCH_BACKTRACK_MAX</name></cpp:macro> <cpp:value>MATCH_THEN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCH_BACKTRACK_MIN</name></cpp:macro> <cpp:value>MATCH_COMMIT</cpp:value></cpp:define>

<comment type="block">/* Group frame type values. Zero means the frame is not a group frame. The
lower 16 bits are used for data (e.g. the capture number). Group frames are
used for most groups so that information about the start is easily available at
the end without having to scan back through intermediate frames (backtrack
points). */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GF_CAPTURE</name></cpp:macro>     <cpp:value>0x00010000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GF_NOCAPTURE</name></cpp:macro>   <cpp:value>0x00020000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GF_CONDASSERT</name></cpp:macro>  <cpp:value>0x00030000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GF_RECURSE</name></cpp:macro>     <cpp:value>0x00040000u</cpp:value></cpp:define>

<comment type="block">/* Masks for the identity and data parts of the group frame type. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GF_IDMASK</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>((a) &amp; 0xffff0000u)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GF_DATAMASK</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((a) &amp; 0x0000ffffu)</cpp:value></cpp:define>

<comment type="block">/* Repetition types */</comment>

<enum>enum <block>{ <decl><name>REPTYPE_MIN</name></decl>, <decl><name>REPTYPE_MAX</name></decl>, <decl><name>REPTYPE_POS</name></decl> }</block>;</enum>

<comment type="block">/* Min and max values for the common repeats; a maximum of UINT32_MAX =&gt;
infinity. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name><name>rep_min</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,       <comment type="block">/* * and *? */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,       <comment type="block">/* + and +? */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,       <comment type="block">/* ? and ?? */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,       <comment type="block">/* dummy placefillers for OP_CR[MIN]RANGE */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>  <comment type="block">/* OP_CRPOS{STAR, PLUS, QUERY} */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name><name>rep_max</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>UINT32_MAX</name></expr>, <expr><name>UINT32_MAX</name></expr>,      <comment type="block">/* * and *? */</comment>
  <expr><name>UINT32_MAX</name></expr>, <expr><name>UINT32_MAX</name></expr>,      <comment type="block">/* + and +? */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,                        <comment type="block">/* ? and ?? */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                        <comment type="block">/* dummy placefillers for OP_CR[MIN]RANGE */</comment>
  <expr><name>UINT32_MAX</name></expr>, <expr><name>UINT32_MAX</name></expr>, <expr><literal type="number">1</literal></expr> }</block></expr></init></decl>;</decl_stmt> <comment type="block">/* OP_CRPOS{STAR, PLUS, QUERY} */</comment>

<comment type="block">/* Repetition types - must include OP_CRPOSRANGE (not needed above) */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name><name>rep_typ</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>REPTYPE_MAX</name></expr>, <expr><name>REPTYPE_MIN</name></expr>,    <comment type="block">/* * and *? */</comment>
  <expr><name>REPTYPE_MAX</name></expr>, <expr><name>REPTYPE_MIN</name></expr>,    <comment type="block">/* + and +? */</comment>
  <expr><name>REPTYPE_MAX</name></expr>, <expr><name>REPTYPE_MIN</name></expr>,    <comment type="block">/* ? and ?? */</comment>
  <expr><name>REPTYPE_MAX</name></expr>, <expr><name>REPTYPE_MIN</name></expr>,    <comment type="block">/* OP_CRRANGE and OP_CRMINRANGE */</comment>
  <expr><name>REPTYPE_POS</name></expr>, <expr><name>REPTYPE_POS</name></expr>,    <comment type="block">/* OP_CRPOSSTAR, OP_CRPOSPLUS */</comment>
  <expr><name>REPTYPE_POS</name></expr>, <expr><name>REPTYPE_POS</name></expr> }</block></expr></init></decl>;</decl_stmt>  <comment type="block">/* OP_CRPOSQUERY, OP_CRPOSRANGE */</comment>

<comment type="block">/* Numbers for RMATCH calls at backtracking points. When these lists are
changed, the code at RETURN_SWITCH below must be updated in sync.  */</comment>

<enum>enum <block>{ <decl><name>RM1</name><init>=<expr><literal type="number">1</literal></expr></init></decl>, <decl><name>RM2</name></decl>,  <decl><name>RM3</name></decl>,  <decl><name>RM4</name></decl>,  <decl><name>RM5</name></decl>,  <decl><name>RM6</name></decl>,  <decl><name>RM7</name></decl>,  <decl><name>RM8</name></decl>,  <decl><name>RM9</name></decl>,  <decl><name>RM10</name></decl>,
       <decl><name>RM11</name></decl>,  <decl><name>RM12</name></decl>, <decl><name>RM13</name></decl>, <decl><name>RM14</name></decl>, <decl><name>RM15</name></decl>, <decl><name>RM16</name></decl>, <decl><name>RM17</name></decl>, <decl><name>RM18</name></decl>, <decl><name>RM19</name></decl>, <decl><name>RM20</name></decl>,
       <decl><name>RM21</name></decl>,  <decl><name>RM22</name></decl>, <decl><name>RM23</name></decl>, <decl><name>RM24</name></decl>, <decl><name>RM25</name></decl>, <decl><name>RM26</name></decl>, <decl><name>RM27</name></decl>, <decl><name>RM28</name></decl>, <decl><name>RM29</name></decl>, <decl><name>RM30</name></decl>,
       <decl><name>RM31</name></decl>,  <decl><name>RM32</name></decl>, <decl><name>RM33</name></decl>, <decl><name>RM34</name></decl>, <decl><name>RM35</name></decl>, <decl><name>RM36</name></decl> }</block>;</enum>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>
<enum>enum <block>{ <decl><name>RM100</name><init>=<expr><literal type="number">100</literal></expr></init></decl>, <decl><name>RM101</name></decl> }</block>;</enum>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<enum>enum <block>{ <decl><name>RM200</name><init>=<expr><literal type="number">200</literal></expr></init></decl>, <decl><name>RM201</name></decl>, <decl><name>RM202</name></decl>, <decl><name>RM203</name></decl>, <decl><name>RM204</name></decl>, <decl><name>RM205</name></decl>, <decl><name>RM206</name></decl>, <decl><name>RM207</name></decl>,
       <decl><name>RM208</name></decl>,     <decl><name>RM209</name></decl>, <decl><name>RM210</name></decl>, <decl><name>RM211</name></decl>, <decl><name>RM212</name></decl>, <decl><name>RM213</name></decl>, <decl><name>RM214</name></decl>, <decl><name>RM215</name></decl>,
       <decl><name>RM216</name></decl>,     <decl><name>RM217</name></decl>, <decl><name>RM218</name></decl>, <decl><name>RM219</name></decl>, <decl><name>RM220</name></decl>, <decl><name>RM221</name></decl>, <decl><name>RM222</name></decl> }</block>;</enum>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Define short names for general fields in the current backtrack frame, which
is always pointed to by the F variable. Occasional references to fields in
other frames are written out explicitly. There are also some fields in the
current frame whose names start with "temp" that are used for short-term,
localised backtracking memory. These are #defined with Lxxx names at the point
of use and undefined afterwards. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Fback_frame</name></cpp:macro>        <cpp:value>F-&gt;back_frame</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Fcapture_last</name></cpp:macro>      <cpp:value>F-&gt;capture_last</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Fcurrent_recurse</name></cpp:macro>   <cpp:value>F-&gt;current_recurse</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Fecode</name></cpp:macro>             <cpp:value>F-&gt;ecode</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Feptr</name></cpp:macro>              <cpp:value>F-&gt;eptr</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Fgroup_frame_type</name></cpp:macro>  <cpp:value>F-&gt;group_frame_type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Flast_group_offset</name></cpp:macro> <cpp:value>F-&gt;last_group_offset</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Flength</name></cpp:macro>            <cpp:value>F-&gt;length</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Fmark</name></cpp:macro>              <cpp:value>F-&gt;mark</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Frdepth</name></cpp:macro>            <cpp:value>F-&gt;rdepth</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Fstart_match</name></cpp:macro>       <cpp:value>F-&gt;start_match</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Foffset_top</name></cpp:macro>        <cpp:value>F-&gt;offset_top</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Foccu</name></cpp:macro>              <cpp:value>F-&gt;occu</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Fop</name></cpp:macro>                <cpp:value>F-&gt;op</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Fovector</name></cpp:macro>           <cpp:value>F-&gt;ovector</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Freturn_id</name></cpp:macro>         <cpp:value>F-&gt;return_id</cpp:value></cpp:define>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_FRAMES_DISPLAY</name></cpp:ifdef>
<comment type="block" format="doxygen">/*************************************************
*      Display current frames and contents       *
*************************************************/</comment>

<comment type="block">/* This debugging function displays the current set of frames and their
contents. It is not called automatically from anywhere, the intention being
that calls can be inserted where necessary when debugging frame-related
problems.

Arguments:
  f           the file to write to
  F           the current top frame
  P           a previous frame of interest
  frame_size  the frame size
  mb          points to the match block
  s           identification text

Returns:    nothing
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>display_frames</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>heapframe</name> <modifier>*</modifier></type><name>F</name></decl></parameter>, <parameter><decl><type><name>heapframe</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>frame_size</name></decl></parameter>,
  <parameter><decl><type><name>match_block</name> <modifier>*</modifier></type><name>mb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>heapframe</name> <modifier>*</modifier></type><name>Q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"FRAMES "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>P</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" P=%lu"</literal></expr></argument>,
  <argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>P</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name><operator>)</operator><operator>)</operator><operator>/</operator><name>frame_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>Q</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name></expr>;</init>
     <condition><expr><name>Q</name> <operator>&lt;=</operator> <name>F</name></expr>;</condition>
     <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>Q</name> <operator>=</operator> <operator>(</operator><name>heapframe</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>Q</name> <operator>+</operator> <name>frame_size</name><operator>)</operator></expr></incr>)</control>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"Frame %d type=%x subj=%lu code=%d back=%lu id=%d"</literal></expr></argument>,
    <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>Q</name><operator>-&gt;</operator><name>group_frame_type</name></name></expr></argument>, <argument><expr><name><name>Q</name><operator>-&gt;</operator><name>eptr</name></name> <operator>-</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name><name>Q</name><operator>-&gt;</operator><name>ecode</name></name><operator>)</operator></expr></argument>,
    <argument><expr><name><name>Q</name><operator>-&gt;</operator><name>back_frame</name></name></expr></argument>, <argument><expr><name><name>Q</name><operator>-&gt;</operator><name>return_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>Q</name><operator>-&gt;</operator><name>last_group_offset</name></name> <operator>==</operator> <name>PCRE2_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" lgoffset=unset\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" lgoffset=%lu\n"</literal></expr></argument>,  <argument><expr><name><name>Q</name><operator>-&gt;</operator><name>last_group_offset</name></name><operator>/</operator><name>frame_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<comment type="block" format="doxygen">/*************************************************
*                Process a callout               *
*************************************************/</comment>

<comment type="block">/* This function is called for all callouts, whether "standalone" or at the
start of a conditional group. Feptr will be pointing to either OP_CALLOUT or
OP_CALLOUT_STR. A callout block is allocated in pcre2_match() and initialized
with fixed values.

Arguments:
  F          points to the current backtracking frame
  mb         points to the match block
  lengthptr  where to return the length of the callout item

Returns:     the return from the callout
             or 0 if no callout function exists
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>do_callout</name><parameter_list>(<parameter><decl><type><name>heapframe</name> <modifier>*</modifier></type><name>F</name></decl></parameter>, <parameter><decl><type><name>match_block</name> <modifier>*</modifier></type><name>mb</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>lengthptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>save0</name></decl>, <decl><type ref="prev"/><name>save1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>callout_ovector</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pcre2_callout_block</name> <modifier>*</modifier></type><name>cb</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>lengthptr</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name>Fecode</name> <operator>==</operator> <name>OP_CALLOUT</name><operator>)</operator></expr>?</condition><then>
  <expr><call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>OP_CALLOUT</name></expr>]</index></expr> </then><else>: <expr><call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>callout</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* No callout function provided */</comment>

<comment type="block">/* The original matching code (pre 10.30) worked directly with the ovector
passed by the user, and this was passed to callouts. Now that the working
ovector is in the backtracking frame, it no longer needs to reserve space for
the overall match offsets (which would waste space in the frame). For backward
compatibility, however, we pass capture_top and offset_vector to the callout as
if for the extended ovector, and we ensure that the first two slots are unset
by preserving and restoring their current contents. Picky compilers complain if
references such as Fovector[-2] are use directly, so we set up a separate
pointer. */</comment>

<expr_stmt><expr><name>callout_ovector</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>Fovector</name><operator>)</operator> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<comment type="block">/* The cb-&gt;version, cb-&gt;subject, cb-&gt;subject_length, and cb-&gt;start_match fields
are set externally. The first 3 never change; the last is updated for each
bumpalong. */</comment>

<expr_stmt><expr><name>cb</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>cb</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>capture_top</name></name>      <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>Foffset_top</name><operator>/</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>capture_last</name></name>     <operator>=</operator> <name>Fcapture_last</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>offset_vector</name></name>    <operator>=</operator> <name>callout_ovector</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>mark</name></name>             <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>nomatch_mark</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>current_position</name></name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>Feptr</name> <operator>-</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>pattern_position</name></name> <operator>=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>next_item_length</name></name> <operator>=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>Fecode</name> <operator>==</operator> <name>OP_CALLOUT</name></expr>)</condition>  <comment type="block">/* Numerical callout */</comment>
  <block>{<block_content>
  <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_number</name></name> <operator>=</operator> <name><name>Fecode</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else  <comment type="block">/* String callout */</comment>
  <block>{<block_content>
  <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_number</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string_offset</name></name> <operator>=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">3</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string</name></name> <operator>=</operator> <name>Fecode</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>LINK_SIZE</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string_length</name></name> <operator>=</operator>
    <operator>*</operator><name>lengthptr</name> <operator>-</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>LINK_SIZE</name><operator>)</operator> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>save0</name> <operator>=</operator> <name><name>callout_ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>save1</name> <operator>=</operator> <name><name>callout_ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>callout_ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>callout_ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>PCRE2_UNSET</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>mb</name><operator>-&gt;</operator><name>callout</name></name><argument_list>(<argument><expr><name>cb</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>callout_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>callout_ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>save0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>callout_ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>save1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*          Match a back-reference                *
*************************************************/</comment>

<comment type="block">/* This function is called only when it is known that the offset lies within
the offsets that have so far been used in the match. Note that in caseless
UTF-8 mode, the number of subject bytes matched may be different to the number
of reference bytes. (In theory this could also happen in UTF-16 mode, but it
seems unlikely.)

Arguments:
  offset      index into the offset vector
  caseless    TRUE if caseless
  F           the current backtracking frame pointer
  mb          points to match block
  lengthptr   pointer for returning the length matched

Returns:      = 0 sucessful match; number of code units matched is set
              &lt; 0 no match
              &gt; 0 partial match
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>match_ref</name><parameter_list>(<parameter><decl><type><name>PCRE2_SIZE</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>caseless</name></decl></parameter>, <parameter><decl><type><name>heapframe</name> <modifier>*</modifier></type><name>F</name></decl></parameter>, <parameter><decl><type><name>match_block</name> <modifier>*</modifier></type><name>mb</name></decl></parameter>,
  <parameter><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>lengthptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>eptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>eptr_start</name></decl>;</decl_stmt>

<comment type="block">/* Deal with an unset group. The default is no match, but there is an option to
match an empty string. */</comment>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <name>Foffset_top</name> <operator>||</operator> <name><name>Fovector</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>==</operator> <name>PCRE2_UNSET</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name> <operator>&amp;</operator> <name>PCRE2_MATCH_UNSET_BACKREF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>lengthptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>      <comment type="block">/* Match */</comment>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>  <comment type="block">/* No match */</comment>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Separate the caseless and UTF cases for speed. */</comment>

<expr_stmt><expr><name>eptr</name> <operator>=</operator> <name>eptr_start</name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name> <operator>+</operator> <name><name>Fovector</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>length</name> <operator>=</operator> <name><name>Fovector</name><index>[<expr><name>offset</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>Fovector</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>caseless</name></expr>)</condition>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name></expr></cpp:if>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>endptr</name> <init>= <expr><name>p</name> <operator>+</operator> <name>length</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Match characters up to the end of the reference. NOTE: the number of
    code units matched may differ, because in UTF-8 there are some characters
    whose upper and lower case codes have different numbers of bytes. For
    example, U+023A (2 bytes in UTF-8) is the upper case version of U+2C65 (3
    bytes in UTF-8); a sequence of 3 of the former uses 6 bytes, as does a
    sequence of two of the latter. It is important, therefore, to check the
    length along the reference, not along the subject (earlier code did this
    wrong). UCP without uses Unicode properties but without UTF encoding. */</comment>

    <while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>endptr</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>ucd_record</name> <modifier>*</modifier></type><name>ur</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>eptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* Partial match */</comment>

      <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>GETCHARINC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GETCHARINC</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>eptr</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><name>ur</name> <operator>=</operator> <call><name>GET_UCD</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>d</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name>d</name> <operator>+</operator> <name><name>ur</name><operator>-&gt;</operator><name>other_case</name></name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>pp</name> <init>= <expr><call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_caseless_sets</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>ur</name><operator>-&gt;</operator><name>caseset</name></name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <operator>*</operator><name>pp</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* No match */</comment>
          <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <operator>*</operator><name>pp</name><operator>++</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if>
  <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Not in UTF or UCP mode */</comment>
    <block>{<block_content>
    <for>for <control>(<init>;</init> <condition><expr><name>length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>length</name><operator>--</operator></expr></incr>)</control>
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>cc</name></decl>, <decl><type ref="prev"/><name>cp</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>eptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* Partial match */</comment>
      <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>TABLE_GET</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>lcc</name></name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>lcc</name></name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* No match */</comment>
      <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>eptr</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>

<comment type="block">/* In the caseful case, we can just compare the code units, whether or not we
are in UTF and/or UCP mode. When partial matching, we have to do this unit by
unit. */</comment>

<else>else
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <for>for <control>(<init>;</init> <condition><expr><name>length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>length</name><operator>--</operator></expr></incr>)</control>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>eptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* Partial match */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>UCHAR21INCTEST</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>UCHAR21INCTEST</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* No match */</comment>
      </block_content>}</block></for>
    </block_content>}</block></if>

  <comment type="block">/* Not partial matching */</comment>

  <else>else
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>-</operator> <name>eptr</name><operator>)</operator> <operator>&lt;</operator> <name>length</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* Partial */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>eptr</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* No match */</comment>
    <expr_stmt><expr><name>eptr</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>lengthptr</name> <operator>=</operator> <name>eptr</name> <operator>-</operator> <name>eptr_start</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* Match */</comment>
</block_content>}</block></function>



<comment type="block" format="doxygen">/******************************************************************************
*******************************************************************************
                   "Recursion" in the match() function

The original match() function was highly recursive, but this proved to be the
source of a number of problems over the years, mostly because of the relatively
small system stacks that are commonly found. As new features were added to
patterns, various kludges were invented to reduce the amount of stack used,
making the code hard to understand in places.

A version did exist that used individual frames on the heap instead of calling
match() recursively, but this ran substantially slower. The current version is
a refactoring that uses a vector of frames to remember backtracking points.
This runs no slower, and possibly even a bit faster than the original recursive
implementation. An initial vector of size START_FRAMES_SIZE (enough for maybe
50 frames) is allocated on the system stack. If this is not big enough, the
heap is used for a larger vector.

*******************************************************************************
******************************************************************************/</comment>




<comment type="block" format="doxygen">/*************************************************
*       Macros for the match() function          *
*************************************************/</comment>

<comment type="block">/* These macros pack up tests that are used for partial matching several times
in the code. The second one is used when we already know we are past the end of
the subject. We set the "hit end" flag if the pointer is at the end of the
subject and either (a) the pointer is past the earliest inspected character
(i.e. something has been matched, even if not part of the actual matched
string), or (b) the pattern contains a lookbehind. These are the conditions for
which adding more characters may allow the current match to continue.

For hard partial matching, we immediately return a partial match. Otherwise,
carrying on means that a complete match on the current subject will be sought.
A partial match is returned only if no complete match can be found. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_PARTIAL</name><parameter_list>()</parameter_list></cpp:macro>\
  <cpp:value>if (Feptr &gt;= mb-&gt;end_subject) \
    { \
    SCHECK_PARTIAL(); \
    }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCHECK_PARTIAL</name><parameter_list>()</parameter_list></cpp:macro>\
  <cpp:value>if (mb-&gt;partial != 0 &amp;&amp; \
      (Feptr &gt; mb-&gt;start_used_ptr || mb-&gt;allowemptypartial)) \
    { \
    mb-&gt;hitend = TRUE; \
    if (mb-&gt;partial &gt; 1) return PCRE2_ERROR_PARTIAL; \
    }</cpp:value></cpp:define>


<comment type="block">/* These macros are used to implement backtracking. They simulate a recursive
call to the match() function by means of a local vector of frames which
remember the backtracking points. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RMATCH</name><parameter_list>(<parameter><type><name>ra</name></type></parameter>,<parameter><type><name>rb</name></type></parameter>)</parameter_list></cpp:macro>\
  <cpp:value>{\
  start_ecode = ra;\
  Freturn_id = rb;\
  goto MATCH_RECURSE;\
  L_##rb:;\
  }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RRETURN</name><parameter_list>(<parameter><type><name>ra</name></type></parameter>)</parameter_list></cpp:macro>\
  <cpp:value>{\
  rrc = ra;\
  goto RETURN_SWITCH;\
  }</cpp:value></cpp:define>



<comment type="block" format="doxygen">/*************************************************
*         Match from current position            *
*************************************************/</comment>

<comment type="block">/* This function is called to run one match attempt at a single starting point
in the subject.

Performance note: It might be tempting to extract commonly used fields from the
mb structure (e.g. end_subject) into individual variables to improve
performance. Tests using gcc on a SPARC disproved this; in the first case, it
made performance worse.

Arguments:
   start_eptr   starting character in subject
   start_ecode  starting position in compiled code
   ovector      pointer to the final output vector
   oveccount    number of pairs in ovector
   top_bracket  number of capturing parentheses in the pattern
   frame_size   size of each backtracking frame
   mb           pointer to "static" variables block

Returns:        MATCH_MATCH if matched            )  these values are &gt;= 0
                MATCH_NOMATCH if failed to match  )
                negative MATCH_xxx value for PRUNE, SKIP, etc
                negative PCRE2_ERROR_xxx value if aborted by an error condition
                (e.g. stopped by repeated call or depth limit)
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>match</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>start_eptr</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>start_ecode</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>ovector</name></decl></parameter>,
  <parameter><decl><type><name>uint16_t</name></type> <name>oveccount</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>top_bracket</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>frame_size</name></decl></parameter>,
  <parameter><decl><type><name>match_block</name> <modifier>*</modifier></type><name>mb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* Frame-handling variables */</comment>

<decl_stmt><decl><type><name>heapframe</name> <modifier>*</modifier></type><name>F</name></decl>;</decl_stmt>           <comment type="block">/* Current frame pointer */</comment>
<decl_stmt><decl><type><name>heapframe</name> <modifier>*</modifier></type><name>N</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* Temporary frame pointers */</comment>
<decl_stmt><decl><type><name>heapframe</name> <modifier>*</modifier></type><name>P</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>heapframe</name> <modifier>*</modifier></type><name>assert_accept_frame</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* For passing back a frame with captures */</comment>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>frame_copy_size</name></decl>;</decl_stmt>     <comment type="block">/* Amount to copy when creating a new frame */</comment>

<comment type="block">/* Local variables that do not need to be preserved over calls to RRMATCH(). */</comment>

<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>bracode</name></decl>;</decl_stmt>     <comment type="block">/* Temp pointer to start of group */</comment>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>offset</name></decl>;</decl_stmt>      <comment type="block">/* Used for group offsets */</comment>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>length</name></decl>;</decl_stmt>      <comment type="block">/* Used for various length calculations */</comment>

<decl_stmt><decl><type><name>int</name></type> <name>rrc</name></decl>;</decl_stmt>                <comment type="block">/* Return from functions &amp; backtracking "recursions" */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>proptype</name></decl>;</decl_stmt>           <comment type="block">/* Type of character property */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>             <comment type="block">/* Used for local loops */</comment>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>fc</name></decl>;</decl_stmt>            <comment type="block">/* Character values */</comment>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>number</name></decl>;</decl_stmt>        <comment type="block">/* Used for group and other numbers */</comment>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>reptype</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* Type of repetition (0 to avoid compiler warning) */</comment>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>group_frame_type</name></decl>;</decl_stmt>  <comment type="block">/* Specifies type for new group frames */</comment>

<decl_stmt><decl><type><name>BOOL</name></type> <name>condition</name></decl>;</decl_stmt>         <comment type="block">/* Used in conditional groups */</comment>
<decl_stmt><decl><type><name>BOOL</name></type> <name>cur_is_word</name></decl>;</decl_stmt>       <comment type="block">/* Used in "word" tests */</comment>
<decl_stmt><decl><type><name>BOOL</name></type> <name>prev_is_word</name></decl>;</decl_stmt>      <comment type="block">/* Used in "word" tests */</comment>

<comment type="block">/* UTF and UCP flags */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>ucp</name> <init>= <expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* Required for convenience even when no Unicode support */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* This is the length of the last part of a backtracking frame that must be
copied when a new frame is created. */</comment>

<expr_stmt><expr><name>frame_copy_size</name> <operator>=</operator> <name>frame_size</name> <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>heapframe</name></expr></argument>, <argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Set up the first current frame at the start of the vector, and initialize
fields that are not reset for new frames. */</comment>

<expr_stmt><expr><name>F</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>Frdepth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                        <comment type="block">/* "Recursion" depth */</comment>
<expr_stmt><expr><name>Fcapture_last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                  <comment type="block">/* Number of most recent capture */</comment>
<expr_stmt><expr><name>Fcurrent_recurse</name> <operator>=</operator> <name>RECURSE_UNSET</name></expr>;</expr_stmt>   <comment type="block">/* Not pattern recursing. */</comment>
<expr_stmt><expr><name>Fstart_match</name> <operator>=</operator> <name>Feptr</name> <operator>=</operator> <name>start_eptr</name></expr>;</expr_stmt>  <comment type="block">/* Current data pointer and start match */</comment>
<expr_stmt><expr><name>Fmark</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>                       <comment type="block">/* Most recent mark */</comment>
<expr_stmt><expr><name>Foffset_top</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                    <comment type="block">/* End of captures within the frame */</comment>
<expr_stmt><expr><name>Flast_group_offset</name> <operator>=</operator> <name>PCRE2_UNSET</name></expr>;</expr_stmt>   <comment type="block">/* Saved frame of most recent group */</comment>
<expr_stmt><expr><name>group_frame_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>               <comment type="block">/* Not a start of group frame */</comment>
<goto>goto <name>NEW_FRAME</name>;</goto>                     <comment type="block">/* Start processing with this frame */</comment>

<comment type="block">/* Come back here when we want to create a new frame for remembering a
backtracking point. */</comment>

<label><name>MATCH_RECURSE</name>:</label>

<comment type="block">/* Set up a new backtracking frame. If the vector is full, get a new one
on the heap, doubling the size, but constrained by the heap limit. */</comment>

<expr_stmt><expr><name>N</name> <operator>=</operator> <operator>(</operator><name>heapframe</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>F</name> <operator>+</operator> <name>frame_size</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>match_frames_top</name></name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>newsize</name> <init>= <expr><name><name>mb</name><operator>-&gt;</operator><name>frame_vector_size</name></name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>heapframe</name> <modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>newsize</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator> <operator>&gt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>heap_limit</name></name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>maxsize</name> <init>= <expr><operator>(</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>heap_limit</name></name> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator><operator>/</operator><name>frame_size</name><operator>)</operator> <operator>*</operator> <name>frame_size</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>frame_vector_size</name></name> <operator>&gt;=</operator> <name>maxsize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_HEAPLIMIT</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>newsize</name> <operator>=</operator> <name>maxsize</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>new</name> <operator>=</operator> <call><name><name>mb</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>malloc</name></name><argument_list>(<argument><expr><name>newsize</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>new</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>frame_vector_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>F</name> <operator>=</operator> <operator>(</operator><name>heapframe</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>new</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>F</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>N</name> <operator>=</operator> <operator>(</operator><name>heapframe</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>F</name> <operator>+</operator> <name>frame_size</name><operator>)</operator></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name> <operator>!=</operator> <name><name>mb</name><operator>-&gt;</operator><name>stack_frames</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name><name>mb</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>free</name></name><argument_list>(<argument><expr><name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>match_frames_top</name></name> <operator>=</operator> <operator>(</operator><name>heapframe</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name> <operator>+</operator> <name>newsize</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>frame_vector_size</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SHOW_RMATCH</name></cpp:ifdef>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"++ RMATCH %2d frame=%d"</literal></expr></argument>, <argument><expr><name>Freturn_id</name></expr></argument>, <argument><expr><name>Frdepth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>group_frame_type</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" type=%x "</literal></expr></argument>, <argument><expr><name>group_frame_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><call><name>GF_IDMASK</name><argument_list>(<argument><expr><name>group_frame_type</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>GF_CAPTURE</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"capture=%d"</literal></expr></argument>, <argument><expr><call><name>GF_DATAMASK</name><argument_list>(<argument><expr><name>group_frame_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>GF_NOCAPTURE</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"nocapture op=%d"</literal></expr></argument>, <argument><expr><call><name>GF_DATAMASK</name><argument_list>(<argument><expr><name>group_frame_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>GF_CONDASSERT</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"condassert op=%d"</literal></expr></argument>, <argument><expr><call><name>GF_DATAMASK</name><argument_list>(<argument><expr><name>group_frame_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>GF_RECURSE</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"recurse=%d"</literal></expr></argument>, <argument><expr><call><name>GF_DATAMASK</name><argument_list>(<argument><expr><name>group_frame_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <default>default:</default>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"*** unknown ***"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Copy those fields that must be copied into the new frame, increase the
"recursion" depth (i.e. the new frame's index) and then make the new frame
current. */</comment>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>N</name> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>heapframe</name></expr></argument>, <argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>F</name> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>heapframe</name></expr></argument>, <argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><name>frame_copy_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>N</name><operator>-&gt;</operator><name>rdepth</name></name> <operator>=</operator> <name>Frdepth</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>F</name> <operator>=</operator> <name>N</name></expr>;</expr_stmt>

<comment type="block">/* Carry on processing with a new frame. */</comment>

<label><name>NEW_FRAME</name>:</label>
<expr_stmt><expr><name>Fgroup_frame_type</name> <operator>=</operator> <name>group_frame_type</name></expr>;</expr_stmt>
<expr_stmt><expr><name>Fecode</name> <operator>=</operator> <name>start_ecode</name></expr>;</expr_stmt>      <comment type="block">/* Starting code pointer */</comment>
<expr_stmt><expr><name>Fback_frame</name> <operator>=</operator> <name>frame_size</name></expr>;</expr_stmt>  <comment type="block">/* Default is go back one frame */</comment>

<comment type="block">/* If this is a special type of group frame, remember its offset for quick
access at the end of the group. If this is a recursion, set a new current
recursion value. */</comment>

<if_stmt><if>if <condition>(<expr><name>group_frame_type</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>Flast_group_offset</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>F</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>GF_IDMASK</name><argument_list>(<argument><expr><name>group_frame_type</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GF_RECURSE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>Fcurrent_recurse</name> <operator>=</operator> <call><name>GF_DATAMASK</name><argument_list>(<argument><expr><name>group_frame_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>group_frame_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>


<comment type="block">/* ========================================================================= */</comment>
<comment type="block">/* This is the main processing loop. First check that we haven't recorded too
many backtracks (search tree is too large), or that we haven't exceeded the
recursive depth limit (used too many backtracking frames). If not, process the
opcodes. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>match_call_count</name></name><operator>++</operator> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>match_limit</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_MATCHLIMIT</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>Frdepth</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>match_limit_depth</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_DEPTHLIMIT</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SHOW_OPS</name></cpp:ifdef>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"++ op=%d\n"</literal></expr></argument>, <argument><expr><operator>*</operator><name>Fecode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>Fop</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>*</operator><name>Fecode</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Cast needed for 16-bit and 32-bit modes */</comment>
  <switch>switch<condition>(<expr><name>Fop</name></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Before OP_ACCEPT there may be any number of OP_CLOSE opcodes, to close
    any currently open capturing brackets. Unlike reaching the end of a group,
    where we know the starting frame is at the top of the chained frames, in
    this case we have to search back for the relevant frame in case other types
    of group that use chained frames have intervened. Multiple OP_CLOSEs always
    come innermost first, which matches the chain order. We can ignore this in
    a recursion, because captures are not passed out of recursions. */</comment>

    <case>case <expr><name>OP_CLOSE</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Fcurrent_recurse</name> <operator>==</operator> <name>RECURSE_UNSET</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>number</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>Flast_group_offset</name></expr>;</expr_stmt>
      <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <name>PCRE2_UNSET</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_INTERNAL</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>N</name> <operator>=</operator> <operator>(</operator><name>heapframe</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>P</name> <operator>=</operator> <operator>(</operator><name>heapframe</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>N</name> <operator>-</operator> <name>frame_size</name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>N</name><operator>-&gt;</operator><name>group_frame_type</name></name> <operator>==</operator> <operator>(</operator><name>GF_CAPTURE</name> <operator>|</operator> <name>number</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>P</name><operator>-&gt;</operator><name>last_group_offset</name></name></expr>;</expr_stmt>
        </block_content>}</block></for>
      <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>number</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>Fcapture_last</name> <operator>=</operator> <name>number</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>Fovector</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>=</operator> <name><name>P</name><operator>-&gt;</operator><name>eptr</name></name> <operator>-</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>Fovector</name><index>[<expr><name>offset</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>Feptr</name> <operator>-</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <name>Foffset_top</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Foffset_top</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>Fecode</name></expr>]</index></expr>;</expr_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Real or forced end of the pattern, assertion, or recursion. In an
    assertion ACCEPT, update the last used pointer and remember the current
    frame so that the captures and mark can be fished out of it. */</comment>

    <case>case <expr><name>OP_ASSERT_ACCEPT</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>assert_accept_frame</name> <operator>=</operator> <name>F</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_ACCEPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If recursing, we have to find the most recent recursion. */</comment>

    <case>case <expr><name>OP_ACCEPT</name></expr>:</case>
    <case>case <expr><name>OP_END</name></expr>:</case>

    <comment type="block">/* Handle end of a recursion. */</comment>

    <if_stmt><if>if <condition>(<expr><name>Fcurrent_recurse</name> <operator>!=</operator> <name>RECURSE_UNSET</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>Flast_group_offset</name></expr>;</expr_stmt>
      <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <name>PCRE2_UNSET</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_INTERNAL</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>N</name> <operator>=</operator> <operator>(</operator><name>heapframe</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>P</name> <operator>=</operator> <operator>(</operator><name>heapframe</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>N</name> <operator>-</operator> <name>frame_size</name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>GF_IDMASK</name><argument_list>(<argument><expr><name><name>N</name><operator>-&gt;</operator><name>group_frame_type</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GF_RECURSE</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>P</name><operator>-&gt;</operator><name>last_group_offset</name></name></expr>;</expr_stmt>
        </block_content>}</block></for>

      <comment type="block">/* N is now the frame of the recursion; the previous frame is at the
      OP_RECURSE position. Go back there, copying the current subject position
      and mark, and move on past the OP_RECURSE. */</comment>

      <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>eptr</name></name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>mark</name></name> <operator>=</operator> <name>Fmark</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>F</name> <operator>=</operator> <name>P</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
      <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Not a recursion. Fail for an empty string match if either PCRE2_NOTEMPTY
    is set, or if PCRE2_NOTEMPTY_ATSTART is set and we have matched at the
    start of the subject. In both cases, backtracking will then try other
    alternatives, if any. */</comment>

    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>==</operator> <name>Fstart_match</name> <operator>&amp;&amp;</operator>
         <operator>(</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_NOTEMPTY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
           <operator>(</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_NOTEMPTY_ATSTART</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
             <name>Fstart_match</name> <operator>==</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name> <operator>+</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_offset</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Also fail if PCRE2_ENDANCHORED is set and the end of the match is not
    the end of the subject. After (*ACCEPT) we fail the entire match (at this
    position) but backtrack on reaching the end of the pattern. */</comment>

    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator>
        <operator>(</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>|</operator> <name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name><operator>)</operator> <operator>&amp;</operator> <name>PCRE2_ENDANCHORED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>Fop</name> <operator>==</operator> <name>OP_END</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <return>return <expr><name>MATCH_NOMATCH</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* We have a successful match of the whole pattern. Record the result and
    then do a direct return from the function. If there is space in the offset
    vector, set any pairs that follow the highest-numbered captured string but
    are less than the number of capturing groups in the pattern to PCRE2_UNSET.
    It is documented that this happens. "Gaps" are set to PCRE2_UNSET
    dynamically. It is only those at the end that need setting here. */</comment>

    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>end_match_ptr</name></name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt>           <comment type="block">/* Record where we ended */</comment>
    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>end_offset_top</name></name> <operator>=</operator> <name>Foffset_top</name></expr>;</expr_stmt>    <comment type="block">/* and how many extracts were taken */</comment>
    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>mark</name></name> <operator>=</operator> <name>Fmark</name></expr>;</expr_stmt>                    <comment type="block">/* and the last success mark */</comment>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>Fstart_match</name> <operator>-</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>Feptr</name> <operator>-</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name></expr>;</expr_stmt>

    <comment type="block">/* Set i to the smaller of the sizes of the external and frame ovectors. */</comment>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>top_bracket</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>oveccount</name><operator>)</operator></expr>?</condition><then> <expr><name>oveccount</name></expr> </then><else>: <expr><name>top_bracket</name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ovector</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>Fovector</name></expr></argument>, <argument><expr><operator>(</operator><name>i</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_SIZE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <name>Foffset_top</name> <operator>+</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ovector</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>PCRE2_UNSET</name></expr>;</expr_stmt></block_content></block></while>
    <return>return <expr><name>MATCH_MATCH</name></expr>;</return>  <comment type="block">/* Note: NOT RRETURN */</comment>


    <comment type="block">/*===================================================================== */</comment>
    <comment type="block">/* Match any single character type except newline; have to take care with
    CRLF newlines and partial matching. */</comment>

    <case>case <expr><name>OP_ANY</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <name>Feptr</name> <operator>==</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
        <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator>
        <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nllen</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
        <call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>hitend</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_PARTIAL</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    <comment type="block">/* Fall through */</comment>

    <comment type="block">/* Match any single character whatsoever. */</comment>

    <case>case <expr><name>OP_ALLANY</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>  <comment type="block">/* DO NOT merge the Feptr++ here; it must */</comment>
      <block>{<block_content>                            <comment type="block">/* not be updated before SCHECK_PARTIAL. */</comment>
      <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ACROSSCHAR</name><argument_list>(<argument><expr><name>Feptr</name> <operator>&lt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>Feptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Match a single code unit, even in UTF mode. This opcode really does
    match any code unit, even newline. (It really should be called ANYCODEUNIT,
    of course - the byte name is from pre-16 bit days.) */</comment>

    <case>case <expr><name>OP_ANYBYTE</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>   <comment type="block">/* DO NOT merge the Feptr++ here; it must */</comment>
      <block>{<block_content>                             <comment type="block">/* not be updated before SCHECK_PARTIAL. */</comment>
      <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Match a single character, casefully */</comment>

    <case>case <expr><name>OP_CHAR</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>Flength</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETCHARLEN</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>Flength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>Flength</name> <operator>&gt;</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>-</operator> <name>Feptr</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>CHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>             <comment type="block">/* Not SCHECK_PARTIAL() */</comment>
        <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <for>for <control>(<init>;</init> <condition><expr><name>Flength</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>Flength</name><operator>--</operator></expr></incr>)</control>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>Fecode</name><operator>++</operator> <operator>!=</operator> <call><name>UCHAR21INC</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if>
    <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Not UTF mode */</comment>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>-</operator> <name>Feptr</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* This one can use SCHECK_PARTIAL() */</comment>
        <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>Fecode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <operator>*</operator><name>Feptr</name><operator>++</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Match a single character, caselessly. If we are at the end of the
    subject, give up immediately. We get here only when the pattern character
    has at most one other case. Characters with more than two cases are coded
    as OP_PROP with the pseudo-property PT_CLIST. */</comment>

    <case>case <expr><name>OP_CHARI</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>Flength</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETCHARLEN</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>Flength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If the pattern character's value is &lt; 128, we know that its other case
      (if any) is also &lt; 128 (and therefore only one code unit long in all
      code-unit widths), so we can use the fast lookup table. We checked above
      that there is at least one character left in the subject. */</comment>

      <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>cc</name> <init>= <expr><call><name>UCHAR21</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>lcc</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>!=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>lcc</name></name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>

      <comment type="block">/* Otherwise we must pick up the subject character and use Unicode
      property support to test its other case. Note that we cannot use the
      value of "Flength" to check for sufficient bytes left, because the other
      case of the character may have more or fewer code units. */</comment>

      <else>else
        <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>dc</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>GETCHARINC</name><argument_list>(<argument><expr><name>dc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <name>Flength</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>dc</name> <operator>!=</operator> <name>fc</name> <operator>&amp;&amp;</operator> <name>dc</name> <operator>!=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if>

    <comment type="block">/* If UCP is set without UTF we must do the same as above, but with one
    character per code unit. */</comment>

    <if type="elseif">else if <condition>(<expr><name>ucp</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>cc</name> <init>= <expr><call><name>UCHAR21</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>fc</name> <operator>=</operator> <name><name>Fecode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>lcc</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>!=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>lcc</name></name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>!=</operator> <name>fc</name> <operator>&amp;&amp;</operator> <name>cc</name> <operator>!=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      </block_content>}</block></if>

    <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* SUPPORT_UNICODE */</comment>

    <comment type="block">/* Not UTF or UCP mode; use the table for characters &lt; 256. */</comment>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>TABLE_GET</name><argument_list>(<argument><expr><name><name>Fecode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>lcc</name></name></expr></argument>, <argument><expr><name><name>Fecode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call>
          <operator>!=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><operator>*</operator><name>Feptr</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>lcc</name></name></expr></argument>, <argument><expr><operator>*</operator><name>Feptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Match not a single character. */</comment>

    <case>case <expr><name>OP_NOT</name></expr>:</case>
    <case>case <expr><name>OP_NOTI</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>ch</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETCHARINC</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>Fecode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETCHARINC</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>fc</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Caseful match */</comment>
        </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>Fop</name> <operator>==</operator> <name>OP_NOTI</name></expr>)</condition>   <comment type="block">/* If caseless */</comment>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>fcc</name></name><operator>)</operator><index>[<expr><name>ch</name></expr>]</index></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>fc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if>

    <comment type="block">/* UCP without UTF is as above, but with one character per code unit. */</comment>

    <if type="elseif">else if <condition>(<expr><name>ucp</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>ch</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>fc</name> <operator>=</operator> <call><name>UCHAR21INC</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ch</name> <operator>=</operator> <name><name>Fecode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>fc</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Caseful match */</comment>
        </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>Fop</name> <operator>==</operator> <name>OP_NOTI</name></expr>)</condition>   <comment type="block">/* If caseless */</comment>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>fcc</name></name><operator>)</operator><index>[<expr><name>ch</name></expr>]</index></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>fc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if>

    <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

    <comment type="block">/* Neither UTF nor UCP is set */</comment>

      <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>ch</name> <init>= <expr><name><name>Fecode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>fc</name> <operator>=</operator> <call><name>UCHAR21INC</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>fc</name> <operator>||</operator> <operator>(</operator><name>Fop</name> <operator>==</operator> <name>OP_NOTI</name> <operator>&amp;&amp;</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>fcc</name></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>fc</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Match a single character repeatedly. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Loclength</name></cpp:macro>    <cpp:value>F-&gt;temp_size</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lstart_eptr</name></cpp:macro>  <cpp:value>F-&gt;temp_sptr[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lcharptr</name></cpp:macro>     <cpp:value>F-&gt;temp_sptr[1]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lmin</name></cpp:macro>         <cpp:value>F-&gt;temp_32[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lmax</name></cpp:macro>         <cpp:value>F-&gt;temp_32[1]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lc</name></cpp:macro>           <cpp:value>F-&gt;temp_32[2]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Loc</name></cpp:macro>          <cpp:value>F-&gt;temp_32[3]</cpp:value></cpp:define>

    <case>case <expr><name>OP_EXACT</name></expr>:</case>
    <case>case <expr><name>OP_EXACTI</name></expr>:</case>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <name>Lmax</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <goto>goto <name>REPEATCHAR</name>;</goto>

    <case>case <expr><name>OP_POSUPTO</name></expr>:</case>
    <case>case <expr><name>OP_POSUPTOI</name></expr>:</case>
    <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name>REPTYPE_POS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <goto>goto <name>REPEATCHAR</name>;</goto>

    <case>case <expr><name>OP_UPTO</name></expr>:</case>
    <case>case <expr><name>OP_UPTOI</name></expr>:</case>
    <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name>REPTYPE_MAX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <goto>goto <name>REPEATCHAR</name>;</goto>

    <case>case <expr><name>OP_MINUPTO</name></expr>:</case>
    <case>case <expr><name>OP_MINUPTOI</name></expr>:</case>
    <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name>REPTYPE_MIN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <goto>goto <name>REPEATCHAR</name>;</goto>

    <case>case <expr><name>OP_POSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_POSSTARI</name></expr>:</case>
    <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name>REPTYPE_POS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <name>UINT32_MAX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <goto>goto <name>REPEATCHAR</name>;</goto>

    <case>case <expr><name>OP_POSPLUS</name></expr>:</case>
    <case>case <expr><name>OP_POSPLUSI</name></expr>:</case>
    <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name>REPTYPE_POS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <name>UINT32_MAX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <goto>goto <name>REPEATCHAR</name>;</goto>

    <case>case <expr><name>OP_POSQUERY</name></expr>:</case>
    <case>case <expr><name>OP_POSQUERYI</name></expr>:</case>
    <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name>REPTYPE_POS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <goto>goto <name>REPEATCHAR</name>;</goto>

    <case>case <expr><name>OP_STAR</name></expr>:</case>
    <case>case <expr><name>OP_STARI</name></expr>:</case>
    <case>case <expr><name>OP_MINSTAR</name></expr>:</case>
    <case>case <expr><name>OP_MINSTARI</name></expr>:</case>
    <case>case <expr><name>OP_PLUS</name></expr>:</case>
    <case>case <expr><name>OP_PLUSI</name></expr>:</case>
    <case>case <expr><name>OP_MINPLUS</name></expr>:</case>
    <case>case <expr><name>OP_MINPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_QUERY</name></expr>:</case>
    <case>case <expr><name>OP_QUERYI</name></expr>:</case>
    <case>case <expr><name>OP_MINQUERY</name></expr>:</case>
    <case>case <expr><name>OP_MINQUERYI</name></expr>:</case>
    <expr_stmt><expr><name>fc</name> <operator>=</operator> <operator>*</operator><name>Fecode</name><operator>++</operator> <operator>-</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>Fop</name> <operator>&lt;</operator> <name>OP_STARI</name><operator>)</operator></expr>?</condition><then> <expr><name>OP_STAR</name></expr> </then><else>: <expr><name>OP_STARI</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <name><name>rep_min</name><index>[<expr><name>fc</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <name><name>rep_max</name><index>[<expr><name>fc</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name><name>rep_typ</name><index>[<expr><name>fc</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* Common code for all repeated single-character matches. We first check
    for the minimum number of characters. If the minimum equals the maximum, we
    are done. Otherwise, if minimizing, check the rest of the pattern for a
    match; if there isn't one, advance up to the maximum, one character at a
    time.

    If maximizing, advance up to the maximum number of matching characters,
    until Feptr is past the end of the maximum run. If possessive, we are
    then done (no backing up). Otherwise, match at this position; anything
    other than no match is immediately returned. For nomatch, back up one
    character, unless we are matching \R and the last thing matched was
    \r\n, in which case, back up two code units until we reach the first
    optional character position.

    The various UTF/non-UTF and caseful/caseless cases are handled separately,
    for speed. */</comment>

    <label><name>REPEATCHAR</name>:</label>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>Flength</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>Lcharptr</name> <operator>=</operator> <name>Fecode</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETCHARLEN</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>Flength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <name>Flength</name></expr>;</expr_stmt>

      <comment type="block">/* Handle multi-code-unit character matching, caseful and caseless. */</comment>

      <if_stmt><if>if <condition>(<expr><name>Flength</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>othercase</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>Fop</name> <operator>&gt;=</operator> <name>OP_STARI</name> <operator>&amp;&amp;</operator>     <comment type="block">/* Caseless */</comment>
            <operator>(</operator><name>othercase</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>fc</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>Loclength</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>ord2utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>othercase</name></expr></argument>, <argument><expr><name>Foccu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>Loclength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>-</operator> <name>Flength</name> <operator>&amp;&amp;</operator>
            <call><name>memcmp</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>Lcharptr</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>Flength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>Flength</name></expr>;</expr_stmt></block_content></block></if>
          <if type="elseif">else if <condition>(<expr><name>Loclength</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                   <name>Feptr</name> <operator>&lt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>-</operator> <name>Loclength</name> <operator>&amp;&amp;</operator>
                   <call><name>memcmp</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>Foccu</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>Loclength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>Loclength</name></expr>;</expr_stmt></block_content></block></if>
          <else>else
            <block>{<block_content>
            <expr_stmt><expr><call><name>CHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>Lmin</name> <operator>==</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>==</operator> <name>REPTYPE_MIN</name></expr>)</condition>
          <block>{<block_content>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM202</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>-</operator> <name>Flength</name> <operator>&amp;&amp;</operator>
              <call><name>memcmp</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>Lcharptr</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>Flength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>Flength</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>Loclength</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                     <name>Feptr</name> <operator>&lt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>-</operator> <name>Loclength</name> <operator>&amp;&amp;</operator>
                     <call><name>memcmp</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>Foccu</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>Loclength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>Loclength</name></expr>;</expr_stmt></block_content></block></if>
            <else>else
              <block>{<block_content>
              <expr_stmt><expr><call><name>CHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>
          <comment type="block">/* Control never gets here */</comment>
          </block_content>}</block></if>

        <else>else  <comment type="block">/* Maximize */</comment>
          <block>{<block_content>
          <expr_stmt><expr><name>Lstart_eptr</name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>-</operator> <name>Flength</name> <operator>&amp;&amp;</operator>
                <call><name>memcmp</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>Lcharptr</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>Flength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>Flength</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>Loclength</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                     <name>Feptr</name> <operator>&lt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>-</operator> <name>Loclength</name> <operator>&amp;&amp;</operator>
                     <call><name>memcmp</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>Foccu</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>Loclength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>Loclength</name></expr>;</expr_stmt></block_content></block></if>
            <else>else
              <block>{<block_content>
              <expr_stmt><expr><call><name>CHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>

          <comment type="block">/* After \C in UTF mode, Lstart_eptr might be in the middle of a
          Unicode character. Use &lt;= Lstart_eptr to ensure backtracking doesn't
          go too far. */</comment>

          <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>!=</operator> <name>REPTYPE_POS</name></expr>)</condition><block type="pseudo"><block_content> <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;=</operator> <name>Lstart_eptr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM203</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BACKCHAR</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for></block_content></block></if></if_stmt>
          </block_content>}</block></else></if_stmt>
        <break>break;</break>   <comment type="block">/* End of repeated wide character handling */</comment>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Length of UTF character is 1. Put it into the preserved variable and
      fall through to the non-UTF code. */</comment>

      <expr_stmt><expr><name>Lc</name> <operator>=</operator> <name>fc</name></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

    <comment type="block">/* When not in UTF mode, load a single-code-unit character. Then proceed as
    above, using Unicode casing if either UTF or UCP is set. */</comment>

    <expr_stmt><expr><name>Lc</name> <operator>=</operator> <operator>*</operator><name>Fecode</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Caseless comparison */</comment>

    <if_stmt><if>if <condition>(<expr><name>Fop</name> <operator>&gt;=</operator> <name>OP_STARI</name></expr>)</condition>
      <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>ucp</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>utf</name> <operator>&amp;&amp;</operator> <name>Lc</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Loc</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>Lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
      <comment type="block">/* Lc will be &lt; 128 in UTF-8 mode. */</comment>
      <expr_stmt><expr><name>Loc</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>fcc</name><index>[<expr><name>Lc</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* 16-bit &amp; 32-bit */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>utf</name> <operator>||</operator> <name>ucp</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>Lc</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Loc</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>Lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
      <expr_stmt><expr><name>Loc</name> <operator>=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>Lc</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>fcc</name></name></expr></argument>, <argument><expr><name>Lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 8 */</comment>

      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>cc</name></decl>;</decl_stmt>                 <comment type="block">/* Faster than PCRE2_UCHAR */</comment>
        <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>Lc</name> <operator>!=</operator> <name>cc</name> <operator>&amp;&amp;</operator> <name>Loc</name> <operator>!=</operator> <name>cc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></for>
      <if_stmt><if>if <condition>(<expr><name>Lmin</name> <operator>==</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>==</operator> <name>REPTYPE_MIN</name></expr>)</condition>
        <block>{<block_content>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
          <block>{<block_content>
          <decl_stmt><decl><type><name>uint32_t</name></type> <name>cc</name></decl>;</decl_stmt>               <comment type="block">/* Faster than PCRE2_UCHAR */</comment>
          <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM25</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>Lc</name> <operator>!=</operator> <name>cc</name> <operator>&amp;&amp;</operator> <name>Loc</name> <operator>!=</operator> <name>cc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></for>
        <comment type="block">/* Control never gets here */</comment>
        </block_content>}</block></if>

      <else>else  <comment type="block">/* Maximize */</comment>
        <block>{<block_content>
        <expr_stmt><expr><name>Lstart_eptr</name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <decl_stmt><decl><type><name>uint32_t</name></type> <name>cc</name></decl>;</decl_stmt>               <comment type="block">/* Faster than PCRE2_UCHAR */</comment>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>Lc</name> <operator>!=</operator> <name>cc</name> <operator>&amp;&amp;</operator> <name>Loc</name> <operator>!=</operator> <name>cc</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>!=</operator> <name>REPTYPE_POS</name></expr>)</condition><block type="pseudo"><block_content> <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>==</operator> <name>Lstart_eptr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM26</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>--</operator></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></for></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if>

    <comment type="block">/* Caseful comparisons (includes all multi-byte characters) */</comment>

    <else>else
      <block>{<block_content>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>Lc</name> <operator>!=</operator> <call><name>UCHAR21INCTEST</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

      <if_stmt><if>if <condition>(<expr><name>Lmin</name> <operator>==</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>==</operator> <name>REPTYPE_MIN</name></expr>)</condition>
        <block>{<block_content>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
          <block>{<block_content>
          <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM27</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>Lc</name> <operator>!=</operator> <call><name>UCHAR21INCTEST</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></for>
        <comment type="block">/* Control never gets here */</comment>
        </block_content>}</block></if>
      <else>else  <comment type="block">/* Maximize */</comment>
        <block>{<block_content>
        <expr_stmt><expr><name>Lstart_eptr</name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
            </block_content>}</block></if></if_stmt>

          <if_stmt><if>if <condition>(<expr><name>Lc</name> <operator>!=</operator> <call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>!=</operator> <name>REPTYPE_POS</name></expr>)</condition><block type="pseudo"><block_content> <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;=</operator> <name>Lstart_eptr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM28</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>--</operator></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></for></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    <break>break;</break>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Loclength</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lstart_eptr</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lcharptr</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lmin</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lmax</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lc</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Loc</name></cpp:undef>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Match a negated single one-byte character repeatedly. This is almost a
    repeat of the code for a repeated single character, but I haven't found a
    nice way of commoning these up that doesn't require a test of the
    positive/negative option for each character match. Maybe that wouldn't add
    very much to the time taken, but character matching *is* what this is all
    about... */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lstart_eptr</name></cpp:macro>  <cpp:value>F-&gt;temp_sptr[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lmin</name></cpp:macro>         <cpp:value>F-&gt;temp_32[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lmax</name></cpp:macro>         <cpp:value>F-&gt;temp_32[1]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lc</name></cpp:macro>           <cpp:value>F-&gt;temp_32[2]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Loc</name></cpp:macro>          <cpp:value>F-&gt;temp_32[3]</cpp:value></cpp:define>

    <case>case <expr><name>OP_NOTEXACT</name></expr>:</case>
    <case>case <expr><name>OP_NOTEXACTI</name></expr>:</case>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <name>Lmax</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <goto>goto <name>REPEATNOTCHAR</name>;</goto>

    <case>case <expr><name>OP_NOTUPTO</name></expr>:</case>
    <case>case <expr><name>OP_NOTUPTOI</name></expr>:</case>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name>REPTYPE_MAX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <goto>goto <name>REPEATNOTCHAR</name>;</goto>

    <case>case <expr><name>OP_NOTMINUPTO</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINUPTOI</name></expr>:</case>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name>REPTYPE_MIN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <goto>goto <name>REPEATNOTCHAR</name>;</goto>

    <case>case <expr><name>OP_NOTPOSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSSTARI</name></expr>:</case>
    <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name>REPTYPE_POS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <name>UINT32_MAX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <goto>goto <name>REPEATNOTCHAR</name>;</goto>

    <case>case <expr><name>OP_NOTPOSPLUS</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSPLUSI</name></expr>:</case>
    <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name>REPTYPE_POS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <name>UINT32_MAX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <goto>goto <name>REPEATNOTCHAR</name>;</goto>

    <case>case <expr><name>OP_NOTPOSQUERY</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSQUERYI</name></expr>:</case>
    <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name>REPTYPE_POS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <goto>goto <name>REPEATNOTCHAR</name>;</goto>

    <case>case <expr><name>OP_NOTPOSUPTO</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSUPTOI</name></expr>:</case>
    <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name>REPTYPE_POS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <goto>goto <name>REPEATNOTCHAR</name>;</goto>

    <case>case <expr><name>OP_NOTSTAR</name></expr>:</case>
    <case>case <expr><name>OP_NOTSTARI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINSTAR</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINSTARI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPLUS</name></expr>:</case>
    <case>case <expr><name>OP_NOTPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINPLUS</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_NOTQUERY</name></expr>:</case>
    <case>case <expr><name>OP_NOTQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINQUERY</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINQUERYI</name></expr>:</case>
    <expr_stmt><expr><name>fc</name> <operator>=</operator> <operator>*</operator><name>Fecode</name><operator>++</operator> <operator>-</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>Fop</name> <operator>&gt;=</operator> <name>OP_NOTSTARI</name><operator>)</operator></expr>?</condition><then> <expr><name>OP_NOTSTARI</name></expr></then><else>: <expr><name>OP_NOTSTAR</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <name><name>rep_min</name><index>[<expr><name>fc</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <name><name>rep_max</name><index>[<expr><name>fc</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name><name>rep_typ</name><index>[<expr><name>fc</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* Common code for all repeated single-character non-matches. */</comment>

    <label><name>REPEATNOTCHAR</name>:</label>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>Lc</name></expr></argument>, <argument><expr><name>Fecode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The code is duplicated for the caseless and caseful cases, for speed,
    since matching characters is likely to be quite common. First, ensure the
    minimum number of matches are present. If Lmin = Lmax, we are done.
    Otherwise, if minimizing, keep trying the rest of the expression and
    advancing one matching character if failing, up to the maximum.
    Alternatively, if maximizing, find the maximum number of characters and
    work backwards. */</comment>

    <if_stmt><if>if <condition>(<expr><name>Fop</name> <operator>&gt;=</operator> <name>OP_NOTSTARI</name></expr>)</condition>     <comment type="block">/* Caseless */</comment>
      <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>utf</name> <operator>||</operator> <name>ucp</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>Lc</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>Loc</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>Lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_UNICODE */</comment>

      <expr_stmt><expr><name>Loc</name> <operator>=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>Lc</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>fcc</name></name></expr></argument>, <argument><expr><name>Lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* Other case from table */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>d</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>GETCHARINC</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>Lc</name> <operator>==</operator> <name>d</name> <operator>||</operator> <name>Loc</name> <operator>==</operator> <name>d</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if>
      <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

      <comment type="block">/* Not UTF mode */</comment>
        <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>Lc</name> <operator>==</operator> <operator>*</operator><name>Feptr</name> <operator>||</operator> <name>Loc</name> <operator>==</operator> <operator>*</operator><name>Feptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>Lmin</name> <operator>==</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>  <comment type="block">/* Finished for exact count */</comment>

      <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>==</operator> <name>REPTYPE_MIN</name></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>uint32_t</name></type> <name>d</name></decl>;</decl_stmt>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM204</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINC</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lc</name> <operator>==</operator> <name>d</name> <operator>||</operator> <name>Loc</name> <operator>==</operator> <name>d</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
          </block_content>}</block></if>
        <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/*SUPPORT_UNICODE */</comment>

        <comment type="block">/* Not UTF mode */</comment>
          <block>{<block_content>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM29</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lc</name> <operator>==</operator> <operator>*</operator><name>Feptr</name> <operator>||</operator> <name>Loc</name> <operator>==</operator> <operator>*</operator><name>Feptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></for>
          </block_content>}</block></else></if_stmt>
        <comment type="block">/* Control never gets here */</comment>
        </block_content>}</block></if>

      <comment type="block">/* Maximize case */</comment>

      <else>else
        <block>{<block_content>
        <expr_stmt><expr><name>Lstart_eptr</name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>uint32_t</name></type> <name>d</name></decl>;</decl_stmt>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLEN</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lc</name> <operator>==</operator> <name>d</name> <operator>||</operator> <name>Loc</name> <operator>==</operator> <name>d</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>

          <comment type="block">/* After \C in UTF mode, Lstart_eptr might be in the middle of a
          Unicode character. Use &lt;= Lstart_eptr to ensure backtracking doesn't
          go too far. */</comment>

          <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>!=</operator> <name>REPTYPE_POS</name></expr>)</condition><block type="pseudo"><block_content> <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;=</operator> <name>Lstart_eptr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM205</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BACKCHAR</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for></block_content></block></if></if_stmt>
          </block_content>}</block></if>
        <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

        <comment type="block">/* Not UTF mode */</comment>
          <block>{<block_content>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lc</name> <operator>==</operator> <operator>*</operator><name>Feptr</name> <operator>||</operator> <name>Loc</name> <operator>==</operator> <operator>*</operator><name>Feptr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></for>
          <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>!=</operator> <name>REPTYPE_POS</name></expr>)</condition><block type="pseudo"><block_content> <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>==</operator> <name>Lstart_eptr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM30</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></for></block_content></block></if></if_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if>

    <comment type="block">/* Caseful comparisons */</comment>

    <else>else
      <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>d</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>GETCHARINC</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>Lc</name> <operator>==</operator> <name>d</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if>
      <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <comment type="block">/* Not UTF mode */</comment>
        <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>Lc</name> <operator>==</operator> <operator>*</operator><name>Feptr</name><operator>++</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>Lmin</name> <operator>==</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>==</operator> <name>REPTYPE_MIN</name></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>uint32_t</name></type> <name>d</name></decl>;</decl_stmt>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM206</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINC</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lc</name> <operator>==</operator> <name>d</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
          </block_content>}</block></if>
        <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Not UTF mode */</comment>
          <block>{<block_content>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM31</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lc</name> <operator>==</operator> <operator>*</operator><name>Feptr</name><operator>++</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
          </block_content>}</block></else></if_stmt>
        <comment type="block">/* Control never gets here */</comment>
        </block_content>}</block></if>

      <comment type="block">/* Maximize case */</comment>

      <else>else
        <block>{<block_content>
        <expr_stmt><expr><name>Lstart_eptr</name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>uint32_t</name></type> <name>d</name></decl>;</decl_stmt>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLEN</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lc</name> <operator>==</operator> <name>d</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>

          <comment type="block">/* After \C in UTF mode, Lstart_eptr might be in the middle of a
          Unicode character. Use &lt;= Lstart_eptr to ensure backtracking doesn't
          go too far. */</comment>

          <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>!=</operator> <name>REPTYPE_POS</name></expr>)</condition><block type="pseudo"><block_content> <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;=</operator> <name>Lstart_eptr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM207</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BACKCHAR</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for></block_content></block></if></if_stmt>
          </block_content>}</block></if>
        <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Not UTF mode */</comment>
          <block>{<block_content>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lc</name> <operator>==</operator> <operator>*</operator><name>Feptr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></for>
          <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>!=</operator> <name>REPTYPE_POS</name></expr>)</condition><block type="pseudo"><block_content> <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>==</operator> <name>Lstart_eptr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></for></block_content></block></if></if_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    <break>break;</break>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lstart_eptr</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lmin</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lmax</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lc</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Loc</name></cpp:undef>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Match a bit-mapped character class, possibly repeatedly. These opcodes
    are used when all the characters in the class have values in the range
    0-255, and either the matching is caseful, or the characters are in the
    range 0-127 when UTF processing is enabled. The only difference between
    OP_CLASS and OP_NCLASS occurs when a data character outside the range is
    encountered. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lmin</name></cpp:macro>               <cpp:value>F-&gt;temp_32[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lmax</name></cpp:macro>               <cpp:value>F-&gt;temp_32[1]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lstart_eptr</name></cpp:macro>        <cpp:value>F-&gt;temp_sptr[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lbyte_map_address</name></cpp:macro>  <cpp:value>F-&gt;temp_sptr[1]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lbyte_map</name></cpp:macro>          <cpp:value>((unsigned char *)Lbyte_map_address)</cpp:value></cpp:define>

    <case>case <expr><name>OP_NCLASS</name></expr>:</case>
    <case>case <expr><name>OP_CLASS</name></expr>:</case>
      <block>{<block_content>
      <expr_stmt><expr><name>Lbyte_map_address</name> <operator>=</operator> <name>Fecode</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>           <comment type="block">/* Save for matching */</comment>
      <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* Advance past the item */</comment>

      <comment type="block">/* Look past the end of the item to see if there is repeat information
      following. Then obey similar code to character type repeats. */</comment>

      <switch>switch <condition>(<expr><operator>*</operator><name>Fecode</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>OP_CRSTAR</name></expr>:</case>
        <case>case <expr><name>OP_CRMINSTAR</name></expr>:</case>
        <case>case <expr><name>OP_CRPLUS</name></expr>:</case>
        <case>case <expr><name>OP_CRMINPLUS</name></expr>:</case>
        <case>case <expr><name>OP_CRQUERY</name></expr>:</case>
        <case>case <expr><name>OP_CRMINQUERY</name></expr>:</case>
        <case>case <expr><name>OP_CRPOSSTAR</name></expr>:</case>
        <case>case <expr><name>OP_CRPOSPLUS</name></expr>:</case>
        <case>case <expr><name>OP_CRPOSQUERY</name></expr>:</case>
        <expr_stmt><expr><name>fc</name> <operator>=</operator> <operator>*</operator><name>Fecode</name><operator>++</operator> <operator>-</operator> <name>OP_CRSTAR</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <name><name>rep_min</name><index>[<expr><name>fc</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <name><name>rep_max</name><index>[<expr><name>fc</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name><name>rep_typ</name><index>[<expr><name>fc</name></expr>]</index></name></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>OP_CRRANGE</name></expr>:</case>
        <case>case <expr><name>OP_CRMINRANGE</name></expr>:</case>
        <case>case <expr><name>OP_CRPOSRANGE</name></expr>:</case>
        <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>Lmax</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <name>UINT32_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>       <comment type="block">/* Max 0 =&gt; infinity */</comment>
        <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name><name>rep_typ</name><index>[<expr><operator>*</operator><name>Fecode</name> <operator>-</operator> <name>OP_CRSTAR</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
        <break>break;</break>

        <default>default:</default>               <comment type="block">/* No repeat follows */</comment>
        <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <name>Lmax</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
        </block_content>}</block></switch>

      <comment type="block">/* First, ensure the minimum number of matches are present. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
        <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>GETCHARINC</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Fop</name> <operator>==</operator> <name>OP_CLASS</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
          <if type="elseif">else
            if <condition>(<expr><operator>(</operator><name><name>Lbyte_map</name><index>[<expr><name>fc</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>fc</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if>
      <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <comment type="block">/* Not UTF mode */</comment>
        <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>fc</name> <operator>=</operator> <operator>*</operator><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
          <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Fop</name> <operator>==</operator> <name>OP_CLASS</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
          <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          if <condition>(<expr><operator>(</operator><name><name>Lbyte_map</name><index>[<expr><name>fc</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>fc</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>

      <comment type="block">/* If Lmax == Lmin we are done. Continue with main loop. */</comment>

      <if_stmt><if>if <condition>(<expr><name>Lmin</name> <operator>==</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

      <comment type="block">/* If minimizing, keep testing the rest of the expression and advancing
      the pointer while it matches the class. */</comment>

      <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>==</operator> <name>REPTYPE_MIN</name></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
          <block>{<block_content>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM200</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINC</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition>
              <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><name>Fop</name> <operator>==</operator> <name>OP_CLASS</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
              </block_content>}</block></if>
            <if type="elseif">else
              if <condition>(<expr><operator>(</operator><name><name>Lbyte_map</name><index>[<expr><name>fc</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>fc</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
          </block_content>}</block></if>
        <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Not UTF mode */</comment>
          <block>{<block_content>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM23</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>fc</name> <operator>=</operator> <operator>*</operator><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
            <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition>
              <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><name>Fop</name> <operator>==</operator> <name>OP_CLASS</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
              </block_content>}</block></if>
            <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            if <condition>(<expr><operator>(</operator><name><name>Lbyte_map</name><index>[<expr><name>fc</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>fc</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
          </block_content>}</block></else></if_stmt>
        <comment type="block">/* Control never gets here */</comment>
        </block_content>}</block></if>

      <comment type="block">/* If maximizing, find the longest possible run, then work backwards. */</comment>

      <else>else
        <block>{<block_content>
        <expr_stmt><expr><name>Lstart_eptr</name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
          <block>{<block_content>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLEN</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition>
              <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><name>Fop</name> <operator>==</operator> <name>OP_CLASS</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
              </block_content>}</block></if>
            <if type="elseif">else
              if <condition>(<expr><operator>(</operator><name><name>Lbyte_map</name><index>[<expr><name>fc</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>fc</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>

          <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>==</operator> <name>REPTYPE_POS</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>    <comment type="block">/* No backtracking */</comment>

          <comment type="block">/* After \C in UTF mode, Lstart_eptr might be in the middle of a
          Unicode character. Use &lt;= Lstart_eptr to ensure backtracking doesn't
          go too far. */</comment>

          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM201</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name><operator>--</operator> <operator>&lt;=</operator> <name>Lstart_eptr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* Tried at original position */</comment>
            <expr_stmt><expr><call><name>BACKCHAR</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
          </block_content>}</block></if>
        <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <comment type="block">/* Not UTF mode */</comment>
          <block>{<block_content>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>fc</name> <operator>=</operator> <operator>*</operator><name>Feptr</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
            <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition>
              <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><name>Fop</name> <operator>==</operator> <name>OP_CLASS</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
              </block_content>}</block></if>
            <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            if <condition>(<expr><operator>(</operator><name><name>Lbyte_map</name><index>[<expr><name>fc</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>fc</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></for>

          <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>==</operator> <name>REPTYPE_POS</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>    <comment type="block">/* No backtracking */</comment>

          <while>while <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name>Lstart_eptr</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM24</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
          </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block>
    <comment type="block">/* Control never gets here */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lbyte_map_address</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lbyte_map</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lstart_eptr</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lmin</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lmax</name></cpp:undef>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Match an extended character class. In the 8-bit library, this opcode is
    encountered only when UTF-8 mode mode is supported. In the 16-bit and
    32-bit libraries, codepoints greater than 255 may be encountered even when
    UTF is not supported. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lstart_eptr</name></cpp:macro>  <cpp:value>F-&gt;temp_sptr[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lxclass_data</name></cpp:macro> <cpp:value>F-&gt;temp_sptr[1]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lmin</name></cpp:macro>         <cpp:value>F-&gt;temp_32[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lmax</name></cpp:macro>         <cpp:value>F-&gt;temp_32[1]</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>
    <case>case <expr><name>OP_XCLASS</name></expr>:</case>
      <block>{<block_content>
      <expr_stmt><expr><name>Lxclass_data</name> <operator>=</operator> <name>Fecode</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>  <comment type="block">/* Save for matching */</comment>
      <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>               <comment type="block">/* Advance past the item */</comment>

      <switch>switch <condition>(<expr><operator>*</operator><name>Fecode</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>OP_CRSTAR</name></expr>:</case>
        <case>case <expr><name>OP_CRMINSTAR</name></expr>:</case>
        <case>case <expr><name>OP_CRPLUS</name></expr>:</case>
        <case>case <expr><name>OP_CRMINPLUS</name></expr>:</case>
        <case>case <expr><name>OP_CRQUERY</name></expr>:</case>
        <case>case <expr><name>OP_CRMINQUERY</name></expr>:</case>
        <case>case <expr><name>OP_CRPOSSTAR</name></expr>:</case>
        <case>case <expr><name>OP_CRPOSPLUS</name></expr>:</case>
        <case>case <expr><name>OP_CRPOSQUERY</name></expr>:</case>
        <expr_stmt><expr><name>fc</name> <operator>=</operator> <operator>*</operator><name>Fecode</name><operator>++</operator> <operator>-</operator> <name>OP_CRSTAR</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <name><name>rep_min</name><index>[<expr><name>fc</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <name><name>rep_max</name><index>[<expr><name>fc</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name><name>rep_typ</name><index>[<expr><name>fc</name></expr>]</index></name></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>OP_CRRANGE</name></expr>:</case>
        <case>case <expr><name>OP_CRMINRANGE</name></expr>:</case>
        <case>case <expr><name>OP_CRPOSRANGE</name></expr>:</case>
        <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>Lmax</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <name>UINT32_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Max 0 =&gt; infinity */</comment>
        <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name><name>rep_typ</name><index>[<expr><operator>*</operator><name>Fecode</name> <operator>-</operator> <name>OP_CRSTAR</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
        <break>break;</break>

        <default>default:</default>               <comment type="block">/* No repeat follows */</comment>
        <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <name>Lmax</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <break>break;</break>
        </block_content>}</block></switch>

      <comment type="block">/* First, ensure the minimum number of matches are present. */</comment>

      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><call><name>PRIV</name><argument_list>(<argument><expr><name>xclass</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Lxclass_data</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

      <comment type="block">/* If Lmax == Lmin we can just continue with the main loop. */</comment>

      <if_stmt><if>if <condition>(<expr><name>Lmin</name> <operator>==</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

      <comment type="block">/* If minimizing, keep testing the rest of the expression and advancing
      the pointer while it matches the class. */</comment>

      <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>==</operator> <name>REPTYPE_MIN</name></expr>)</condition>
        <block>{<block_content>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
          <block>{<block_content>
          <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM100</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><call><name>PRIV</name><argument_list>(<argument><expr><name>xclass</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Lxclass_data</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></for>
        <comment type="block">/* Control never gets here */</comment>
        </block_content>}</block></if>

      <comment type="block">/* If maximizing, find the longest possible run, then work backwards. */</comment>

      <else>else
        <block>{<block_content>
        <expr_stmt><expr><name>Lstart_eptr</name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
            </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
          <expr_stmt><expr><call><name>GETCHARLENTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <expr_stmt><expr><name>fc</name> <operator>=</operator> <operator>*</operator><name>Feptr</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><call><name>PRIV</name><argument_list>(<argument><expr><name>xclass</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Lxclass_data</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
          </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>==</operator> <name>REPTYPE_POS</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>    <comment type="block">/* No backtracking */</comment>

        <comment type="block">/* After \C in UTF mode, Lstart_eptr might be in the middle of a
        Unicode character. Use &lt;= Lstart_eptr to ensure backtracking doesn't
        go too far. */</comment>

        <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
          <block>{<block_content>
          <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM101</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name><operator>--</operator> <operator>&lt;=</operator> <name>Lstart_eptr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* Tried at original position */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
          <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>BACKCHAR</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          </block_content>}</block></for>
        <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

      <comment type="block">/* Control never gets here */</comment>
      </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_WIDE_CHARS: end of XCLASS */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lstart_eptr</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lxclass_data</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lmin</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lmax</name></cpp:undef>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Match various character types when PCRE2_UCP is not set. These opcodes
    are not generated when PCRE2_UCP is set - instead appropriate property
    tests are compiled. */</comment>

    <case>case <expr><name>OP_NOT_DIGIT</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>CHMAX_255</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_digit</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_DIGIT</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHMAX_255</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_digit</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_NOT_WHITESPACE</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>CHMAX_255</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_space</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_WHITESPACE</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHMAX_255</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_space</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_NOT_WORDCHAR</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>CHMAX_255</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_WORDCHAR</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHMAX_255</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_ANYNL</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
      <block>{<block_content>
      <default>default:</default> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <case>case <expr><name>CHAR_CR</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CHAR_LF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>

      <case>case <expr><name>CHAR_LF</name></expr>:</case>
      <break>break;</break>

      <case>case <expr><name>CHAR_VT</name></expr>:</case>
      <case>case <expr><name>CHAR_FF</name></expr>:</case>
      <case>case <expr><name>CHAR_NEL</name></expr>:</case>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EBCDIC</name></cpp:ifndef>
      <case>case <expr><literal type="number">0x2028</literal></expr>:</case>
      <case>case <expr><literal type="number">0x2029</literal></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* Not EBCDIC */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>bsr_convention</name></name> <operator>==</operator> <name>PCRE2_BSR_ANYCRLF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
      </block_content>}</block></switch>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_NOT_HSPACE</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
      <block>{<block_content>
      <label><name>HSPACE_CASES</name>:</label> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Byte and multibyte cases */</comment>
      <default>default:</default> <break>break;</break>
      </block_content>}</block></switch>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_HSPACE</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
      <block>{<block_content>
      <label><name>HSPACE_CASES</name>:</label> <break>break;</break>  <comment type="block">/* Byte and multibyte cases */</comment>
      <default>default:</default> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></switch>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_NOT_VSPACE</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
      <block>{<block_content>
      <label><name>VSPACE_CASES</name>:</label> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <default>default:</default> <break>break;</break>
      </block_content>}</block></switch>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_VSPACE</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
      <block>{<block_content>
      <label><name>VSPACE_CASES</name>:</label> <break>break;</break>
      <default>default:</default> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></switch>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>

    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Check the next character by Unicode property. We will get here only
    if the support is in the binary; otherwise a compile-time error occurs. */</comment>

    <case>case <expr><name>OP_PROP</name></expr>:</case>
    <case>case <expr><name>OP_NOTPROP</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>ucd_record</name> <modifier>*</modifier></type><name>prop</name> <init>= <expr><call><name>GET_UCD</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <switch>switch<condition>(<expr><name><name>Fecode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>PT_ANY</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name>Fop</name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>

        <case>case <expr><name>PT_LAMP</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name>ucp_Lu</name> <operator>||</operator>
             <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name>ucp_Ll</name> <operator>||</operator>
             <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name>ucp_Lt</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Fop</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>

        <case>case <expr><name>PT_GC</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>Fecode</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Fop</name> <operator>==</operator> <name>OP_PROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>

        <case>case <expr><name>PT_PC</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>Fecode</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Fop</name> <operator>==</operator> <name>OP_PROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>

        <case>case <expr><name>PT_SC</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>Fecode</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <name><name>prop</name><operator>-&gt;</operator><name>script</name></name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Fop</name> <operator>==</operator> <name>OP_PROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>

        <comment type="block">/* These are specials */</comment>

        <case>case <expr><name>PT_ALNUM</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_L</name> <operator>||</operator>
             <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_N</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Fop</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>

        <comment type="block">/* Perl space used to exclude VT, but from Perl 5.18 it is included,
        which means that Perl space and POSIX space are now identical. PCRE
        was changed at release 8.34. */</comment>

        <case>case <expr><name>PT_SPACE</name></expr>:</case>    <comment type="block">/* Perl space */</comment>
        <case>case <expr><name>PT_PXSPACE</name></expr>:</case>  <comment type="block">/* POSIX space */</comment>
        <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
          <block>{<block_content>
          <label><name>HSPACE_CASES</name>:</label>
          <label><name>VSPACE_CASES</name>:</label>
          <if_stmt><if>if <condition>(<expr><name>Fop</name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>

          <default>default:</default>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_Z</name><operator>)</operator> <operator>==</operator>
            <operator>(</operator><name>Fop</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
          </block_content>}</block></switch>
        <break>break;</break>

        <case>case <expr><name>PT_WORD</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_L</name> <operator>||</operator>
             <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_N</name> <operator>||</operator>
             <name>fc</name> <operator>==</operator> <name>CHAR_UNDERSCORE</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Fop</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>

        <case>case <expr><name>PT_CLIST</name></expr>:</case>
        <expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_caseless_sets</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>Fecode</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&lt;</operator> <operator>*</operator><name>cp</name></expr>)</condition>
            <block>{<block_content> <if_stmt><if>if <condition>(<expr><name>Fop</name> <operator>==</operator> <name>OP_PROP</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if> <else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt> </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>==</operator> <operator>*</operator><name>cp</name><operator>++</operator></expr>)</condition>
            <block>{<block_content> <if_stmt><if>if <condition>(<expr><name>Fop</name> <operator>==</operator> <name>OP_PROP</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if> <else>else <block>{<block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></else></if_stmt> </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>PT_UCNC</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fc</name> <operator>==</operator> <name>CHAR_DOLLAR_SIGN</name> <operator>||</operator> <name>fc</name> <operator>==</operator> <name>CHAR_COMMERCIAL_AT</name> <operator>||</operator>
             <name>fc</name> <operator>==</operator> <name>CHAR_GRAVE_ACCENT</name> <operator>||</operator> <operator>(</operator><name>fc</name> <operator>&gt;=</operator> <literal type="number">0xa0</literal> <operator>&amp;&amp;</operator> <name>fc</name> <operator>&lt;=</operator> <literal type="number">0xd7ff</literal><operator>)</operator> <operator>||</operator>
             <name>fc</name> <operator>&gt;=</operator> <literal type="number">0xe000</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Fop</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>

        <comment type="block">/* This should never occur */</comment>

        <default>default:</default>
        <return>return <expr><name>PCRE2_ERROR_INTERNAL</name></expr>;</return>
        </block_content>}</block></switch>

      <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      </block_content>}</block>
    <break>break;</break>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Match an extended Unicode sequence. We will get here only if the support
    is in the binary; otherwise a compile-time error occurs. */</comment>

    <case>case <expr><name>OP_EXTUNI</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>Feptr</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>extuni</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr></argument>, <argument><expr><name>utf</name></expr></argument>,
        <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>CHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Match a single character type repeatedly. Note that the property type
    does not need to be in a stack frame as it is not used within an RMATCH()
    loop. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lstart_eptr</name></cpp:macro>  <cpp:value>F-&gt;temp_sptr[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lmin</name></cpp:macro>         <cpp:value>F-&gt;temp_32[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lmax</name></cpp:macro>         <cpp:value>F-&gt;temp_32[1]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lctype</name></cpp:macro>       <cpp:value>F-&gt;temp_32[2]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lpropvalue</name></cpp:macro>   <cpp:value>F-&gt;temp_32[3]</cpp:value></cpp:define>

    <case>case <expr><name>OP_TYPEEXACT</name></expr>:</case>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <name>Lmax</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <goto>goto <name>REPEATTYPE</name>;</goto>

    <case>case <expr><name>OP_TYPEUPTO</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINUPTO</name></expr>:</case>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>reptype</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name>Fecode</name> <operator>==</operator> <name>OP_TYPEMINUPTO</name><operator>)</operator></expr>?</condition><then> <expr><name>REPTYPE_MIN</name></expr> </then><else>: <expr><name>REPTYPE_MAX</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <goto>goto <name>REPEATTYPE</name>;</goto>

    <case>case <expr><name>OP_TYPEPOSSTAR</name></expr>:</case>
    <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name>REPTYPE_POS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <name>UINT32_MAX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <goto>goto <name>REPEATTYPE</name>;</goto>

    <case>case <expr><name>OP_TYPEPOSPLUS</name></expr>:</case>
    <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name>REPTYPE_POS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <name>UINT32_MAX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <goto>goto <name>REPEATTYPE</name>;</goto>

    <case>case <expr><name>OP_TYPEPOSQUERY</name></expr>:</case>
    <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name>REPTYPE_POS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <goto>goto <name>REPEATTYPE</name>;</goto>

    <case>case <expr><name>OP_TYPEPOSUPTO</name></expr>:</case>
    <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name>REPTYPE_POS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <goto>goto <name>REPEATTYPE</name>;</goto>

    <case>case <expr><name>OP_TYPESTAR</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINSTAR</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPLUS</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINPLUS</name></expr>:</case>
    <case>case <expr><name>OP_TYPEQUERY</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINQUERY</name></expr>:</case>
    <expr_stmt><expr><name>fc</name> <operator>=</operator> <operator>*</operator><name>Fecode</name><operator>++</operator> <operator>-</operator> <name>OP_TYPESTAR</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <name><name>rep_min</name><index>[<expr><name>fc</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <name><name>rep_max</name><index>[<expr><name>fc</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name><name>rep_typ</name><index>[<expr><name>fc</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* Common code for all repeated character type matches. */</comment>

    <label><name>REPEATTYPE</name>:</label>
    <expr_stmt><expr><name>Lctype</name> <operator>=</operator> <operator>*</operator><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>      <comment type="block">/* Code for the character type */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>Lctype</name> <operator>==</operator> <name>OP_PROP</name> <operator>||</operator> <name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>proptype</name> <operator>=</operator> <operator>*</operator><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>Lpropvalue</name> <operator>=</operator> <operator>*</operator><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>proptype</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* First, ensure the minimum number of matches are present. Use inline
    code for maximizing the speed, and do the type test once at the start
    (i.e. keep it out of the loop). The code for UTF mode is separated out for
    tidiness, except for Unicode property tests. */</comment>

    <if_stmt><if>if <condition>(<expr><name>Lmin</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>proptype</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>  <comment type="block">/* Property tests in all modes */</comment>
        <block>{<block_content>
        <switch>switch<condition>(<expr><name>proptype</name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>PT_ANY</name></expr>:</case>
          <if_stmt><if>if <condition>(<expr><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>PT_LAMP</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>chartype</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>chartype</name> <operator>=</operator> <call><name>UCD_CHARTYPE</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>chartype</name> <operator>==</operator> <name>ucp_Lu</name> <operator>||</operator>
                 <name>chartype</name> <operator>==</operator> <name>ucp_Ll</name> <operator>||</operator>
                 <name>chartype</name> <operator>==</operator> <name>ucp_Lt</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>PT_GC</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>UCD_CATEGORY</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Lpropvalue</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>PT_PC</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>UCD_CHARTYPE</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Lpropvalue</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>PT_SC</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>UCD_SCRIPT</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Lpropvalue</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>PT_ALNUM</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>category</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>category</name> <operator>=</operator> <call><name>UCD_CATEGORY</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>category</name> <operator>==</operator> <name>ucp_L</name> <operator>||</operator> <name>category</name> <operator>==</operator> <name>ucp_N</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <comment type="block">/* Perl space used to exclude VT, but from Perl 5.18 it is included,
          which means that Perl space and POSIX space are now identical. PCRE
          was changed at release 8.34. */</comment>

          <case>case <expr><name>PT_SPACE</name></expr>:</case>    <comment type="block">/* Perl space */</comment>
          <case>case <expr><name>PT_PXSPACE</name></expr>:</case>  <comment type="block">/* POSIX space */</comment>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
              <block>{<block_content>
              <label><name>HSPACE_CASES</name>:</label>
              <label><name>VSPACE_CASES</name>:</label>
              <if_stmt><if>if <condition>(<expr><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
              <break>break;</break>

              <default>default:</default>
              <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>UCD_CATEGORY</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ucp_Z</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
              <break>break;</break>
              </block_content>}</block></switch>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>PT_WORD</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>category</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>category</name> <operator>=</operator> <call><name>UCD_CATEGORY</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>category</name> <operator>==</operator> <name>ucp_L</name> <operator>||</operator> <name>category</name> <operator>==</operator> <name>ucp_N</name> <operator>||</operator>
                <name>fc</name> <operator>==</operator> <name>CHAR_UNDERSCORE</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>PT_CLIST</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_caseless_sets</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>Lpropvalue</name></expr>;</expr_stmt>
            <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
              <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&lt;</operator> <operator>*</operator><name>cp</name></expr>)</condition>
                <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
              <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>==</operator> <operator>*</operator><name>cp</name><operator>++</operator></expr>)</condition>
                <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
                </block_content>}</block></if></if_stmt>
              </block_content>}</block></for>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>PT_UCNC</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fc</name> <operator>==</operator> <name>CHAR_DOLLAR_SIGN</name> <operator>||</operator> <name>fc</name> <operator>==</operator> <name>CHAR_COMMERCIAL_AT</name> <operator>||</operator>
                 <name>fc</name> <operator>==</operator> <name>CHAR_GRAVE_ACCENT</name> <operator>||</operator> <operator>(</operator><name>fc</name> <operator>&gt;=</operator> <literal type="number">0xa0</literal> <operator>&amp;&amp;</operator> <name>fc</name> <operator>&lt;=</operator> <literal type="number">0xd7ff</literal><operator>)</operator> <operator>||</operator>
                 <name>fc</name> <operator>&gt;=</operator> <literal type="number">0xe000</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <comment type="block">/* This should not occur */</comment>

          <default>default:</default>
          <return>return <expr><name>PCRE2_ERROR_INTERNAL</name></expr>;</return>
          </block_content>}</block></switch>
        </block_content>}</block></if>

      <comment type="block">/* Match extended Unicode sequences. We will get here only if the
      support is in the binary; otherwise a compile-time error occurs. */</comment>

      <if type="elseif">else if <condition>(<expr><name>Lctype</name> <operator>==</operator> <name>OP_EXTUNI</name></expr>)</condition>
        <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
          <else>else
            <block>{<block_content>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>Feptr</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>extuni</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name></expr></argument>,
              <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><call><name>CHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if>
      <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>     <comment type="block">/* SUPPORT_UNICODE */</comment>

<comment type="block">/* Handle all other cases in UTF mode */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <switch>switch<condition>(<expr><name>Lctype</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>OP_ANY</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
              <name>Feptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator>
              <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator>
              <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nllen</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
              <call><name>UCHAR21</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>hitend</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_PARTIAL</name></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ACROSSCHAR</name><argument_list>(<argument><expr><name>Feptr</name> <operator>&lt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>Feptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_ALLANY</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ACROSSCHAR</name><argument_list>(<argument><expr><name>Feptr</name> <operator>&lt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>Feptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_ANYBYTE</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>-</operator> <name>Lmin</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>Lmin</name></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>OP_ANYNL</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>GETCHARINC</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
            <block>{<block_content>
            <default>default:</default> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <case>case <expr><name>CHAR_CR</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator> <call><name>UCHAR21</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CHAR_LF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>

            <case>case <expr><name>CHAR_LF</name></expr>:</case>
            <break>break;</break>

            <case>case <expr><name>CHAR_VT</name></expr>:</case>
            <case>case <expr><name>CHAR_FF</name></expr>:</case>
            <case>case <expr><name>CHAR_NEL</name></expr>:</case>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EBCDIC</name></cpp:ifndef>
            <case>case <expr><literal type="number">0x2028</literal></expr>:</case>
            <case>case <expr><literal type="number">0x2029</literal></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* Not EBCDIC */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>bsr_convention</name></name> <operator>==</operator> <name>PCRE2_BSR_ANYCRLF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
            </block_content>}</block></switch>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_NOT_HSPACE</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>GETCHARINC</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
            <block>{<block_content>
            <label><name>HSPACE_CASES</name>:</label> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <default>default:</default> <break>break;</break>
            </block_content>}</block></switch>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_HSPACE</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>GETCHARINC</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
            <block>{<block_content>
            <label><name>HSPACE_CASES</name>:</label> <break>break;</break>
            <default>default:</default> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></switch>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_NOT_VSPACE</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>GETCHARINC</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
            <block>{<block_content>
            <label><name>VSPACE_CASES</name>:</label> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <default>default:</default> <break>break;</break>
            </block_content>}</block></switch>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_VSPACE</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>GETCHARINC</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
            <block>{<block_content>
            <label><name>VSPACE_CASES</name>:</label> <break>break;</break>
            <default>default:</default> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></switch>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_NOT_DIGIT</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>GETCHARINC</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&lt;</operator> <literal type="number">128</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_digit</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_DIGIT</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <decl_stmt><decl><type><name>uint32_t</name></type> <name>cc</name></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>UCHAR21</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&gt;=</operator> <literal type="number">128</literal> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>cc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_digit</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
          <comment type="block">/* No need to skip more code units - we know it has only one. */</comment>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_NOT_WHITESPACE</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <decl_stmt><decl><type><name>uint32_t</name></type> <name>cc</name></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>UCHAR21</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&lt;</operator> <literal type="number">128</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>cc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_space</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ACROSSCHAR</name><argument_list>(<argument><expr><name>Feptr</name> <operator>&lt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>Feptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_WHITESPACE</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <decl_stmt><decl><type><name>uint32_t</name></type> <name>cc</name></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>UCHAR21</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&gt;=</operator> <literal type="number">128</literal> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>cc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_space</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
          <comment type="block">/* No need to skip more code units - we know it has only one. */</comment>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_NOT_WORDCHAR</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <decl_stmt><decl><type><name>uint32_t</name></type> <name>cc</name></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>UCHAR21</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&lt;</operator> <literal type="number">128</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>cc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ACROSSCHAR</name><argument_list>(<argument><expr><name>Feptr</name> <operator>&lt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>Feptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_WORDCHAR</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <decl_stmt><decl><type><name>uint32_t</name></type> <name>cc</name></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>UCHAR21</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&gt;=</operator> <literal type="number">128</literal> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>cc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
          <comment type="block">/* No need to skip more code units - we know it has only one. */</comment>
          </block_content>}</block></for>
        <break>break;</break>

        <default>default:</default>
        <return>return <expr><name>PCRE2_ERROR_INTERNAL</name></expr>;</return>
        </block_content>}</block></switch></block_content></block></if>  <comment type="block">/* End switch(Lctype) */</comment>

      <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>     <comment type="block">/* SUPPORT_UNICODE */</comment>

      <comment type="block">/* Code for the non-UTF case for minimum matching of operators other
      than OP_PROP and OP_NOTPROP. */</comment>

      <switch>switch<condition>(<expr><name>Lctype</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>OP_ANY</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
              <name>Feptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator>
              <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator>
              <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nllen</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
              <operator>*</operator><name>Feptr</name> <operator>==</operator> <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>hitend</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_PARTIAL</name></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_ALLANY</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>-</operator> <name>Lmin</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>Lmin</name></expr>;</expr_stmt>
        <break>break;</break>

        <comment type="block">/* This OP_ANYBYTE case will never be reached because \C gets turned
        into OP_ALLANY in non-UTF mode. Cut out the code so that coverage
        reports don't complain about it's never being used. */</comment>

<comment type="block">/*        case OP_ANYBYTE:
*        if (Feptr &gt; mb-&gt;end_subject - Lmin)
*          {
*          SCHECK_PARTIAL();
*          RRETURN(MATCH_NOMATCH);
*          }
*        Feptr += Lmin;
*        break;
*/</comment>
        <case>case <expr><name>OP_ANYNL</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <switch>switch<condition>(<expr><operator>*</operator><name>Feptr</name><operator>++</operator></expr>)</condition>
            <block>{<block_content>
            <default>default:</default> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <case>case <expr><name>CHAR_CR</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>Feptr</name> <operator>==</operator> <name>CHAR_LF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>

            <case>case <expr><name>CHAR_LF</name></expr>:</case>
            <break>break;</break>

            <case>case <expr><name>CHAR_VT</name></expr>:</case>
            <case>case <expr><name>CHAR_FF</name></expr>:</case>
            <case>case <expr><name>CHAR_NEL</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
            <case>case <expr><literal type="number">0x2028</literal></expr>:</case>
            <case>case <expr><literal type="number">0x2029</literal></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>bsr_convention</name></name> <operator>==</operator> <name>PCRE2_BSR_ANYCRLF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
            </block_content>}</block></switch>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_NOT_HSPACE</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <switch>switch<condition>(<expr><operator>*</operator><name>Feptr</name><operator>++</operator></expr>)</condition>
            <block>{<block_content>
            <default>default:</default> <break>break;</break>
            <label><name>HSPACE_BYTE_CASES</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
            <label><name>HSPACE_MULTIBYTE_CASES</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></switch>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_HSPACE</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <switch>switch<condition>(<expr><operator>*</operator><name>Feptr</name><operator>++</operator></expr>)</condition>
            <block>{<block_content>
            <default>default:</default> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <label><name>HSPACE_BYTE_CASES</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
            <label><name>HSPACE_MULTIBYTE_CASES</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <break>break;</break>
            </block_content>}</block></switch>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_NOT_VSPACE</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <switch>switch<condition>(<expr><operator>*</operator><name>Feptr</name><operator>++</operator></expr>)</condition>
            <block>{<block_content>
            <label><name>VSPACE_BYTE_CASES</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
            <label><name>VSPACE_MULTIBYTE_CASES</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <default>default:</default> <break>break;</break>
            </block_content>}</block></switch>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_VSPACE</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <switch>switch<condition>(<expr><operator>*</operator><name>Feptr</name><operator>++</operator></expr>)</condition>
            <block>{<block_content>
            <default>default:</default> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <label><name>VSPACE_BYTE_CASES</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
            <label><name>VSPACE_MULTIBYTE_CASES</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <break>break;</break>
            </block_content>}</block></switch>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_NOT_DIGIT</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><call><name>MAX_255</name><argument_list>(<argument><expr><operator>*</operator><name>Feptr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><operator>*</operator><name>Feptr</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_digit</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_DIGIT</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MAX_255</name><argument_list>(<argument><expr><operator>*</operator><name>Feptr</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><operator>*</operator><name>Feptr</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_digit</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_NOT_WHITESPACE</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><call><name>MAX_255</name><argument_list>(<argument><expr><operator>*</operator><name>Feptr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><operator>*</operator><name>Feptr</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_space</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_WHITESPACE</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MAX_255</name><argument_list>(<argument><expr><operator>*</operator><name>Feptr</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><operator>*</operator><name>Feptr</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_space</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_NOT_WORDCHAR</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><call><name>MAX_255</name><argument_list>(<argument><expr><operator>*</operator><name>Feptr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><operator>*</operator><name>Feptr</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></for>
        <break>break;</break>

        <case>case <expr><name>OP_WORDCHAR</name></expr>:</case>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MAX_255</name><argument_list>(<argument><expr><operator>*</operator><name>Feptr</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><operator>*</operator><name>Feptr</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></for>
        <break>break;</break>

        <default>default:</default>
        <return>return <expr><name>PCRE2_ERROR_INTERNAL</name></expr>;</return>
        </block_content>}</block></switch></block_content></block></else></if_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* If Lmin = Lmax we are done. Continue with the main loop. */</comment>

    <if_stmt><if>if <condition>(<expr><name>Lmin</name> <operator>==</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <comment type="block">/* If minimizing, we have to test the rest of the pattern before each
    subsequent match. */</comment>

    <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>==</operator> <name>REPTYPE_MIN</name></expr>)</condition>
      <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>proptype</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <switch>switch<condition>(<expr><name>proptype</name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>PT_ANY</name></expr>:</case>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM208</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
          <comment type="block">/* Control never gets here */</comment>

          <case>case <expr><name>PT_LAMP</name></expr>:</case>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>chartype</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM209</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>chartype</name> <operator>=</operator> <call><name>UCD_CHARTYPE</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>chartype</name> <operator>==</operator> <name>ucp_Lu</name> <operator>||</operator>
                 <name>chartype</name> <operator>==</operator> <name>ucp_Ll</name> <operator>||</operator>
                 <name>chartype</name> <operator>==</operator> <name>ucp_Lt</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
          <comment type="block">/* Control never gets here */</comment>

          <case>case <expr><name>PT_GC</name></expr>:</case>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM210</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>UCD_CATEGORY</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Lpropvalue</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
          <comment type="block">/* Control never gets here */</comment>

          <case>case <expr><name>PT_PC</name></expr>:</case>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM211</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>UCD_CHARTYPE</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Lpropvalue</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
          <comment type="block">/* Control never gets here */</comment>

          <case>case <expr><name>PT_SC</name></expr>:</case>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM212</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>UCD_SCRIPT</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Lpropvalue</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
          <comment type="block">/* Control never gets here */</comment>

          <case>case <expr><name>PT_ALNUM</name></expr>:</case>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>category</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM213</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>category</name> <operator>=</operator> <call><name>UCD_CATEGORY</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>category</name> <operator>==</operator> <name>ucp_L</name> <operator>||</operator> <name>category</name> <operator>==</operator> <name>ucp_N</name><operator>)</operator> <operator>==</operator>
                <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
          <comment type="block">/* Control never gets here */</comment>

          <comment type="block">/* Perl space used to exclude VT, but from Perl 5.18 it is included,
          which means that Perl space and POSIX space are now identical. PCRE
          was changed at release 8.34. */</comment>

          <case>case <expr><name>PT_SPACE</name></expr>:</case>    <comment type="block">/* Perl space */</comment>
          <case>case <expr><name>PT_PXSPACE</name></expr>:</case>  <comment type="block">/* POSIX space */</comment>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM214</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
              <block>{<block_content>
              <label><name>HSPACE_CASES</name>:</label>
              <label><name>VSPACE_CASES</name>:</label>
              <if_stmt><if>if <condition>(<expr><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
              <break>break;</break>

              <default>default:</default>
              <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>UCD_CATEGORY</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ucp_Z</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
              <break>break;</break>
              </block_content>}</block></switch>
            </block_content>}</block></for>
          <comment type="block">/* Control never gets here */</comment>

          <case>case <expr><name>PT_WORD</name></expr>:</case>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>category</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM215</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>category</name> <operator>=</operator> <call><name>UCD_CATEGORY</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>category</name> <operator>==</operator> <name>ucp_L</name> <operator>||</operator>
                 <name>category</name> <operator>==</operator> <name>ucp_N</name> <operator>||</operator>
                 <name>fc</name> <operator>==</operator> <name>CHAR_UNDERSCORE</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
          <comment type="block">/* Control never gets here */</comment>

          <case>case <expr><name>PT_CLIST</name></expr>:</case>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM216</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_caseless_sets</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>Lpropvalue</name></expr>;</expr_stmt>
            <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
              <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&lt;</operator> <operator>*</operator><name>cp</name></expr>)</condition>
                <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
              <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>==</operator> <operator>*</operator><name>cp</name><operator>++</operator></expr>)</condition>
                <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
                </block_content>}</block></if></if_stmt>
              </block_content>}</block></for>
            </block_content>}</block></for>
          <comment type="block">/* Control never gets here */</comment>

          <case>case <expr><name>PT_UCNC</name></expr>:</case>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM217</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fc</name> <operator>==</operator> <name>CHAR_DOLLAR_SIGN</name> <operator>||</operator> <name>fc</name> <operator>==</operator> <name>CHAR_COMMERCIAL_AT</name> <operator>||</operator>
                 <name>fc</name> <operator>==</operator> <name>CHAR_GRAVE_ACCENT</name> <operator>||</operator> <operator>(</operator><name>fc</name> <operator>&gt;=</operator> <literal type="number">0xa0</literal> <operator>&amp;&amp;</operator> <name>fc</name> <operator>&lt;=</operator> <literal type="number">0xd7ff</literal><operator>)</operator> <operator>||</operator>
                 <name>fc</name> <operator>&gt;=</operator> <literal type="number">0xe000</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
          <comment type="block">/* Control never gets here */</comment>

          <comment type="block">/* This should never occur */</comment>
          <default>default:</default>
          <return>return <expr><name>PCRE2_ERROR_INTERNAL</name></expr>;</return>
          </block_content>}</block></switch>
        </block_content>}</block></if>

      <comment type="block">/* Match extended Unicode sequences. We will get here only if the
      support is in the binary; otherwise a compile-time error occurs. */</comment>

      <if type="elseif">else if <condition>(<expr><name>Lctype</name> <operator>==</operator> <name>OP_EXTUNI</name></expr>)</condition>
        <block>{<block_content>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
          <block>{<block_content>
          <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM218</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
          <else>else
            <block>{<block_content>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>Feptr</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>extuni</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr></argument>,
              <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><call><name>CHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if>
      <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>     <comment type="block">/* SUPPORT_UNICODE */</comment>

      <comment type="block">/* UTF mode for non-property testing character types. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      if <condition>(<expr><name>utf</name></expr>)</condition>
        <block>{<block_content>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
          <block>{<block_content>
          <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM219</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>Lctype</name> <operator>==</operator> <name>OP_ANY</name> <operator>&amp;&amp;</operator> <call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>GETCHARINC</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <switch>switch<condition>(<expr><name>Lctype</name></expr>)</condition>
            <block>{<block_content>
            <case>case <expr><name>OP_ANY</name></expr>:</case>               <comment type="block">/* This is the non-NL case */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>    <comment type="block">/* Take care with CRLF partial */</comment>
                <name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator>
                <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator>
                <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nllen</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
                <name>fc</name> <operator>==</operator> <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>hitend</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
              <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_PARTIAL</name></expr>;</return></block_content></block></if></if_stmt>
              </block_content>}</block></if></if_stmt>
            <break>break;</break>

            <case>case <expr><name>OP_ALLANY</name></expr>:</case>
            <case>case <expr><name>OP_ANYBYTE</name></expr>:</case>
            <break>break;</break>

            <case>case <expr><name>OP_ANYNL</name></expr>:</case>
            <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
              <block>{<block_content>
              <default>default:</default> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <case>case <expr><name>CHAR_CR</name></expr>:</case>
              <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator> <call><name>UCHAR21</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CHAR_LF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
              <break>break;</break>

              <case>case <expr><name>CHAR_LF</name></expr>:</case>
              <break>break;</break>

              <case>case <expr><name>CHAR_VT</name></expr>:</case>
              <case>case <expr><name>CHAR_FF</name></expr>:</case>
              <case>case <expr><name>CHAR_NEL</name></expr>:</case>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EBCDIC</name></cpp:ifndef>
              <case>case <expr><literal type="number">0x2028</literal></expr>:</case>
              <case>case <expr><literal type="number">0x2029</literal></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* Not EBCDIC */</comment>
              <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>bsr_convention</name></name> <operator>==</operator> <name>PCRE2_BSR_ANYCRLF</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
              <break>break;</break>
              </block_content>}</block></switch>
            <break>break;</break>

            <case>case <expr><name>OP_NOT_HSPACE</name></expr>:</case>
            <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
              <block>{<block_content>
              <label><name>HSPACE_CASES</name>:</label> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <default>default:</default> <break>break;</break>
              </block_content>}</block></switch>
            <break>break;</break>

            <case>case <expr><name>OP_HSPACE</name></expr>:</case>
            <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
              <block>{<block_content>
              <label><name>HSPACE_CASES</name>:</label> <break>break;</break>
              <default>default:</default> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></switch>
            <break>break;</break>

            <case>case <expr><name>OP_NOT_VSPACE</name></expr>:</case>
            <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
              <block>{<block_content>
              <label><name>VSPACE_CASES</name>:</label> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <default>default:</default> <break>break;</break>
              </block_content>}</block></switch>
            <break>break;</break>

            <case>case <expr><name>OP_VSPACE</name></expr>:</case>
            <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
              <block>{<block_content>
              <label><name>VSPACE_CASES</name>:</label> <break>break;</break>
              <default>default:</default> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></switch>
            <break>break;</break>

            <case>case <expr><name>OP_NOT_DIGIT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_digit</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>

            <case>case <expr><name>OP_DIGIT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&gt;=</operator> <literal type="number">256</literal> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_digit</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>

            <case>case <expr><name>OP_NOT_WHITESPACE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_space</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>

            <case>case <expr><name>OP_WHITESPACE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&gt;=</operator> <literal type="number">256</literal> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_space</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>

            <case>case <expr><name>OP_NOT_WORDCHAR</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>

            <case>case <expr><name>OP_WORDCHAR</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&gt;=</operator> <literal type="number">256</literal> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>

            <default>default:</default>
            <return>return <expr><name>PCRE2_ERROR_INTERNAL</name></expr>;</return>
            </block_content>}</block></switch>
          </block_content>}</block></for>
        </block_content>}</block></if>
      <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

      <comment type="block">/* Not UTF mode */</comment>
        <block>{<block_content>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
          <block>{<block_content>
          <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM33</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>Lctype</name> <operator>==</operator> <name>OP_ANY</name> <operator>&amp;&amp;</operator> <call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>fc</name> <operator>=</operator> <operator>*</operator><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
          <switch>switch<condition>(<expr><name>Lctype</name></expr>)</condition>
            <block>{<block_content>
            <case>case <expr><name>OP_ANY</name></expr>:</case>               <comment type="block">/* This is the non-NL case */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>    <comment type="block">/* Take care with CRLF partial */</comment>
                <name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator>
                <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator>
                <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nllen</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
                <name>fc</name> <operator>==</operator> <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>hitend</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
              <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_PARTIAL</name></expr>;</return></block_content></block></if></if_stmt>
              </block_content>}</block></if></if_stmt>
            <break>break;</break>

            <case>case <expr><name>OP_ALLANY</name></expr>:</case>
            <case>case <expr><name>OP_ANYBYTE</name></expr>:</case>
            <break>break;</break>

            <case>case <expr><name>OP_ANYNL</name></expr>:</case>
            <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
              <block>{<block_content>
              <default>default:</default> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <case>case <expr><name>CHAR_CR</name></expr>:</case>
              <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>Feptr</name> <operator>==</operator> <name>CHAR_LF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
              <break>break;</break>

              <case>case <expr><name>CHAR_LF</name></expr>:</case>
              <break>break;</break>

              <case>case <expr><name>CHAR_VT</name></expr>:</case>
              <case>case <expr><name>CHAR_FF</name></expr>:</case>
              <case>case <expr><name>CHAR_NEL</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
              <case>case <expr><literal type="number">0x2028</literal></expr>:</case>
              <case>case <expr><literal type="number">0x2029</literal></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>bsr_convention</name></name> <operator>==</operator> <name>PCRE2_BSR_ANYCRLF</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
              <break>break;</break>
              </block_content>}</block></switch>
            <break>break;</break>

            <case>case <expr><name>OP_NOT_HSPACE</name></expr>:</case>
            <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
              <block>{<block_content>
              <default>default:</default> <break>break;</break>
              <label><name>HSPACE_BYTE_CASES</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
              <label><name>HSPACE_MULTIBYTE_CASES</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></switch>
            <break>break;</break>

            <case>case <expr><name>OP_HSPACE</name></expr>:</case>
            <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
              <block>{<block_content>
              <default>default:</default> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <label><name>HSPACE_BYTE_CASES</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
              <label><name>HSPACE_MULTIBYTE_CASES</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              <break>break;</break>
              </block_content>}</block></switch>
            <break>break;</break>

            <case>case <expr><name>OP_NOT_VSPACE</name></expr>:</case>
            <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
              <block>{<block_content>
              <default>default:</default> <break>break;</break>
              <label><name>VSPACE_BYTE_CASES</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
              <label><name>VSPACE_MULTIBYTE_CASES</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></switch>
            <break>break;</break>

            <case>case <expr><name>OP_VSPACE</name></expr>:</case>
            <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
              <block>{<block_content>
              <default>default:</default> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <label><name>VSPACE_BYTE_CASES</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
              <label><name>VSPACE_MULTIBYTE_CASES</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              <break>break;</break>
              </block_content>}</block></switch>
            <break>break;</break>

            <case>case <expr><name>OP_NOT_DIGIT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>MAX_255</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_digit</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>

            <case>case <expr><name>OP_DIGIT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MAX_255</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_digit</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>

            <case>case <expr><name>OP_NOT_WHITESPACE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>MAX_255</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_space</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>

            <case>case <expr><name>OP_WHITESPACE</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MAX_255</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_space</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>

            <case>case <expr><name>OP_NOT_WORDCHAR</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>MAX_255</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>

            <case>case <expr><name>OP_WORDCHAR</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MAX_255</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>

            <default>default:</default>
            <return>return <expr><name>PCRE2_ERROR_INTERNAL</name></expr>;</return>
            </block_content>}</block></switch>
          </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
      <comment type="block">/* Control never gets here */</comment>
      </block_content>}</block></if>

    <comment type="block">/* If maximizing, it is worth using inline code for speed, doing the type
    test once at the start (i.e. keep it out of the loop). */</comment>

    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name>Lstart_eptr</name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt>  <comment type="block">/* Remember where we started */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>proptype</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <switch>switch<condition>(<expr><name>proptype</name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>PT_ANY</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLENTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>PT_LAMP</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>chartype</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLENTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>chartype</name> <operator>=</operator> <call><name>UCD_CHARTYPE</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>chartype</name> <operator>==</operator> <name>ucp_Lu</name> <operator>||</operator>
                 <name>chartype</name> <operator>==</operator> <name>ucp_Ll</name> <operator>||</operator>
                 <name>chartype</name> <operator>==</operator> <name>ucp_Lt</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>PT_GC</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLENTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>UCD_CATEGORY</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Lpropvalue</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>PT_PC</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLENTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>UCD_CHARTYPE</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Lpropvalue</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>PT_SC</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLENTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>UCD_SCRIPT</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Lpropvalue</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>PT_ALNUM</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>category</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLENTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>category</name> <operator>=</operator> <call><name>UCD_CATEGORY</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>category</name> <operator>==</operator> <name>ucp_L</name> <operator>||</operator> <name>category</name> <operator>==</operator> <name>ucp_N</name><operator>)</operator> <operator>==</operator>
                <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <comment type="block">/* Perl space used to exclude VT, but from Perl 5.18 it is included,
          which means that Perl space and POSIX space are now identical. PCRE
          was changed at release 8.34. */</comment>

          <case>case <expr><name>PT_SPACE</name></expr>:</case>    <comment type="block">/* Perl space */</comment>
          <case>case <expr><name>PT_PXSPACE</name></expr>:</case>  <comment type="block">/* POSIX space */</comment>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLENTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
              <block>{<block_content>
              <label><name>HSPACE_CASES</name>:</label>
              <label><name>VSPACE_CASES</name>:</label>
              <if_stmt><if>if <condition>(<expr><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>ENDLOOP99</name>;</goto></block_content></block></if></if_stmt>  <comment type="block">/* Break the loop */</comment>
              <break>break;</break>

              <default>default:</default>
              <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>UCD_CATEGORY</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ucp_Z</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <goto>goto <name>ENDLOOP99</name>;</goto></block_content></block></if></if_stmt>   <comment type="block">/* Break the loop */</comment>
              <break>break;</break>
              </block_content>}</block></switch>
            <expr_stmt><expr><name>Feptr</name><operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          <label><name>ENDLOOP99</name>:</label>
          <break>break;</break>

          <case>case <expr><name>PT_WORD</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>category</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLENTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>category</name> <operator>=</operator> <call><name>UCD_CATEGORY</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>category</name> <operator>==</operator> <name>ucp_L</name> <operator>||</operator> <name>category</name> <operator>==</operator> <name>ucp_N</name> <operator>||</operator>
                 <name>fc</name> <operator>==</operator> <name>CHAR_UNDERSCORE</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>PT_CLIST</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLENTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_caseless_sets</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>Lpropvalue</name></expr>;</expr_stmt>
            <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
              <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&lt;</operator> <operator>*</operator><name>cp</name></expr>)</condition>
                <block>{<block_content> <if_stmt><if>if <condition>(<expr><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if> <else>else<block type="pseudo"><block_content> <goto>goto <name>GOT_MAX</name>;</goto></block_content></block></else></if_stmt> </block_content>}</block></if></if_stmt>
              <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>==</operator> <operator>*</operator><name>cp</name><operator>++</operator></expr>)</condition>
                <block>{<block_content> <if_stmt><if>if <condition>(<expr><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>GOT_MAX</name>;</goto></block_content></block></if> <else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt> </block_content>}</block></if></if_stmt>
              </block_content>}</block></for>
            <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          <label><name>GOT_MAX</name>:</label>
          <break>break;</break>

          <case>case <expr><name>PT_UCNC</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLENTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fc</name> <operator>==</operator> <name>CHAR_DOLLAR_SIGN</name> <operator>||</operator> <name>fc</name> <operator>==</operator> <name>CHAR_COMMERCIAL_AT</name> <operator>||</operator>
                 <name>fc</name> <operator>==</operator> <name>CHAR_GRAVE_ACCENT</name> <operator>||</operator> <operator>(</operator><name>fc</name> <operator>&gt;=</operator> <literal type="number">0xa0</literal> <operator>&amp;&amp;</operator> <name>fc</name> <operator>&lt;=</operator> <literal type="number">0xd7ff</literal><operator>)</operator> <operator>||</operator>
                 <name>fc</name> <operator>&gt;=</operator> <literal type="number">0xe000</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
              <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <default>default:</default>
          <return>return <expr><name>PCRE2_ERROR_INTERNAL</name></expr>;</return>
          </block_content>}</block></switch>

        <comment type="block">/* Feptr is now past the end of the maximum run */</comment>

        <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>==</operator> <name>REPTYPE_POS</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>    <comment type="block">/* No backtracking */</comment>

        <comment type="block">/* After \C in UTF mode, Lstart_eptr might be in the middle of a
        Unicode character. Use &lt;= Lstart_eptr to ensure backtracking doesn't
        go too far. */</comment>

        <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;=</operator> <name>Lstart_eptr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM222</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>--</operator></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>BACKCHAR</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if>

      <comment type="block">/* Match extended Unicode grapheme clusters. We will get here only if the
      support is in the binary; otherwise a compile-time error occurs. */</comment>

      <if type="elseif">else if <condition>(<expr><name>Lctype</name> <operator>==</operator> <name>OP_EXTUNI</name></expr>)</condition>
        <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
            </block_content>}</block></if>
          <else>else
            <block>{<block_content>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>Feptr</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>extuni</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr></argument>,
              <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><call><name>CHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>

        <comment type="block">/* Feptr is now past the end of the maximum run */</comment>

        <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>==</operator> <name>REPTYPE_POS</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>    <comment type="block">/* No backtracking */</comment>

        <comment type="block">/* We use &lt;= Lstart_eptr rather than == Lstart_eptr to detect the start
        of the run while backtracking because the use of \C in UTF mode can
        cause BACKCHAR to move back past Lstart_eptr. This is just palliative;
        the use of \C in UTF mode is fraught with danger. */</comment>

        <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
          <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>lgb</name></decl>, <decl><type ref="prev"/><name>rgb</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>fptr</name></decl>;</decl_stmt>

          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;=</operator> <name>Lstart_eptr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>   <comment type="block">/* At start of char run */</comment>
          <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM220</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

          <comment type="block">/* Backtracking over an extended grapheme cluster involves inspecting
          the previous two characters (if present) to see if a break is
          permitted between them. */</comment>

          <expr_stmt><expr><name>Feptr</name><operator>--</operator></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>fc</name> <operator>=</operator> <operator>*</operator><name>Feptr</name></expr>;</expr_stmt></block_content></block></if> <else>else
            <block>{<block_content>
            <expr_stmt><expr><call><name>BACKCHAR</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>GETCHAR</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name>rgb</name> <operator>=</operator> <call><name>UCD_GRAPHBREAK</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;=</operator> <name>Lstart_eptr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>   <comment type="block">/* At start of char run */</comment>
            <expr_stmt><expr><name>fptr</name> <operator>=</operator> <name>Feptr</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>fc</name> <operator>=</operator> <operator>*</operator><name>fptr</name></expr>;</expr_stmt></block_content></block></if> <else>else
              <block>{<block_content>
              <expr_stmt><expr><call><name>BACKCHAR</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>GETCHAR</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>lgb</name> <operator>=</operator> <call><name>UCD_GRAPHBREAK</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gbtable</name></expr></argument>)</argument_list></call><index>[<expr><name>lgb</name></expr>]</index> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>rgb</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name> <operator>=</operator> <name>fptr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rgb</name> <operator>=</operator> <name>lgb</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          </block_content>}</block></for>
        </block_content>}</block></if>

      <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* SUPPORT_UNICODE */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      if <condition>(<expr><name>utf</name></expr>)</condition>
        <block>{<block_content>
        <switch>switch<condition>(<expr><name>Lctype</name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>OP_ANY</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>    <comment type="block">/* Take care with CRLF partial */</comment>
                <name>Feptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator>
                <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator>
                <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nllen</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
                <call><name>UCHAR21</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>hitend</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
              <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_PARTIAL</name></expr>;</return></block_content></block></if></if_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ACROSSCHAR</name><argument_list>(<argument><expr><name>Feptr</name> <operator>&lt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>Feptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>OP_ALLANY</name></expr>:</case>
          <if_stmt><if>if <condition>(<expr><name>Lmax</name> <operator>&lt;</operator> <name>UINT32_MAX</name></expr>)</condition>
            <block>{<block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
              <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
                <block>{<block_content>
                <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
                </block_content>}</block></if></if_stmt>
              <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>ACROSSCHAR</name><argument_list>(<argument><expr><name>Feptr</name> <operator>&lt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>Feptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></for>
            </block_content>}</block></if>
          <else>else
            <block>{<block_content>
            <expr_stmt><expr><name>Feptr</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>;</expr_stmt>   <comment type="block">/* Unlimited UTF-8 repeat */</comment>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          <break>break;</break>

          <comment type="block">/* The "byte" (i.e. "code unit") case is the same as non-UTF */</comment>

          <case>case <expr><name>OP_ANYBYTE</name></expr>:</case>
          <expr_stmt><expr><name>fc</name> <operator>=</operator> <name>Lmax</name> <operator>-</operator> <name>Lmin</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&gt;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>-</operator> <name>Feptr</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>Feptr</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
          <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>fc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
          <break>break;</break>

          <case>case <expr><name>OP_ANYNL</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLEN</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>==</operator> <name>CHAR_CR</name></expr>)</condition>
              <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><operator>++</operator><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
              <if_stmt><if>if <condition>(<expr><call><name>UCHAR21</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CHAR_LF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
              </block_content>}</block></if>
            <else>else
              <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>!=</operator> <name>CHAR_LF</name> <operator>&amp;&amp;</operator>
                  <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>bsr_convention</name></name> <operator>==</operator> <name>PCRE2_BSR_ANYCRLF</name> <operator>||</operator>
                   <operator>(</operator><name>fc</name> <operator>!=</operator> <name>CHAR_VT</name> <operator>&amp;&amp;</operator> <name>fc</name> <operator>!=</operator> <name>CHAR_FF</name> <operator>&amp;&amp;</operator> <name>fc</name> <operator>!=</operator> <name>CHAR_NEL</name>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EBCDIC</name></cpp:ifndef>
                    <operator>&amp;&amp;</operator> <name>fc</name> <operator>!=</operator> <literal type="number">0x2028</literal> <operator>&amp;&amp;</operator> <name>fc</name> <operator>!=</operator> <literal type="number">0x2029</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* Not EBCDIC */</comment>
                    <operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
              <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>OP_NOT_HSPACE</name></expr>:</case>
          <case>case <expr><name>OP_HSPACE</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>BOOL</name></type> <name>gotspace</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLEN</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
              <block>{<block_content>
              <label><name>HSPACE_CASES</name>:</label> <expr_stmt><expr><name>gotspace</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break>
              <default>default:</default> <expr_stmt><expr><name>gotspace</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt> <break>break;</break>
              </block_content>}</block></switch>
            <if_stmt><if>if <condition>(<expr><name>gotspace</name> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOT_HSPACE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>OP_NOT_VSPACE</name></expr>:</case>
          <case>case <expr><name>OP_VSPACE</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>BOOL</name></type> <name>gotspace</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLEN</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <switch>switch<condition>(<expr><name>fc</name></expr>)</condition>
              <block>{<block_content>
              <label><name>VSPACE_CASES</name>:</label> <expr_stmt><expr><name>gotspace</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break>
              <default>default:</default> <expr_stmt><expr><name>gotspace</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt> <break>break;</break>
              </block_content>}</block></switch>
            <if_stmt><if>if <condition>(<expr><name>gotspace</name> <operator>==</operator> <operator>(</operator><name>Lctype</name> <operator>==</operator> <name>OP_NOT_VSPACE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>OP_NOT_DIGIT</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLEN</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_digit</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>OP_DIGIT</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLEN</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&gt;=</operator> <literal type="number">256</literal> <operator>||</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_digit</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>OP_NOT_WHITESPACE</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLEN</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_space</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>OP_WHITESPACE</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLEN</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&gt;=</operator> <literal type="number">256</literal> <operator>||</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_space</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>OP_NOT_WORDCHAR</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLEN</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>OP_WORDCHAR</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>GETCHARLEN</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&gt;=</operator> <literal type="number">256</literal> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <default>default:</default>
          <return>return <expr><name>PCRE2_ERROR_INTERNAL</name></expr>;</return>
          </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>==</operator> <name>REPTYPE_POS</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>    <comment type="block">/* No backtracking */</comment>

        <comment type="block">/* After \C in UTF mode, Lstart_eptr might be in the middle of a
        Unicode character. Use &lt;= Lstart_eptr to ensure backtracking doesn't go
        too far. */</comment>

        <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;=</operator> <name>Lstart_eptr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM221</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>BACKCHAR</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>Lctype</name> <operator>==</operator> <name>OP_ANYNL</name> <operator>&amp;&amp;</operator> <name>Feptr</name> <operator>&gt;</operator> <name>Lstart_eptr</name> <operator>&amp;&amp;</operator>
              <call><name>UCHAR21</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CHAR_NL</name> <operator>&amp;&amp;</operator> <call><name>UCHAR21</name><argument_list>(<argument><expr><name>Feptr</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>CHAR_CR</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>Feptr</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if>
      <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

      <comment type="block">/* Not UTF mode */</comment>
        <block>{<block_content>
        <switch>switch<condition>(<expr><name>Lctype</name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>OP_ANY</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>    <comment type="block">/* Take care with CRLF partial */</comment>
                <name>Feptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator>
                <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator>
                <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nllen</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
                <operator>*</operator><name>Feptr</name> <operator>==</operator> <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>hitend</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
              <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_PARTIAL</name></expr>;</return></block_content></block></if></if_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>OP_ALLANY</name></expr>:</case>
          <case>case <expr><name>OP_ANYBYTE</name></expr>:</case>
          <expr_stmt><expr><name>fc</name> <operator>=</operator> <name>Lmax</name> <operator>-</operator> <name>Lmin</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>&gt;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>-</operator> <name>Feptr</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>Feptr</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
          <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>fc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
          <break>break;</break>

          <case>case <expr><name>OP_ANYNL</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>fc</name> <operator>=</operator> <operator>*</operator><name>Feptr</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>==</operator> <name>CHAR_CR</name></expr>)</condition>
              <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><operator>++</operator><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
              <if_stmt><if>if <condition>(<expr><operator>*</operator><name>Feptr</name> <operator>==</operator> <name>CHAR_LF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
              </block_content>}</block></if>
            <else>else
              <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>!=</operator> <name>CHAR_LF</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>bsr_convention</name></name> <operator>==</operator> <name>PCRE2_BSR_ANYCRLF</name> <operator>||</operator>
                 <operator>(</operator><name>fc</name> <operator>!=</operator> <name>CHAR_VT</name> <operator>&amp;&amp;</operator> <name>fc</name> <operator>!=</operator> <name>CHAR_FF</name> <operator>&amp;&amp;</operator> <name>fc</name> <operator>!=</operator> <name>CHAR_NEL</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
                 <operator>&amp;&amp;</operator> <name>fc</name> <operator>!=</operator> <literal type="number">0x2028</literal> <operator>&amp;&amp;</operator> <name>fc</name> <operator>!=</operator> <literal type="number">0x2029</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                 <operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
              <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>OP_NOT_HSPACE</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <switch>switch<condition>(<expr><operator>*</operator><name>Feptr</name></expr>)</condition>
              <block>{<block_content>
              <default>default:</default> <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt> <break>break;</break>
              <label><name>HSPACE_BYTE_CASES</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
              <label><name>HSPACE_MULTIBYTE_CASES</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              <goto>goto <name>ENDLOOP00</name>;</goto>
              </block_content>}</block></switch>
            </block_content>}</block></for>
          <label><name>ENDLOOP00</name>:</label>
          <break>break;</break>

          <case>case <expr><name>OP_HSPACE</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <switch>switch<condition>(<expr><operator>*</operator><name>Feptr</name></expr>)</condition>
              <block>{<block_content>
              <default>default:</default> <goto>goto <name>ENDLOOP01</name>;</goto>
              <label><name>HSPACE_BYTE_CASES</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
              <label><name>HSPACE_MULTIBYTE_CASES</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt> <break>break;</break>
              </block_content>}</block></switch>
            </block_content>}</block></for>
          <label><name>ENDLOOP01</name>:</label>
          <break>break;</break>

          <case>case <expr><name>OP_NOT_VSPACE</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <switch>switch<condition>(<expr><operator>*</operator><name>Feptr</name></expr>)</condition>
              <block>{<block_content>
              <default>default:</default> <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt> <break>break;</break>
              <label><name>VSPACE_BYTE_CASES</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
              <label><name>VSPACE_MULTIBYTE_CASES</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              <goto>goto <name>ENDLOOP02</name>;</goto>
              </block_content>}</block></switch>
            </block_content>}</block></for>
          <label><name>ENDLOOP02</name>:</label>
          <break>break;</break>

          <case>case <expr><name>OP_VSPACE</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <switch>switch<condition>(<expr><operator>*</operator><name>Feptr</name></expr>)</condition>
              <block>{<block_content>
              <default>default:</default> <goto>goto <name>ENDLOOP03</name>;</goto>
              <label><name>VSPACE_BYTE_CASES</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
              <label><name>VSPACE_MULTIBYTE_CASES</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt> <break>break;</break>
              </block_content>}</block></switch>
            </block_content>}</block></for>
          <label><name>ENDLOOP03</name>:</label>
          <break>break;</break>

          <case>case <expr><name>OP_NOT_DIGIT</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>MAX_255</name><argument_list>(<argument><expr><operator>*</operator><name>Feptr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><operator>*</operator><name>Feptr</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_digit</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>OP_DIGIT</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MAX_255</name><argument_list>(<argument><expr><operator>*</operator><name>Feptr</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><operator>*</operator><name>Feptr</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_digit</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>OP_NOT_WHITESPACE</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>MAX_255</name><argument_list>(<argument><expr><operator>*</operator><name>Feptr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><operator>*</operator><name>Feptr</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_space</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>OP_WHITESPACE</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MAX_255</name><argument_list>(<argument><expr><operator>*</operator><name>Feptr</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><operator>*</operator><name>Feptr</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_space</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>OP_NOT_WORDCHAR</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>MAX_255</name><argument_list>(<argument><expr><operator>*</operator><name>Feptr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><operator>*</operator><name>Feptr</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>OP_WORDCHAR</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MAX_255</name><argument_list>(<argument><expr><operator>*</operator><name>Feptr</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><operator>*</operator><name>Feptr</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>Feptr</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <default>default:</default>
          <return>return <expr><name>PCRE2_ERROR_INTERNAL</name></expr>;</return>
          </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>==</operator> <name>REPTYPE_POS</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>    <comment type="block">/* No backtracking */</comment>

        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>==</operator> <name>Lstart_eptr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM34</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name><operator>--</operator></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>Lctype</name> <operator>==</operator> <name>OP_ANYNL</name> <operator>&amp;&amp;</operator> <name>Feptr</name> <operator>&gt;</operator> <name>Lstart_eptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>Feptr</name> <operator>==</operator> <name>CHAR_LF</name> <operator>&amp;&amp;</operator>
              <name><name>Feptr</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_CR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Feptr</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    <break>break;</break>  <comment type="block">/* End of repeat character type processing */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lstart_eptr</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lmin</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lmax</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lctype</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lpropvalue</name></cpp:undef>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Match a back reference, possibly repeatedly. Look past the end of the
    item to see if there is repeat information following. The OP_REF and
    OP_REFI opcodes are used for a reference to a numbered group or to a
    non-duplicated named group. For a duplicated named group, OP_DNREF and
    OP_DNREFI are used. In this case we must scan the list of groups to which
    the name refers, and use the first one that is set. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lmin</name></cpp:macro>      <cpp:value>F-&gt;temp_32[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lmax</name></cpp:macro>      <cpp:value>F-&gt;temp_32[1]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lcaseless</name></cpp:macro> <cpp:value>F-&gt;temp_32[2]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lstart</name></cpp:macro>    <cpp:value>F-&gt;temp_sptr[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Loffset</name></cpp:macro>   <cpp:value>F-&gt;temp_size</cpp:value></cpp:define>

    <case>case <expr><name>OP_DNREF</name></expr>:</case>
    <case>case <expr><name>OP_DNREFI</name></expr>:</case>
    <expr_stmt><expr><name>Lcaseless</name> <operator>=</operator> <operator>(</operator><name>Fop</name> <operator>==</operator> <name>OP_DNREFI</name><operator>)</operator></expr>;</expr_stmt>
      <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>slot</name> <init>= <expr><name><name>mb</name><operator>-&gt;</operator><name>name_table</name></name> <operator>+</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>mb</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>IMM2_SIZE</name></expr>;</expr_stmt>

      <while>while <condition>(<expr><name>count</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>Loffset</name> <operator>=</operator> <operator>(</operator><call><name>GET2</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>Loffset</name> <operator>&lt;</operator> <name>Foffset_top</name> <operator>&amp;&amp;</operator> <name><name>Fovector</name><index>[<expr><name>Loffset</name></expr>]</index></name> <operator>!=</operator> <name>PCRE2_UNSET</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>slot</name> <operator>+=</operator> <name><name>mb</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block>
    <goto>goto <name>REF_REPEAT</name>;</goto>

    <case>case <expr><name>OP_REF</name></expr>:</case>
    <case>case <expr><name>OP_REFI</name></expr>:</case>
    <expr_stmt><expr><name>Lcaseless</name> <operator>=</operator> <operator>(</operator><name>Fop</name> <operator>==</operator> <name>OP_REFI</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>Loffset</name> <operator>=</operator> <operator>(</operator><call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>

    <comment type="block">/* Set up for repetition, or handle the non-repeated case. The maximum and
    minimum must be in the heap frame, but as they are short-term values, we
    use temporary fields. */</comment>

    <label><name>REF_REPEAT</name>:</label>
    <switch>switch <condition>(<expr><operator>*</operator><name>Fecode</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>OP_CRSTAR</name></expr>:</case>
      <case>case <expr><name>OP_CRMINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_CRPLUS</name></expr>:</case>
      <case>case <expr><name>OP_CRMINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_CRQUERY</name></expr>:</case>
      <case>case <expr><name>OP_CRMINQUERY</name></expr>:</case>
      <expr_stmt><expr><name>fc</name> <operator>=</operator> <operator>*</operator><name>Fecode</name><operator>++</operator> <operator>-</operator> <name>OP_CRSTAR</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <name><name>rep_min</name><index>[<expr><name>fc</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <name><name>rep_max</name><index>[<expr><name>fc</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name><name>rep_typ</name><index>[<expr><name>fc</name></expr>]</index></name></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_CRRANGE</name></expr>:</case>
      <case>case <expr><name>OP_CRMINRANGE</name></expr>:</case>
      <expr_stmt><expr><name>Lmin</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>reptype</name> <operator>=</operator> <name><name>rep_typ</name><index>[<expr><operator>*</operator><name>Fecode</name> <operator>-</operator> <name>OP_CRSTAR</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>Lmax</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <name>UINT32_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Max 0 =&gt; infinity */</comment>
      <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
      <break>break;</break>

      <default>default:</default>                  <comment type="block">/* No repeat follows */</comment>
        <block>{<block_content>
        <expr_stmt><expr><name>rrc</name> <operator>=</operator> <call><name>match_ref</name><argument_list>(<argument><expr><name>Loffset</name></expr></argument>, <argument><expr><name>Lcaseless</name></expr></argument>, <argument><expr><name>F</name></expr></argument>, <argument><expr><name>mb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Feptr</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* Partial match */</comment>
          <expr_stmt><expr><call><name>CHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block>
      <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
      <continue>continue;</continue>              <comment type="block">/* With the main loop */</comment>
      </block_content>}</block></switch>

    <comment type="block">/* Handle repeated back references. If a set group has length zero, just
    continue with the main loop, because it matches however many times. For an
    unset reference, if the minimum is zero, we can also just continue. We can
    also continue if PCRE2_MATCH_UNSET_BACKREF is set, because this makes unset
    group behave as a zero-length group. For any other unset cases, carrying
    on will result in NOMATCH. */</comment>

    <if_stmt><if>if <condition>(<expr><name>Loffset</name> <operator>&lt;</operator> <name>Foffset_top</name> <operator>&amp;&amp;</operator> <name><name>Fovector</name><index>[<expr><name>Loffset</name></expr>]</index></name> <operator>!=</operator> <name>PCRE2_UNSET</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>Fovector</name><index>[<expr><name>Loffset</name></expr>]</index></name> <operator>==</operator> <name><name>Fovector</name><index>[<expr><name>Loffset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      </block_content>}</block></if>
    <else>else  <comment type="block">/* Group is not set */</comment>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>Lmin</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name> <operator>&amp;</operator> <name>PCRE2_MATCH_UNSET_BACKREF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <continue>continue;</continue></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>

    <comment type="block">/* First, ensure the minimum number of matches are present. */</comment>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>Lmin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
      <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>slength</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>rrc</name> <operator>=</operator> <call><name>match_ref</name><argument_list>(<argument><expr><name>Loffset</name></expr></argument>, <argument><expr><name>Lcaseless</name></expr></argument>, <argument><expr><name>F</name></expr></argument>, <argument><expr><name>mb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Feptr</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* Partial match */</comment>
        <expr_stmt><expr><call><name>CHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>slength</name></expr>;</expr_stmt>
      </block_content>}</block></for>

    <comment type="block">/* If min = max, we are done. They are not both allowed to be zero. */</comment>

    <if_stmt><if>if <condition>(<expr><name>Lmin</name> <operator>==</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

    <comment type="block">/* If minimizing, keep trying and advancing the pointer. */</comment>

    <if_stmt><if>if <condition>(<expr><name>reptype</name> <operator>==</operator> <name>REPTYPE_MIN</name></expr>)</condition>
      <block>{<block_content>
      <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>slength</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM20</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>Lmin</name><operator>++</operator> <operator>&gt;=</operator> <name>Lmax</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>rrc</name> <operator>=</operator> <call><name>match_ref</name><argument_list>(<argument><expr><name>Loffset</name></expr></argument>, <argument><expr><name>Lcaseless</name></expr></argument>, <argument><expr><name>F</name></expr></argument>, <argument><expr><name>mb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Feptr</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* Partial match */</comment>
          <expr_stmt><expr><call><name>CHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>slength</name></expr>;</expr_stmt>
        </block_content>}</block></for>
      <comment type="block">/* Control never gets here */</comment>
      </block_content>}</block></if>

    <comment type="block">/* If maximizing, find the longest string and work backwards, as long as
    the matched lengths for each iteration are the same. */</comment>

    <else>else
      <block>{<block_content>
      <decl_stmt><decl><type><name>BOOL</name></type> <name>samelengths</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>Lstart</name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt>     <comment type="block">/* Starting position */</comment>
      <expr_stmt><expr><name>Flength</name> <operator>=</operator> <name><name>Fovector</name><index>[<expr><name>Loffset</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>Fovector</name><index>[<expr><name>Loffset</name></expr>]</index></name></expr>;</expr_stmt>

      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>slength</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rrc</name> <operator>=</operator> <call><name>match_ref</name><argument_list>(<argument><expr><name>Loffset</name></expr></argument>, <argument><expr><name>Lcaseless</name></expr></argument>, <argument><expr><name>F</name></expr></argument>, <argument><expr><name>mb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <comment type="block">/* Can't use CHECK_PARTIAL because we don't want to update Feptr in
          the soft partial matching case. */</comment>

          <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
              <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&gt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>hitend</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_PARTIAL</name></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
          <break>break;</break>
          </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>slength</name> <operator>!=</operator> <name>Flength</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>samelengths</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>slength</name></expr>;</expr_stmt>
        </block_content>}</block></for>

      <comment type="block">/* If the length matched for each repetition is the same as the length of
      the captured group, we can easily work backwards. This is the normal
      case. However, in caseless UTF-8 mode there are pairs of case-equivalent
      characters whose lengths (in terms of code units) differ. However, this
      is very rare, so we handle it by re-matching fewer and fewer times. */</comment>

      <if_stmt><if>if <condition>(<expr><name>samelengths</name></expr>)</condition>
        <block>{<block_content>
        <while>while <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name>Lstart</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM21</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>Feptr</name> <operator>-=</operator> <name>Flength</name></expr>;</expr_stmt>
          </block_content>}</block></while>
        </block_content>}</block></if>

      <comment type="block">/* The rare case of non-matching lengths. Re-scan the repetition for each
      iteration. We know that match_ref() will succeed every time. */</comment>

      <else>else
        <block>{<block_content>
        <expr_stmt><expr><name>Lmax</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
          <block>{<block_content>
          <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM22</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>==</operator> <name>Lstart</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* Failed after minimal repetition */</comment>
          <expr_stmt><expr><name>Feptr</name> <operator>=</operator> <name>Lstart</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>Lmax</name><operator>--</operator></expr>;</expr_stmt>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>Lmin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Lmax</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>slength</name></decl>;</decl_stmt>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>match_ref</name><argument_list>(<argument><expr><name>Loffset</name></expr></argument>, <argument><expr><name>Lcaseless</name></expr></argument>, <argument><expr><name>F</name></expr></argument>, <argument><expr><name>mb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>Feptr</name> <operator>+=</operator> <name>slength</name></expr>;</expr_stmt>
            </block_content>}</block></for>
          </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <comment type="block">/* Control never gets here */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lcaseless</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lmin</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lmax</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lstart</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Loffset</name></cpp:undef>



<comment type="block">/* ========================================================================= */</comment>
<comment type="block">/*           Opcodes for the start of various parenthesized items            */</comment>
<comment type="block">/* ========================================================================= */</comment>

    <comment type="block">/* In all cases, if the result of RMATCH() is MATCH_THEN, check whether the
    (*THEN) is within the current branch by comparing the address of OP_THEN
    that is passed back with the end of the branch. If (*THEN) is within the
    current branch, and the branch is one of two or more alternatives (it
    either starts or ends with OP_ALT), we have reached the limit of THEN's
    action, so convert the return code to NOMATCH, which will cause normal
    backtracking to happen from now on. Otherwise, THEN is passed back to an
    outer alternative. This implements Perl's treatment of parenthesized
    groups, where a group not containing | does not affect the current
    alternative, that is, (X) is NOT the same as (X|(*F)). */</comment>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* BRAZERO, BRAMINZERO and SKIPZERO occur just before a non-possessive
    bracket group, indicating that it may occur zero times. It may repeat
    infinitely, or not at all - i.e. it could be ()* or ()? or even (){0} in
    the pattern. Brackets with fixed upper repeat limits are compiled as a
    number of copies, with the optional ones preceded by BRAZERO or BRAMINZERO.
    Possessive groups with possible zero repeats are preceded by BRAPOSZERO. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lnext_ecode</name></cpp:macro> <cpp:value>F-&gt;temp_sptr[0]</cpp:value></cpp:define>

    <case>case <expr><name>OP_BRAZERO</name></expr>:</case>
    <expr_stmt><expr><name>Lnext_ecode</name> <operator>=</operator> <name>Fecode</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Lnext_ecode</name></expr></argument>, <argument><expr><name>RM9</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>Lnext_ecode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Lnext_ecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>Lnext_ecode</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
    <expr_stmt><expr><name>Fecode</name> <operator>=</operator> <name>Lnext_ecode</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_BRAMINZERO</name></expr>:</case>
    <expr_stmt><expr><name>Lnext_ecode</name> <operator>=</operator> <name>Fecode</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>Lnext_ecode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Lnext_ecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>Lnext_ecode</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
    <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Lnext_ecode</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>, <argument><expr><name>RM10</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lnext_ecode</name></cpp:undef>

    <case>case <expr><name>OP_SKIPZERO</name></expr>:</case>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>Fecode</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Handle possessive brackets with an unlimited repeat. The end of these
    brackets will always be OP_KETRPOS, which returns MATCH_KETRPOS without
    going further in the pattern. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lframe_type</name></cpp:macro>    <cpp:value>F-&gt;temp_32[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lmatched_once</name></cpp:macro>  <cpp:value>F-&gt;temp_32[1]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lzero_allowed</name></cpp:macro>  <cpp:value>F-&gt;temp_32[2]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lstart_eptr</name></cpp:macro>    <cpp:value>F-&gt;temp_sptr[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lstart_group</name></cpp:macro>   <cpp:value>F-&gt;temp_sptr[1]</cpp:value></cpp:define>

    <case>case <expr><name>OP_BRAPOSZERO</name></expr>:</case>
    <expr_stmt><expr><name>Lzero_allowed</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>                <comment type="block">/* Zero repeat is allowed */</comment>
    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>Fecode</name> <operator>==</operator> <name>OP_CBRAPOS</name> <operator>||</operator> <operator>*</operator><name>Fecode</name> <operator>==</operator> <name>OP_SCBRAPOS</name></expr>)</condition><block type="pseudo"><block_content>
      <goto>goto <name>POSSESSIVE_CAPTURE</name>;</goto></block_content></block></if></if_stmt>
    <goto>goto <name>POSSESSIVE_NON_CAPTURE</name>;</goto>

    <case>case <expr><name>OP_BRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SBRAPOS</name></expr>:</case>
    <expr_stmt><expr><name>Lzero_allowed</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>               <comment type="block">/* Zero repeat not allowed */</comment>

    <label><name>POSSESSIVE_NON_CAPTURE</name>:</label>
    <expr_stmt><expr><name>Lframe_type</name> <operator>=</operator> <name>GF_NOCAPTURE</name></expr>;</expr_stmt>          <comment type="block">/* Remembered frame type */</comment>
    <goto>goto <name>POSSESSIVE_GROUP</name>;</goto>

    <case>case <expr><name>OP_CBRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SCBRAPOS</name></expr>:</case>
    <expr_stmt><expr><name>Lzero_allowed</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>               <comment type="block">/* Zero repeat not allowed */</comment>

    <label><name>POSSESSIVE_CAPTURE</name>:</label>
    <expr_stmt><expr><name>number</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lframe_type</name> <operator>=</operator> <name>GF_CAPTURE</name> <operator>|</operator> <name>number</name></expr>;</expr_stmt>   <comment type="block">/* Remembered frame type */</comment>

    <label><name>POSSESSIVE_GROUP</name>:</label>
    <expr_stmt><expr><name>Lmatched_once</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>               <comment type="block">/* Never matched */</comment>
    <expr_stmt><expr><name>Lstart_group</name> <operator>=</operator> <name>Fecode</name></expr>;</expr_stmt>               <comment type="block">/* Start of this group */</comment>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
      <block>{<block_content>
      <expr_stmt><expr><name>Lstart_eptr</name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt>               <comment type="block">/* Position at group start */</comment>
      <expr_stmt><expr><name>group_frame_type</name> <operator>=</operator> <name>Lframe_type</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>Fecode</name></expr>]</index></expr></argument>, <argument><expr><name>RM8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>==</operator> <name>MATCH_KETRPOS</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>Lmatched_once</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>            <comment type="block">/* Matched at least once */</comment>
        <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>==</operator> <name>Lstart_eptr</name></expr>)</condition>        <comment type="block">/* Empty match; skip to end */</comment>
          <block>{<block_content>
          <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>Fecode</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
          <break>break;</break>
          </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>Fecode</name> <operator>=</operator> <name>Lstart_group</name></expr>;</expr_stmt>
        <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* See comment above about handling THEN. */</comment>

      <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>==</operator> <name>MATCH_THEN</name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>next_ecode</name> <init>= <expr><name>Fecode</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>verb_ecode_ptr</name></name> <operator>&lt;</operator> <name>next_ecode</name> <operator>&amp;&amp;</operator>
            <operator>(</operator><operator>*</operator><name>Fecode</name> <operator>==</operator> <name>OP_ALT</name> <operator>||</operator> <operator>*</operator><name>next_ecode</name> <operator>==</operator> <name>OP_ALT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>rrc</name> <operator>=</operator> <name>MATCH_NOMATCH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>Fecode</name> <operator>!=</operator> <name>OP_ALT</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>

    <comment type="block">/* Success if matched something or zero repeat allowed */</comment>

    <if_stmt><if>if <condition>(<expr><name>Lmatched_once</name> <operator>||</operator> <name>Lzero_allowed</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lmatched_once</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lzero_allowed</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lframe_type</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lstart_eptr</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lstart_group</name></cpp:undef>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Handle non-capturing brackets that cannot match an empty string. When we
    get to the final alternative within the brackets, as long as there are no
    THEN's in the pattern, we can optimize by not recording a new backtracking
    point. (Ideally we should test for a THEN within this group, but we don't
    have that information.) Don't do this if we are at the very top level,
    however, because that would make handling assertions and once-only brackets
    messier when there is nothing to go back to. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lframe_type</name></cpp:macro> <cpp:value>F-&gt;temp_32[0]</cpp:value></cpp:define>     <comment type="block">/* Set for all that use GROUPLOOP */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lnext_branch</name></cpp:macro> <cpp:value>F-&gt;temp_sptr[0]</cpp:value></cpp:define>  <comment type="block">/* Used only in OP_BRA handling */</comment>

    <case>case <expr><name>OP_BRA</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>hasthen</name></name> <operator>||</operator> <name>Frdepth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>Lframe_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <goto>goto <name>GROUPLOOP</name>;</goto>
      </block_content>}</block></if></if_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
      <block>{<block_content>
      <expr_stmt><expr><name>Lnext_branch</name> <operator>=</operator> <name>Fecode</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>Lnext_branch</name> <operator>!=</operator> <name>OP_ALT</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

      <comment type="block">/* This is never the final branch. We do not need to test for MATCH_THEN
      here because this code is not used when there is a THEN in the pattern. */</comment>

      <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>Fecode</name></expr>]</index></expr></argument>, <argument><expr><name>RM1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>Fecode</name> <operator>=</operator> <name>Lnext_branch</name></expr>;</expr_stmt>
      </block_content>}</block></for>

    <comment type="block">/* Hit the start of the final branch. Continue at this level. */</comment>

    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>Fecode</name></expr>]</index></expr>;</expr_stmt>
    <break>break;</break>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lnext_branch</name></cpp:undef>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Handle a capturing bracket, other than those that are possessive with an
    unlimited repeat. */</comment>

    <case>case <expr><name>OP_CBRA</name></expr>:</case>
    <case>case <expr><name>OP_SCBRA</name></expr>:</case>
    <expr_stmt><expr><name>Lframe_type</name> <operator>=</operator> <name>GF_CAPTURE</name> <operator>|</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>GROUPLOOP</name>;</goto>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Atomic groups and non-capturing brackets that can match an empty string
    must record a backtracking point and also set up a chained frame. */</comment>

    <case>case <expr><name>OP_ONCE</name></expr>:</case>
    <case>case <expr><name>OP_SCRIPT_RUN</name></expr>:</case>
    <case>case <expr><name>OP_SBRA</name></expr>:</case>
    <expr_stmt><expr><name>Lframe_type</name> <operator>=</operator> <name>GF_NOCAPTURE</name> <operator>|</operator> <name>Fop</name></expr>;</expr_stmt>

    <label><name>GROUPLOOP</name>:</label>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
      <block>{<block_content>
      <expr_stmt><expr><name>group_frame_type</name> <operator>=</operator> <name>Lframe_type</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>Fecode</name></expr>]</index></expr></argument>, <argument><expr><name>RM2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>==</operator> <name>MATCH_THEN</name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>next_ecode</name> <init>= <expr><name>Fecode</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>verb_ecode_ptr</name></name> <operator>&lt;</operator> <name>next_ecode</name> <operator>&amp;&amp;</operator>
            <operator>(</operator><operator>*</operator><name>Fecode</name> <operator>==</operator> <name>OP_ALT</name> <operator>||</operator> <operator>*</operator><name>next_ecode</name> <operator>==</operator> <name>OP_ALT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>rrc</name> <operator>=</operator> <name>MATCH_NOMATCH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>Fecode</name> <operator>!=</operator> <name>OP_ALT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    <comment type="block">/* Control never reaches here. */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lframe_type</name></cpp:undef>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Recursion either matches the current regex, or some subexpression. The
    offset data is the offset to the starting bracket from the start of the
    whole pattern. (This is so that it works from duplicated subpatterns.) */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lframe_type</name></cpp:macro> <cpp:value>F-&gt;temp_32[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lstart_branch</name></cpp:macro> <cpp:value>F-&gt;temp_sptr[0]</cpp:value></cpp:define>

    <case>case <expr><name>OP_RECURSE</name></expr>:</case>
    <expr_stmt><expr><name>bracode</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_code</name></name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>number</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>bracode</name> <operator>==</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_code</name></name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>GET2</name><argument_list>(<argument><expr><name>bracode</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* If we are already in a recursion, check for repeating the same one
    without advancing the subject pointer. This should catch convoluted mutual
    recursions. (Some simple cases are caught at compile time.) */</comment>

    <if_stmt><if>if <condition>(<expr><name>Fcurrent_recurse</name> <operator>!=</operator> <name>RECURSE_UNSET</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>Flast_group_offset</name></expr>;</expr_stmt>
      <while>while <condition>(<expr><name>offset</name> <operator>!=</operator> <name>PCRE2_UNSET</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>N</name> <operator>=</operator> <operator>(</operator><name>heapframe</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>P</name> <operator>=</operator> <operator>(</operator><name>heapframe</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>N</name> <operator>-</operator> <name>frame_size</name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>N</name><operator>-&gt;</operator><name>group_frame_type</name></name> <operator>==</operator> <operator>(</operator><name>GF_RECURSE</name> <operator>|</operator> <name>number</name><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>==</operator> <name><name>P</name><operator>-&gt;</operator><name>eptr</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_RECURSELOOP</name></expr>;</return></block_content></block></if></if_stmt>
          <break>break;</break>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>P</name><operator>-&gt;</operator><name>last_group_offset</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Now run the recursion, branch by branch. */</comment>

    <expr_stmt><expr><name>Lstart_branch</name> <operator>=</operator> <name>bracode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Lframe_type</name> <operator>=</operator> <name>GF_RECURSE</name> <operator>|</operator> <name>number</name></expr>;</expr_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
      <block>{<block_content>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>next_ecode</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>group_frame_type</name> <operator>=</operator> <name>Lframe_type</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Lstart_branch</name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>Lstart_branch</name></expr>]</index></expr></argument>, <argument><expr><name>RM11</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>next_ecode</name> <operator>=</operator> <name>Lstart_branch</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Lstart_branch</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Handle backtracking verbs, which are defined in a range that can
      easily be tested for. PCRE does not allow THEN, SKIP, PRUNE or COMMIT to
      escape beyond a recursion; they cause a NOMATCH for the entire recursion.

      When one of these verbs triggers, the current recursion group number is
      recorded. If it matches the recursion we are processing, the verb
      happened within the recursion and we must deal with it. Otherwise it must
      have happened after the recursion completed, and so has to be passed
      back. See comment above about handling THEN. */</comment>

      <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>&gt;=</operator> <name>MATCH_BACKTRACK_MIN</name> <operator>&amp;&amp;</operator> <name>rrc</name> <operator>&lt;=</operator> <name>MATCH_BACKTRACK_MAX</name> <operator>&amp;&amp;</operator>
          <name><name>mb</name><operator>-&gt;</operator><name>verb_current_recurse</name></name> <operator>==</operator> <operator>(</operator><name>Lframe_type</name> <operator>^</operator> <name>GF_RECURSE</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>==</operator> <name>MATCH_THEN</name> <operator>&amp;&amp;</operator> <name><name>mb</name><operator>-&gt;</operator><name>verb_ecode_ptr</name></name> <operator>&lt;</operator> <name>next_ecode</name> <operator>&amp;&amp;</operator>
            <operator>(</operator><operator>*</operator><name>Lstart_branch</name> <operator>==</operator> <name>OP_ALT</name> <operator>||</operator> <operator>*</operator><name>next_ecode</name> <operator>==</operator> <name>OP_ALT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>rrc</name> <operator>=</operator> <name>MATCH_NOMATCH</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Note that carrying on after (*ACCEPT) in a recursion is handled in the
      OP_ACCEPT code. Nothing needs to be done here. */</comment>

      <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>Lstart_branch</name> <operator>=</operator> <name>next_ecode</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>Lstart_branch</name> <operator>!=</operator> <name>OP_ALT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    <comment type="block">/* Control never reaches here. */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lframe_type</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lstart_branch</name></cpp:undef>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Positive assertions are like other groups except that PCRE doesn't allow
    the effect of (*THEN) to escape beyond an assertion; it is therefore
    treated as NOMATCH. (*ACCEPT) is treated as successful assertion, with its
    captures and mark retained. Any other return is an error. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lframe_type</name></cpp:macro>  <cpp:value>F-&gt;temp_32[0]</cpp:value></cpp:define>

    <case>case <expr><name>OP_ASSERT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT_NA</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NA</name></expr>:</case>
    <expr_stmt><expr><name>Lframe_type</name> <operator>=</operator> <name>GF_NOCAPTURE</name> <operator>|</operator> <name>Fop</name></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
      <block>{<block_content>
      <expr_stmt><expr><name>group_frame_type</name> <operator>=</operator> <name>Lframe_type</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>Fecode</name></expr>]</index></expr></argument>, <argument><expr><name>RM3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>==</operator> <name>MATCH_ACCEPT</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>Fovector</name></expr></argument>,
              <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>assert_accept_frame</name> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>heapframe</name></expr></argument>, <argument><expr><name>ovector</name></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><name><name>assert_accept_frame</name><operator>-&gt;</operator><name>offset_top</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_SIZE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>Foffset_top</name> <operator>=</operator> <name><name>assert_accept_frame</name><operator>-&gt;</operator><name>offset_top</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>Fmark</name> <operator>=</operator> <name><name>assert_accept_frame</name><operator>-&gt;</operator><name>mark</name></name></expr>;</expr_stmt>
        <break>break;</break>
        </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name> <operator>&amp;&amp;</operator> <name>rrc</name> <operator>!=</operator> <name>MATCH_THEN</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>Fecode</name> <operator>!=</operator> <name>OP_ALT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>

    <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>Fecode</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lframe_type</name></cpp:undef>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Handle negative assertions. Loop for each non-matching branch as for
    positive assertions. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lframe_type</name></cpp:macro>  <cpp:value>F-&gt;temp_32[0]</cpp:value></cpp:define>

    <case>case <expr><name>OP_ASSERT_NOT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NOT</name></expr>:</case>
    <expr_stmt><expr><name>Lframe_type</name>  <operator>=</operator> <name>GF_NOCAPTURE</name> <operator>|</operator> <name>Fop</name></expr>;</expr_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
      <block>{<block_content>
      <expr_stmt><expr><name>group_frame_type</name> <operator>=</operator> <name>Lframe_type</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>Fecode</name></expr>]</index></expr></argument>, <argument><expr><name>RM4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <switch>switch<condition>(<expr><name>rrc</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>MATCH_ACCEPT</name></expr>:</case>   <comment type="block">/* Assertion matched, therefore it fails. */</comment>
        <case>case <expr><name>MATCH_MATCH</name></expr>:</case>
        <expr_stmt><expr><call><name>RRETURN</name> <argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <case>case <expr><name>MATCH_NOMATCH</name></expr>:</case>  <comment type="block">/* Branch failed, try next if present. */</comment>
        <case>case <expr><name>MATCH_THEN</name></expr>:</case>
        <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>Fecode</name> <operator>!=</operator> <name>OP_ALT</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>ASSERT_NOT_FAILED</name>;</goto></block_content></block></if></if_stmt>
        <break>break;</break>

        <case>case <expr><name>MATCH_COMMIT</name></expr>:</case>   <comment type="block">/* Assertion forced to fail, therefore continue. */</comment>
        <case>case <expr><name>MATCH_SKIP</name></expr>:</case>
        <case>case <expr><name>MATCH_PRUNE</name></expr>:</case>
        <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>Fecode</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
        <goto>goto <name>ASSERT_NOT_FAILED</name>;</goto>

        <default>default:</default>             <comment type="block">/* Pass back any other return */</comment>
        <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
      </block_content>}</block></for>

    <comment type="block">/* None of the branches have matched or there was a backtrack to (*COMMIT),
    (*SKIP), (*PRUNE), or (*THEN) in the last branch. This is success for a
    negative assertion, so carry on. */</comment>

    <label><name>ASSERT_NOT_FAILED</name>:</label>
    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lframe_type</name></cpp:undef>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* The callout item calls an external function, if one is provided, passing
    details of the match so far. This is mainly for debugging, though the
    function is able to force a failure. */</comment>

    <case>case <expr><name>OP_CALLOUT</name></expr>:</case>
    <case>case <expr><name>OP_CALLOUT_STR</name></expr>:</case>
    <expr_stmt><expr><name>rrc</name> <operator>=</operator> <call><name>do_callout</name><argument_list>(<argument><expr><name>F</name></expr></argument>, <argument><expr><name>mb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Conditional group: compilation checked that there are no more than two
    branches. If the condition is false, skipping the first branch takes us
    past the end of the item if there is only one branch, but that's exactly
    what we want. */</comment>

    <case>case <expr><name>OP_COND</name></expr>:</case>
    <case>case <expr><name>OP_SCOND</name></expr>:</case>

    <comment type="block">/* The variable Flength will be added to Fecode when the condition is
    false, to get to the second branch. Setting it to the offset to the ALT or
    KET, then incrementing Fecode achieves this effect. However, if the second
    branch is non-existent, we must point to the KET so that the end of the
    group is correctly processed. We now have Fecode pointing to the condition
    or callout. */</comment>

    <expr_stmt><expr><name>Flength</name> <operator>=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* Offset to the second branch */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>Fecode</name><index>[<expr><name>Flength</name></expr>]</index></name> <operator>!=</operator> <name>OP_ALT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Flength</name> <operator>-=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>     <comment type="block">/* From this opcode */</comment>

    <comment type="block">/* Because of the way auto-callout works during compile, a callout item is
    inserted between OP_COND and an assertion condition. Such a callout can
    also be inserted manually. */</comment>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>Fecode</name> <operator>==</operator> <name>OP_CALLOUT</name> <operator>||</operator> <operator>*</operator><name>Fecode</name> <operator>==</operator> <name>OP_CALLOUT_STR</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>rrc</name> <operator>=</operator> <call><name>do_callout</name><argument_list>(<argument><expr><name>F</name></expr></argument>, <argument><expr><name>mb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <comment type="block">/* Advance Fecode past the callout, so it now points to the condition. We
      must adjust Flength so that the value of Fecode+Flength is unchanged. */</comment>

      <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>Flength</name> <operator>-=</operator> <name>length</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Test the various possible conditions */</comment>

    <expr_stmt><expr><name>condition</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <switch>switch<condition>(<expr><operator>*</operator><name>Fecode</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>OP_RREF</name></expr>:</case>                  <comment type="block">/* Group recursion test */</comment>
      <if_stmt><if>if <condition>(<expr><name>Fcurrent_recurse</name> <operator>!=</operator> <name>RECURSE_UNSET</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>number</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>condition</name> <operator>=</operator> <operator>(</operator><name>number</name> <operator>==</operator> <name>RREF_ANY</name> <operator>||</operator> <name>number</name> <operator>==</operator> <name>Fcurrent_recurse</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_DNRREF</name></expr>:</case>       <comment type="block">/* Duplicate named group recursion test */</comment>
      <if_stmt><if>if <condition>(<expr><name>Fcurrent_recurse</name> <operator>!=</operator> <name>RECURSE_UNSET</name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>slot</name> <init>= <expr><name><name>mb</name><operator>-&gt;</operator><name>name_table</name></name> <operator>+</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>mb</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>count</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>number</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>condition</name> <operator>=</operator> <name>number</name> <operator>==</operator> <name>Fcurrent_recurse</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>condition</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>slot</name> <operator>+=</operator> <name><name>mb</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>
          </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_CREF</name></expr>:</case>                         <comment type="block">/* Numbered group used test */</comment>
      <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>  <comment type="block">/* Doubled ref number */</comment>
      <expr_stmt><expr><name>condition</name> <operator>=</operator> <name>offset</name> <operator>&lt;</operator> <name>Foffset_top</name> <operator>&amp;&amp;</operator> <name><name>Fovector</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>!=</operator> <name>PCRE2_UNSET</name></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_DNCREF</name></expr>:</case>      <comment type="block">/* Duplicate named group used test */</comment>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>slot</name> <init>= <expr><name><name>mb</name><operator>-&gt;</operator><name>name_table</name></name> <operator>+</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>mb</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>count</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><call><name>GET2</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>condition</name> <operator>=</operator> <name>offset</name> <operator>&lt;</operator> <name>Foffset_top</name> <operator>&amp;&amp;</operator> <name><name>Fovector</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>!=</operator> <name>PCRE2_UNSET</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>condition</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>slot</name> <operator>+=</operator> <name><name>mb</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>
          </block_content>}</block></while>
        </block_content>}</block>
      <break>break;</break>

      <case>case <expr><name>OP_FALSE</name></expr>:</case>
      <case>case <expr><name>OP_FAIL</name></expr>:</case>   <comment type="block">/* The assertion (?!) becomes OP_FAIL */</comment>
      <break>break;</break>

      <case>case <expr><name>OP_TRUE</name></expr>:</case>
      <expr_stmt><expr><name>condition</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/* The condition is an assertion. Run code similar to the assertion code
      above. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lpositive</name></cpp:macro>      <cpp:value>F-&gt;temp_32[0]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Lstart_branch</name></cpp:macro>  <cpp:value>F-&gt;temp_sptr[0]</cpp:value></cpp:define>

      <default>default:</default>
      <expr_stmt><expr><name>Lpositive</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>Fecode</name> <operator>==</operator> <name>OP_ASSERT</name> <operator>||</operator> <operator>*</operator><name>Fecode</name> <operator>==</operator> <name>OP_ASSERTBACK</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>Lstart_branch</name> <operator>=</operator> <name>Fecode</name></expr>;</expr_stmt>

      <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
        <expr_stmt><expr><name>group_frame_type</name> <operator>=</operator> <name>GF_CONDASSERT</name> <operator>|</operator> <operator>*</operator><name>Fecode</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Lstart_branch</name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>Lstart_branch</name></expr>]</index></expr></argument>, <argument><expr><name>RM5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <switch>switch<condition>(<expr><name>rrc</name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>MATCH_ACCEPT</name></expr>:</case>  <comment type="block">/* Save captures */</comment>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>Fovector</name></expr></argument>,
                <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>assert_accept_frame</name> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>heapframe</name></expr></argument>, <argument><expr><name>ovector</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name><name>assert_accept_frame</name><operator>-&gt;</operator><name>offset_top</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_SIZE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>Foffset_top</name> <operator>=</operator> <name><name>assert_accept_frame</name><operator>-&gt;</operator><name>offset_top</name></name></expr>;</expr_stmt>

          <comment type="block">/* Fall through */</comment>
          <comment type="block">/* In the case of a match, the captures have already been put into
          the current frame. */</comment>

          <case>case <expr><name>MATCH_MATCH</name></expr>:</case>
          <expr_stmt><expr><name>condition</name> <operator>=</operator> <name>Lpositive</name></expr>;</expr_stmt>   <comment type="block">/* TRUE for positive assertion */</comment>
          <break>break;</break>

          <comment type="block">/* PCRE doesn't allow the effect of (*THEN) to escape beyond an
          assertion; it is therefore always treated as NOMATCH. */</comment>

          <case>case <expr><name>MATCH_NOMATCH</name></expr>:</case>
          <case>case <expr><name>MATCH_THEN</name></expr>:</case>
          <expr_stmt><expr><name>Lstart_branch</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Lstart_branch</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>*</operator><name>Lstart_branch</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>  <comment type="block">/* Try next branch */</comment>
          <expr_stmt><expr><name>condition</name> <operator>=</operator> <operator>!</operator><name>Lpositive</name></expr>;</expr_stmt>  <comment type="block">/* TRUE for negative assertion */</comment>
          <break>break;</break>

          <comment type="block">/* These force no match without checking other branches. */</comment>

          <case>case <expr><name>MATCH_COMMIT</name></expr>:</case>
          <case>case <expr><name>MATCH_SKIP</name></expr>:</case>
          <case>case <expr><name>MATCH_PRUNE</name></expr>:</case>
          <expr_stmt><expr><name>condition</name> <operator>=</operator> <operator>!</operator><name>Lpositive</name></expr>;</expr_stmt>
          <break>break;</break>

          <default>default:</default>
          <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></switch>
        <break>break;</break>  <comment type="block">/* Out of the branch loop */</comment>
        </block_content>}</block></for>

      <comment type="block">/* If the condition is true, find the end of the assertion so that
      advancing past it gets us to the start of the first branch. */</comment>

      <if_stmt><if>if <condition>(<expr><name>condition</name></expr>)</condition>
        <block>{<block_content>
        <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>Fecode</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>  <comment type="block">/* End of assertion condition */</comment>
      </block_content>}</block></switch>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lpositive</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Lstart_branch</name></cpp:undef>

    <comment type="block">/* Choose branch according to the condition. */</comment>

    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <ternary><condition><expr><name>condition</name></expr>?</condition><then> <expr><call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>Fecode</name></expr>]</index></expr> </then><else>: <expr><name>Flength</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* If the opcode is OP_SCOND it means we are at a repeated conditional
    group that might match an empty string. We must therefore descend a level
    so that the start is remembered for checking. For OP_COND we can just
    continue at this level. */</comment>

    <if_stmt><if>if <condition>(<expr><name>Fop</name> <operator>==</operator> <name>OP_SCOND</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>group_frame_type</name>  <operator>=</operator> <name>GF_NOCAPTURE</name> <operator>|</operator> <name>Fop</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><name>RM35</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <break>break;</break>



<comment type="block">/* ========================================================================= */</comment>
<comment type="block">/*                  End of start of parenthesis opcodes                      */</comment>
<comment type="block">/* ========================================================================= */</comment>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Move the subject pointer back. This occurs only at the start of each
    branch of a lookbehind assertion. If we are too close to the start to move
    back, fail. When working with UTF-8 we move back a number of characters,
    not bytes. */</comment>

    <case>case <expr><name>OP_REVERSE</name></expr>:</case>
    <expr_stmt><expr><name>number</name> <operator>=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
      <block>{<block_content>
      <while>while <condition>(<expr><name>number</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>check_subject</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>Feptr</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BACKCHAR</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block></if>
    <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* No UTF-8 support, or not in UTF-8 mode: count is code unit count */</comment>

      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>number</name> <operator>&gt;</operator> <name>Feptr</name> <operator>-</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>Feptr</name> <operator>-=</operator> <name>number</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

    <comment type="block">/* Save the earliest consulted character, then skip to next opcode */</comment>

    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>start_used_ptr</name></name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* An alternation is the end of a branch; scan along to find the end of the
    bracketed group. */</comment>

    <case>case <expr><name>OP_ALT</name></expr>:</case>
    <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>Fecode</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
    <break>break;</break>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* The end of a parenthesized group. For all but OP_BRA and OP_COND, the
    starting frame was added to the chained frames in order to remember the
    starting subject position for the group. */</comment>

    <case>case <expr><name>OP_KET</name></expr>:</case>
    <case>case <expr><name>OP_KETRMIN</name></expr>:</case>
    <case>case <expr><name>OP_KETRMAX</name></expr>:</case>
    <case>case <expr><name>OP_KETRPOS</name></expr>:</case>

    <expr_stmt><expr><name>bracode</name> <operator>=</operator> <name>Fecode</name> <operator>-</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Point N to the frame at the start of the most recent group.
    Remember the subject pointer at the start of the group. */</comment>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>bracode</name> <operator>!=</operator> <name>OP_BRA</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>bracode</name> <operator>!=</operator> <name>OP_COND</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>N</name> <operator>=</operator> <operator>(</operator><name>heapframe</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name> <operator>+</operator> <name>Flast_group_offset</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>P</name> <operator>=</operator> <operator>(</operator><name>heapframe</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>N</name> <operator>-</operator> <name>frame_size</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>Flast_group_offset</name> <operator>=</operator> <name><name>P</name><operator>-&gt;</operator><name>last_group_offset</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SHOW_RMATCH</name></cpp:ifdef>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"++ KET for frame=%d type=%x prev char offset=%lu\n"</literal></expr></argument>,
        <argument><expr><name><name>N</name><operator>-&gt;</operator><name>rdepth</name></name></expr></argument>, <argument><expr><name><name>N</name><operator>-&gt;</operator><name>group_frame_type</name></name></expr></argument>,
        <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>P</name><operator>-&gt;</operator><name>eptr</name></name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <comment type="block">/* If we are at the end of an assertion that is a condition, return a
      match, discarding any intermediate backtracking points. Copy back the
      mark setting and the captures into the frame before N so that they are
      set on return. Doing this for all assertions, both positive and negative,
      seems to match what Perl does. */</comment>

      <if_stmt><if>if <condition>(<expr><call><name>GF_IDMASK</name><argument_list>(<argument><expr><name><name>N</name><operator>-&gt;</operator><name>group_frame_type</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>GF_CONDASSERT</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>P</name> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>heapframe</name></expr></argument>, <argument><expr><name>ovector</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Fovector</name></expr></argument>,
          <argument><expr><name>Foffset_top</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_SIZE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>offset_top</name></name> <operator>=</operator> <name>Foffset_top</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>mark</name></name> <operator>=</operator> <name>Fmark</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>Fback_frame</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>F</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>P</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_MATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>P</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>   <comment type="block">/* Indicates starting frame not recorded */</comment>

    <comment type="block">/* The group was not a conditional assertion. */</comment>

    <switch>switch <condition>(<expr><operator>*</operator><name>bracode</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>OP_BRA</name></expr>:</case>    <comment type="block">/* No need to do anything for these */</comment>
      <case>case <expr><name>OP_COND</name></expr>:</case>
      <case>case <expr><name>OP_SCOND</name></expr>:</case>
      <break>break;</break>

      <comment type="block">/* Non-atomic positive assertions are like OP_BRA, except that the
      subject pointer must be put back to where it was at the start of the
      assertion. */</comment>

      <case>case <expr><name>OP_ASSERT_NA</name></expr>:</case>
      <case>case <expr><name>OP_ASSERTBACK_NA</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>Feptr</name> <operator>=</operator> <name><name>P</name><operator>-&gt;</operator><name>eptr</name></name></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/* Atomic positive assertions are like OP_ONCE, except that in addition
      the subject pointer must be put back to where it was at the start of the
      assertion. */</comment>

      <case>case <expr><name>OP_ASSERT</name></expr>:</case>
      <case>case <expr><name>OP_ASSERTBACK</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>Feptr</name> <operator>=</operator> <name><name>P</name><operator>-&gt;</operator><name>eptr</name></name></expr>;</expr_stmt>
      <comment type="block">/* Fall through */</comment>

      <comment type="block">/* For an atomic group, discard internal backtracking points. We must
      also ensure that any remaining branches within the top-level of the group
      are not tried. Do this by adjusting the code pointer within the backtrack
      frame so that it points to the final branch. */</comment>

      <case>case <expr><name>OP_ONCE</name></expr>:</case>
      <expr_stmt><expr><name>Fback_frame</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>F</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>P</name><operator>)</operator></expr>;</expr_stmt>
      <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>y</name> <init>= <expr><call><name>GET</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>ecode</name></name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>P</name><operator>-&gt;</operator><name>ecode</name></name><operator>)</operator><index>[<expr><name>y</name></expr>]</index> <operator>!=</operator> <name>OP_ALT</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>ecode</name></name> <operator>+=</operator> <name>y</name></expr>;</expr_stmt>
        </block_content>}</block></for>
      <break>break;</break>

      <comment type="block">/* A matching negative assertion returns MATCH, which is turned into
      NOMATCH at the assertion level. */</comment>

      <case>case <expr><name>OP_ASSERT_NOT</name></expr>:</case>
      <case>case <expr><name>OP_ASSERTBACK_NOT</name></expr>:</case>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_MATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* At the end of a script run, apply the script-checking rules. This code
      will never by exercised if Unicode support it not compiled, because in
      that environment script runs cause an error at compile time. */</comment>

      <case>case <expr><name>OP_SCRIPT_RUN</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><call><name>PRIV</name><argument_list>(<argument><expr><name>script_run</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>eptr</name></name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/* Whole-pattern recursion is coded as a recurse into group 0, so it
      won't be picked up here. Instead, we catch it when the OP_END is reached.
      Other recursion is handled here. */</comment>

      <case>case <expr><name>OP_CBRA</name></expr>:</case>
      <case>case <expr><name>OP_CBRAPOS</name></expr>:</case>
      <case>case <expr><name>OP_SCBRA</name></expr>:</case>
      <case>case <expr><name>OP_SCBRAPOS</name></expr>:</case>
      <expr_stmt><expr><name>number</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>bracode</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Handle a recursively called group. We reinstate the previous set of
      captures and then carry on after the recursion call. */</comment>

      <if_stmt><if>if <condition>(<expr><name>Fcurrent_recurse</name> <operator>==</operator> <name>number</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>P</name> <operator>=</operator> <operator>(</operator><name>heapframe</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>N</name> <operator>-</operator> <name>frame_size</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>F</name> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>heapframe</name></expr></argument>, <argument><expr><name>ovector</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>ovector</name></name></expr></argument>,
          <argument><expr><name><name>P</name><operator>-&gt;</operator><name>offset_top</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_SIZE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>Foffset_top</name> <operator>=</operator> <name><name>P</name><operator>-&gt;</operator><name>offset_top</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>Fcapture_last</name> <operator>=</operator> <name><name>P</name><operator>-&gt;</operator><name>capture_last</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>Fcurrent_recurse</name> <operator>=</operator> <name><name>P</name><operator>-&gt;</operator><name>current_recurse</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>Fecode</name> <operator>=</operator> <name><name>P</name><operator>-&gt;</operator><name>ecode</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
        <continue>continue;</continue>  <comment type="block">/* With next opcode */</comment>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Deal with actual capturing. */</comment>

      <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>number</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>Fcapture_last</name> <operator>=</operator> <name>number</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>Fovector</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>=</operator> <name><name>P</name><operator>-&gt;</operator><name>eptr</name></name> <operator>-</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>Fovector</name><index>[<expr><name>offset</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>Feptr</name> <operator>-</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <name>Foffset_top</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Foffset_top</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
      </block_content>}</block></switch>  <comment type="block">/* End actions relating to the starting opcode */</comment>

    <comment type="block">/* OP_KETRPOS is a possessive repeating ket. Remember the current position,
    and return the MATCH_KETRPOS. This makes it possible to do the repeats one
    at a time from the outer level. This must precede the empty string test -
    in this case that test is done at the outer level. */</comment>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>Fecode</name> <operator>==</operator> <name>OP_KETRPOS</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>P</name> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>heapframe</name></expr></argument>, <argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>F</name> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>heapframe</name></expr></argument>, <argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><name>frame_copy_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_KETRPOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Handle the different kinds of closing brackets. A non-repeating ket
    needs no special action, just continuing at this level. This also happens
    for the repeating kets if the group matched no characters, in order to
    forcibly break infinite loops. Otherwise, the repeating kets try the rest
    of the pattern or restart from the preceding bracket, in the appropriate
    order. */</comment>

    <if_stmt><if>if <condition>(<expr><name>Fop</name> <operator>!=</operator> <name>OP_KET</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>P</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>Feptr</name> <operator>!=</operator> <name><name>P</name><operator>-&gt;</operator><name>eptr</name></name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>Fop</name> <operator>==</operator> <name>OP_KETRMIN</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>, <argument><expr><name>RM6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>Fecode</name> <operator>-=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>Fecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>   <comment type="block">/* End of ket processing */</comment>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Repeat the maximum number of times (KETRMAX) */</comment>

      <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>bracode</name></expr></argument>, <argument><expr><name>RM7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Carry on at this level for a non-repeating ket, or after matching an
    empty string, or after repeating for a maximum number of times. */</comment>

    <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Start and end of line assertions, not multiline mode. */</comment>

    <case>case <expr><name>OP_CIRC</name></expr>:</case>   <comment type="block">/* Start of line, unless PCRE2_NOTBOL is set. */</comment>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>!=</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_NOTBOL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_SOD</name></expr>:</case>    <comment type="block">/* Unconditional start of subject */</comment>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>!=</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* When PCRE2_NOTEOL is unset, assert before the subject end, or a
    terminating newline unless PCRE2_DOLLAR_ENDONLY is set. */</comment>

    <case>case <expr><name>OP_DOLL</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_NOTEOL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name> <operator>&amp;</operator> <name>PCRE2_DOLLAR_ENDONLY</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>ASSERT_NL_OR_EOS</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Fall through */</comment>
    <comment type="block">/* Unconditional end of subject assertion (\z) */</comment>

    <case>case <expr><name>OP_EOD</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>hitend</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_PARTIAL</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* End of subject or ending \n assertion (\Z) */</comment>

    <case>case <expr><name>OP_EODN</name></expr>:</case>
    <label><name>ASSERT_NL_OR_EOS</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator>
        <operator>(</operator><operator>!</operator><call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>Feptr</name> <operator>!=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>-</operator> <name><name>mb</name><operator>-&gt;</operator><name>nllen</name></name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
          <name>Feptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator>
          <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator>
          <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nllen</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
          <call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>hitend</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_PARTIAL</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Either at end of string or \n before end. */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>hitend</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_PARTIAL</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Start and end of line assertions, multiline mode. */</comment>

    <comment type="block">/* Start of subject unless notbol, or after any newline except for one at
    the very end, unless PCRE2_ALT_CIRCUMFLEX is set. */</comment>

    <case>case <expr><name>OP_CIRCM</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_NOTBOL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>Feptr</name> <operator>==</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>!=</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name> <operator>&amp;&amp;</operator>
        <operator>(</operator><operator>(</operator><name>Feptr</name> <operator>==</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator>
           <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name> <operator>&amp;</operator> <name>PCRE2_ALT_CIRCUMFLEX</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
         <operator>!</operator><call><name>WAS_NEWLINE</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* Assert before any newline, or before end of subject unless noteol is
    set. */</comment>

    <case>case <expr><name>OP_DOLLM</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&lt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name>Feptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator>
            <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator>
            <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nllen</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
            <call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>Feptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>hitend</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_PARTIAL</name></expr>;</return></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_NOTEOL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Start of match assertion */</comment>

    <case>case <expr><name>OP_SOM</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>!=</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name> <operator>+</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_offset</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Reset the start of match point */</comment>

    <case>case <expr><name>OP_SET_SOM</name></expr>:</case>
    <expr_stmt><expr><name>Fstart_match</name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>Fecode</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Word boundary assertions. Find out if the previous and current
    characters are "word" characters. It takes a bit more work in UTF mode.
    Characters &gt; 255 are assumed to be "non-word" characters when PCRE2_UCP is
    not set. When it is set, use Unicode properties if available, even when not
    in UTF mode. Remember the earliest and latest consulted characters. */</comment>

    <case>case <expr><name>OP_NOT_WORD_BOUNDARY</name></expr>:</case>
    <case>case <expr><name>OP_WORD_BOUNDARY</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>==</operator> <name><name>mb</name><operator>-&gt;</operator><name>check_subject</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>prev_is_word</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if> <else>else
      <block>{<block_content>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>lastptr</name> <init>= <expr><name>Feptr</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>BACKCHAR</name><argument_list>(<argument><expr><name>lastptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GETCHAR</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>lastptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
      <expr_stmt><expr><name>fc</name> <operator>=</operator> <operator>*</operator><name>lastptr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>lastptr</name> <operator>&lt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>start_used_ptr</name></name> <operator>=</operator> <name>lastptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>prev_is_word</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if> <else>else
          <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>cat</name> <init>= <expr><call><name>UCD_CATEGORY</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>prev_is_word</name> <operator>=</operator> <operator>(</operator><name>cat</name> <operator>==</operator> <name>ucp_L</name> <operator>||</operator> <name>cat</name> <operator>==</operator> <name>ucp_N</name><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
      <expr_stmt><expr><name>prev_is_word</name> <operator>=</operator> <call><name>CHMAX_255</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></else></if_stmt>

    <comment type="block">/* Get status of next character */</comment>

    <if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>SCHECK_PARTIAL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>cur_is_word</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>nextptr</name> <init>= <expr><name>Feptr</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>FORWARDCHARTEST</name><argument_list>(<argument><expr><name>nextptr</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>GETCHAR</name><argument_list>(<argument><expr><name>fc</name></expr></argument>, <argument><expr><name>Feptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
      <expr_stmt><expr><name>fc</name> <operator>=</operator> <operator>*</operator><name>Feptr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>nextptr</name> <operator>&gt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name> <operator>=</operator> <name>nextptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>fc</name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cur_is_word</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if> <else>else
          <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>cat</name> <init>= <expr><call><name>UCD_CATEGORY</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>cur_is_word</name> <operator>=</operator> <operator>(</operator><name>cat</name> <operator>==</operator> <name>ucp_L</name> <operator>||</operator> <name>cat</name> <operator>==</operator> <name>ucp_N</name><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
      <expr_stmt><expr><name>cur_is_word</name> <operator>=</operator> <call><name>CHMAX_255</name><argument_list>(<argument><expr><name>fc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>fc</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></else></if_stmt>

    <comment type="block">/* Now see if the situation is what we want */</comment>

    <if_stmt><if>if <condition>(<expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>Fecode</name><operator>++</operator> <operator>==</operator> <name>OP_WORD_BOUNDARY</name><operator>)</operator></expr>?</condition><then>
         <expr><name>cur_is_word</name> <operator>==</operator> <name>prev_is_word</name></expr> </then><else>: <expr><name>cur_is_word</name> <operator>!=</operator> <name>prev_is_word</name></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* Backtracking (*VERB)s, with and without arguments. Note that if the
    pattern is successfully matched, we do not come back from RMATCH. */</comment>

    <case>case <expr><name>OP_MARK</name></expr>:</case>
    <expr_stmt><expr><name>Fmark</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>nomatch_mark</name></name> <operator>=</operator> <name>Fecode</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>Fecode</name></expr>]</index> <operator>+</operator> <name><name>Fecode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>RM12</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* A return of MATCH_SKIP_ARG means that matching failed at SKIP with an
    argument, and we must check whether that argument matches this MARK's
    argument. It is passed back in mb-&gt;verb_skip_ptr. If it does match, we
    return MATCH_SKIP with mb-&gt;verb_skip_ptr now pointing to the subject
    position that corresponds to this mark. Otherwise, pass back the return
    code unaltered. */</comment>

    <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>==</operator> <name>MATCH_SKIP_ARG</name> <operator>&amp;&amp;</operator>
             <call><call><name>PRIV</name><argument_list>(<argument><expr><name>strcmp</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>Fecode</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>verb_skip_ptr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>verb_skip_ptr</name></name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt>   <comment type="block">/* Pass back current position */</comment>
      <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_SKIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <case>case <expr><name>OP_FAIL</name></expr>:</case>
    <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Record the current recursing group number in mb-&gt;verb_current_recurse
    when a backtracking return such as MATCH_COMMIT is given. This enables the
    recurse processing to catch verbs from within the recursion. */</comment>

    <case>case <expr><name>OP_COMMIT</name></expr>:</case>
    <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>Fecode</name></expr>]</index></expr></argument>, <argument><expr><name>RM13</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>verb_current_recurse</name></name> <operator>=</operator> <name>Fcurrent_recurse</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_COMMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <case>case <expr><name>OP_COMMIT_ARG</name></expr>:</case>
    <expr_stmt><expr><name>Fmark</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>nomatch_mark</name></name> <operator>=</operator> <name>Fecode</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>Fecode</name></expr>]</index> <operator>+</operator> <name><name>Fecode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>RM36</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>verb_current_recurse</name></name> <operator>=</operator> <name>Fcurrent_recurse</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_COMMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <case>case <expr><name>OP_PRUNE</name></expr>:</case>
    <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>Fecode</name></expr>]</index></expr></argument>, <argument><expr><name>RM14</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>verb_current_recurse</name></name> <operator>=</operator> <name>Fcurrent_recurse</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_PRUNE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <case>case <expr><name>OP_PRUNE_ARG</name></expr>:</case>
    <expr_stmt><expr><name>Fmark</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>nomatch_mark</name></name> <operator>=</operator> <name>Fecode</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>Fecode</name></expr>]</index> <operator>+</operator> <name><name>Fecode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>RM15</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>verb_current_recurse</name></name> <operator>=</operator> <name>Fcurrent_recurse</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_PRUNE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <case>case <expr><name>OP_SKIP</name></expr>:</case>
    <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>Fecode</name></expr>]</index></expr></argument>, <argument><expr><name>RM16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>verb_skip_ptr</name></name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt>   <comment type="block">/* Pass back current position */</comment>
    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>verb_current_recurse</name></name> <operator>=</operator> <name>Fcurrent_recurse</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_SKIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Note that, for Perl compatibility, SKIP with an argument does NOT set
    nomatch_mark. When a pattern match ends with a SKIP_ARG for which there was
    not a matching mark, we have to re-run the match, ignoring the SKIP_ARG
    that failed and any that precede it (either they also failed, or were not
    triggered). To do this, we maintain a count of executed SKIP_ARGs. If a
    SKIP_ARG gets to top level, the match is re-run with mb-&gt;ignore_skip_arg
    set to the count of the one that failed. */</comment>

    <case>case <expr><name>OP_SKIP_ARG</name></expr>:</case>
    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>skip_arg_count</name></name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>skip_arg_count</name></name> <operator>&lt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>ignore_skip_arg</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>Fecode</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>Fecode</name></expr>]</index> <operator>+</operator> <name><name>Fecode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>Fecode</name></expr>]</index> <operator>+</operator> <name><name>Fecode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>RM17</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Pass back the current skip name and return the special MATCH_SKIP_ARG
    return code. This will either be caught by a matching MARK, or get to the
    top, where it causes a rematch with mb-&gt;ignore_skip_arg set to the value of
    mb-&gt;skip_arg_count. */</comment>

    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>verb_skip_ptr</name></name> <operator>=</operator> <name>Fecode</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>verb_current_recurse</name></name> <operator>=</operator> <name>Fcurrent_recurse</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_SKIP_ARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* For THEN (and THEN_ARG) we pass back the address of the opcode, so that
    the branch in which it occurs can be determined. */</comment>

    <case>case <expr><name>OP_THEN</name></expr>:</case>
    <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>Fecode</name></expr>]</index></expr></argument>, <argument><expr><name>RM18</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>verb_ecode_ptr</name></name> <operator>=</operator> <name>Fecode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>verb_current_recurse</name></name> <operator>=</operator> <name>Fcurrent_recurse</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_THEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <case>case <expr><name>OP_THEN_ARG</name></expr>:</case>
    <expr_stmt><expr><name>Fmark</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>nomatch_mark</name></name> <operator>=</operator> <name>Fecode</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>Fecode</name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>Fecode</name></expr>]</index> <operator>+</operator> <name><name>Fecode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>RM19</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>rrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>verb_ecode_ptr</name></name> <operator>=</operator> <name>Fecode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>verb_current_recurse</name></name> <operator>=</operator> <name>Fcurrent_recurse</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>RRETURN</name><argument_list>(<argument><expr><name>MATCH_THEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/* ===================================================================== */</comment>
    <comment type="block">/* There's been some horrible disaster. Arrival here can only mean there is
    something seriously wrong in the code above or the OP_xxx definitions. */</comment>

    <default>default:</default>
    <return>return <expr><name>PCRE2_ERROR_INTERNAL</name></expr>;</return>
    </block_content>}</block></switch>

  <comment type="block">/* Do not insert any code in here without much thought; it is assumed
  that "continue" in the code above comes out to here to repeat the main
  loop. */</comment>

  </block_content>}</block></for>  <comment type="block">/* End of main loop */</comment>
<comment type="block">/* Control never reaches here */</comment>


<comment type="block">/* ========================================================================= */</comment>
<comment type="block">/* The RRETURN() macro jumps here. The number that is saved in Freturn_id
indicates which label we actually want to return to. The value in Frdepth is
the index number of the frame in the vector. The return value has been placed
in rrc. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LBL</name><parameter_list>(<parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case val: goto L_RM##val;</cpp:value></cpp:define>

<label><name>RETURN_SWITCH</name>:</label>
<if_stmt><if>if <condition>(<expr><name>Feptr</name> <operator>&gt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name> <operator>=</operator> <name>Feptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>Frdepth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rrc</name></expr>;</return></block_content></block></if></if_stmt>                     <comment type="block">/* Exit from the top level */</comment>
<expr_stmt><expr><name>F</name> <operator>=</operator> <operator>(</operator><name>heapframe</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>F</name> <operator>-</operator> <name>Fback_frame</name><operator>)</operator></expr>;</expr_stmt>       <comment type="block">/* Backtrack */</comment>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>cb</name><operator>-&gt;</operator><name>callout_flags</name></name> <operator>|=</operator> <name>PCRE2_CALLOUT_BACKTRACK</name></expr>;</expr_stmt> <comment type="block">/* Note for callouts */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SHOW_RMATCH</name></cpp:ifdef>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"++ RETURN %d to %d\n"</literal></expr></argument>, <argument><expr><name>rrc</name></expr></argument>, <argument><expr><name>Freturn_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<switch>switch <condition>(<expr><name>Freturn_id</name></expr>)</condition>
  <block>{<block_content>
  <macro><name>LBL</name><argument_list>( <argument><literal type="number">1</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>( <argument><literal type="number">2</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>( <argument><literal type="number">3</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>( <argument><literal type="number">4</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>( <argument><literal type="number">5</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>( <argument><literal type="number">6</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>( <argument><literal type="number">7</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>( <argument><literal type="number">8</literal></argument>)</argument_list></macro>
  <macro><name>LBL</name><argument_list>( <argument><literal type="number">9</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">10</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">11</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">12</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">13</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">14</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">15</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">16</literal></argument>)</argument_list></macro>
  <macro><name>LBL</name><argument_list>(<argument><literal type="number">17</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">18</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">19</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">20</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">21</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">22</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">23</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">24</literal></argument>)</argument_list></macro>
  <macro><name>LBL</name><argument_list>(<argument><literal type="number">25</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">26</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">27</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">28</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">29</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">30</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">31</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">32</literal></argument>)</argument_list></macro>
  <macro><name>LBL</name><argument_list>(<argument><literal type="number">33</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">34</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">35</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">36</literal></argument>)</argument_list></macro>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>
  <macro><name>LBL</name><argument_list>(<argument><literal type="number">100</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">101</literal></argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <macro><name>LBL</name><argument_list>(<argument><literal type="number">200</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">201</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">202</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">203</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">204</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">205</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">206</literal></argument>)</argument_list></macro>
  <macro><name>LBL</name><argument_list>(<argument><literal type="number">207</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">208</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">209</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">210</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">211</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">212</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">213</literal></argument>)</argument_list></macro>
  <macro><name>LBL</name><argument_list>(<argument><literal type="number">214</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">215</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">216</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">217</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">218</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">219</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">220</literal></argument>)</argument_list></macro>
  <macro><name>LBL</name><argument_list>(<argument><literal type="number">221</literal></argument>)</argument_list></macro> <macro><name>LBL</name><argument_list>(<argument><literal type="number">222</literal></argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <default>default:</default>
  <return>return <expr><name>PCRE2_ERROR_INTERNAL</name></expr>;</return>
  </block_content>}</block></switch>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LBL</name></cpp:undef>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*           Match a Regular Expression           *
*************************************************/</comment>

<comment type="block">/* This function applies a compiled pattern to a subject string and picks out
portions of the string if it matches. Two elements in the vector are set for
each substring: the offsets to the start and end of the substring.

Arguments:
  code            points to the compiled expression
  subject         points to the subject string
  length          length of subject string (may contain binary zeros)
  start_offset    where to start in the subject string
  options         option bits
  match_data      points to a match_data block
  mcontext        points a PCRE2 context

Returns:          &gt; 0 =&gt; success; value is the number of ovector pairs filled
                  = 0 =&gt; success, but ovector is not big enough
                  = -1 =&gt; failed to match (PCRE2_ERROR_NOMATCH)
                  = -2 =&gt; partial match (PCRE2_ERROR_PARTIAL)
                  &lt; -2 =&gt; some kind of unexpected problem
*/</comment>

<function><type><name>PCRE2_EXP_DEFN</name> <name>int</name> <name>PCRE2_CALL_CONVENTION</name></type>
<name>pcre2_match</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pcre2_code</name> <modifier>*</modifier></type><name>code</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>subject</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>length</name></decl></parameter>,
  <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>start_offset</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>pcre2_match_data</name> <modifier>*</modifier></type><name>match_data</name></decl></parameter>,
  <parameter><decl><type><name>pcre2_match_context</name> <modifier>*</modifier></type><name>mcontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>was_zero_terminated</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>start_bits</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>pcre2_real_code</name> <modifier>*</modifier></type><name>re</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>pcre2_real_code</name> <operator>*</operator><operator>)</operator><name>code</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>BOOL</name></type> <name>anchored</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>firstline</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>has_first_cu</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>has_req_cu</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>startline</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<decl_stmt><decl><type><name>BOOL</name></type> <name>memchr_not_found_first_cu</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>memchr_not_found_first_cu2</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>first_cu</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>first_cu2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>req_cu</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>req_cu2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>bumpalong_limit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>end_subject</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>true_end_subject</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>start_match</name> <init>= <expr><name>subject</name> <operator>+</operator> <name>start_offset</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>req_cu_ptr</name> <init>= <expr><name>start_match</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>start_partial</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>match_partial</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_JIT</name></cpp:ifdef>
<decl_stmt><decl><type><name>BOOL</name></type> <name>use_jit</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* This flag is needed even when Unicode is not supported for convenience
(it is used by the IS_NEWLINE macro). */</comment>

<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<decl_stmt><decl><type><name>BOOL</name></type> <name>ucp</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>allow_invalid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>fragment_options</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_JIT</name></cpp:ifdef>
<decl_stmt><decl><type><name>BOOL</name></type> <name>jit_checked_utf</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>frame_size</name></decl>;</decl_stmt>

<comment type="block">/* We need to have mb as a pointer to a match block, because the IS_NEWLINE
macro is used below, and it expects NLBLOCK to be defined as a pointer. */</comment>

<decl_stmt><decl><type><name>pcre2_callout_block</name></type> <name>cb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>match_block</name></type> <name>actual_match_block</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>match_block</name> <modifier>*</modifier></type><name>mb</name> <init>= <expr><operator>&amp;</operator><name>actual_match_block</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Allocate an initial vector of backtracking frames on the stack. If this
proves to be too small, it is replaced by a larger one on the heap. To get a
vector of the size required that is aligned for pointers, allocate it as a
vector of pointers. */</comment>

<decl_stmt><decl><type><name>PCRE2_SPTR</name> <name><name>stack_frames_vector</name><index>[<expr><name>START_FRAMES_SIZE</name><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_SPTR</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></type>
    <name>PCRE2_KEEP_UNINITIALIZED</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>stack_frames</name></name> <operator>=</operator> <operator>(</operator><name>heapframe</name> <operator>*</operator><operator>)</operator><name>stack_frames_vector</name></expr>;</expr_stmt>

<comment type="block">/* A length equal to PCRE2_ZERO_TERMINATED implies a zero-terminated
subject string. */</comment>

<if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <name>PCRE2_ZERO_TERMINATED</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>length</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>strlen</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>subject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>was_zero_terminated</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>true_end_subject</name> <operator>=</operator> <name>end_subject</name> <operator>=</operator> <name>subject</name> <operator>+</operator> <name>length</name></expr>;</expr_stmt>

<comment type="block">/* Plausibility checks */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <operator>~</operator><name>PUBLIC_MATCH_OPTIONS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_BADOPTION</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>code</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>subject</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>match_data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>PCRE2_ERROR_NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>start_offset</name> <operator>&gt;</operator> <name>length</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_BADOFFSET</name></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* Check that the first field in the block is the magic number. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>magic_number</name></name> <operator>!=</operator> <name>MAGIC_NUMBER</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_BADMAGIC</name></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* Check the code unit width. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_MODE_MASK</name><operator>)</operator> <operator>!=</operator> <name>PCRE2_CODE_UNIT_WIDTH</name><operator>/</operator><literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>PCRE2_ERROR_BADMODE</name></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* PCRE2_NOTEMPTY and PCRE2_NOTEMPTY_ATSTART are match-time flags in the
options variable for this function. Users of PCRE2 who are not calling the
function directly would like to have a way of setting these flags, in the same
way that they can set pcre2_compile() flags like PCRE2_NO_AUTOPOSSESS with
constructions like (*NO_AUTOPOSSESS). To enable this, (*NOTEMPTY) and
(*NOTEMPTY_ATSTART) set bits in the pattern's "flag" function which we now
transfer to the options for this function. The bits are guaranteed to be
adjacent, but do not have the same values. This bit of Boolean trickery assumes
that the match-time bits are not more significant than the flag bits. If by
accident this is not the case, a compile-time division by zero error will
occur. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FF</name></cpp:macro> <cpp:value>(PCRE2_NOTEMPTY_SET|PCRE2_NE_ATST_SET)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OO</name></cpp:macro> <cpp:value>(PCRE2_NOTEMPTY|PCRE2_NOTEMPTY_ATSTART)</cpp:value></cpp:define>
<expr_stmt><expr><name>options</name> <operator>|=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>FF</name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>FF</name> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><name>FF</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <operator>(</operator><name>OO</name> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><name>OO</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FF</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OO</name></cpp:undef>

<comment type="block">/* If the pattern was successfully studied with JIT support, we will run the
JIT executable instead of the rest of this function. Most options must be set
at compile time for the JIT code to be usable. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_JIT</name></cpp:ifdef>
<expr_stmt><expr><name>use_jit</name> <operator>=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>executable_jit</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
          <operator>(</operator><name>options</name> <operator>&amp;</operator> <operator>~</operator><name>PUBLIC_JIT_MATCH_OPTIONS</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Initialize UTF/UCP parameters. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<expr_stmt><expr><name>utf</name> <operator>=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>allow_invalid</name> <operator>=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_MATCH_INVALID_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ucp</name> <operator>=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

<comment type="block">/* Convert the partial matching flags into an integer. */</comment>

<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_PARTIAL_HARD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>:
              <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_PARTIAL_SOFT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>

<comment type="block">/* Partial matching and PCRE2_ENDANCHORED are currently not allowed at the same
time. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
   <operator>(</operator><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>|</operator> <name>options</name><operator>)</operator> <operator>&amp;</operator> <name>PCRE2_ENDANCHORED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>PCRE2_ERROR_BADOPTION</name></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* It is an error to set an offset limit without setting the flag at compile
time. */</comment>

<if_stmt><if>if <condition>(<expr><name>mcontext</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>mcontext</name><operator>-&gt;</operator><name>offset_limit</name></name> <operator>!=</operator> <name>PCRE2_UNSET</name> <operator>&amp;&amp;</operator>
     <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_USE_OFFSET_LIMIT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>PCRE2_ERROR_BADOFFSETLIMIT</name></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* If the match data block was previously used with PCRE2_COPY_MATCHED_SUBJECT,
free the memory that was obtained. Set the field to NULL for no match cases. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>match_data</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_MD_COPIED_SUBJECT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name><name>match_data</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>free</name></name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>match_data</name><operator>-&gt;</operator><name>subject</name></name></expr></argument>,
    <argument><expr><name><name>match_data</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>PCRE2_MD_COPIED_SUBJECT</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>subject</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<comment type="block">/* Zero the error offset in case the first code unit is invalid UTF. */</comment>

<expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>startchar</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<comment type="block">/* ============================= JIT matching ============================== */</comment>

<comment type="block">/* Prepare for JIT matching. Check a UTF string for validity unless no check is
requested or invalid UTF can be handled. We check only the portion of the
subject that might be be inspected during matching - from the offset minus the
maximum lookbehind to the given length. This saves time when a small part of a
large subject is being matched by the use of a starting offset. Note that the
maximum lookbehind is a number of characters, not code units. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_JIT</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>use_jit</name></expr>)</condition>
  <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NO_UTF_CHECK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>allow_invalid</name></expr>)</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* For 8-bit and 16-bit UTF, check that the first code unit is a valid
    character start. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>start_match</name> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator> <call><name>NOT_FIRSTCU</name><argument_list>(<argument><expr><operator>*</operator><name>start_match</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>start_offset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_BADUTFOFFSET</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
      <return>return <expr><name>PCRE2_ERROR_UTF8_ERR20</name></expr>;</return>  <comment type="block">/* Isolated 0x80 byte */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <return>return <expr><name>PCRE2_ERROR_UTF16_ERR3</name></expr>;</return>  <comment type="block">/* Isolated low surrogate */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* WIDTH != 32 */</comment>

    <comment type="block">/* Move back by the maximum lookbehind, just in case it happens at the very
    start of matching. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>max_lookbehind</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>start_match</name> <operator>&gt;</operator> <name>subject</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
      <block>{<block_content>
      <expr_stmt><expr><name>start_match</name><operator>--</operator></expr>;</expr_stmt>
      <while>while <condition>(<expr><name>start_match</name> <operator>&gt;</operator> <name>subject</name> <operator>&amp;&amp;</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
      <operator>(</operator><operator>*</operator><name>start_match</name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* 16-bit */</comment>
      <expr_stmt><expr><operator>(</operator><operator>*</operator><name>start_match</name> <operator>&amp;</operator> <literal type="number">0xfc00</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xdc00</literal></expr></expr_stmt></block_content></block></while>)</block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        start_match--</block><empty_stmt>;</empty_stmt></for>
      </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* PCRE2_CODE_UNIT_WIDTH != 32 */</comment>

    <comment type="block">/* In the 32-bit library, one code unit equals one character. However,
    we cannot just subtract the lookbehind and then compare pointers, because
    a very large lookbehind could create an invalid pointer. */</comment>

    <if_stmt><if>if <condition>(<expr><name>start_offset</name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>max_lookbehind</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>start_match</name> <operator>-=</operator> <name><name>re</name><operator>-&gt;</operator><name>max_lookbehind</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>start_match</name> <operator>=</operator> <name>subject</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* PCRE2_CODE_UNIT_WIDTH != 32 */</comment>

    <comment type="block">/* Validate the relevant portion of the subject. Adjust the offset of an
    invalid code point to be an absolute offset in the whole string. */</comment>

    <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>valid_utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>start_match</name></expr></argument>,
      <argument><expr><name>length</name> <operator>-</operator> <operator>(</operator><name>start_match</name> <operator>-</operator> <name>subject</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>match_data</name><operator>-&gt;</operator><name>startchar</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>match_data</name><operator>-&gt;</operator><name>rc</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>startchar</name></name> <operator>+=</operator> <name>start_match</name> <operator>-</operator> <name>subject</name></expr>;</expr_stmt>
      <return>return <expr><name><name>match_data</name><operator>-&gt;</operator><name>rc</name></name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>jit_checked_utf</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

  <comment type="block">/* If JIT returns BADOPTION, which means that the selected complete or
  partial matching mode was not compiled, fall through to the interpreter. */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pcre2_jit_match</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>subject</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>start_offset</name></expr></argument>, <argument><expr><name>options</name></expr></argument>,
    <argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PCRE2_ERROR_JIT_BADOPTION</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_COPY_MATCHED_SUBJECT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>CU2BYTES</name><argument_list>(<argument><expr><name>length</name> <operator>+</operator> <name>was_zero_terminated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>subject</name></name> <operator>=</operator> <call><name><name>match_data</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>malloc</name></name><argument_list>(<argument><expr><name>length</name></expr></argument>,
        <argument><expr><name><name>match_data</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>match_data</name><operator>-&gt;</operator><name>subject</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>match_data</name><operator>-&gt;</operator><name>subject</name></name></expr></argument>, <argument><expr><name>subject</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PCRE2_MD_COPIED_SUBJECT</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_JIT */</comment>

<comment type="block">/* ========================= End of JIT matching ========================== */</comment>


<comment type="block">/* Proceed with non-JIT matching. The default is to allow lookbehinds to the
start of the subject. A UTF check when there is a non-zero offset may change
this. */</comment>

<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>check_subject</name></name> <operator>=</operator> <name>subject</name></expr>;</expr_stmt>

<comment type="block">/* If a UTF subject string was not checked for validity in the JIT code above,
check it here, and handle support for invalid UTF strings. The check above
happens only when invalid UTF is not supported and PCRE2_NO_CHECK_UTF is unset.
If we get here in those circumstances, it means the subject string is valid,
but for some reason JIT matching was not successful. There is no need to check
the subject again.

We check only the portion of the subject that might be be inspected during
matching - from the offset minus the maximum lookbehind to the given length.
This saves time when a small part of a large subject is being matched by the
use of a starting offset. Note that the maximum lookbehind is a number of
characters, not code units.

Note also that support for invalid UTF forces a check, overriding the setting
of PCRE2_NO_CHECK_UTF. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_JIT</name></cpp:ifdef>
    <operator>!</operator><name>jit_checked_utf</name> <operator>&amp;&amp;</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NO_UTF_CHECK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>allow_invalid</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>skipped_bad_start</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* For 8-bit and 16-bit UTF, check that the first code unit is a valid
  character start. If we are handling invalid UTF, just skip over such code
  units. Otherwise, give an appropriate error. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>allow_invalid</name></expr>)</condition>
    <block>{<block_content>
    <while>while <condition>(<expr><name>start_match</name> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator> <call><name>NOT_FIRSTCU</name><argument_list>(<argument><expr><operator>*</operator><name>start_match</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>start_match</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>skipped_bad_start</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>start_match</name> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator> <call><name>NOT_FIRSTCU</name><argument_list>(<argument><expr><operator>*</operator><name>start_match</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>start_offset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_BADUTFOFFSET</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <return>return <expr><name>PCRE2_ERROR_UTF8_ERR20</name></expr>;</return>  <comment type="block">/* Isolated 0x80 byte */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><name>PCRE2_ERROR_UTF16_ERR3</name></expr>;</return>  <comment type="block">/* Isolated low surrogate */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* WIDTH != 32 */</comment>

  <comment type="block">/* The mb-&gt;check_subject field points to the start of UTF checking;
  lookbehinds can go back no further than this. */</comment>

  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>check_subject</name></name> <operator>=</operator> <name>start_match</name></expr>;</expr_stmt>

  <comment type="block">/* Move back by the maximum lookbehind, just in case it happens at the very
  start of matching, but don't do this if we skipped bad 8-bit or 16-bit code
  units above. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>skipped_bad_start</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>max_lookbehind</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>mb</name><operator>-&gt;</operator><name>check_subject</name></name> <operator>&gt;</operator> <name>subject</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
      <block>{<block_content>
      <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>check_subject</name></name><operator>--</operator></expr>;</expr_stmt>
      <while>while <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>check_subject</name></name> <operator>&gt;</operator> <name>subject</name> <operator>&amp;&amp;</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
      <operator>(</operator><operator>*</operator><name><name>mb</name><operator>-&gt;</operator><name>check_subject</name></name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* 16-bit */</comment>
      <expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>mb</name><operator>-&gt;</operator><name>check_subject</name></name> <operator>&amp;</operator> <literal type="number">0xfc00</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xdc00</literal></expr></expr_stmt></block_content></block></while>)</block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        mb-&gt;check_subject--</block><empty_stmt>;</empty_stmt></for>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* PCRE2_CODE_UNIT_WIDTH != 32 */</comment>

  <comment type="block">/* In the 32-bit library, one code unit equals one character. However,
  we cannot just subtract the lookbehind and then compare pointers, because
  a very large lookbehind could create an invalid pointer. */</comment>

  <if_stmt><if>if <condition>(<expr><name>start_offset</name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>max_lookbehind</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>check_subject</name></name> <operator>-=</operator> <name><name>re</name><operator>-&gt;</operator><name>max_lookbehind</name></name></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>check_subject</name></name> <operator>=</operator> <name>subject</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* PCRE2_CODE_UNIT_WIDTH != 32 */</comment>

  <comment type="block">/* Validate the relevant portion of the subject. There's a loop in case we
  encounter bad UTF in the characters preceding start_match which we are
  scanning because of a lookbehind. */</comment>

  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
    <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>valid_utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name><name>mb</name><operator>-&gt;</operator><name>check_subject</name></name></expr></argument>,
      <argument><expr><name>length</name> <operator>-</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>check_subject</name></name> <operator>-</operator> <name>subject</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>match_data</name><operator>-&gt;</operator><name>startchar</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>match_data</name><operator>-&gt;</operator><name>rc</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>   <comment type="block">/* Valid UTF string */</comment>

    <comment type="block">/* Invalid UTF string. Adjust the offset to be an absolute offset in the
    whole string. If we are handling invalid UTF strings, set end_subject to
    stop before the bad code unit, and set the options to "not end of line".
    Otherwise return the error. */</comment>

    <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>startchar</name></name> <operator>+=</operator> <name><name>mb</name><operator>-&gt;</operator><name>check_subject</name></name> <operator>-</operator> <name>subject</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>allow_invalid</name> <operator>||</operator> <name><name>match_data</name><operator>-&gt;</operator><name>rc</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>match_data</name><operator>-&gt;</operator><name>rc</name></name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>end_subject</name> <operator>=</operator> <name>subject</name> <operator>+</operator> <name><name>match_data</name><operator>-&gt;</operator><name>startchar</name></name></expr>;</expr_stmt>

    <comment type="block">/* If the end precedes start_match, it means there is invalid UTF in the
    extra code units we reversed over because of a lookbehind. Advance past the
    first bad code unit, and then skip invalid character starting code units in
    8-bit and 16-bit modes, and try again. */</comment>

    <if_stmt><if>if <condition>(<expr><name>end_subject</name> <operator>&lt;</operator> <name>start_match</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>check_subject</name></name> <operator>=</operator> <name>end_subject</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
      <while>while <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>check_subject</name></name> <operator>&lt;</operator> <name>start_match</name> <operator>&amp;&amp;</operator> <call><name>NOT_FIRSTCU</name><argument_list>(<argument><expr><operator>*</operator><name><name>mb</name><operator>-&gt;</operator><name>check_subject</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>check_subject</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if>

    <comment type="block">/* Otherwise, set the not end of line option, and do the match. */</comment>

    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name>fragment_options</name> <operator>=</operator> <name>PCRE2_NOTEOL</name></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

<comment type="block">/* A NULL match context means "use a default context", but we take the memory
control functions from the pattern. */</comment>

if <expr_stmt><expr><operator>(</operator><name>mcontext</name> <operator>==</operator> <name>NULL</name><operator>)</operator>
  <block>{
  <expr><name>mcontext</name> <operator>=</operator> <operator>(</operator><name>pcre2_match_context</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>default_match_context</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;
  <expr><name><name>mb</name><operator>-&gt;</operator><name>memctl</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>memctl</name></name></expr>;
  }</block></expr></expr_stmt>
<if_stmt><else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>memctl</name></name> <operator>=</operator> <name><name>mcontext</name><operator>-&gt;</operator><name>memctl</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>anchored</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>|</operator> <name>options</name><operator>)</operator> <operator>&amp;</operator> <name>PCRE2_ANCHORED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>firstline</name> <operator>=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_FIRSTLINE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>startline</name> <operator>=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_STARTLINE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>bumpalong_limit</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>mcontext</name><operator>-&gt;</operator><name>offset_limit</name></name> <operator>==</operator> <name>PCRE2_UNSET</name><operator>)</operator></expr>?</condition><then>
  <expr><name>true_end_subject</name></expr> </then><else>: <expr><name>subject</name> <operator>+</operator> <name><name>mcontext</name><operator>-&gt;</operator><name>offset_limit</name></name></expr></else></ternary></expr>;</expr_stmt>

<comment type="block">/* Initialize and set up the fixed fields in the callout block, with a pointer
in the match block. */</comment>

<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>cb</name></name> <operator>=</operator> <operator>&amp;</operator><name>cb</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>version</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>subject</name></name> <operator>=</operator> <name>subject</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>subject_length</name></name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>end_subject</name> <operator>-</operator> <name>subject</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>callout_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<comment type="block">/* Fill in the remaining fields in the match block, except for moptions, which
gets set later. */</comment>

<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>callout</name></name> <operator>=</operator> <name><name>mcontext</name><operator>-&gt;</operator><name>callout</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>callout_data</name></name> <operator>=</operator> <name><name>mcontext</name><operator>-&gt;</operator><name>callout_data</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name> <operator>=</operator> <name>subject</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>start_offset</name></name> <operator>=</operator> <name>start_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>=</operator> <name>end_subject</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>hasthen</name></name> <operator>=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_HASTHEN</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>allowemptypartial</name></name> <operator>=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>max_lookbehind</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
    <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_MATCH_EMPTY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name></expr>;</expr_stmt>          <comment type="block">/* Pattern options */</comment>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>ignore_skip_arg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>mark</name></name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>nomatch_mark</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>          <comment type="block">/* In case never set */</comment>

<comment type="block">/* The name table is needed for finding all the numbers associated with a
given name, for condition testing. The code follows the name table. */</comment>

<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>name_table</name></name> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>re</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pcre2_real_code</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>name_count</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>name_count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>name_entry_size</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>start_code</name></name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>name_table</name></name> <operator>+</operator> <name><name>re</name><operator>-&gt;</operator><name>name_count</name></name> <operator>*</operator> <name><name>re</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>

<comment type="block">/* Process the \R and newline settings. */</comment>

<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>bsr_convention</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>bsr_convention</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nltype</name></name> <operator>=</operator> <name>NLTYPE_FIXED</name></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>newline_convention</name></name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><name>PCRE2_NEWLINE_CR</name></expr>:</case>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nllen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_CR</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>PCRE2_NEWLINE_LF</name></expr>:</case>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nllen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_NL</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>PCRE2_NEWLINE_NUL</name></expr>:</case>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nllen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_NUL</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>PCRE2_NEWLINE_CRLF</name></expr>:</case>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nllen</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_CR</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_NL</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>PCRE2_NEWLINE_ANY</name></expr>:</case>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nltype</name></name> <operator>=</operator> <name>NLTYPE_ANY</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>PCRE2_NEWLINE_ANYCRLF</name></expr>:</case>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nltype</name></name> <operator>=</operator> <name>NLTYPE_ANYCRLF</name></expr>;</expr_stmt>
  <break>break;</break>

  <default>default:</default> <return>return <expr><name>PCRE2_ERROR_INTERNAL</name></expr>;</return>
  </block_content>}</block></switch>

<comment type="block">/* The backtracking frames have fixed data at the front, and a PCRE2_SIZE
vector at the end, whose size depends on the number of capturing parentheses in
the pattern. It is not used at all if there are no capturing parentheses.

  frame_size             is the total size of each frame
  mb-&gt;frame_vector_size  is the total usable size of the vector (rounded down
                           to a whole number of frames)

The last of these is changed within the match() function if the frame vector
has to be expanded. We therefore put it into the match block so that it is
correct when calling match() more than once for non-anchored patterns. */</comment>

<expr_stmt><expr><name>frame_size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>heapframe</name></expr></argument>, <argument><expr><name>ovector</name></expr></argument>)</argument_list></call> <operator>+</operator>
  <name><name>re</name><operator>-&gt;</operator><name>top_bracket</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_SIZE</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<comment type="block">/* Limits set in the pattern override the match context only if they are
smaller. */</comment>

<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>heap_limit</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>mcontext</name><operator>-&gt;</operator><name>heap_limit</name></name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>limit_heap</name></name><operator>)</operator></expr>?</condition><then>
  <expr><name><name>mcontext</name><operator>-&gt;</operator><name>heap_limit</name></name></expr> </then><else>: <expr><name><name>re</name><operator>-&gt;</operator><name>limit_heap</name></name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>match_limit</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>mcontext</name><operator>-&gt;</operator><name>match_limit</name></name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>limit_match</name></name><operator>)</operator></expr>?</condition><then>
  <expr><name><name>mcontext</name><operator>-&gt;</operator><name>match_limit</name></name></expr> </then><else>: <expr><name><name>re</name><operator>-&gt;</operator><name>limit_match</name></name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>match_limit_depth</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>mcontext</name><operator>-&gt;</operator><name>depth_limit</name></name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>limit_depth</name></name><operator>)</operator></expr>?</condition><then>
  <expr><name><name>mcontext</name><operator>-&gt;</operator><name>depth_limit</name></name></expr> </then><else>: <expr><name><name>re</name><operator>-&gt;</operator><name>limit_depth</name></name></expr></else></ternary></expr>;</expr_stmt>

<comment type="block">/* If a pattern has very many capturing parentheses, the frame size may be very
large. Ensure that there are at least 10 available frames by getting an initial
vector on the heap if necessary, except when the heap limit prevents this. Get
fewer if possible. (The heap limit is in kibibytes.) */</comment>

<if_stmt><if>if <condition>(<expr><name>frame_size</name> <operator>&lt;=</operator> <name>START_FRAMES_SIZE</name><operator>/</operator><literal type="number">10</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>stack_frames</name></name></expr>;</expr_stmt>   <comment type="block">/* Initial frame vector on the stack */</comment>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>frame_vector_size</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>START_FRAMES_SIZE</name><operator>/</operator><name>frame_size</name><operator>)</operator> <operator>*</operator> <name>frame_size</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>frame_vector_size</name></name> <operator>=</operator> <name>frame_size</name> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>frame_vector_size</name></name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator> <operator>&gt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>heap_limit</name></name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>frame_size</name> <operator>&gt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>heap_limit</name></name> <operator>*</operator> <literal type="number">1024</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_HEAPLIMIT</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>frame_vector_size</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>heap_limit</name></name> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator><operator>/</operator><name>frame_size</name><operator>)</operator> <operator>*</operator> <name>frame_size</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name> <operator>=</operator> <call><name><name>mb</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>malloc</name></name><argument_list>(<argument><expr><name><name>mb</name><operator>-&gt;</operator><name>frame_vector_size</name></name></expr></argument>,
    <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>match_frames_top</name></name> <operator>=</operator>
  <operator>(</operator><name>heapframe</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name> <operator>+</operator> <name><name>mb</name><operator>-&gt;</operator><name>frame_vector_size</name></name><operator>)</operator></expr>;</expr_stmt>

<comment type="block">/* Write to the ovector within the first frame to mark every capture unset and
to avoid uninitialized memory read errors when it is copied to a new frame. */</comment>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name><operator>)</operator> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>heapframe</name></expr></argument>, <argument><expr><name>ovector</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0xff</literal></expr></argument>,
  <argument><expr><name><name>re</name><operator>-&gt;</operator><name>top_bracket</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_SIZE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Pointers to the individual character tables */</comment>

<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>lcc</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>tables</name></name> <operator>+</operator> <name>lcc_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>fcc</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>tables</name></name> <operator>+</operator> <name>fcc_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>ctypes</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>tables</name></name> <operator>+</operator> <name>ctypes_offset</name></expr>;</expr_stmt>

<comment type="block">/* Set up the first code unit to match, if available. If there's no first code
unit there may be a bitmap of possible first characters. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_FIRSTSET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>has_first_cu</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>first_cu</name> <operator>=</operator> <name>first_cu2</name> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name><operator>)</operator><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>first_codeunit</name></name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_FIRSTCASELESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>first_cu2</name> <operator>=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>first_cu</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>fcc</name></name></expr></argument>, <argument><expr><name>first_cu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>first_cu</name> <operator>&gt;</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <name>ucp</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>first_cu2</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>first_cu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name>first_cu</name> <operator>&gt;</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>utf</name> <operator>||</operator> <name>ucp</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>first_cu2</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>first_cu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
<if type="elseif">else
  if <condition>(<expr><operator>!</operator><name>startline</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_FIRSTMAPSET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>start_bits</name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>start_bitmap</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* There may also be a "last known required character" set. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_LASTSET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>has_req_cu</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>req_cu</name> <operator>=</operator> <name>req_cu2</name> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name><operator>)</operator><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>last_codeunit</name></name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_LASTCASELESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>req_cu2</name> <operator>=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>req_cu</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>fcc</name></name></expr></argument>, <argument><expr><name>req_cu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>req_cu</name> <operator>&gt;</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <name>ucp</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>req_cu2</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>req_cu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name>req_cu</name> <operator>&gt;</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>utf</name> <operator>||</operator> <name>ucp</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>req_cu2</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>req_cu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>


<comment type="block">/* ==========================================================================*/</comment>

<comment type="block">/* Loop for handling unanchored repeated matching attempts; for anchored regexs
the loop runs just once. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<label><name>FRAGMENT_RESTART</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>start_partial</name> <operator>=</operator> <name>match_partial</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>hitend</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<expr_stmt><expr><name>memchr_not_found_first_cu</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>memchr_not_found_first_cu2</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>new_start_match</name></decl>;</decl_stmt>

  <comment type="block">/* ----------------- Start of match optimizations ---------------- */</comment>

  <comment type="block">/* There are some optimizations that avoid running the match if a known
  starting point is not found, or if a known later code unit is not present.
  However, there is an option (settable at compile time) that disables these,
  for testing and for ensuring that all callouts do actually occur. */</comment>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_NO_START_OPTIMIZE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* If firstline is TRUE, the start of the match is constrained to the first
    line of a multiline string. That is, the match must be before or at the
    first newline following the start of matching. Temporarily adjust
    end_subject so that we stop the scans for a first code unit at a newline.
    If the match fails at the newline, later code breaks the loop. */</comment>

    <if_stmt><if>if <condition>(<expr><name>firstline</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>t</name> <init>= <expr><name>start_match</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
        <block>{<block_content>
        <while>while <condition>(<expr><name>t</name> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>t</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ACROSSCHAR</name><argument_list>(<argument><expr><name>t</name> <operator>&lt;</operator> <name>end_subject</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></while>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <while>while <condition>(<expr><name>t</name> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>t</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while></block_content></block></else></if_stmt>
      <expr_stmt><expr><name>end_subject</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Anchored: check the first code unit if one is recorded. This may seem
    pointless but it can help in detecting a no match case without scanning for
    the required code unit. */</comment>

    <if_stmt><if>if <condition>(<expr><name>anchored</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>has_first_cu</name> <operator>||</operator> <name>start_bits</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>ok</name> <init>= <expr><name>start_match</name> <operator>&lt;</operator> <name>end_subject</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>ok</name></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>c</name> <init>= <expr><call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>ok</name> <operator>=</operator> <name>has_first_cu</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>==</operator> <name>first_cu</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>first_cu2</name><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name> <operator>&amp;&amp;</operator> <name>start_bits</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>ok</name> <operator>=</operator> <operator>(</operator><name><name>start_bits</name><index>[<expr><name>c</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>MATCH_NOMATCH</name></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if>

    <comment type="block">/* Not anchored. Advance to a unique first code unit if there is one. In
    8-bit mode, the use of memchr() gives a big speed up, even though we have
    to call it twice in caseless mode, in order to find the earliest occurrence
    of the character in either of its cases. If a call to memchr() that
    searches the rest of the subject fails to find one case, remember that in
    order not to keep on repeating the search. This can make a huge difference
    when the strings are very long and only one case is present. */</comment>

    <else>else
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>has_first_cu</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>first_cu</name> <operator>!=</operator> <name>first_cu2</name></expr>)</condition>  <comment type="block">/* Caseless */</comment>
          <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
          <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>smc</name></decl>;</decl_stmt>
          <while>while <condition>(<expr><name>start_match</name> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator>
                <operator>(</operator><name>smc</name> <operator>=</operator> <call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>first_cu</name> <operator>&amp;&amp;</operator>
                  <name>smc</name> <operator>!=</operator> <name>first_cu2</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>start_match</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* 8-bit code units */</comment>
          <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>pp1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>pp2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>cu2size</name> <init>= <expr><name>end_subject</name> <operator>-</operator> <name>start_match</name></expr></init></decl>;</decl_stmt>

          <if_stmt><if>if <condition>(<expr><operator>!</operator><name>memchr_not_found_first_cu</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>pp1</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>, <argument><expr><name>first_cu</name></expr></argument>, <argument><expr><name>end_subject</name> <operator>-</operator> <name>start_match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>pp1</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>memchr_not_found_first_cu</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>
              <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>cu2size</name> <operator>=</operator> <name>pp1</name> <operator>-</operator> <name>start_match</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

          <comment type="block">/* If pp1 is not NULL, we have arranged to search only as far as pp1,
          to see if the other case is earlier, so we can set "not found" only
          when both searches have returned NULL. */</comment>

          <if_stmt><if>if <condition>(<expr><operator>!</operator><name>memchr_not_found_first_cu2</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>pp2</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>, <argument><expr><name>first_cu2</name></expr></argument>, <argument><expr><name>cu2size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>memchr_not_found_first_cu2</name> <operator>=</operator> <operator>(</operator><name>pp2</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>pp1</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

          <if_stmt><if>if <condition>(<expr><name>pp1</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>start_match</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>pp2</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then> <expr><name>end_subject</name></expr> </then><else>: <expr><name>pp2</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
          <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>start_match</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>pp2</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>pp1</name> <operator>&lt;</operator> <name>pp2</name><operator>)</operator></expr>?</condition><then> <expr><name>pp1</name></expr> </then><else>: <expr><name>pp2</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          </block_content>}</block></if>

        <comment type="block">/* The caseful case */</comment>

        <else>else
          <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
          <while>while <condition>(<expr><name>start_match</name> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator> <call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>)</argument_list></call> <operator>!=</operator>
                 <name>first_cu</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>start_match</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <expr_stmt><expr><name>start_match</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>, <argument><expr><name>first_cu</name></expr></argument>, <argument><expr><name>end_subject</name> <operator>-</operator> <name>start_match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>start_match</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>start_match</name> <operator>=</operator> <name>end_subject</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          </block_content>}</block></else></if_stmt>

        <comment type="block">/* If we can't find the required first code unit, having reached the
        true end of the subject, break the bumpalong loop, to force a match
        failure, except when doing partial matching, when we let the next cycle
        run at the end of the subject. To see why, consider the pattern
        /(?&lt;=abc)def/, which partially matches "abc", even though the string
        does not contain the starting character "d". If we have not reached the
        true end of the subject (PCRE2_FIRSTLINE caused end_subject to be
        temporarily modified) we also let the cycle run, because the matching
        string is legitimately allowed to start with the first code unit of a
        newline. */</comment>

        <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>start_match</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>MATCH_NOMATCH</name></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>

      <comment type="block">/* If there's no first code unit, advance to just after a linebreak for a
      multiline match if required. */</comment>

      <if type="elseif">else if <condition>(<expr><name>startline</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>start_match</name> <operator>&gt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name> <operator>+</operator> <name>start_offset</name></expr>)</condition>
          <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
          <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
            <block>{<block_content>
            <while>while <condition>(<expr><name>start_match</name> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>WAS_NEWLINE</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>)</argument_list></call></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><name>start_match</name><operator>++</operator></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>ACROSSCHAR</name><argument_list>(<argument><expr><name>start_match</name> <operator>&lt;</operator> <name>end_subject</name></expr></argument>, <argument><expr><name>start_match</name></expr></argument>, <argument><expr><name>start_match</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></while>
            </block_content>}</block></if>
          <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <while>while <condition>(<expr><name>start_match</name> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>WAS_NEWLINE</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>start_match</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while></block_content></block></else></if_stmt>

          <comment type="block">/* If we have just passed a CR and the newline option is ANY or
          ANYCRLF, and we are now at a LF, advance the match position by one
          more code unit. */</comment>

          <if_stmt><if>if <condition>(<expr><name><name>start_match</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_CR</name> <operator>&amp;&amp;</operator>
               <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_ANY</name> <operator>||</operator> <name><name>mb</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_ANYCRLF</name><operator>)</operator> <operator>&amp;&amp;</operator>
               <name>start_match</name> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator>
               <call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CHAR_NL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>start_match</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>

      <comment type="block">/* If there's no first code unit or a requirement for a multiline line
      start, advance to a non-unique first code unit if any have been
      identified. The bitmap contains only 256 bits. When code units are 16 or
      32 bits wide, all code units greater than 254 set the 255 bit. */</comment>

      <if type="elseif">else if <condition>(<expr><name>start_bits</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
        <while>while <condition>(<expr><name>start_match</name> <operator>&lt;</operator> <name>end_subject</name></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name> <init>= <expr><call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
          <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>start_bits</name><index>[<expr><name>c</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>start_match</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></while>

        <comment type="block">/* See comment above in first_cu checking about the next few lines. */</comment>

        <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>start_match</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>MATCH_NOMATCH</name></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>   <comment type="block">/* End first code unit handling */</comment>

    <comment type="block">/* Restore fudged end_subject */</comment>

    <expr_stmt><expr><name>end_subject</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>;</expr_stmt>

    <comment type="block">/* The following two optimizations must be disabled for partial matching. */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>partial</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>p</name></decl>;</decl_stmt>

      <comment type="block">/* The minimum matching length is a lower bound; no string of that length
      may actually match the pattern. Although the value is, strictly, in
      characters, we treat it as code units to avoid spending too much time in
      this optimization. */</comment>

      <if_stmt><if>if <condition>(<expr><name>end_subject</name> <operator>-</operator> <name>start_match</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>minlength</name></name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>MATCH_NOMATCH</name></expr>;</expr_stmt>
        <break>break;</break>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* If req_cu is set, we know that that code unit must appear in the
      subject for the (non-partial) match to succeed. If the first code unit is
      set, req_cu must be later in the subject; otherwise the test starts at
      the match point. This optimization can save a huge amount of backtracking
      in patterns with nested unlimited repeats that aren't going to match.
      Writing separate code for caseful/caseless versions makes it go faster,
      as does using an autoincrement and backing off on a match. As in the case
      of the first code unit, using memchr() in the 8-bit library gives a big
      speed up. Unlike the first_cu check above, we do not need to call
      memchr() twice in the caseless case because we only need to check for the
      presence of the character in either case, not find the first occurrence.

      The search can be skipped if the code unit was found later than the
      current starting point in a previous iteration of the bumpalong loop.

      HOWEVER: when the subject string is very, very long, searching to its end
      can take a long time, and give bad performance on quite ordinary
      anchored patterns. This showed up when somebody was matching something
      like /^\d+C/ on a 32-megabyte string... so we don't do this when the
      string is sufficiently long, but it's worth searching a lot more for
      unanchored patterns. */</comment>

      <expr_stmt><expr><name>p</name> <operator>=</operator> <name>start_match</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>has_first_cu</name></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>has_req_cu</name> <operator>&amp;&amp;</operator> <name>p</name> <operator>&gt;</operator> <name>req_cu_ptr</name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>check_length</name> <init>= <expr><name>end_subject</name> <operator>-</operator> <name>start_match</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>check_length</name> <operator>&lt;</operator> <name>REQ_CU_MAX</name> <operator>||</operator>
              <operator>(</operator><operator>!</operator><name>anchored</name> <operator>&amp;&amp;</operator> <name>check_length</name> <operator>&lt;</operator> <name>REQ_CU_MAX</name> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>req_cu</name> <operator>!=</operator> <name>req_cu2</name></expr>)</condition>  <comment type="block">/* Caseless */</comment>
            <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
            <while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end_subject</name></expr>)</condition>
              <block>{<block_content>
              <decl_stmt><decl><type><name>uint32_t</name></type> <name>pp</name> <init>= <expr><call><name>UCHAR21INCTEST</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <if_stmt><if>if <condition>(<expr><name>pp</name> <operator>==</operator> <name>req_cu</name> <operator>||</operator> <name>pp</name> <operator>==</operator> <name>req_cu2</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
              </block_content>}</block></while>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* 8-bit code units */</comment>
            <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>pp</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>req_cu</name></expr></argument>, <argument><expr><name>end_subject</name> <operator>-</operator> <name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>req_cu2</name></expr></argument>, <argument><expr><name>end_subject</name> <operator>-</operator> <name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name>end_subject</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
              </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH != 8 */</comment>
            </block_content>}</block></if>

          <comment type="block">/* The caseful case */</comment>

          <else>else
            <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
            <while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end_subject</name></expr>)</condition>
              <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><call><name>UCHAR21INCTEST</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>req_cu</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
              </block_content>}</block></while>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* 8-bit code units */</comment>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>req_cu</name></expr></argument>, <argument><expr><name>end_subject</name> <operator>-</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name>end_subject</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></else></if_stmt>

          <comment type="block">/* If we can't find the required code unit, break the bumpalong loop,
          forcing a match failure. */</comment>

          <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name>end_subject</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>MATCH_NOMATCH</name></expr>;</expr_stmt>
            <break>break;</break>
            </block_content>}</block></if></if_stmt>

          <comment type="block">/* If we have found the required code unit, save the point where we
          found it, so that we don't search again next time round the bumpalong
          loop if the start hasn't yet passed this code unit. */</comment>

          <expr_stmt><expr><name>req_cu_ptr</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* ------------ End of start of match optimizations ------------ */</comment>

  <comment type="block">/* Give no match if we have passed the bumpalong limit. */</comment>

  <if_stmt><if>if <condition>(<expr><name>start_match</name> <operator>&gt;</operator> <name>bumpalong_limit</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>MATCH_NOMATCH</name></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* OK, we can now run the match. If "hitend" is set afterwards, remember the
  first starting point for which a partial match was found. */</comment>

  <expr_stmt><expr><name><name>cb</name><operator>.</operator><name>start_match</name></name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>start_match</name> <operator>-</operator> <name>subject</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>.</operator><name>callout_flags</name></name> <operator>|=</operator> <name>PCRE2_CALLOUT_STARTMATCH</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>start_used_ptr</name></name> <operator>=</operator> <name>start_match</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name> <operator>=</operator> <name>start_match</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>=</operator> <name>options</name> <operator>|</operator> <name>fragment_options</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>=</operator> <name>options</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>match_call_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>end_offset_top</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>skip_arg_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>match</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>start_code</name></name></expr></argument>, <argument><expr><name><name>match_data</name><operator>-&gt;</operator><name>ovector</name></name></expr></argument>,
    <argument><expr><name><name>match_data</name><operator>-&gt;</operator><name>oveccount</name></name></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>top_bracket</name></name></expr></argument>, <argument><expr><name>frame_size</name></expr></argument>, <argument><expr><name>mb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>hitend</name></name> <operator>&amp;&amp;</operator> <name>start_partial</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>start_partial</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>match_partial</name> <operator>=</operator> <name>start_match</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <switch>switch<condition>(<expr><name>rc</name></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* If MATCH_SKIP_ARG reaches this level it means that a MARK that matched
    the SKIP's arg was not found. In this circumstance, Perl ignores the SKIP
    entirely. The only way we can do that is to re-do the match at the same
    point, with a flag to force SKIP with an argument to be ignored. Just
    treating this case as NOMATCH does not work because it does not check other
    alternatives in patterns such as A(*SKIP:A)B|AC when the subject is AC. */</comment>

    <case>case <expr><name>MATCH_SKIP_ARG</name></expr>:</case>
    <expr_stmt><expr><name>new_start_match</name> <operator>=</operator> <name>start_match</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>ignore_skip_arg</name></name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>skip_arg_count</name></name></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* SKIP passes back the next starting point explicitly, but if it is no
    greater than the match we have just done, treat it as NOMATCH. */</comment>

    <case>case <expr><name>MATCH_SKIP</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>verb_skip_ptr</name></name> <operator>&gt;</operator> <name>start_match</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>new_start_match</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>verb_skip_ptr</name></name></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if></if_stmt>
    <comment type="block">/* Fall through */</comment>

    <comment type="block">/* NOMATCH and PRUNE advance by one character. THEN at this level acts
    exactly like PRUNE. Unset ignore SKIP-with-argument. */</comment>

    <case>case <expr><name>MATCH_NOMATCH</name></expr>:</case>
    <case>case <expr><name>MATCH_PRUNE</name></expr>:</case>
    <case>case <expr><name>MATCH_THEN</name></expr>:</case>
    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>ignore_skip_arg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>new_start_match</name> <operator>=</operator> <name>start_match</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>ACROSSCHAR</name><argument_list>(<argument><expr><name>new_start_match</name> <operator>&lt;</operator> <name>end_subject</name></expr></argument>, <argument><expr><name>new_start_match</name></expr></argument>,
        <argument><expr><name>new_start_match</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>

    <comment type="block">/* COMMIT disables the bumpalong, but otherwise behaves as NOMATCH. */</comment>

    <case>case <expr><name>MATCH_COMMIT</name></expr>:</case>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>MATCH_NOMATCH</name></expr>;</expr_stmt>
    <goto>goto <name>ENDLOOP</name>;</goto>

    <comment type="block">/* Any other return is either a match, or some kind of error. */</comment>

    <default>default:</default>
    <goto>goto <name>ENDLOOP</name>;</goto>
    </block_content>}</block></switch>

  <comment type="block">/* Control reaches here for the various types of "no match at this point"
  result. Reset the code to MATCH_NOMATCH for subsequent checking. */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>MATCH_NOMATCH</name></expr>;</expr_stmt>

  <comment type="block">/* If PCRE2_FIRSTLINE is set, the match must happen before or at the first
  newline in the subject (though it may continue over the newline). Therefore,
  if we have just failed to match, starting at a newline, do not continue. */</comment>

  <if_stmt><if>if <condition>(<expr><name>firstline</name> <operator>&amp;&amp;</operator> <call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

  <comment type="block">/* Advance to new matching position */</comment>

  <expr_stmt><expr><name>start_match</name> <operator>=</operator> <name>new_start_match</name></expr>;</expr_stmt>

  <comment type="block">/* Break the loop if the pattern is anchored or if we have passed the end of
  the subject. */</comment>

  <if_stmt><if>if <condition>(<expr><name>anchored</name> <operator>||</operator> <name>start_match</name> <operator>&gt;</operator> <name>end_subject</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

  <comment type="block">/* If we have just passed a CR and we are now at a LF, and the pattern does
  not contain any explicit matches for \r or \n, and the newline option is CRLF
  or ANY or ANYCRLF, advance the match position by one more code unit. In
  normal matching start_match will aways be greater than the first position at
  this stage, but a failed *SKIP can cause a return at the same point, which is
  why the first test exists. */</comment>

  <if_stmt><if>if <condition>(<expr><name>start_match</name> <operator>&gt;</operator> <name>subject</name> <operator>+</operator> <name>start_offset</name> <operator>&amp;&amp;</operator>
      <name><name>start_match</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_CR</name> <operator>&amp;&amp;</operator>
      <name>start_match</name> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator>
      <operator>*</operator><name>start_match</name> <operator>==</operator> <name>CHAR_NL</name> <operator>&amp;&amp;</operator>
      <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_HASCRORLF</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_ANY</name> <operator>||</operator>
         <name><name>mb</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_ANYCRLF</name> <operator>||</operator>
         <name><name>mb</name><operator>-&gt;</operator><name>nllen</name></name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>start_match</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>mark</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>   <comment type="block">/* Reset for start of next match attempt */</comment>
  </block_content>}</block></for>                  <comment type="block">/* End of for(;;) "bumpalong" loop */</comment>

<comment type="block">/* ==========================================================================*/</comment>

<comment type="block">/* When we reach here, one of the following stopping conditions is true:

(1) The match succeeded, either completely, or partially;

(2) The pattern is anchored or the match was failed after (*COMMIT);

(3) We are past the end of the subject or the bumpalong limit;

(4) PCRE2_FIRSTLINE is set and we have failed to match at a newline, because
    this option requests that a match occur at or before the first newline in
    the subject.

(5) Some kind of error occurred.

*/</comment>

<label><name>ENDLOOP</name>:</label>

<comment type="block">/* If end_subject != true_end_subject, it means we are handling invalid UTF,
and have just processed a non-terminal fragment. If this resulted in no match
or a partial match we must carry on to the next fragment (a partial match is
returned to the caller only at the very end of the subject). A loop is used to
avoid trying to match against empty fragments; if the pattern can match an
empty string it would have done so already. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <name>end_subject</name> <operator>!=</operator> <name>true_end_subject</name> <operator>&amp;&amp;</operator>
    <operator>(</operator><name>rc</name> <operator>==</operator> <name>MATCH_NOMATCH</name> <operator>||</operator> <name>rc</name> <operator>==</operator> <name>PCRE2_ERROR_PARTIAL</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
    <comment type="block">/* Advance past the first bad code unit, and then skip invalid character
    starting code units in 8-bit and 16-bit modes. */</comment>

    <expr_stmt><expr><name>start_match</name> <operator>=</operator> <name>end_subject</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
    <while>while <condition>(<expr><name>start_match</name> <operator>&lt;</operator> <name>true_end_subject</name> <operator>&amp;&amp;</operator> <call><name>NOT_FIRSTCU</name><argument_list>(<argument><expr><operator>*</operator><name>start_match</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>start_match</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* If we have hit the end of the subject, there isn't another non-empty
    fragment, so give up. */</comment>

    <if_stmt><if>if <condition>(<expr><name>start_match</name> <operator>&gt;=</operator> <name>true_end_subject</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>MATCH_NOMATCH</name></expr>;</expr_stmt>  <comment type="block">/* In case it was partial */</comment>
      <break>break;</break>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check the rest of the subject */</comment>

    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>check_subject</name></name> <operator>=</operator> <name>start_match</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>valid_utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>start_match</name></expr></argument>, <argument><expr><name>length</name> <operator>-</operator> <operator>(</operator><name>start_match</name> <operator>-</operator> <name>subject</name><operator>)</operator></expr></argument>,
      <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>match_data</name><operator>-&gt;</operator><name>startchar</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The rest of the subject is valid UTF. */</comment>

    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>=</operator> <name>end_subject</name> <operator>=</operator> <name>true_end_subject</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>fragment_options</name> <operator>=</operator> <name>PCRE2_NOTBOL</name></expr>;</expr_stmt>
      <goto>goto <name>FRAGMENT_RESTART</name>;</goto>
      </block_content>}</block></if>

    <comment type="block">/* A subsequent UTF error has been found; if the next fragment is
    non-empty, set up to process it. Otherwise, let the loop advance. */</comment>

    <if type="elseif">else if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>=</operator> <name>end_subject</name> <operator>=</operator> <name>start_match</name> <operator>+</operator> <name><name>match_data</name><operator>-&gt;</operator><name>startchar</name></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>end_subject</name> <operator>&gt;</operator> <name>start_match</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>fragment_options</name> <operator>=</operator> <name>PCRE2_NOTBOL</name><operator>|</operator><name>PCRE2_NOTEOL</name></expr>;</expr_stmt>
        <goto>goto <name>FRAGMENT_RESTART</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

<comment type="block">/* Release an enlarged frame vector that is on the heap. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name> <operator>!=</operator> <name><name>mb</name><operator>-&gt;</operator><name>stack_frames</name></name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name><name>mb</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>free</name></name><argument_list>(<argument><expr><name><name>mb</name><operator>-&gt;</operator><name>match_frames</name></name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* Fill in fields that are always returned in the match data. */</comment>

<expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>re</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>mark</name></name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>mark</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>matchedby</name></name> <operator>=</operator> <name>PCRE2_MATCHEDBY_INTERPRETER</name></expr>;</expr_stmt>

<comment type="block">/* Handle a fully successful match. Set the return code to the number of
captured strings, or 0 if there were too many to fit into the ovector, and then
set the remaining returned values before returning. Make a copy of the subject
string if requested. */</comment>

<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>MATCH_MATCH</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name><name>mb</name><operator>-&gt;</operator><name>end_offset_top</name></name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>match_data</name><operator>-&gt;</operator><name>oveccount</name></name><operator>)</operator></expr>?</condition><then>
    <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>mb</name><operator>-&gt;</operator><name>end_offset_top</name></name><operator>/</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>startchar</name></name> <operator>=</operator> <name>start_match</name> <operator>-</operator> <name>subject</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>leftchar</name></name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_used_ptr</name></name> <operator>-</operator> <name>subject</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>rightchar</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name> <operator>&gt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_match_ptr</name></name><operator>)</operator></expr>?</condition><then>
    <expr><name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name></expr> </then><else>: <expr><name><name>mb</name><operator>-&gt;</operator><name>end_match_ptr</name></name></expr></else></ternary><operator>)</operator> <operator>-</operator> <name>subject</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_COPY_MATCHED_SUBJECT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>CU2BYTES</name><argument_list>(<argument><expr><name>length</name> <operator>+</operator> <name>was_zero_terminated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>subject</name></name> <operator>=</operator> <call><name><name>match_data</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>malloc</name></name><argument_list>(<argument><expr><name>length</name></expr></argument>,
      <argument><expr><name><name>match_data</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>match_data</name><operator>-&gt;</operator><name>subject</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>match_data</name><operator>-&gt;</operator><name>subject</name></name></expr></argument>, <argument><expr><name>subject</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PCRE2_MD_COPIED_SUBJECT</name></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>subject</name></name> <operator>=</operator> <name>subject</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <return>return <expr><name><name>match_data</name><operator>-&gt;</operator><name>rc</name></name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Control gets here if there has been a partial match, an error, or if the
overall match attempt has failed at all permitted starting positions. Any mark
data is in the nomatch_mark field. */</comment>

<expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>mark</name></name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>nomatch_mark</name></name></expr>;</expr_stmt>

<comment type="block">/* For anything other than nomatch or partial match, just return the code. */</comment>

<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>MATCH_NOMATCH</name> <operator>&amp;&amp;</operator> <name>rc</name> <operator>!=</operator> <name>PCRE2_ERROR_PARTIAL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt></block_content></block></if>

<comment type="block">/* Handle a partial match. If a "soft" partial match was requested, searching
for a complete match will have continued, and the value of rc at this point
will be MATCH_NOMATCH. For a "hard" partial match, it will already be
PCRE2_ERROR_PARTIAL. */</comment>

<if type="elseif">else if <condition>(<expr><name>match_partial</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>subject</name></name> <operator>=</operator> <name>subject</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>match_partial</name> <operator>-</operator> <name>subject</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>end_subject</name> <operator>-</operator> <name>subject</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>startchar</name></name> <operator>=</operator> <name>match_partial</name> <operator>-</operator> <name>subject</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>leftchar</name></name> <operator>=</operator> <name>start_partial</name> <operator>-</operator> <name>subject</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>rightchar</name></name> <operator>=</operator> <name>end_subject</name> <operator>-</operator> <name>subject</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>PCRE2_ERROR_PARTIAL</name></expr>;</expr_stmt>
  </block_content>}</block></if>

<comment type="block">/* Else this is the classic nomatch case. */</comment>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>PCRE2_ERROR_NOMATCH</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name><name>match_data</name><operator>-&gt;</operator><name>rc</name></name></expr>;</return>
}

<comment type="block">/* End of pcre2_match.c */</comment>
</unit>
