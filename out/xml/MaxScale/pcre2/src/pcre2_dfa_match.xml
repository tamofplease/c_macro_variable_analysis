<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/pcre2/src/pcre2_dfa_match.c"><comment type="block" format="doxygen">/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/</comment>

<comment type="block">/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
     Original API code Copyright (c) 1997-2012 University of Cambridge
          New API code Copyright (c) 2016-2020 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/</comment>


<comment type="block">/* This module contains the external function pcre2_dfa_match(), which is an
alternative matching function that uses a sort of DFA algorithm (not a true
FSM). This is NOT Perl-compatible, but it has advantages in certain
applications. */</comment>


<comment type="block">/* NOTE ABOUT PERFORMANCE: A user of this function sent some code that improved
the performance of his patterns greatly. I could not use it as it stood, as it
was not thread safe, and made assumptions about pattern sizes. Also, it caused
test 7 to loop, and test 9 to crash with a segfault.

The issue is the check for duplicate states, which is done by a simple linear
search up the state list. (Grep for "duplicate" below to find the code.) For
many patterns, there will never be many states active at one time, so a simple
linear search is fine. In patterns that have many active states, it might be a
bottleneck. The suggested code used an indexing scheme to remember which states
had previously been used for each character, and avoided the linear search when
it knew there was no chance of a duplicate. This was implemented when adding
states to the state lists.

I wrote some thread-safe, not-limited code to try something similar at the time
of checking for duplicates (instead of when adding states), using index vectors
on the stack. It did give a 13% improvement with one specially constructed
pattern for certain subject strings, but on other strings and on many of the
simpler patterns in the test suite it did worse. The major problem, I think,
was the extra time to initialize the index. This had to be done for each call
of internal_dfa_match(). (The supplied patch used a static vector, initialized
only once - I suspect this was the cause of the problems with the tests.)

Overall, I concluded that the gains in some cases did not outweigh the losses
in others, so I abandoned this code. */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NLBLOCK</name></cpp:macro> <cpp:value>mb</cpp:value></cpp:define>             <comment type="block">/* Block containing newline information */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSSTART</name></cpp:macro> <cpp:value>start_subject</cpp:value></cpp:define>  <comment type="block">/* Field containing processed string start */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSEND</name></cpp:macro>   <cpp:value>end_subject</cpp:value></cpp:define>    <comment type="block">/* Field containing processed string end */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_internal.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUBLIC_DFA_MATCH_OPTIONS</name></cpp:macro> \
  <cpp:value>(PCRE2_ANCHORED|PCRE2_ENDANCHORED|PCRE2_NOTBOL|PCRE2_NOTEOL|PCRE2_NOTEMPTY| \
   PCRE2_NOTEMPTY_ATSTART|PCRE2_NO_UTF_CHECK|PCRE2_PARTIAL_HARD| \
   PCRE2_PARTIAL_SOFT|PCRE2_DFA_SHORTEST|PCRE2_DFA_RESTART| \
   PCRE2_COPY_MATCHED_SUBJECT)</cpp:value></cpp:define>


<comment type="block" format="doxygen">/*************************************************
*      Code parameters and static tables         *
*************************************************/</comment>

<comment type="block">/* These are offsets that are used to turn the OP_TYPESTAR and friends opcodes
into others, under special conditions. A gap of 20 between the blocks should be
enough. The resulting opcodes don't have to be less than 256 because they are
never stored, so we push them well clear of the normal opcodes. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP_PROP_EXTRA</name></cpp:macro>       <cpp:value>300</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP_EXTUNI_EXTRA</name></cpp:macro>     <cpp:value>320</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP_ANYNL_EXTRA</name></cpp:macro>      <cpp:value>340</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP_HSPACE_EXTRA</name></cpp:macro>     <cpp:value>360</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP_VSPACE_EXTRA</name></cpp:macro>     <cpp:value>380</cpp:value></cpp:define>


<comment type="block">/* This table identifies those opcodes that are followed immediately by a
character that is to be tested in some way. This makes it possible to
centralize the loading of these characters. In the case of Type * etc, the
"character" is the opcode for \D, \d, \S, \s, \W, or \w, which will always be a
small value. Non-zero values in the table are the offsets from the opcode where
the character is to be found. ***NOTE*** If the start of this table is
modified, the three tables that follow must also be modified. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>coptable</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* End                                    */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                 <comment type="block">/* \A, \G, \K, \B, \b                     */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,              <comment type="block">/* \D, \d, \S, \s, \W, \w                 */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* Any, AllAny, Anybyte                   */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                          <comment type="block">/* \P, \p                                 */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                 <comment type="block">/* \R, \H, \h, \V, \v                     */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* \X                                     */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,              <comment type="block">/* \Z, \z, $, $M, ^, ^M                   */</comment>
  <expr><literal type="number">1</literal></expr>,                             <comment type="block">/* Char                                   */</comment>
  <expr><literal type="number">1</literal></expr>,                             <comment type="block">/* Chari                                  */</comment>
  <expr><literal type="number">1</literal></expr>,                             <comment type="block">/* not                                    */</comment>
  <expr><literal type="number">1</literal></expr>,                             <comment type="block">/* noti                                   */</comment>
  <comment type="block">/* Positive single-char repeats                                          */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,              <comment type="block">/* *, *?, +, +?, ?, ??                    */</comment>
  <expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>, <expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>,      <comment type="block">/* upto, minupto                          */</comment>
  <expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>,                   <comment type="block">/* exact                                  */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>,          <comment type="block">/* *+, ++, ?+, upto+                      */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,              <comment type="block">/* *I, *?I, +I, +?I, ?I, ??I              */</comment>
  <expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>, <expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>,      <comment type="block">/* upto I, minupto I                      */</comment>
  <expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>,                   <comment type="block">/* exact I                                */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>,          <comment type="block">/* *+I, ++I, ?+I, upto+I                  */</comment>
  <comment type="block">/* Negative single-char repeats - only for chars &lt; 256                   */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,              <comment type="block">/* NOT *, *?, +, +?, ?, ??                */</comment>
  <expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>, <expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>,      <comment type="block">/* NOT upto, minupto                      */</comment>
  <expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>,                   <comment type="block">/* NOT exact                              */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>,          <comment type="block">/* NOT *+, ++, ?+, upto+                  */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,              <comment type="block">/* NOT *I, *?I, +I, +?I, ?I, ??I          */</comment>
  <expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>, <expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>,      <comment type="block">/* NOT upto I, minupto I                  */</comment>
  <expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>,                   <comment type="block">/* NOT exact I                            */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>,          <comment type="block">/* NOT *+I, ++I, ?+I, upto+I              */</comment>
  <comment type="block">/* Positive type repeats                                                 */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,              <comment type="block">/* Type *, *?, +, +?, ?, ??               */</comment>
  <expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>, <expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>,      <comment type="block">/* Type upto, minupto                     */</comment>
  <expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>,                   <comment type="block">/* Type exact                             */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>,          <comment type="block">/* Type *+, ++, ?+, upto+                 */</comment>
  <comment type="block">/* Character class &amp; ref repeats                                         */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,              <comment type="block">/* *, *?, +, +?, ?, ??                    */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                          <comment type="block">/* CRRANGE, CRMINRANGE                    */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                    <comment type="block">/* Possessive *+, ++, ?+, CRPOSRANGE      */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* CLASS                                  */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* NCLASS                                 */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* XCLASS - variable length               */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* REF                                    */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* REFI                                   */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* DNREF                                  */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* DNREFI                                 */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* RECURSE                                */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* CALLOUT                                */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* CALLOUT_STR                            */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* Alt                                    */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* Ket                                    */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* KetRmax                                */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* KetRmin                                */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* KetRpos                                */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* Reverse                                */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* Assert                                 */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* Assert not                             */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* Assert behind                          */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* Assert behind not                      */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* NA assert                              */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* NA assert behind                       */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* ONCE                                   */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* SCRIPT_RUN                             */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                 <comment type="block">/* BRA, BRAPOS, CBRA, CBRAPOS, COND       */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                 <comment type="block">/* SBRA, SBRAPOS, SCBRA, SCBRAPOS, SCOND  */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                          <comment type="block">/* CREF, DNCREF                           */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                          <comment type="block">/* RREF, DNRREF                           */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                          <comment type="block">/* FALSE, TRUE                            */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* BRAZERO, BRAMINZERO, BRAPOSZERO        */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* MARK, PRUNE, PRUNE_ARG                 */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                    <comment type="block">/* SKIP, SKIP_ARG, THEN, THEN_ARG         */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                          <comment type="block">/* COMMIT, COMMIT_ARG                     */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* FAIL, ACCEPT, ASSERT_ACCEPT            */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>                        <comment type="block">/* CLOSE, SKIPZERO, DEFINE                */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* This table identifies those opcodes that inspect a character. It is used to
remember the fact that a character could have been inspected when the end of
the subject is reached. ***NOTE*** If the start of this table is modified, the
two tables that follow must also be modified. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>poptable</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* End                                    */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,                 <comment type="block">/* \A, \G, \K, \B, \b                     */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,              <comment type="block">/* \D, \d, \S, \s, \W, \w                 */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,                       <comment type="block">/* Any, AllAny, Anybyte                   */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,                          <comment type="block">/* \P, \p                                 */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,                 <comment type="block">/* \R, \H, \h, \V, \v                     */</comment>
  <expr><literal type="number">1</literal></expr>,                             <comment type="block">/* \X                                     */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,              <comment type="block">/* \Z, \z, $, $M, ^, ^M                   */</comment>
  <expr><literal type="number">1</literal></expr>,                             <comment type="block">/* Char                                   */</comment>
  <expr><literal type="number">1</literal></expr>,                             <comment type="block">/* Chari                                  */</comment>
  <expr><literal type="number">1</literal></expr>,                             <comment type="block">/* not                                    */</comment>
  <expr><literal type="number">1</literal></expr>,                             <comment type="block">/* noti                                   */</comment>
  <comment type="block">/* Positive single-char repeats                                          */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,              <comment type="block">/* *, *?, +, +?, ?, ??                    */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,                       <comment type="block">/* upto, minupto, exact                   */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,                    <comment type="block">/* *+, ++, ?+, upto+                      */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,              <comment type="block">/* *I, *?I, +I, +?I, ?I, ??I              */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,                       <comment type="block">/* upto I, minupto I, exact I             */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,                    <comment type="block">/* *+I, ++I, ?+I, upto+I                  */</comment>
  <comment type="block">/* Negative single-char repeats - only for chars &lt; 256                   */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,              <comment type="block">/* NOT *, *?, +, +?, ?, ??                */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,                       <comment type="block">/* NOT upto, minupto, exact               */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,                    <comment type="block">/* NOT *+, ++, ?+, upto+                  */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,              <comment type="block">/* NOT *I, *?I, +I, +?I, ?I, ??I          */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,                       <comment type="block">/* NOT upto I, minupto I, exact I         */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,                    <comment type="block">/* NOT *+I, ++I, ?+I, upto+I              */</comment>
  <comment type="block">/* Positive type repeats                                                 */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,              <comment type="block">/* Type *, *?, +, +?, ?, ??               */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,                       <comment type="block">/* Type upto, minupto, exact              */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,                    <comment type="block">/* Type *+, ++, ?+, upto+                 */</comment>
  <comment type="block">/* Character class &amp; ref repeats                                         */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,              <comment type="block">/* *, *?, +, +?, ?, ??                    */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,                          <comment type="block">/* CRRANGE, CRMINRANGE                    */</comment>
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,                    <comment type="block">/* Possessive *+, ++, ?+, CRPOSRANGE      */</comment>
  <expr><literal type="number">1</literal></expr>,                             <comment type="block">/* CLASS                                  */</comment>
  <expr><literal type="number">1</literal></expr>,                             <comment type="block">/* NCLASS                                 */</comment>
  <expr><literal type="number">1</literal></expr>,                             <comment type="block">/* XCLASS - variable length               */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* REF                                    */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* REFI                                   */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* DNREF                                  */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* DNREFI                                 */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* RECURSE                                */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* CALLOUT                                */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* CALLOUT_STR                            */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* Alt                                    */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* Ket                                    */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* KetRmax                                */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* KetRmin                                */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* KetRpos                                */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* Reverse                                */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* Assert                                 */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* Assert not                             */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* Assert behind                          */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* Assert behind not                      */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* NA assert                              */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* NA assert behind                       */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* ONCE                                   */</comment>
  <expr><literal type="number">0</literal></expr>,                             <comment type="block">/* SCRIPT_RUN                             */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                 <comment type="block">/* BRA, BRAPOS, CBRA, CBRAPOS, COND       */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                 <comment type="block">/* SBRA, SBRAPOS, SCBRA, SCBRAPOS, SCOND  */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                          <comment type="block">/* CREF, DNCREF                           */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                          <comment type="block">/* RREF, DNRREF                           */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                          <comment type="block">/* FALSE, TRUE                            */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* BRAZERO, BRAMINZERO, BRAPOSZERO        */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* MARK, PRUNE, PRUNE_ARG                 */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                    <comment type="block">/* SKIP, SKIP_ARG, THEN, THEN_ARG         */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                          <comment type="block">/* COMMIT, COMMIT_ARG                     */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* FAIL, ACCEPT, ASSERT_ACCEPT            */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>                        <comment type="block">/* CLOSE, SKIPZERO, DEFINE                */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* These 2 tables allow for compact code for testing for \D, \d, \S, \s, \W,
and \w */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>toptable1</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><name>ctype_digit</name></expr>, <expr><name>ctype_digit</name></expr>,
  <expr><name>ctype_space</name></expr>, <expr><name>ctype_space</name></expr>,
  <expr><name>ctype_word</name></expr>,  <expr><name>ctype_word</name></expr>,
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>                            <comment type="block">/* OP_ANY, OP_ALLANY */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>toptable2</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><name>ctype_digit</name></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><name>ctype_space</name></expr>, <expr><literal type="number">0</literal></expr>,
  <expr><name>ctype_word</name></expr>,  <expr><literal type="number">0</literal></expr>,
  <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>                            <comment type="block">/* OP_ANY, OP_ALLANY */</comment>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Structure for holding data about a particular state, which is in effect the
current data for an active path through the match tree. It must consist
entirely of ints because the working vector we are passed, and which we put
these structures in, is a vector of ints. */</comment>

<typedef>typedef <type><struct>struct <name>stateblock</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>                     <comment type="block">/* Offset to opcode (-ve has meaning) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>                      <comment type="block">/* Count for repeats */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>data</name></decl>;</decl_stmt>                       <comment type="block">/* Some use extra data */</comment>
}</block></struct></type> <name>stateblock</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTS_PER_STATEBLOCK</name></cpp:macro>  <cpp:value>(int)(sizeof(stateblock)/sizeof(int))</cpp:value></cpp:define>


<comment type="block">/* Before version 10.32 the recursive calls of internal_dfa_match() were passed
local working space and output vectors that were created on the stack. This has
caused issues for some patterns, especially in small-stack environments such as
Windows. A new scheme is now in use which sets up a vector on the stack, but if
this is too small, heap memory is used, up to the heap_limit. The main
parameters are all numbers of ints because the workspace is a vector of ints.

The size of the starting stack vector, DFA_START_RWS_SIZE, is in bytes, and is
defined in pcre2_internal.h so as to be available to pcre2test when it is
finding the minimum heap requirement for a match. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OVEC_UNIT</name></cpp:macro>  <cpp:value>(sizeof(PCRE2_SIZE)/sizeof(int))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RWS_BASE_SIZE</name></cpp:macro>   <cpp:value>(DFA_START_RWS_SIZE/sizeof(int))</cpp:value></cpp:define>  <comment type="block">/* Stack vector */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RWS_RSIZE</name></cpp:macro>       <cpp:value>1000</cpp:value></cpp:define>                    <comment type="block">/* Work size for recursion */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RWS_OVEC_RSIZE</name></cpp:macro>  <cpp:value>(1000*OVEC_UNIT)</cpp:value></cpp:define>        <comment type="block">/* Ovector for recursion */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RWS_OVEC_OSIZE</name></cpp:macro>  <cpp:value>(2*OVEC_UNIT)</cpp:value></cpp:define>           <comment type="block">/* Ovector in other cases */</comment>

<comment type="block">/* This structure is at the start of each workspace block. */</comment>

<typedef>typedef <type><struct>struct <name>RWS_anchor</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>RWS_anchor</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>size</name></decl>;</decl_stmt>  <comment type="block">/* Number of ints */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>free</name></decl>;</decl_stmt>  <comment type="block">/* Number of ints */</comment>
}</block></struct></type> <name>RWS_anchor</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RWS_ANCHOR_SIZE</name></cpp:macro> <cpp:value>(sizeof(RWS_anchor)/sizeof(int))</cpp:value></cpp:define>



<comment type="block" format="doxygen">/*************************************************
*               Process a callout                *
*************************************************/</comment>

<comment type="block">/* This function is called to perform a callout.

Arguments:
  code              current code pointer
  offsets           points to current capture offsets
  current_subject   start of current subject match
  ptr               current position in subject
  mb                the match block
  extracode         extra code offset when called from condition
  lengthptr         where to return the callout length

Returns:            the return from the callout
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>do_callout</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>offsets</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>current_subject</name></decl></parameter>,
  <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>dfa_match_block</name> <modifier>*</modifier></type><name>mb</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>extracode</name></decl></parameter>,
  <parameter><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>lengthptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcre2_callout_block</name> <modifier>*</modifier></type><name>cb</name> <init>= <expr><name><name>mb</name><operator>-&gt;</operator><name>cb</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>lengthptr</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>code</name><index>[<expr><name>extracode</name></expr>]</index></name> <operator>==</operator> <name>OP_CALLOUT</name><operator>)</operator></expr>?</condition><then>
  <expr><operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>OP_CALLOUT</name></expr>]</index></expr> </then><else>:
  <expr><operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name> <operator>+</operator> <name>extracode</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>callout</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* No callout provided */</comment>

<comment type="block">/* Fixed fields in the callout block are set once and for all at the start of
matching. */</comment>

<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>offset_vector</name></name>    <operator>=</operator> <name>offsets</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>start_match</name></name>      <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>current_subject</name> <operator>-</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>current_position</name></name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>pattern_position</name></name> <operator>=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>extracode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>next_item_length</name></name> <operator>=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <name>extracode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>code</name><index>[<expr><name>extracode</name></expr>]</index></name> <operator>==</operator> <name>OP_CALLOUT</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_number</name></name> <operator>=</operator> <name><name>code</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name> <operator>+</operator> <name>extracode</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_number</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string_offset</name></name> <operator>=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">3</literal><operator>*</operator><name>LINK_SIZE</name> <operator>+</operator> <name>extracode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string</name></name> <operator>=</operator> <name>code</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>LINK_SIZE</name> <operator>+</operator> <name>extracode</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>callout_string_length</name></name> <operator>=</operator> <operator>*</operator><name>lengthptr</name> <operator>-</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>LINK_SIZE</name><operator>)</operator> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<return>return <expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>callout</name></name><operator>)</operator><operator>(</operator><name>cb</name><operator>,</operator> <name><name>mb</name><operator>-&gt;</operator><name>callout_data</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*         Expand local workspace memory          *
*************************************************/</comment>

<comment type="block">/* This function is called when internal_dfa_match() is about to be called
recursively and there is insufficient working space left in the current
workspace block. If there's an existing next block, use it; otherwise get a new
block unless the heap limit is reached.

Arguments:
  rwsptr     pointer to block pointer (updated)
  ovecsize   space needed for an ovector
  mb         the match block

Returns:     0 rwsptr has been updated
            !0 an error code
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>more_workspace</name><parameter_list>(<parameter><decl><type><name>RWS_anchor</name> <modifier>*</modifier><modifier>*</modifier></type><name>rwsptr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>ovecsize</name></decl></parameter>, <parameter><decl><type><name>dfa_match_block</name> <modifier>*</modifier></type><name>mb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>RWS_anchor</name> <modifier>*</modifier></type><name>rws</name> <init>= <expr><operator>*</operator><name>rwsptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RWS_anchor</name> <modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rws</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>new</name> <operator>=</operator> <name><name>rws</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  </block_content>}</block></if>

<comment type="block">/* Sizes in the RWS_anchor blocks are in units of sizeof(int), but
mb-&gt;heap_limit and mb-&gt;heap_used are in kibibytes. Play carefully, to avoid
overflow. */</comment>

<else>else
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>newsize</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>rws</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;=</operator> <name>UINT32_MAX</name><operator>/</operator><literal type="number">2</literal><operator>)</operator></expr>?</condition><then> <expr><name>UINT32_MAX</name><operator>/</operator><literal type="number">2</literal></expr> </then><else>: <expr><name><name>rws</name><operator>-&gt;</operator><name>size</name></name> <operator>*</operator> <literal type="number">2</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>newsizeK</name> <init>= <expr><name>newsize</name><operator>/</operator><operator>(</operator><literal type="number">1024</literal><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>newsizeK</name> <operator>+</operator> <name><name>mb</name><operator>-&gt;</operator><name>heap_used</name></name> <operator>&gt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>heap_limit</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>newsizeK</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>heap_limit</name></name> <operator>-</operator> <name><name>mb</name><operator>-&gt;</operator><name>heap_used</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>newsize</name> <operator>=</operator> <name>newsizeK</name><operator>*</operator><operator>(</operator><literal type="number">1024</literal><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>newsize</name> <operator>&lt;</operator> <name>RWS_RSIZE</name> <operator>+</operator> <name>ovecsize</name> <operator>+</operator> <name>RWS_ANCHOR_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>PCRE2_ERROR_HEAPLIMIT</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>new</name> <operator>=</operator> <call><name><name>mb</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>malloc</name></name><argument_list>(<argument><expr><name>newsize</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>new</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>heap_used</name></name> <operator>+=</operator> <name>newsizeK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rws</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name><name>new</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name>RWS_ANCHOR_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>rwsptr</name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*     Match a Regular Expression - DFA engine    *
*************************************************/</comment>

<comment type="block">/* This internal function applies a compiled pattern to a subject string,
starting at a given point, using a DFA engine. This function is called from the
external one, possibly multiple times if the pattern is not anchored. The
function calls itself recursively for some kinds of subpattern.

Arguments:
  mb                the match_data block with fixed information
  this_start_code   the opening bracket of this subexpression's code
  current_subject   where we currently are in the subject string
  start_offset      start offset in the subject string
  offsets           vector to contain the matching string offsets
  offsetcount       size of same
  workspace         vector of workspace
  wscount           size of same
  rlevel            function call recursion level

Returns:            &gt; 0 =&gt; number of match offset pairs placed in offsets
                    = 0 =&gt; offsets overflowed; longest matches are present
                     -1 =&gt; failed to match
                   &lt; -1 =&gt; some kind of unexpected problem

The following macros are used for adding states to the two state vectors (one
for the current character, one for the following character). */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_ACTIVE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (active_count++ &lt; wscount) \
    { \
    next_active_state-&gt;offset = (x); \
    next_active_state-&gt;count  = (y); \
    next_active_state++; \
    } \
  else return PCRE2_ERROR_DFA_WSSIZE</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_ACTIVE_DATA</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (active_count++ &lt; wscount) \
    { \
    next_active_state-&gt;offset = (x); \
    next_active_state-&gt;count  = (y); \
    next_active_state-&gt;data   = (z); \
    next_active_state++; \
    } \
  else return PCRE2_ERROR_DFA_WSSIZE</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_NEW</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (new_count++ &lt; wscount) \
    { \
    next_new_state-&gt;offset = (x); \
    next_new_state-&gt;count  = (y); \
    next_new_state++; \
    } \
  else return PCRE2_ERROR_DFA_WSSIZE</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_NEW_DATA</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>,<parameter><type><name>z</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>if (new_count++ &lt; wscount) \
    { \
    next_new_state-&gt;offset = (x); \
    next_new_state-&gt;count  = (y); \
    next_new_state-&gt;data   = (z); \
    next_new_state++; \
    } \
  else return PCRE2_ERROR_DFA_WSSIZE</cpp:value></cpp:define>

<comment type="block">/* And now, here is the code */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>internal_dfa_match</name><parameter_list>(
  <parameter><decl><type><name>dfa_match_block</name> <modifier>*</modifier></type><name>mb</name></decl></parameter>,
  <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>this_start_code</name></decl></parameter>,
  <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>current_subject</name></decl></parameter>,
  <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>start_offset</name></decl></parameter>,
  <parameter><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>offsets</name></decl></parameter>,
  <parameter><decl><type><name>uint32_t</name></type> <name>offsetcount</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>workspace</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>wscount</name></decl></parameter>,
  <parameter><decl><type><name>uint32_t</name></type> <name>rlevel</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>RWS</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>stateblock</name> <modifier>*</modifier></type><name>active_states</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>new_states</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp_states</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>stateblock</name> <modifier>*</modifier></type><name>next_active_state</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next_new_state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>ctypes</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lcc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>fcc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>end_code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dfa_recursion_info</name></type> <name>new_recursive</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>active_count</name></decl>, <decl><type ref="prev"/><name>new_count</name></decl>, <decl><type ref="prev"/><name>match_count</name></decl>;</decl_stmt>

<comment type="block">/* Some fields in the mb block are frequently referenced, so we load them into
independent variables in the hope that this will perform better. */</comment>

<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>start_subject</name> <init>= <expr><name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>end_subject</name> <init>= <expr><name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>start_code</name> <init>= <expr><name><name>mb</name><operator>-&gt;</operator><name>start_code</name></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf_or_ucp</name> <init>= <expr><name>utf</name> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>BOOL</name></type> <name>reset_could_continue</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>match_call_count</name></name><operator>++</operator> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>match_limit</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_MATCHLIMIT</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rlevel</name><operator>++</operator> <operator>&gt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>match_limit_depth</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_DEPTHLIMIT</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>offsetcount</name> <operator>&amp;=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Round down */</comment>

<expr_stmt><expr><name>wscount</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>wscount</name> <operator>=</operator> <operator>(</operator><name>wscount</name> <operator>-</operator> <operator>(</operator><name>wscount</name> <operator>%</operator> <operator>(</operator><name>INTS_PER_STATEBLOCK</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>/</operator>
          <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name>INTS_PER_STATEBLOCK</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>ctypes</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>tables</name></name> <operator>+</operator> <name>ctypes_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lcc</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>tables</name></name> <operator>+</operator> <name>lcc_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>fcc</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>tables</name></name> <operator>+</operator> <name>fcc_offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name>match_count</name> <operator>=</operator> <name>PCRE2_ERROR_NOMATCH</name></expr>;</expr_stmt>   <comment type="block">/* A negative number */</comment>

<expr_stmt><expr><name>active_states</name> <operator>=</operator> <operator>(</operator><name>stateblock</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>workspace</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>next_new_state</name> <operator>=</operator> <name>new_states</name> <operator>=</operator> <name>active_states</name> <operator>+</operator> <name>wscount</name></expr>;</expr_stmt>
<expr_stmt><expr><name>new_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<comment type="block">/* The first thing in any (sub) pattern is a bracket of some sort. Push all
the alternative states onto the list, and find out where the end is. This
makes is possible to use this function recursively, when we want to stop at a
matching internal ket rather than at the end.

If we are dealing with a backward assertion we have to find out the maximum
amount to move back, and set up each alternative appropriately. */</comment>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>this_start_code</name> <operator>==</operator> <name>OP_ASSERTBACK</name> <operator>||</operator> <operator>*</operator><name>this_start_code</name> <operator>==</operator> <name>OP_ASSERTBACK_NOT</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>max_back</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>gone_back</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>end_code</name> <operator>=</operator> <name>this_start_code</name></expr>;</expr_stmt>
  <do>do
    <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>back</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><call><name>GET</name><argument_list>(<argument><expr><name>end_code</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>+</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>back</name> <operator>&gt;</operator> <name>max_back</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>max_back</name> <operator>=</operator> <name>back</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>end_code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>end_code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
  while <condition>(<expr><operator>*</operator><name>end_code</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>

  <comment type="block">/* If we can't go back the amount required for the longest lookbehind
  pattern, go back as far as we can; some alternatives may still be viable. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <comment type="block">/* In character mode we have to step back character by character */</comment>

  <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
    <block>{<block_content>
    <for>for <control>(<init><expr><name>gone_back</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>gone_back</name> <operator>&lt;</operator> <name>max_back</name></expr>;</condition> <incr><expr><name>gone_back</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>current_subject</name> <operator>&lt;=</operator> <name>start_subject</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>current_subject</name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ACROSSCHAR</name><argument_list>(<argument><expr><name>current_subject</name> <operator>&gt;</operator> <name>start_subject</name></expr></argument>, <argument><expr><name>current_subject</name></expr></argument>,
        <argument><expr><name>current_subject</name><operator>--</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if>
  <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* In byte-mode we can do this quickly. */</comment>

    <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>current_offset</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>current_subject</name> <operator>-</operator> <name>start_subject</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>gone_back</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>current_offset</name> <operator>&lt;</operator> <name>max_back</name><operator>)</operator></expr>?</condition><then> <expr><name>current_offset</name></expr> </then><else>: <expr><name>max_back</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>current_subject</name> <operator>-=</operator> <name>gone_back</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

  <comment type="block">/* Save the earliest consulted character */</comment>

  <if_stmt><if>if <condition>(<expr><name>current_subject</name> <operator>&lt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>start_used_ptr</name></name> <operator>=</operator> <name>current_subject</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Now we can process the individual branches. There will be an OP_REVERSE at
  the start of each branch, except when the length of the branch is zero. */</comment>

  <expr_stmt><expr><name>end_code</name> <operator>=</operator> <name>this_start_code</name></expr>;</expr_stmt>
  <do>do
    <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>revlen</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>end_code</name><index>[<expr><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_REVERSE</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>back</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>revlen</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>size_t</name><operator>)</operator><call><name>GET</name><argument_list>(<argument><expr><name>end_code</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>+</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>back</name> <operator>&lt;=</operator> <name>gone_back</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>bstate</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>end_code</name> <operator>-</operator> <name>start_code</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <name>revlen</name><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><name>bstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>gone_back</name> <operator>-</operator> <name>back</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>end_code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>end_code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
  while <condition>(<expr><operator>*</operator><name>end_code</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
 </block_content>}</block></if>

<comment type="block">/* This is the code for a "normal" subpattern (not a backward assertion). The
start of a whole pattern is always one of these. If we are at the top level,
we may be asked to restart matching from the same point that we reached for a
previous partial match. We still have to scan through the top-level branches to
find the end state. */</comment>

<else>else
  <block>{<block_content>
  <expr_stmt><expr><name>end_code</name> <operator>=</operator> <name>this_start_code</name></expr>;</expr_stmt>

  <comment type="block">/* Restarting */</comment>

  <if_stmt><if>if <condition>(<expr><name>rlevel</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_DFA_RESTART</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <do>do <block>{<block_content> <expr_stmt><expr><name>end_code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>end_code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block> while <condition>(<expr><operator>*</operator><name>end_code</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
    <expr_stmt><expr><name>new_count</name> <operator>=</operator> <name><name>workspace</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>workspace</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_states</name></expr></argument>, <argument><expr><name>active_states</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>new_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>stateblock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>

  <comment type="block">/* Not restarting */</comment>

  <else>else
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>length</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator>
      <operator>(</operator><ternary><condition><expr><operator>(</operator><operator>*</operator><name>this_start_code</name> <operator>==</operator> <name>OP_CBRA</name> <operator>||</operator> <operator>*</operator><name>this_start_code</name> <operator>==</operator> <name>OP_SCBRA</name> <operator>||</operator>
        <operator>*</operator><name>this_start_code</name> <operator>==</operator> <name>OP_CBRAPOS</name> <operator>||</operator> <operator>*</operator><name>this_start_code</name> <operator>==</operator> <name>OP_SCBRAPOS</name><operator>)</operator></expr>
        ?</condition><then> <expr><name>IMM2_SIZE</name></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <do>do
      <block>{<block_content>
      <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>end_code</name> <operator>-</operator> <name>start_code</name> <operator>+</operator> <name>length</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>end_code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>end_code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
      </block_content>}</block>
    while <condition>(<expr><operator>*</operator><name>end_code</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>workspace</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* Bit indicating which vector is current */</comment>

<comment type="block">/* Loop for scanning the subject */</comment>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>current_subject</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>clen</name></decl>, <decl><type ref="prev"/><name>dlen</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>forced_fail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>partial_newline</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>could_continue</name> <init>= <expr><name>reset_could_continue</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>reset_could_continue</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Make the new state list into the active state list and empty the
  new state list. */</comment>

  <expr_stmt><expr><name>temp_states</name> <operator>=</operator> <name>active_states</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>active_states</name> <operator>=</operator> <name>new_states</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>new_states</name> <operator>=</operator> <name>temp_states</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>active_count</name> <operator>=</operator> <name>new_count</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>new_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>workspace</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>^=</operator> <literal type="number">1</literal></expr>;</expr_stmt>              <comment type="block">/* Remember for the restarting feature */</comment>
  <expr_stmt><expr><name><name>workspace</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>active_count</name></expr>;</expr_stmt>

  <comment type="block">/* Set the pointers for adding new states */</comment>

  <expr_stmt><expr><name>next_active_state</name> <operator>=</operator> <name>active_states</name> <operator>+</operator> <name>active_count</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>next_new_state</name> <operator>=</operator> <name>new_states</name></expr>;</expr_stmt>

  <comment type="block">/* Load the current character from the subject outside the loop, as many
  different states may want to look at it, and we assume that at least one
  will. */</comment>

  <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>end_subject</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>clen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>        <comment type="block">/* Number of data items in the character */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <expr_stmt><expr><call><name>GETCHARLENTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>ptr</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><name>clen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>        <comment type="block">/* This indicates the end of the subject */</comment>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name>NOTACHAR</name></expr>;</expr_stmt>    <comment type="block">/* This value should never actually be used */</comment>
    </block_content>}</block></else></if_stmt>

  <comment type="block">/* Scan up the active states and act on each one. The result of an action
  may be to add more states to the currently active list (e.g. on hitting a
  parenthesis) or it may be to put states on the new list, for considering
  when we move the character pointer on. */</comment>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>active_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
    <decl_stmt><decl><type><name>stateblock</name> <modifier>*</modifier></type><name>current_state</name> <init>= <expr><name>active_states</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOOL</name></type> <name>caseless</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>code</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>codevalue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>state_offset</name> <init>= <expr><name><name>current_state</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rrc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>

    <comment type="block">/* A negative offset is a special case meaning "hold off going to this
    (negated) state until the number of characters in the data field have
    been skipped". If the could_continue flag was passed over from a previous
    state, arrange for it to passed on. */</comment>

    <if_stmt><if>if <condition>(<expr><name>state_offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>current_state</name><operator>-&gt;</operator><name>data</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><name>state_offset</name></expr></argument>, <argument><expr><name><name>current_state</name><operator>-&gt;</operator><name>count</name></name></expr></argument>,
          <argument><expr><name><name>current_state</name><operator>-&gt;</operator><name>data</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>could_continue</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>reset_could_continue</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <continue>continue;</continue>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><name><name>current_state</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>state_offset</name> <operator>=</operator> <operator>-</operator><name>state_offset</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check for a duplicate state with the same count, and skip if found.
    See the note at the head of this module about the possibility of improving
    performance here. */</comment>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>active_states</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>==</operator> <name>state_offset</name> <operator>&amp;&amp;</operator>
          <name><name>active_states</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>==</operator> <name><name>current_state</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>NEXT_ACTIVE_STATE</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block></for>

    <comment type="block">/* The state offset is the offset to the opcode */</comment>

    <expr_stmt><expr><name>code</name> <operator>=</operator> <name>start_code</name> <operator>+</operator> <name>state_offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>codevalue</name> <operator>=</operator> <operator>*</operator><name>code</name></expr>;</expr_stmt>

    <comment type="block">/* If this opcode inspects a character, but we are at the end of the
    subject, remember the fact for use when testing for a partial match. */</comment>

    <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>poptable</name><index>[<expr><name>codevalue</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>could_continue</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If this opcode is followed by an inline character, load it. It is
    tempting to test for the presence of a subject character here, but that
    is wrong, because sometimes zero repetitions of the subject are
    permitted.

    We also use this mechanism for opcodes such as OP_TYPEPLUS that take an
    argument that is not a data character - but is always one byte long because
    the values are small. We have to take special action to deal with  \P, \p,
    \H, \h, \V, \v and \X in this case. To keep the other cases fast, convert
    these ones to new opcodes. */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>coptable</name><index>[<expr><name>codevalue</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>dlen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>GETCHARLEN</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>(</operator><name>code</name> <operator>+</operator> <name><name>coptable</name><index>[<expr><name>codevalue</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>dlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
      <expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>code</name><index>[<expr><name><name>coptable</name><index>[<expr><name>codevalue</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>&gt;=</operator> <name>OP_TYPESTAR</name></expr>)</condition>
        <block>{<block_content>
        <switch>switch<condition>(<expr><name>d</name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>OP_ANYBYTE</name></expr>:</case> <return>return <expr><name>PCRE2_ERROR_DFA_UITEM</name></expr>;</return>
          <case>case <expr><name>OP_NOTPROP</name></expr>:</case>
          <case>case <expr><name>OP_PROP</name></expr>:</case> <expr_stmt><expr><name>codevalue</name> <operator>+=</operator> <name>OP_PROP_EXTRA</name></expr>;</expr_stmt> <break>break;</break>
          <case>case <expr><name>OP_ANYNL</name></expr>:</case> <expr_stmt><expr><name>codevalue</name> <operator>+=</operator> <name>OP_ANYNL_EXTRA</name></expr>;</expr_stmt> <break>break;</break>
          <case>case <expr><name>OP_EXTUNI</name></expr>:</case> <expr_stmt><expr><name>codevalue</name> <operator>+=</operator> <name>OP_EXTUNI_EXTRA</name></expr>;</expr_stmt> <break>break;</break>
          <case>case <expr><name>OP_NOT_HSPACE</name></expr>:</case>
          <case>case <expr><name>OP_HSPACE</name></expr>:</case> <expr_stmt><expr><name>codevalue</name> <operator>+=</operator> <name>OP_HSPACE_EXTRA</name></expr>;</expr_stmt> <break>break;</break>
          <case>case <expr><name>OP_NOT_VSPACE</name></expr>:</case>
          <case>case <expr><name>OP_VSPACE</name></expr>:</case> <expr_stmt><expr><name>codevalue</name> <operator>+=</operator> <name>OP_VSPACE_EXTRA</name></expr>;</expr_stmt> <break>break;</break>
          <default>default:</default> <break>break;</break>
          </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name>dlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>         <comment type="block">/* Not strictly necessary, but compilers moan */</comment>
      <expr_stmt><expr><name>d</name> <operator>=</operator> <name>NOTACHAR</name></expr>;</expr_stmt>     <comment type="block">/* if these variables are not set. */</comment>
      </block_content>}</block></else></if_stmt>


    <comment type="block">/* Now process the individual opcodes */</comment>

    <switch>switch <condition>(<expr><name>codevalue</name></expr>)</condition>
      <block>{<block_content>
<comment type="block">/* ========================================================================== */</comment>
      <comment type="block">/* These cases are never obeyed. This is a fudge that causes a compile-
      time error if the vectors coptable or poptable, which are indexed by
      opcode, are not the correct length. It seems to be the only way to do
      such a check at compile time, as the sizeof() operator does not work
      in the C preprocessor. */</comment>

      <case>case <expr><name>OP_TABLE_LENGTH</name></expr>:</case>
      <case>case <expr><name>OP_TABLE_LENGTH</name> <operator>+</operator>
        <operator>(</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>coptable</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <name>OP_TABLE_LENGTH</name><operator>)</operator> <operator>&amp;&amp;</operator>
         <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>poptable</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <name>OP_TABLE_LENGTH</name><operator>)</operator><operator>)</operator></expr>:</case>
      <return>return <expr><literal type="number">0</literal></expr>;</return>

<comment type="block">/* ========================================================================== */</comment>
      <comment type="block">/* Reached a closing bracket. If not at the end of the pattern, carry
      on with the next opcode. For repeating opcodes, also add the repeat
      state. Note that KETRPOS will always be encountered at the end of the
      subpattern, because the possessive subpattern repeats are always handled
      using recursive calls. Thus, it never adds any new states.

      At the end of the (sub)pattern, unless we have an empty string and
      PCRE2_NOTEMPTY is set, or PCRE2_NOTEMPTY_ATSTART is set and we are at the
      start of the subject, save the match data, shifting up all previous
      matches so we always have the longest first. */</comment>

      <case>case <expr><name>OP_KET</name></expr>:</case>
      <case>case <expr><name>OP_KETRMIN</name></expr>:</case>
      <case>case <expr><name>OP_KETRMAX</name></expr>:</case>
      <case>case <expr><name>OP_KETRPOS</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>end_code</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>!=</operator> <name>OP_KET</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;</operator> <name>current_subject</name> <operator>||</operator>
            <operator>(</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_NOTEMPTY</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
              <operator>(</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_NOTEMPTY_ATSTART</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                <name>current_subject</name> <operator>&gt;</operator> <name>start_subject</name> <operator>+</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_offset</name></name><operator>)</operator><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>match_count</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>match_count</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>offsetcount</name> <operator>&gt;=</operator> <literal type="number">2</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>match_count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>++</operator><name>match_count</name> <operator>*</operator> <literal type="number">2</literal> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>offsetcount</name></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><name>match_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>count</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>match_count</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><operator>(</operator><name>int</name><operator>)</operator><name>offsetcount</name></expr> </then><else>: <expr><name>match_count</name> <operator>*</operator> <literal type="number">2</literal></expr></else></ternary><operator>)</operator> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memmove</name><argument_list>(<argument><expr><name>offsets</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>offsets</name></expr></argument>,
            <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_SIZE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>offsetcount</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name><name>offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>current_subject</name> <operator>-</operator> <name>start_subject</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name>start_subject</name><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_DFA_SHORTEST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>match_count</name></expr>;</return></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      <break>break;</break>

<comment type="block">/* ========================================================================== */</comment>
      <comment type="block">/* These opcodes add to the current list of states without looking
      at the current character. */</comment>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_ALT</name></expr>:</case>
      <do>do <block>{<block_content> <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block> while <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
      <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>code</name> <operator>-</operator> <name>start_code</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_BRA</name></expr>:</case>
      <case>case <expr><name>OP_SBRA</name></expr>:</case>
      <do>do
        <block>{<block_content>
        <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>code</name> <operator>-</operator> <name>start_code</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
      while <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_CBRA</name></expr>:</case>
      <case>case <expr><name>OP_SCBRA</name></expr>:</case>
      <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>code</name> <operator>-</operator> <name>start_code</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <name>IMM2_SIZE</name><operator>)</operator></expr></argument>,  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>code</name> <operator>-</operator> <name>start_code</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name><operator>)</operator></expr></argument>,  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_BRAZERO</name></expr>:</case>
      <case>case <expr><name>OP_BRAMINZERO</name></expr>:</case>
      <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
      <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>code</name> <operator>-</operator> <name>start_code</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_SKIPZERO</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
      <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>code</name> <operator>-</operator> <name>start_code</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_CIRC</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>start_subject</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_NOTBOL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_CIRCM</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptr</name> <operator>==</operator> <name>start_subject</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_NOTBOL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
          <operator>(</operator><operator>(</operator><name>ptr</name> <operator>!=</operator> <name>end_subject</name> <operator>||</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name> <operator>&amp;</operator> <name>PCRE2_ALT_CIRCUMFLEX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>)</operator>
            <operator>&amp;&amp;</operator> <call><name>WAS_NEWLINE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_EOD</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>end_subject</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_PARTIAL_HARD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <return>return <expr><name>PCRE2_ERROR_PARTIAL</name></expr>;</return></block_content></block></if>
        <else>else <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_SOD</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>start_subject</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_SOM</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>start_subject</name> <operator>+</operator> <name>start_offset</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <break>break;</break>


<comment type="block">/* ========================================================================== */</comment>
      <comment type="block">/* These opcodes inspect the next subject character, and sometimes
      the previous one as well, but do not have an argument. The variable
      clen contains the length of the current character and is zero if we are
      at the end of the subject. */</comment>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_ANY</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_PARTIAL_HARD</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator>
            <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nllen</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
            <name>c</name> <operator>==</operator> <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>could_continue</name> <operator>=</operator> <name>partial_newline</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          </block_content>}</block></if>
        <else>else
          <block>{<block_content>
          <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_ALLANY</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_EODN</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>==</operator> <name>end_subject</name> <operator>-</operator> <name><name>mb</name><operator>-&gt;</operator><name>nllen</name></name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_PARTIAL_HARD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <return>return <expr><name>PCRE2_ERROR_PARTIAL</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_DOLL</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_NOTEOL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_PARTIAL_HARD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>could_continue</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>clen</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
            <operator>(</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name> <operator>&amp;</operator> <name>PCRE2_DOLLAR_ENDONLY</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
               <operator>(</operator><name>ptr</name> <operator>==</operator> <name>end_subject</name> <operator>-</operator> <name><name>mb</name><operator>-&gt;</operator><name>nllen</name></name><operator>)</operator>
            <operator>)</operator></expr>)</condition>
          <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator>
                 <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_PARTIAL_HARD</name><operator>|</operator><name>PCRE2_PARTIAL_SOFT</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                 <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator>
                 <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nllen</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
                 <name>c</name> <operator>==</operator> <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_PARTIAL_HARD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>reset_could_continue</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
          <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>could_continue</name> <operator>=</operator> <name>partial_newline</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_DOLLM</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_NOTEOL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_PARTIAL_HARD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>could_continue</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>clen</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
            <operator>(</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name> <operator>&amp;</operator> <name>PCRE2_DOLLAR_ENDONLY</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
          <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator>
                 <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_PARTIAL_HARD</name><operator>|</operator><name>PCRE2_PARTIAL_SOFT</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                 <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator>
                 <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nllen</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
                 <name>c</name> <operator>==</operator> <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_PARTIAL_HARD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>reset_could_continue</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
          <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>could_continue</name> <operator>=</operator> <name>partial_newline</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>

      <case>case <expr><name>OP_DIGIT</name></expr>:</case>
      <case>case <expr><name>OP_WHITESPACE</name></expr>:</case>
      <case>case <expr><name>OP_WORDCHAR</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator>
            <operator>(</operator><operator>(</operator><name><name>ctypes</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name><name>toptable1</name><index>[<expr><name>codevalue</name></expr>]</index></name><operator>)</operator> <operator>^</operator> <name><name>toptable2</name><index>[<expr><name>codevalue</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_NOT_DIGIT</name></expr>:</case>
      <case>case <expr><name>OP_NOT_WHITESPACE</name></expr>:</case>
      <case>case <expr><name>OP_NOT_WORDCHAR</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="number">256</literal> <operator>||</operator>
            <operator>(</operator><operator>(</operator><name><name>ctypes</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name><name>toptable1</name><index>[<expr><name>codevalue</name></expr>]</index></name><operator>)</operator> <operator>^</operator> <name><name>toptable2</name><index>[<expr><name>codevalue</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_WORD_BOUNDARY</name></expr>:</case>
      <case>case <expr><name>OP_NOT_WORD_BOUNDARY</name></expr>:</case>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>left_word</name></decl>, <decl><type ref="prev"/><name>right_word</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;</operator> <name>start_subject</name></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>temp</name> <init>= <expr><name>ptr</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>temp</name> <operator>&lt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_used_ptr</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>start_used_ptr</name></name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
          <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>BACKCHAR</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <expr_stmt><expr><call><name>GETCHARTEST</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>left_word</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if> <else>else
              <block>{<block_content>
              <decl_stmt><decl><type><name>uint32_t</name></type> <name>cat</name> <init>= <expr><call><name>UCD_CATEGORY</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name>left_word</name> <operator>=</operator> <operator>(</operator><name>cat</name> <operator>==</operator> <name>ucp_L</name> <operator>||</operator> <name>cat</name> <operator>==</operator> <name>ucp_N</name><operator>)</operator></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
          <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <expr_stmt><expr><name>left_word</name> <operator>=</operator> <name>d</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ctypes</name><index>[<expr><name>d</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
          </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>left_word</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name></expr>)</condition>
            <block>{<block_content>
            <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>temp</name> <init>= <expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
            <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>FORWARDCHARTEST</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>right_word</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if> <else>else
              <block>{<block_content>
              <decl_stmt><decl><type><name>uint32_t</name></type> <name>cat</name> <init>= <expr><call><name>UCD_CATEGORY</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name>right_word</name> <operator>=</operator> <operator>(</operator><name>cat</name> <operator>==</operator> <name>ucp_L</name> <operator>||</operator> <name>cat</name> <operator>==</operator> <name>ucp_N</name><operator>)</operator></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
          <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <expr_stmt><expr><name>right_word</name> <operator>=</operator> <name>c</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ctypes</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
          </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>right_word</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>left_word</name> <operator>==</operator> <name>right_word</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>codevalue</name> <operator>==</operator> <name>OP_NOT_WORD_BOUNDARY</name><operator>)</operator></expr>)</condition>
          <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
        </block_content>}</block>
      <break>break;</break>


      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <comment type="block">/* Check the next character by Unicode property. We will get here only
      if the support is in the binary; otherwise a compile-time error occurs.
      */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <case>case <expr><name>OP_PROP</name></expr>:</case>
      <case>case <expr><name>OP_NOTPROP</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>OK</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>ucd_record</name> <modifier>*</modifier></type> <name>prop</name> <init>= <expr><call><name>GET_UCD</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <switch>switch<condition>(<expr><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>PT_ANY</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PT_LAMP</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name>ucp_Lu</name> <operator>||</operator> <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name>ucp_Ll</name> <operator>||</operator>
               <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name>ucp_Lt</name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PT_GC</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name><name>code</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PT_PC</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name><name>code</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PT_SC</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name><name>prop</name><operator>-&gt;</operator><name>script</name></name> <operator>==</operator> <name><name>code</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
          <break>break;</break>

          <comment type="block">/* These are specials for combination cases. */</comment>

          <case>case <expr><name>PT_ALNUM</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_L</name> <operator>||</operator>
               <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_N</name></expr>;</expr_stmt>
          <break>break;</break>

          <comment type="block">/* Perl space used to exclude VT, but from Perl 5.18 it is included,
          which means that Perl space and POSIX space are now identical. PCRE
          was changed at release 8.34. */</comment>

          <case>case <expr><name>PT_SPACE</name></expr>:</case>    <comment type="block">/* Perl space */</comment>
          <case>case <expr><name>PT_PXSPACE</name></expr>:</case>  <comment type="block">/* POSIX space */</comment>
          <switch>switch<condition>(<expr><name>c</name></expr>)</condition>
            <block>{<block_content>
            <label><name>HSPACE_CASES</name>:</label>
            <label><name>VSPACE_CASES</name>:</label>
            <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
            <break>break;</break>

            <default>default:</default>
            <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_Z</name></expr>;</expr_stmt>
            <break>break;</break>
            </block_content>}</block></switch>
          <break>break;</break>

          <case>case <expr><name>PT_WORD</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_L</name> <operator>||</operator>
               <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_N</name> <operator>||</operator>
               <name>c</name> <operator>==</operator> <name>CHAR_UNDERSCORE</name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PT_CLIST</name></expr>:</case>
          <expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_caseless_sets</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>code</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <operator>*</operator><name>cp</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <operator>*</operator><name>cp</name><operator>++</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>PT_UCNC</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>c</name> <operator>==</operator> <name>CHAR_DOLLAR_SIGN</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>CHAR_COMMERCIAL_AT</name> <operator>||</operator>
               <name>c</name> <operator>==</operator> <name>CHAR_GRAVE_ACCENT</name> <operator>||</operator> <operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="number">0xa0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="number">0xd7ff</literal><operator>)</operator> <operator>||</operator>
               <name>c</name> <operator>&gt;=</operator> <literal type="number">0xe000</literal></expr>;</expr_stmt>
          <break>break;</break>

          <comment type="block">/* Should never occur, but keep compilers from grumbling. */</comment>

          <default>default:</default>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>codevalue</name> <operator>!=</operator> <name>OP_PROP</name></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name>OK</name> <operator>==</operator> <operator>(</operator><name>codevalue</name> <operator>==</operator> <name>OP_PROP</name><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<comment type="block">/* ========================================================================== */</comment>
      <comment type="block">/* These opcodes likewise inspect the subject character, but have an
      argument that is not a data character. It is one of these opcodes:
      OP_ANY, OP_ALLANY, OP_DIGIT, OP_NOT_DIGIT, OP_WHITESPACE, OP_NOT_SPACE,
      OP_WORDCHAR, OP_NOT_WORDCHAR. The value is loaded into d. */</comment>

      <case>case <expr><name>OP_TYPEPLUS</name></expr>:</case>
      <case>case <expr><name>OP_TYPEMINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_TYPEPOSPLUS</name></expr>:</case>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>current_state</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>  <comment type="block">/* Already matched */</comment>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>OP_ANY</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_PARTIAL_HARD</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator>
            <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nllen</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
            <name>c</name> <operator>==</operator> <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>could_continue</name> <operator>=</operator> <name>partial_newline</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <name>d</name> <operator>!=</operator> <name>OP_DIGIT</name> <operator>&amp;&amp;</operator> <name>d</name> <operator>!=</operator> <name>OP_WHITESPACE</name> <operator>&amp;&amp;</operator> <name>d</name> <operator>!=</operator> <name>OP_WORDCHAR</name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator>
              <operator>(</operator><name>d</name> <operator>!=</operator> <name>OP_ANY</name> <operator>||</operator> <operator>!</operator><call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
              <operator>(</operator><operator>(</operator><name><name>ctypes</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name><name>toptable1</name><index>[<expr><name>d</name></expr>]</index></name><operator>)</operator> <operator>^</operator> <name><name>toptable2</name><index>[<expr><name>d</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>codevalue</name> <operator>==</operator> <name>OP_TYPEPOSPLUS</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>            <comment type="block">/* Remove non-match possibility */</comment>
            <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_TYPEQUERY</name></expr>:</case>
      <case>case <expr><name>OP_TYPEMINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_TYPEPOSQUERY</name></expr>:</case>
      <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>OP_ANY</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_PARTIAL_HARD</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator>
            <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nllen</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
            <name>c</name> <operator>==</operator> <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>could_continue</name> <operator>=</operator> <name>partial_newline</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <name>d</name> <operator>!=</operator> <name>OP_DIGIT</name> <operator>&amp;&amp;</operator> <name>d</name> <operator>!=</operator> <name>OP_WHITESPACE</name> <operator>&amp;&amp;</operator> <name>d</name> <operator>!=</operator> <name>OP_WORDCHAR</name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator>
              <operator>(</operator><name>d</name> <operator>!=</operator> <name>OP_ANY</name> <operator>||</operator> <operator>!</operator><call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
              <operator>(</operator><operator>(</operator><name><name>ctypes</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name><name>toptable1</name><index>[<expr><name>d</name></expr>]</index></name><operator>)</operator> <operator>^</operator> <name><name>toptable2</name><index>[<expr><name>d</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>==</operator> <name>OP_TYPEPOSQUERY</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>            <comment type="block">/* Remove non-match possibility */</comment>
            <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_TYPESTAR</name></expr>:</case>
      <case>case <expr><name>OP_TYPEMINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_TYPEPOSSTAR</name></expr>:</case>
      <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>OP_ANY</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_PARTIAL_HARD</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator>
            <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nllen</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
            <name>c</name> <operator>==</operator> <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>could_continue</name> <operator>=</operator> <name>partial_newline</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <name>d</name> <operator>!=</operator> <name>OP_DIGIT</name> <operator>&amp;&amp;</operator> <name>d</name> <operator>!=</operator> <name>OP_WHITESPACE</name> <operator>&amp;&amp;</operator> <name>d</name> <operator>!=</operator> <name>OP_WORDCHAR</name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator>
              <operator>(</operator><name>d</name> <operator>!=</operator> <name>OP_ANY</name> <operator>||</operator> <operator>!</operator><call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
              <operator>(</operator><operator>(</operator><name><name>ctypes</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name><name>toptable1</name><index>[<expr><name>d</name></expr>]</index></name><operator>)</operator> <operator>^</operator> <name><name>toptable2</name><index>[<expr><name>d</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>==</operator> <name>OP_TYPEPOSSTAR</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>            <comment type="block">/* Remove non-match possibility */</comment>
            <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_TYPEEXACT</name></expr>:</case>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>current_state</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>  <comment type="block">/* Number already matched */</comment>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>OP_ANY</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_PARTIAL_HARD</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator>
            <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nllen</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
            <name>c</name> <operator>==</operator> <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>could_continue</name> <operator>=</operator> <name>partial_newline</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <name>d</name> <operator>!=</operator> <name>OP_DIGIT</name> <operator>&amp;&amp;</operator> <name>d</name> <operator>!=</operator> <name>OP_WHITESPACE</name> <operator>&amp;&amp;</operator> <name>d</name> <operator>!=</operator> <name>OP_WORDCHAR</name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator>
              <operator>(</operator><name>d</name> <operator>!=</operator> <name>OP_ANY</name> <operator>||</operator> <operator>!</operator><call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
              <operator>(</operator><operator>(</operator><name><name>ctypes</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name><name>toptable1</name><index>[<expr><name>d</name></expr>]</index></name><operator>)</operator> <operator>^</operator> <name><name>toptable2</name><index>[<expr><name>d</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>++</operator><name>count</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if>
          <else>else
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_TYPEUPTO</name></expr>:</case>
      <case>case <expr><name>OP_TYPEMINUPTO</name></expr>:</case>
      <case>case <expr><name>OP_TYPEPOSUPTO</name></expr>:</case>
      <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>current_state</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>  <comment type="block">/* Number already matched */</comment>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>OP_ANY</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_PARTIAL_HARD</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_FIXED</name> <operator>&amp;&amp;</operator>
            <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nllen</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
            <name>c</name> <operator>==</operator> <name><name>NLBLOCK</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>could_continue</name> <operator>=</operator> <name>partial_newline</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <name>d</name> <operator>!=</operator> <name>OP_DIGIT</name> <operator>&amp;&amp;</operator> <name>d</name> <operator>!=</operator> <name>OP_WHITESPACE</name> <operator>&amp;&amp;</operator> <name>d</name> <operator>!=</operator> <name>OP_WORDCHAR</name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator>
              <operator>(</operator><name>d</name> <operator>!=</operator> <name>OP_ANY</name> <operator>||</operator> <operator>!</operator><call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
              <operator>(</operator><operator>(</operator><name><name>ctypes</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name><name>toptable1</name><index>[<expr><name>d</name></expr>]</index></name><operator>)</operator> <operator>^</operator> <name><name>toptable2</name><index>[<expr><name>d</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>==</operator> <name>OP_TYPEPOSUPTO</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>           <comment type="block">/* Remove non-match possibility */</comment>
            <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><operator>++</operator><name>count</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if>
          <else>else
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

<comment type="block">/* ========================================================================== */</comment>
      <comment type="block">/* These are virtual opcodes that are used when something like
      OP_TYPEPLUS has OP_PROP, OP_NOTPROP, OP_ANYNL, or OP_EXTUNI as its
      argument. It keeps the code above fast for the other cases. The argument
      is in the d variable. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <case>case <expr><name>OP_PROP_EXTRA</name> <operator>+</operator> <name>OP_TYPEPLUS</name></expr>:</case>
      <case>case <expr><name>OP_PROP_EXTRA</name> <operator>+</operator> <name>OP_TYPEMINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_PROP_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSPLUS</name></expr>:</case>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>current_state</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>           <comment type="block">/* Already matched */</comment>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>OK</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>ucd_record</name> <modifier>*</modifier></type> <name>prop</name> <init>= <expr><call><name>GET_UCD</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <switch>switch<condition>(<expr><name><name>code</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>PT_ANY</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PT_LAMP</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name>ucp_Lu</name> <operator>||</operator> <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name>ucp_Ll</name> <operator>||</operator>
            <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name>ucp_Lt</name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PT_GC</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name><name>code</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PT_PC</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name><name>code</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PT_SC</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name><name>prop</name><operator>-&gt;</operator><name>script</name></name> <operator>==</operator> <name><name>code</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
          <break>break;</break>

          <comment type="block">/* These are specials for combination cases. */</comment>

          <case>case <expr><name>PT_ALNUM</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_L</name> <operator>||</operator>
               <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_N</name></expr>;</expr_stmt>
          <break>break;</break>

          <comment type="block">/* Perl space used to exclude VT, but from Perl 5.18 it is included,
          which means that Perl space and POSIX space are now identical. PCRE
          was changed at release 8.34. */</comment>

          <case>case <expr><name>PT_SPACE</name></expr>:</case>    <comment type="block">/* Perl space */</comment>
          <case>case <expr><name>PT_PXSPACE</name></expr>:</case>  <comment type="block">/* POSIX space */</comment>
          <switch>switch<condition>(<expr><name>c</name></expr>)</condition>
            <block>{<block_content>
            <label><name>HSPACE_CASES</name>:</label>
            <label><name>VSPACE_CASES</name>:</label>
            <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
            <break>break;</break>

            <default>default:</default>
            <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_Z</name></expr>;</expr_stmt>
            <break>break;</break>
            </block_content>}</block></switch>
          <break>break;</break>

          <case>case <expr><name>PT_WORD</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_L</name> <operator>||</operator>
               <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_N</name> <operator>||</operator>
               <name>c</name> <operator>==</operator> <name>CHAR_UNDERSCORE</name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PT_CLIST</name></expr>:</case>
          <expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_caseless_sets</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>code</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <operator>*</operator><name>cp</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <operator>*</operator><name>cp</name><operator>++</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>PT_UCNC</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>c</name> <operator>==</operator> <name>CHAR_DOLLAR_SIGN</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>CHAR_COMMERCIAL_AT</name> <operator>||</operator>
               <name>c</name> <operator>==</operator> <name>CHAR_GRAVE_ACCENT</name> <operator>||</operator> <operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="number">0xa0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="number">0xd7ff</literal><operator>)</operator> <operator>||</operator>
               <name>c</name> <operator>&gt;=</operator> <literal type="number">0xe000</literal></expr>;</expr_stmt>
          <break>break;</break>

          <comment type="block">/* Should never occur, but keep compilers from grumbling. */</comment>

          <default>default:</default>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>codevalue</name> <operator>!=</operator> <name>OP_PROP</name></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name>OK</name> <operator>==</operator> <operator>(</operator><name>d</name> <operator>==</operator> <name>OP_PROP</name><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>codevalue</name> <operator>==</operator> <name>OP_PROP_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSPLUS</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>           <comment type="block">/* Remove non-match possibility */</comment>
            <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_EXTUNI_EXTRA</name> <operator>+</operator> <name>OP_TYPEPLUS</name></expr>:</case>
      <case>case <expr><name>OP_EXTUNI_EXTRA</name> <operator>+</operator> <name>OP_TYPEMINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_EXTUNI_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSPLUS</name></expr>:</case>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>current_state</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>  <comment type="block">/* Already matched */</comment>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>ncount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>codevalue</name> <operator>==</operator> <name>OP_EXTUNI_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSPLUS</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>           <comment type="block">/* Remove non-match possibility */</comment>
          <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><call><name>PRIV</name><argument_list>(<argument><expr><name>extuni</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>clen</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name></expr></argument>, <argument><expr><name>end_subject</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name>ncount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><name>state_offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>ncount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_ANYNL_EXTRA</name> <operator>+</operator> <name>OP_TYPEPLUS</name></expr>:</case>
      <case>case <expr><name>OP_ANYNL_EXTRA</name> <operator>+</operator> <name>OP_TYPEMINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_ANYNL_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSPLUS</name></expr>:</case>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>current_state</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>  <comment type="block">/* Already matched */</comment>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>ncount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>CHAR_VT</name></expr>:</case>
          <case>case <expr><name>CHAR_FF</name></expr>:</case>
          <case>case <expr><name>CHAR_NEL</name></expr>:</case>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EBCDIC</name></cpp:ifndef>
          <case>case <expr><literal type="number">0x2028</literal></expr>:</case>
          <case>case <expr><literal type="number">0x2029</literal></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* Not EBCDIC */</comment>
          <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>bsr_convention</name></name> <operator>==</operator> <name>PCRE2_BSR_ANYCRLF</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <goto>goto <name>ANYNL01</name>;</goto>

          <case>case <expr><name>CHAR_CR</name></expr>:</case>
          <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator> <call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>CHAR_LF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ncount</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <comment type="block">/* Fall through */</comment>

          <label><name>ANYNL01</name>:</label>
          <case>case <expr><name>CHAR_LF</name></expr>:</case>
          <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>codevalue</name> <operator>==</operator> <name>OP_ANYNL_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSPLUS</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>           <comment type="block">/* Remove non-match possibility */</comment>
            <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><name>state_offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>ncount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>

          <default>default:</default>
          <break>break;</break>
          </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_VSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEPLUS</name></expr>:</case>
      <case>case <expr><name>OP_VSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEMINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_VSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSPLUS</name></expr>:</case>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>current_state</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>  <comment type="block">/* Already matched */</comment>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>OK</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
          <block>{<block_content>
          <label><name>VSPACE_CASES</name>:</label>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

          <default>default:</default>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name>OK</name> <operator>==</operator> <operator>(</operator><name>d</name> <operator>==</operator> <name>OP_VSPACE</name><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>codevalue</name> <operator>==</operator> <name>OP_VSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSPLUS</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>           <comment type="block">/* Remove non-match possibility */</comment>
            <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><name>state_offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_HSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEPLUS</name></expr>:</case>
      <case>case <expr><name>OP_HSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEMINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_HSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSPLUS</name></expr>:</case>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>current_state</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>  <comment type="block">/* Already matched */</comment>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>OK</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
          <block>{<block_content>
          <label><name>HSPACE_CASES</name>:</label>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

          <default>default:</default>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name>OK</name> <operator>==</operator> <operator>(</operator><name>d</name> <operator>==</operator> <name>OP_HSPACE</name><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>codevalue</name> <operator>==</operator> <name>OP_HSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSPLUS</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>           <comment type="block">/* Remove non-match possibility */</comment>
            <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><name>state_offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <case>case <expr><name>OP_PROP_EXTRA</name> <operator>+</operator> <name>OP_TYPEQUERY</name></expr>:</case>
      <case>case <expr><name>OP_PROP_EXTRA</name> <operator>+</operator> <name>OP_TYPEMINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_PROP_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSQUERY</name></expr>:</case>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      <goto>goto <name>QS1</name>;</goto>

      <case>case <expr><name>OP_PROP_EXTRA</name> <operator>+</operator> <name>OP_TYPESTAR</name></expr>:</case>
      <case>case <expr><name>OP_PROP_EXTRA</name> <operator>+</operator> <name>OP_TYPEMINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_PROP_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSSTAR</name></expr>:</case>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <label><name>QS1</name>:</label>

      <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>OK</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>ucd_record</name> <modifier>*</modifier></type> <name>prop</name> <init>= <expr><call><name>GET_UCD</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <switch>switch<condition>(<expr><name><name>code</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>PT_ANY</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PT_LAMP</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name>ucp_Lu</name> <operator>||</operator> <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name>ucp_Ll</name> <operator>||</operator>
            <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name>ucp_Lt</name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PT_GC</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name><name>code</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PT_PC</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name><name>code</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PT_SC</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name><name>prop</name><operator>-&gt;</operator><name>script</name></name> <operator>==</operator> <name><name>code</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
          <break>break;</break>

          <comment type="block">/* These are specials for combination cases. */</comment>

          <case>case <expr><name>PT_ALNUM</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_L</name> <operator>||</operator>
               <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_N</name></expr>;</expr_stmt>
          <break>break;</break>

          <comment type="block">/* Perl space used to exclude VT, but from Perl 5.18 it is included,
          which means that Perl space and POSIX space are now identical. PCRE
          was changed at release 8.34. */</comment>

          <case>case <expr><name>PT_SPACE</name></expr>:</case>    <comment type="block">/* Perl space */</comment>
          <case>case <expr><name>PT_PXSPACE</name></expr>:</case>  <comment type="block">/* POSIX space */</comment>
          <switch>switch<condition>(<expr><name>c</name></expr>)</condition>
            <block>{<block_content>
            <label><name>HSPACE_CASES</name>:</label>
            <label><name>VSPACE_CASES</name>:</label>
            <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
            <break>break;</break>

            <default>default:</default>
            <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_Z</name></expr>;</expr_stmt>
            <break>break;</break>
            </block_content>}</block></switch>
          <break>break;</break>

          <case>case <expr><name>PT_WORD</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_L</name> <operator>||</operator>
               <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_N</name> <operator>||</operator>
               <name>c</name> <operator>==</operator> <name>CHAR_UNDERSCORE</name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PT_CLIST</name></expr>:</case>
          <expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_caseless_sets</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>code</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <operator>*</operator><name>cp</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <operator>*</operator><name>cp</name><operator>++</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>PT_UCNC</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>c</name> <operator>==</operator> <name>CHAR_DOLLAR_SIGN</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>CHAR_COMMERCIAL_AT</name> <operator>||</operator>
               <name>c</name> <operator>==</operator> <name>CHAR_GRAVE_ACCENT</name> <operator>||</operator> <operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="number">0xa0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="number">0xd7ff</literal><operator>)</operator> <operator>||</operator>
               <name>c</name> <operator>&gt;=</operator> <literal type="number">0xe000</literal></expr>;</expr_stmt>
          <break>break;</break>

          <comment type="block">/* Should never occur, but keep compilers from grumbling. */</comment>

          <default>default:</default>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>codevalue</name> <operator>!=</operator> <name>OP_PROP</name></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name>OK</name> <operator>==</operator> <operator>(</operator><name>d</name> <operator>==</operator> <name>OP_PROP</name><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>==</operator> <name>OP_PROP_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSSTAR</name> <operator>||</operator>
              <name>codevalue</name> <operator>==</operator> <name>OP_PROP_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSQUERY</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>           <comment type="block">/* Remove non-match possibility */</comment>
            <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <name>count</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_EXTUNI_EXTRA</name> <operator>+</operator> <name>OP_TYPEQUERY</name></expr>:</case>
      <case>case <expr><name>OP_EXTUNI_EXTRA</name> <operator>+</operator> <name>OP_TYPEMINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_EXTUNI_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSQUERY</name></expr>:</case>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <goto>goto <name>QS2</name>;</goto>

      <case>case <expr><name>OP_EXTUNI_EXTRA</name> <operator>+</operator> <name>OP_TYPESTAR</name></expr>:</case>
      <case>case <expr><name>OP_EXTUNI_EXTRA</name> <operator>+</operator> <name>OP_TYPEMINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_EXTUNI_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSSTAR</name></expr>:</case>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <label><name>QS2</name>:</label>

      <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>ncount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>==</operator> <name>OP_EXTUNI_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSSTAR</name> <operator>||</operator>
            <name>codevalue</name> <operator>==</operator> <name>OP_EXTUNI_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSQUERY</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>           <comment type="block">/* Remove non-match possibility */</comment>
          <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><call><name>PRIV</name><argument_list>(<argument><expr><name>extuni</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>clen</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name></expr></argument>, <argument><expr><name>end_subject</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name>ncount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name>state_offset</name> <operator>+</operator> <name>count</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ncount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_ANYNL_EXTRA</name> <operator>+</operator> <name>OP_TYPEQUERY</name></expr>:</case>
      <case>case <expr><name>OP_ANYNL_EXTRA</name> <operator>+</operator> <name>OP_TYPEMINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_ANYNL_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSQUERY</name></expr>:</case>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <goto>goto <name>QS3</name>;</goto>

      <case>case <expr><name>OP_ANYNL_EXTRA</name> <operator>+</operator> <name>OP_TYPESTAR</name></expr>:</case>
      <case>case <expr><name>OP_ANYNL_EXTRA</name> <operator>+</operator> <name>OP_TYPEMINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_ANYNL_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSSTAR</name></expr>:</case>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <label><name>QS3</name>:</label>
      <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>ncount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>CHAR_VT</name></expr>:</case>
          <case>case <expr><name>CHAR_FF</name></expr>:</case>
          <case>case <expr><name>CHAR_NEL</name></expr>:</case>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EBCDIC</name></cpp:ifndef>
          <case>case <expr><literal type="number">0x2028</literal></expr>:</case>
          <case>case <expr><literal type="number">0x2029</literal></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* Not EBCDIC */</comment>
          <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>bsr_convention</name></name> <operator>==</operator> <name>PCRE2_BSR_ANYCRLF</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <goto>goto <name>ANYNL02</name>;</goto>

          <case>case <expr><name>CHAR_CR</name></expr>:</case>
          <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator> <call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>CHAR_LF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ncount</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <comment type="block">/* Fall through */</comment>

          <label><name>ANYNL02</name>:</label>
          <case>case <expr><name>CHAR_LF</name></expr>:</case>
          <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>==</operator> <name>OP_ANYNL_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSSTAR</name> <operator>||</operator>
              <name>codevalue</name> <operator>==</operator> <name>OP_ANYNL_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSQUERY</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>           <comment type="block">/* Remove non-match possibility */</comment>
            <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name>state_offset</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><name>count</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ncount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>

          <default>default:</default>
          <break>break;</break>
          </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_VSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEQUERY</name></expr>:</case>
      <case>case <expr><name>OP_VSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEMINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_VSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSQUERY</name></expr>:</case>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <goto>goto <name>QS4</name>;</goto>

      <case>case <expr><name>OP_VSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPESTAR</name></expr>:</case>
      <case>case <expr><name>OP_VSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEMINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_VSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSSTAR</name></expr>:</case>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <label><name>QS4</name>:</label>
      <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>OK</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
          <block>{<block_content>
          <label><name>VSPACE_CASES</name>:</label>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

          <default>default:</default>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></switch>
        <if_stmt><if>if <condition>(<expr><name>OK</name> <operator>==</operator> <operator>(</operator><name>d</name> <operator>==</operator> <name>OP_VSPACE</name><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>==</operator> <name>OP_VSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSSTAR</name> <operator>||</operator>
              <name>codevalue</name> <operator>==</operator> <name>OP_VSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSQUERY</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>           <comment type="block">/* Remove non-match possibility */</comment>
            <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name>state_offset</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><name>count</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_HSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEQUERY</name></expr>:</case>
      <case>case <expr><name>OP_HSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEMINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_HSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSQUERY</name></expr>:</case>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <goto>goto <name>QS5</name>;</goto>

      <case>case <expr><name>OP_HSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPESTAR</name></expr>:</case>
      <case>case <expr><name>OP_HSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEMINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_HSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSSTAR</name></expr>:</case>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <label><name>QS5</name>:</label>
      <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>OK</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
          <block>{<block_content>
          <label><name>HSPACE_CASES</name>:</label>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

          <default>default:</default>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name>OK</name> <operator>==</operator> <operator>(</operator><name>d</name> <operator>==</operator> <name>OP_HSPACE</name><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>==</operator> <name>OP_HSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSSTAR</name> <operator>||</operator>
              <name>codevalue</name> <operator>==</operator> <name>OP_HSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSQUERY</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>           <comment type="block">/* Remove non-match possibility */</comment>
            <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name>state_offset</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><name>count</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <case>case <expr><name>OP_PROP_EXTRA</name> <operator>+</operator> <name>OP_TYPEEXACT</name></expr>:</case>
      <case>case <expr><name>OP_PROP_EXTRA</name> <operator>+</operator> <name>OP_TYPEUPTO</name></expr>:</case>
      <case>case <expr><name>OP_PROP_EXTRA</name> <operator>+</operator> <name>OP_TYPEMINUPTO</name></expr>:</case>
      <case>case <expr><name>OP_PROP_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSUPTO</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>!=</operator> <name>OP_PROP_EXTRA</name> <operator>+</operator> <name>OP_TYPEEXACT</name></expr>)</condition>
        <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>current_state</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>  <comment type="block">/* Number already matched */</comment>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>OK</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>ucd_record</name> <modifier>*</modifier></type> <name>prop</name> <init>= <expr><call><name>GET_UCD</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <switch>switch<condition>(<expr><name><name>code</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>PT_ANY</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PT_LAMP</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name>ucp_Lu</name> <operator>||</operator> <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name>ucp_Ll</name> <operator>||</operator>
            <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name>ucp_Lt</name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PT_GC</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name><name>code</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PT_PC</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name><name>code</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PT_SC</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name><name>prop</name><operator>-&gt;</operator><name>script</name></name> <operator>==</operator> <name><name>code</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
          <break>break;</break>

          <comment type="block">/* These are specials for combination cases. */</comment>

          <case>case <expr><name>PT_ALNUM</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_L</name> <operator>||</operator>
               <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_N</name></expr>;</expr_stmt>
          <break>break;</break>

          <comment type="block">/* Perl space used to exclude VT, but from Perl 5.18 it is included,
          which means that Perl space and POSIX space are now identical. PCRE
          was changed at release 8.34. */</comment>

          <case>case <expr><name>PT_SPACE</name></expr>:</case>    <comment type="block">/* Perl space */</comment>
          <case>case <expr><name>PT_PXSPACE</name></expr>:</case>  <comment type="block">/* POSIX space */</comment>
          <switch>switch<condition>(<expr><name>c</name></expr>)</condition>
            <block>{<block_content>
            <label><name>HSPACE_CASES</name>:</label>
            <label><name>VSPACE_CASES</name>:</label>
            <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
            <break>break;</break>

            <default>default:</default>
            <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_Z</name></expr>;</expr_stmt>
            <break>break;</break>
            </block_content>}</block></switch>
          <break>break;</break>

          <case>case <expr><name>PT_WORD</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_L</name> <operator>||</operator>
               <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_N</name> <operator>||</operator>
               <name>c</name> <operator>==</operator> <name>CHAR_UNDERSCORE</name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PT_CLIST</name></expr>:</case>
          <expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_caseless_sets</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>code</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
          <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <operator>*</operator><name>cp</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <operator>*</operator><name>cp</name><operator>++</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
          <break>break;</break>

          <case>case <expr><name>PT_UCNC</name></expr>:</case>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>c</name> <operator>==</operator> <name>CHAR_DOLLAR_SIGN</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>CHAR_COMMERCIAL_AT</name> <operator>||</operator>
               <name>c</name> <operator>==</operator> <name>CHAR_GRAVE_ACCENT</name> <operator>||</operator> <operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="number">0xa0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="number">0xd7ff</literal><operator>)</operator> <operator>||</operator>
               <name>c</name> <operator>&gt;=</operator> <literal type="number">0xe000</literal></expr>;</expr_stmt>
          <break>break;</break>

          <comment type="block">/* Should never occur, but keep compilers from grumbling. */</comment>

          <default>default:</default>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>codevalue</name> <operator>!=</operator> <name>OP_PROP</name></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name>OK</name> <operator>==</operator> <operator>(</operator><name>d</name> <operator>==</operator> <name>OP_PROP</name><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>==</operator> <name>OP_PROP_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSUPTO</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>           <comment type="block">/* Remove non-match possibility */</comment>
            <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><operator>++</operator><name>count</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if>
          <else>else
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_EXTUNI_EXTRA</name> <operator>+</operator> <name>OP_TYPEEXACT</name></expr>:</case>
      <case>case <expr><name>OP_EXTUNI_EXTRA</name> <operator>+</operator> <name>OP_TYPEUPTO</name></expr>:</case>
      <case>case <expr><name>OP_EXTUNI_EXTRA</name> <operator>+</operator> <name>OP_TYPEMINUPTO</name></expr>:</case>
      <case>case <expr><name>OP_EXTUNI_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSUPTO</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>!=</operator> <name>OP_EXTUNI_EXTRA</name> <operator>+</operator> <name>OP_TYPEEXACT</name></expr>)</condition>
        <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>current_state</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>  <comment type="block">/* Number already matched */</comment>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>nptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>ncount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>==</operator> <name>OP_EXTUNI_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSUPTO</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>           <comment type="block">/* Remove non-match possibility */</comment>
          <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>nptr</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>extuni</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>clen</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name></expr></argument>, <argument><expr><name>end_subject</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name>ncount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nptr</name> <operator>&gt;=</operator> <name>end_subject</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_PARTIAL_HARD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>reset_could_continue</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>++</operator><name>count</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
          <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>IMM2_SIZE</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ncount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if>
        <else>else
          <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><name>state_offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>ncount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_ANYNL_EXTRA</name> <operator>+</operator> <name>OP_TYPEEXACT</name></expr>:</case>
      <case>case <expr><name>OP_ANYNL_EXTRA</name> <operator>+</operator> <name>OP_TYPEUPTO</name></expr>:</case>
      <case>case <expr><name>OP_ANYNL_EXTRA</name> <operator>+</operator> <name>OP_TYPEMINUPTO</name></expr>:</case>
      <case>case <expr><name>OP_ANYNL_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSUPTO</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>!=</operator> <name>OP_ANYNL_EXTRA</name> <operator>+</operator> <name>OP_TYPEEXACT</name></expr>)</condition>
        <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>current_state</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>  <comment type="block">/* Number already matched */</comment>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>ncount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>CHAR_VT</name></expr>:</case>
          <case>case <expr><name>CHAR_FF</name></expr>:</case>
          <case>case <expr><name>CHAR_NEL</name></expr>:</case>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EBCDIC</name></cpp:ifndef>
          <case>case <expr><literal type="number">0x2028</literal></expr>:</case>
          <case>case <expr><literal type="number">0x2029</literal></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* Not EBCDIC */</comment>
          <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>bsr_convention</name></name> <operator>==</operator> <name>PCRE2_BSR_ANYCRLF</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <goto>goto <name>ANYNL03</name>;</goto>

          <case>case <expr><name>CHAR_CR</name></expr>:</case>
          <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator> <call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>CHAR_LF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ncount</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <comment type="block">/* Fall through */</comment>

          <label><name>ANYNL03</name>:</label>
          <case>case <expr><name>CHAR_LF</name></expr>:</case>
          <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>==</operator> <name>OP_ANYNL_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSUPTO</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>           <comment type="block">/* Remove non-match possibility */</comment>
            <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><operator>++</operator><name>count</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>IMM2_SIZE</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ncount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if>
          <else>else
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><name>state_offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>ncount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
          <break>break;</break>

          <default>default:</default>
          <break>break;</break>
          </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_VSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEEXACT</name></expr>:</case>
      <case>case <expr><name>OP_VSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEUPTO</name></expr>:</case>
      <case>case <expr><name>OP_VSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEMINUPTO</name></expr>:</case>
      <case>case <expr><name>OP_VSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSUPTO</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>!=</operator> <name>OP_VSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEEXACT</name></expr>)</condition>
        <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>current_state</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>  <comment type="block">/* Number already matched */</comment>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>OK</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
          <block>{<block_content>
          <label><name>VSPACE_CASES</name>:</label>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

          <default>default:</default>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
          </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name>OK</name> <operator>==</operator> <operator>(</operator><name>d</name> <operator>==</operator> <name>OP_VSPACE</name><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>==</operator> <name>OP_VSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSUPTO</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>           <comment type="block">/* Remove non-match possibility */</comment>
            <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><operator>++</operator><name>count</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>IMM2_SIZE</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if>
          <else>else
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><name>state_offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_HSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEEXACT</name></expr>:</case>
      <case>case <expr><name>OP_HSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEUPTO</name></expr>:</case>
      <case>case <expr><name>OP_HSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEMINUPTO</name></expr>:</case>
      <case>case <expr><name>OP_HSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSUPTO</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>!=</operator> <name>OP_HSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEEXACT</name></expr>)</condition>
        <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>current_state</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>  <comment type="block">/* Number already matched */</comment>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>OK</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
          <block>{<block_content>
          <label><name>HSPACE_CASES</name>:</label>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

          <default>default:</default>
          <expr_stmt><expr><name>OK</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name>OK</name> <operator>==</operator> <operator>(</operator><name>d</name> <operator>==</operator> <name>OP_HSPACE</name><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>==</operator> <name>OP_HSPACE_EXTRA</name> <operator>+</operator> <name>OP_TYPEPOSUPTO</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>           <comment type="block">/* Remove non-match possibility */</comment>
            <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><operator>++</operator><name>count</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>IMM2_SIZE</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if>
          <else>else
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><name>state_offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

<comment type="block">/* ========================================================================== */</comment>
      <comment type="block">/* These opcodes are followed by a character that is usually compared
      to the current subject character; it is loaded into d. We still get
      here even if there is no subject character, because in some cases zero
      repetitions are permitted. */</comment>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_CHAR</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <name>d</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <name>dlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_CHARI</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>utf_or_ucp</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>d</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <name>dlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if> <else>else
          <block>{<block_content>
          <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>othercase</name></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>othercase</name> <operator>=</operator> <name><name>fcc</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
          <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>othercase</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>othercase</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <name>dlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
      <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
      <comment type="block">/* Not UTF or UCP mode */</comment>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>TABLE_GET</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>lcc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>lcc</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition>
          <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      <break>break;</break>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <comment type="block">/* This is a tricky one because it can match more than one character.
      Find out how many characters to skip, and then set up a negative state
      to wait for them to pass before continuing. */</comment>

      <case>case <expr><name>OP_EXTUNI</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>ncount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>nptr</name> <init>= <expr><call><call><name>PRIV</name><argument_list>(<argument><expr><name>extuni</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>clen</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name></expr></argument>,
          <argument><expr><name>end_subject</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ncount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>nptr</name> <operator>&gt;=</operator> <name>end_subject</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_PARTIAL_HARD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>reset_could_continue</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ncount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <comment type="block">/* This is a tricky like EXTUNI because it too can match more than one
      character (when CR is followed by LF). In this case, set up a negative
      state to wait for one character to pass before continuing. */</comment>

      <case>case <expr><name>OP_ANYNL</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <switch>switch<condition>(<expr><name>c</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>CHAR_VT</name></expr>:</case>
        <case>case <expr><name>CHAR_FF</name></expr>:</case>
        <case>case <expr><name>CHAR_NEL</name></expr>:</case>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EBCDIC</name></cpp:ifndef>
        <case>case <expr><literal type="number">0x2028</literal></expr>:</case>
        <case>case <expr><literal type="number">0x2029</literal></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* Not EBCDIC */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>bsr_convention</name></name> <operator>==</operator> <name>PCRE2_BSR_ANYCRLF</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <comment type="block">/* Fall through */</comment>

        <case>case <expr><name>CHAR_LF</name></expr>:</case>
        <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>CHAR_CR</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>end_subject</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_PARTIAL_HARD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>reset_could_continue</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>CHAR_LF</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if>
        <else>else
          <block>{<block_content>
          <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        <break>break;</break>
        </block_content>}</block></switch></block_content></block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_NOT_VSPACE</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <switch>switch<condition>(<expr><name>c</name></expr>)</condition>
        <block>{<block_content>
        <label><name>VSPACE_CASES</name>:</label>
        <break>break;</break>

        <default>default:</default>
        <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
        </block_content>}</block></switch></block_content></block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_VSPACE</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <switch>switch<condition>(<expr><name>c</name></expr>)</condition>
        <block>{<block_content>
        <label><name>VSPACE_CASES</name>:</label>
        <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

        <default>default:</default>
        <break>break;</break>
        </block_content>}</block></switch></block_content></block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_NOT_HSPACE</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <switch>switch<condition>(<expr><name>c</name></expr>)</condition>
        <block>{<block_content>
        <label><name>HSPACE_CASES</name>:</label>
        <break>break;</break>

        <default>default:</default>
        <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
        </block_content>}</block></switch></block_content></block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_HSPACE</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <switch>switch<condition>(<expr><name>c</name></expr>)</condition>
        <block>{<block_content>
        <label><name>HSPACE_CASES</name>:</label>
        <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

        <default>default:</default>
        <break>break;</break>
        </block_content>}</block></switch></block_content></block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <comment type="block">/* Match a negated single character casefully. */</comment>

      <case>case <expr><name>OP_NOT</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>d</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <name>dlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <comment type="block">/* Match a negated single character caselessly. */</comment>

      <case>case <expr><name>OP_NOTI</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>otherd</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>utf_or_ucp</name> <operator>&amp;&amp;</operator> <name>d</name> <operator>&gt;=</operator> <literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>otherd</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
        <expr_stmt><expr><name>otherd</name> <operator>=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>fcc</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>d</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>otherd</name></expr>)</condition>
          <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <name>dlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_PLUSI</name></expr>:</case>
      <case>case <expr><name>OP_MINPLUSI</name></expr>:</case>
      <case>case <expr><name>OP_POSPLUSI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPLUSI</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINPLUSI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSPLUSI</name></expr>:</case>
      <expr_stmt><expr><name>caseless</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>codevalue</name> <operator>-=</operator> <name>OP_STARI</name> <operator>-</operator> <name>OP_STAR</name></expr>;</expr_stmt>

      <comment type="block">/* Fall through */</comment>
      <case>case <expr><name>OP_PLUS</name></expr>:</case>
      <case>case <expr><name>OP_MINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_POSPLUS</name></expr>:</case>
      <case>case <expr><name>OP_NOTPLUS</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSPLUS</name></expr>:</case>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>current_state</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>  <comment type="block">/* Already matched */</comment>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <name>dlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>otherd</name> <init>= <expr><name>NOTACHAR</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>caseless</name></expr>)</condition>
          <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
          <if_stmt><if>if <condition>(<expr><name>utf_or_ucp</name> <operator>&amp;&amp;</operator> <name>d</name> <operator>&gt;=</operator> <literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>otherd</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
          <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
          <expr_stmt><expr><name>otherd</name> <operator>=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>fcc</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>==</operator> <name>d</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>otherd</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>codevalue</name> <operator>&lt;</operator> <name>OP_NOTSTAR</name><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
              <operator>(</operator><name>codevalue</name> <operator>==</operator> <name>OP_POSPLUS</name> <operator>||</operator> <name>codevalue</name> <operator>==</operator> <name>OP_NOTPOSPLUS</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>             <comment type="block">/* Remove non-match possibility */</comment>
            <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_QUERYI</name></expr>:</case>
      <case>case <expr><name>OP_MINQUERYI</name></expr>:</case>
      <case>case <expr><name>OP_POSQUERYI</name></expr>:</case>
      <case>case <expr><name>OP_NOTQUERYI</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINQUERYI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSQUERYI</name></expr>:</case>
      <expr_stmt><expr><name>caseless</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>codevalue</name> <operator>-=</operator> <name>OP_STARI</name> <operator>-</operator> <name>OP_STAR</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through */</comment>
      <case>case <expr><name>OP_QUERY</name></expr>:</case>
      <case>case <expr><name>OP_MINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_POSQUERY</name></expr>:</case>
      <case>case <expr><name>OP_NOTQUERY</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSQUERY</name></expr>:</case>
      <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <name>dlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>otherd</name> <init>= <expr><name>NOTACHAR</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>caseless</name></expr>)</condition>
          <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
          <if_stmt><if>if <condition>(<expr><name>utf_or_ucp</name> <operator>&amp;&amp;</operator> <name>d</name> <operator>&gt;=</operator> <literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>otherd</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
          <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
          <expr_stmt><expr><name>otherd</name> <operator>=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>fcc</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>==</operator> <name>d</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>otherd</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>codevalue</name> <operator>&lt;</operator> <name>OP_NOTSTAR</name><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>==</operator> <name>OP_POSQUERY</name> <operator>||</operator> <name>codevalue</name> <operator>==</operator> <name>OP_NOTPOSQUERY</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>            <comment type="block">/* Remove non-match possibility */</comment>
            <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <name>dlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_STARI</name></expr>:</case>
      <case>case <expr><name>OP_MINSTARI</name></expr>:</case>
      <case>case <expr><name>OP_POSSTARI</name></expr>:</case>
      <case>case <expr><name>OP_NOTSTARI</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINSTARI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSSTARI</name></expr>:</case>
      <expr_stmt><expr><name>caseless</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>codevalue</name> <operator>-=</operator> <name>OP_STARI</name> <operator>-</operator> <name>OP_STAR</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through */</comment>
      <case>case <expr><name>OP_STAR</name></expr>:</case>
      <case>case <expr><name>OP_MINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_POSSTAR</name></expr>:</case>
      <case>case <expr><name>OP_NOTSTAR</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSSTAR</name></expr>:</case>
      <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <name>dlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>otherd</name> <init>= <expr><name>NOTACHAR</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>caseless</name></expr>)</condition>
          <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
          <if_stmt><if>if <condition>(<expr><name>utf_or_ucp</name> <operator>&amp;&amp;</operator> <name>d</name> <operator>&gt;=</operator> <literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>otherd</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
          <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
          <expr_stmt><expr><name>otherd</name> <operator>=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>fcc</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>==</operator> <name>d</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>otherd</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>codevalue</name> <operator>&lt;</operator> <name>OP_NOTSTAR</name><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>==</operator> <name>OP_POSSTAR</name> <operator>||</operator> <name>codevalue</name> <operator>==</operator> <name>OP_NOTPOSSTAR</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>            <comment type="block">/* Remove non-match possibility */</comment>
            <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_EXACTI</name></expr>:</case>
      <case>case <expr><name>OP_NOTEXACTI</name></expr>:</case>
      <expr_stmt><expr><name>caseless</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>codevalue</name> <operator>-=</operator> <name>OP_STARI</name> <operator>-</operator> <name>OP_STAR</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through */</comment>
      <case>case <expr><name>OP_EXACT</name></expr>:</case>
      <case>case <expr><name>OP_NOTEXACT</name></expr>:</case>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>current_state</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>  <comment type="block">/* Number already matched */</comment>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>otherd</name> <init>= <expr><name>NOTACHAR</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>caseless</name></expr>)</condition>
          <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
          <if_stmt><if>if <condition>(<expr><name>utf_or_ucp</name> <operator>&amp;&amp;</operator> <name>d</name> <operator>&gt;=</operator> <literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>otherd</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
          <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
          <expr_stmt><expr><name>otherd</name> <operator>=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>fcc</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>==</operator> <name>d</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>otherd</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>codevalue</name> <operator>&lt;</operator> <name>OP_NOTSTAR</name><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>++</operator><name>count</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <name>dlen</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if>
          <else>else
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_UPTOI</name></expr>:</case>
      <case>case <expr><name>OP_MINUPTOI</name></expr>:</case>
      <case>case <expr><name>OP_POSUPTOI</name></expr>:</case>
      <case>case <expr><name>OP_NOTUPTOI</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINUPTOI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSUPTOI</name></expr>:</case>
      <expr_stmt><expr><name>caseless</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>codevalue</name> <operator>-=</operator> <name>OP_STARI</name> <operator>-</operator> <name>OP_STAR</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through */</comment>
      <case>case <expr><name>OP_UPTO</name></expr>:</case>
      <case>case <expr><name>OP_MINUPTO</name></expr>:</case>
      <case>case <expr><name>OP_POSUPTO</name></expr>:</case>
      <case>case <expr><name>OP_NOTUPTO</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINUPTO</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSUPTO</name></expr>:</case>
      <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <name>dlen</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>current_state</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>  <comment type="block">/* Number already matched */</comment>
      <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>otherd</name> <init>= <expr><name>NOTACHAR</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>caseless</name></expr>)</condition>
          <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
          <if_stmt><if>if <condition>(<expr><name>utf_or_ucp</name> <operator>&amp;&amp;</operator> <name>d</name> <operator>&gt;=</operator> <literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>otherd</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
          <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
          <expr_stmt><expr><name>otherd</name> <operator>=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>fcc</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>==</operator> <name>d</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>otherd</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>codevalue</name> <operator>&lt;</operator> <name>OP_NOTSTAR</name><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>==</operator> <name>OP_POSUPTO</name> <operator>||</operator> <name>codevalue</name> <operator>==</operator> <name>OP_NOTPOSUPTO</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>             <comment type="block">/* Remove non-match possibility */</comment>
            <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><operator>++</operator><name>count</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <name>dlen</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if>
          <else>else
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>


<comment type="block">/* ========================================================================== */</comment>
      <comment type="block">/* These are the class-handling opcodes */</comment>

      <case>case <expr><name>OP_CLASS</name></expr>:</case>
      <case>case <expr><name>OP_NCLASS</name></expr>:</case>
      <case>case <expr><name>OP_XCLASS</name></expr>:</case>
        <block>{<block_content>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>isinclass</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>next_state_offset</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ecode</name></decl>;</decl_stmt>

        <comment type="block">/* For a simple class, there is always just a 32-byte table, and we
        can set isinclass from it. */</comment>

        <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>!=</operator> <name>OP_XCLASS</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>ecode</name> <operator>=</operator> <name>code</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>isinclass</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>c</name> <operator>&gt;</operator> <literal type="number">255</literal><operator>)</operator></expr>?</condition><then> <expr><operator>(</operator><name>codevalue</name> <operator>==</operator> <name>OP_NCLASS</name><operator>)</operator></expr> </then><else>:
              <expr><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>code</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator><index>[<expr><name>c</name><operator>/</operator><literal type="number">8</literal></expr>]</index> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if>

        <comment type="block">/* An extended class may have a table or a list of single characters,
        ranges, or both, and it may be positive or negative. There's a
        function that sorts all this out. */</comment>

        <else>else
         <block>{<block_content>
         <expr_stmt><expr><name>ecode</name> <operator>=</operator> <name>code</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>isinclass</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>xclass</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>code</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
         </block_content>}</block></else></if_stmt>

        <comment type="block">/* At this point, isinclass is set for all kinds of class, and ecode
        points to the byte after the end of the class. If there is a
        quantifier, this is where it will be. */</comment>

        <expr_stmt><expr><name>next_state_offset</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ecode</name> <operator>-</operator> <name>start_code</name><operator>)</operator></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><operator>*</operator><name>ecode</name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>OP_CRSTAR</name></expr>:</case>
          <case>case <expr><name>OP_CRMINSTAR</name></expr>:</case>
          <case>case <expr><name>OP_CRPOSSTAR</name></expr>:</case>
          <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>next_state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>isinclass</name></expr>)</condition>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ecode</name> <operator>==</operator> <name>OP_CRPOSSTAR</name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>           <comment type="block">/* Remove non-match possibility */</comment>
              <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <break>break;</break>

          <case>case <expr><name>OP_CRPLUS</name></expr>:</case>
          <case>case <expr><name>OP_CRMINPLUS</name></expr>:</case>
          <case>case <expr><name>OP_CRPOSPLUS</name></expr>:</case>
          <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>current_state</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>  <comment type="block">/* Already matched */</comment>
          <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>next_state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>isinclass</name></expr>)</condition>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ecode</name> <operator>==</operator> <name>OP_CRPOSPLUS</name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>           <comment type="block">/* Remove non-match possibility */</comment>
              <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <break>break;</break>

          <case>case <expr><name>OP_CRQUERY</name></expr>:</case>
          <case>case <expr><name>OP_CRMINQUERY</name></expr>:</case>
          <case>case <expr><name>OP_CRPOSQUERY</name></expr>:</case>
          <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>next_state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>isinclass</name></expr>)</condition>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ecode</name> <operator>==</operator> <name>OP_CRPOSQUERY</name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>           <comment type="block">/* Remove non-match possibility */</comment>
              <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>next_state_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <break>break;</break>

          <case>case <expr><name>OP_CRRANGE</name></expr>:</case>
          <case>case <expr><name>OP_CRMINRANGE</name></expr>:</case>
          <case>case <expr><name>OP_CRPOSRANGE</name></expr>:</case>
          <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>current_state</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>  <comment type="block">/* Already matched */</comment>
          <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GET2</name><argument_list>(<argument><expr><name>ecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>next_state_offset</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>IMM2_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>isinclass</name></expr>)</condition>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>max</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>GET2</name><argument_list>(<argument><expr><name>ecode</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ecode</name> <operator>==</operator> <name>OP_CRPOSRANGE</name> <operator>&amp;&amp;</operator> <name>count</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GET2</name><argument_list>(<argument><expr><name>ecode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><name>active_count</name><operator>--</operator></expr>;</expr_stmt>           <comment type="block">/* Remove non-match possibility */</comment>
              <expr_stmt><expr><name>next_active_state</name><operator>--</operator></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>++</operator><name>count</name> <operator>&gt;=</operator> <name>max</name> <operator>&amp;&amp;</operator> <name>max</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>   <comment type="block">/* Max 0 =&gt; no limit */</comment>
              <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>next_state_offset</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>IMM2_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if>
            <else>else
              <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>state_offset</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
          <break>break;</break>

          <default>default:</default>
          <if_stmt><if>if <condition>(<expr><name>isinclass</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>next_state_offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
          <break>break;</break>
          </block_content>}</block></switch>
        </block_content>}</block>
      <break>break;</break>

<comment type="block">/* ========================================================================== */</comment>
      <comment type="block">/* These are the opcodes for fancy brackets of various kinds. We have
      to use recursion in order to handle them. The "always failing" assertion
      (?!) is optimised to OP_FAIL when compiling, so we have to support that,
      though the other "backtracking verbs" are not supported. */</comment>

      <case>case <expr><name>OP_FAIL</name></expr>:</case>
      <expr_stmt><expr><name>forced_fail</name><operator>++</operator></expr>;</expr_stmt>    <comment type="block">/* Count FAILs for multiple states */</comment>
      <break>break;</break>

      <case>case <expr><name>OP_ASSERT</name></expr>:</case>
      <case>case <expr><name>OP_ASSERT_NOT</name></expr>:</case>
      <case>case <expr><name>OP_ASSERTBACK</name></expr>:</case>
      <case>case <expr><name>OP_ASSERTBACK_NOT</name></expr>:</case>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>local_workspace</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>local_offsets</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>endasscode</name> <init>= <expr><name>code</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RWS_anchor</name> <modifier>*</modifier></type><name>rws</name> <init>= <expr><operator>(</operator><name>RWS_anchor</name> <operator>*</operator><operator>)</operator><name>RWS</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>rws</name><operator>-&gt;</operator><name>free</name></name> <operator>&lt;</operator> <name>RWS_RSIZE</name> <operator>+</operator> <name>RWS_OVEC_OSIZE</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>more_workspace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rws</name></expr></argument>, <argument><expr><name>RWS_OVEC_OSIZE</name></expr></argument>, <argument><expr><name>mb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>RWS</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>rws</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>local_offsets</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>RWS</name> <operator>+</operator> <name><name>rws</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>rws</name><operator>-&gt;</operator><name>free</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>local_workspace</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>local_offsets</name><operator>)</operator> <operator>+</operator> <name>RWS_OVEC_OSIZE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rws</name><operator>-&gt;</operator><name>free</name></name> <operator>-=</operator> <name>RWS_RSIZE</name> <operator>+</operator> <name>RWS_OVEC_OSIZE</name></expr>;</expr_stmt>

        <while>while <condition>(<expr><operator>*</operator><name>endasscode</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>endasscode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>endasscode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>internal_dfa_match</name><argument_list>(
          <argument><expr><name>mb</name></expr></argument>,                                   <comment type="block">/* static match data */</comment>
          <argument><expr><name>code</name></expr></argument>,                                 <comment type="block">/* this subexpression's code */</comment>
          <argument><expr><name>ptr</name></expr></argument>,                                  <comment type="block">/* where we currently are */</comment>
          <argument><expr><operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name>start_subject</name><operator>)</operator></expr></argument>,    <comment type="block">/* start offset */</comment>
          <argument><expr><name>local_offsets</name></expr></argument>,                        <comment type="block">/* offset vector */</comment>
          <argument><expr><name>RWS_OVEC_OSIZE</name><operator>/</operator><name>OVEC_UNIT</name></expr></argument>,             <comment type="block">/* size of same */</comment>
          <argument><expr><name>local_workspace</name></expr></argument>,                      <comment type="block">/* workspace vector */</comment>
          <argument><expr><name>RWS_RSIZE</name></expr></argument>,                            <comment type="block">/* size of same */</comment>
          <argument><expr><name>rlevel</name></expr></argument>,                               <comment type="block">/* function recursion level */</comment>
          <argument><expr><name>RWS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                 <comment type="block">/* recursion workspace */</comment>

        <expr_stmt><expr><name><name>rws</name><operator>-&gt;</operator><name>free</name></name> <operator>+=</operator> <name>RWS_RSIZE</name> <operator>+</operator> <name>RWS_OVEC_OSIZE</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name> <operator>!=</operator> <name>PCRE2_ERROR_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><name>codevalue</name> <operator>==</operator> <name>OP_ASSERT</name> <operator>||</operator> <name>codevalue</name> <operator>==</operator> <name>OP_ASSERTBACK</name><operator>)</operator></expr>)</condition>
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>endasscode</name> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>start_code</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
        </block_content>}</block>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_COND</name></expr>:</case>
      <case>case <expr><name>OP_SCOND</name></expr>:</case>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>codelink</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>condcode</name></decl>;</decl_stmt>

        <comment type="block">/* Because of the way auto-callout works during compile, a callout item
        is inserted between OP_COND and an assertion condition. This does not
        happen for the other conditions. */</comment>

        <if_stmt><if>if <condition>(<expr><name><name>code</name><index>[<expr><name>LINK_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>OP_CALLOUT</name>
            <operator>||</operator> <name><name>code</name><index>[<expr><name>LINK_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>OP_CALLOUT_STR</name></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>callout_length</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>rrc</name> <operator>=</operator> <call><name>do_callout</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>offsets</name></expr></argument>, <argument><expr><name>current_subject</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>mb</name></expr></argument>,
            <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>callout_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rrc</name></expr>;</return></block_content></block></if></if_stmt>                 <comment type="block">/* Abandon */</comment>
          <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>                      <comment type="block">/* Fail this thread */</comment>
          <expr_stmt><expr><name>code</name> <operator>+=</operator> <name>callout_length</name></expr>;</expr_stmt>                  <comment type="block">/* Skip callout data */</comment>
          </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>condcode</name> <operator>=</operator> <name><name>code</name><index>[<expr><name>LINK_SIZE</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/* Back reference conditions and duplicate named recursion conditions
        are not supported */</comment>

        <if_stmt><if>if <condition>(<expr><name>condcode</name> <operator>==</operator> <name>OP_CREF</name> <operator>||</operator> <name>condcode</name> <operator>==</operator> <name>OP_DNCREF</name> <operator>||</operator>
            <name>condcode</name> <operator>==</operator> <name>OP_DNRREF</name></expr>)</condition><block type="pseudo"><block_content>
          <return>return <expr><name>PCRE2_ERROR_DFA_UCOND</name></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* The DEFINE condition is always false, and the assertion (?!) is
        converted to OP_FAIL. */</comment>

        <if_stmt><if>if <condition>(<expr><name>condcode</name> <operator>==</operator> <name>OP_FALSE</name> <operator>||</operator> <name>condcode</name> <operator>==</operator> <name>OP_FAIL</name></expr>)</condition>
          <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <name>codelink</name> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if>

        <comment type="block">/* There is also an always-true condition */</comment>

        <if type="elseif">else if <condition>(<expr><name>condcode</name> <operator>==</operator> <name>OP_TRUE</name></expr>)</condition>
          <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if>

        <comment type="block">/* The only supported version of OP_RREF is for the value RREF_ANY,
        which means "test if in any recursion". We can't test for specifically
        recursed groups. */</comment>

        <if type="elseif">else if <condition>(<expr><name>condcode</name> <operator>==</operator> <name>OP_RREF</name></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>value</name> <init>= <expr><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>LINK_SIZE</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <name>RREF_ANY</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_DFA_UCOND</name></expr>;</return></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>recursive</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if>
          <else>else <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <name>codelink</name> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
          </block_content>}</block></if>

        <comment type="block">/* Otherwise, the condition is an assertion */</comment>

        <else>else
          <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>local_workspace</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>local_offsets</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>asscode</name> <init>= <expr><name>code</name> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>endasscode</name> <init>= <expr><name>asscode</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>asscode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>RWS_anchor</name> <modifier>*</modifier></type><name>rws</name> <init>= <expr><operator>(</operator><name>RWS_anchor</name> <operator>*</operator><operator>)</operator><name>RWS</name></expr></init></decl>;</decl_stmt>

          <if_stmt><if>if <condition>(<expr><name><name>rws</name><operator>-&gt;</operator><name>free</name></name> <operator>&lt;</operator> <name>RWS_RSIZE</name> <operator>+</operator> <name>RWS_OVEC_OSIZE</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>more_workspace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rws</name></expr></argument>, <argument><expr><name>RWS_OVEC_OSIZE</name></expr></argument>, <argument><expr><name>mb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>RWS</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>rws</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

          <expr_stmt><expr><name>local_offsets</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>RWS</name> <operator>+</operator> <name><name>rws</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>rws</name><operator>-&gt;</operator><name>free</name></name><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>local_workspace</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>local_offsets</name><operator>)</operator> <operator>+</operator> <name>RWS_OVEC_OSIZE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>rws</name><operator>-&gt;</operator><name>free</name></name> <operator>-=</operator> <name>RWS_RSIZE</name> <operator>+</operator> <name>RWS_OVEC_OSIZE</name></expr>;</expr_stmt>

          <while>while <condition>(<expr><operator>*</operator><name>endasscode</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>endasscode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>endasscode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>internal_dfa_match</name><argument_list>(
            <argument><expr><name>mb</name></expr></argument>,                                   <comment type="block">/* fixed match data */</comment>
            <argument><expr><name>asscode</name></expr></argument>,                              <comment type="block">/* this subexpression's code */</comment>
            <argument><expr><name>ptr</name></expr></argument>,                                  <comment type="block">/* where we currently are */</comment>
            <argument><expr><operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name>start_subject</name><operator>)</operator></expr></argument>,    <comment type="block">/* start offset */</comment>
            <argument><expr><name>local_offsets</name></expr></argument>,                        <comment type="block">/* offset vector */</comment>
            <argument><expr><name>RWS_OVEC_OSIZE</name><operator>/</operator><name>OVEC_UNIT</name></expr></argument>,             <comment type="block">/* size of same */</comment>
            <argument><expr><name>local_workspace</name></expr></argument>,                      <comment type="block">/* workspace vector */</comment>
            <argument><expr><name>RWS_RSIZE</name></expr></argument>,                            <comment type="block">/* size of same */</comment>
            <argument><expr><name>rlevel</name></expr></argument>,                               <comment type="block">/* function recursion level */</comment>
            <argument><expr><name>RWS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                 <comment type="block">/* recursion workspace */</comment>

          <expr_stmt><expr><name><name>rws</name><operator>-&gt;</operator><name>free</name></name> <operator>+=</operator> <name>RWS_RSIZE</name> <operator>+</operator> <name>RWS_OVEC_OSIZE</name></expr>;</expr_stmt>

          <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name> <operator>!=</operator> <name>PCRE2_ERROR_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>==</operator>
                <operator>(</operator><name>condcode</name> <operator>==</operator> <name>OP_ASSERT</name> <operator>||</operator> <name>condcode</name> <operator>==</operator> <name>OP_ASSERTBACK</name><operator>)</operator></expr>)</condition>
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>endasscode</name> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>start_code</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if>
          <else>else
            <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <name>codelink</name> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_RECURSE</name></expr>:</case>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>local_workspace</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>local_offsets</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RWS_anchor</name> <modifier>*</modifier></type><name>rws</name> <init>= <expr><operator>(</operator><name>RWS_anchor</name> <operator>*</operator><operator>)</operator><name>RWS</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dfa_recursion_info</name> <modifier>*</modifier></type><name>ri</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>callpat</name> <init>= <expr><name>start_code</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>recno</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>callpat</name> <operator>==</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_code</name></name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
          <expr><call><name>GET2</name><argument_list>(<argument><expr><name>callpat</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>rws</name><operator>-&gt;</operator><name>free</name></name> <operator>&lt;</operator> <name>RWS_RSIZE</name> <operator>+</operator> <name>RWS_OVEC_RSIZE</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>more_workspace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rws</name></expr></argument>, <argument><expr><name>RWS_OVEC_RSIZE</name></expr></argument>, <argument><expr><name>mb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>RWS</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>rws</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>local_offsets</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>RWS</name> <operator>+</operator> <name><name>rws</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>rws</name><operator>-&gt;</operator><name>free</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>local_workspace</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>local_offsets</name><operator>)</operator> <operator>+</operator> <name>RWS_OVEC_RSIZE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rws</name><operator>-&gt;</operator><name>free</name></name> <operator>-=</operator> <name>RWS_RSIZE</name> <operator>+</operator> <name>RWS_OVEC_RSIZE</name></expr>;</expr_stmt>

        <comment type="block">/* Check for repeating a recursion without advancing the subject
        pointer. This should catch convoluted mutual recursions. (Some simple
        cases are caught at compile time.) */</comment>

        <for>for <control>(<init><expr><name>ri</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>recursive</name></name></expr>;</init> <condition><expr><name>ri</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ri</name> <operator>=</operator> <name><name>ri</name><operator>-&gt;</operator><name>prevrec</name></name></expr></incr>)</control><block type="pseudo"><block_content>
          <if_stmt><if>if <condition>(<expr><name>recno</name> <operator>==</operator> <name><name>ri</name><operator>-&gt;</operator><name>group_num</name></name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>==</operator> <name><name>ri</name><operator>-&gt;</operator><name>subject_position</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>PCRE2_ERROR_RECURSELOOP</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

        <comment type="block">/* Remember this recursion and where we started it so as to
        catch infinite loops. */</comment>

        <expr_stmt><expr><name><name>new_recursive</name><operator>.</operator><name>group_num</name></name> <operator>=</operator> <name>recno</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_recursive</name><operator>.</operator><name>subject_position</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_recursive</name><operator>.</operator><name>prevrec</name></name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>recursive</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>recursive</name></name> <operator>=</operator> <operator>&amp;</operator><name>new_recursive</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>internal_dfa_match</name><argument_list>(
          <argument><expr><name>mb</name></expr></argument>,                                   <comment type="block">/* fixed match data */</comment>
          <argument><expr><name>callpat</name></expr></argument>,                              <comment type="block">/* this subexpression's code */</comment>
          <argument><expr><name>ptr</name></expr></argument>,                                  <comment type="block">/* where we currently are */</comment>
          <argument><expr><operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name>start_subject</name><operator>)</operator></expr></argument>,    <comment type="block">/* start offset */</comment>
          <argument><expr><name>local_offsets</name></expr></argument>,                        <comment type="block">/* offset vector */</comment>
          <argument><expr><name>RWS_OVEC_RSIZE</name><operator>/</operator><name>OVEC_UNIT</name></expr></argument>,             <comment type="block">/* size of same */</comment>
          <argument><expr><name>local_workspace</name></expr></argument>,                      <comment type="block">/* workspace vector */</comment>
          <argument><expr><name>RWS_RSIZE</name></expr></argument>,                            <comment type="block">/* size of same */</comment>
          <argument><expr><name>rlevel</name></expr></argument>,                               <comment type="block">/* function recursion level */</comment>
          <argument><expr><name>RWS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                 <comment type="block">/* recursion workspace */</comment>

        <expr_stmt><expr><name><name>rws</name><operator>-&gt;</operator><name>free</name></name> <operator>+=</operator> <name>RWS_RSIZE</name> <operator>+</operator> <name>RWS_OVEC_RSIZE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>recursive</name></name> <operator>=</operator> <name><name>new_recursive</name><operator>.</operator><name>prevrec</name></name></expr>;</expr_stmt>  <comment type="block">/* Done this recursion */</comment>

        <comment type="block">/* Ran out of internal offsets */</comment>

        <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_DFA_RECURSE</name></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* For each successful matched substring, set up the next state with a
        count of characters to skip before trying it. Note that the count is in
        characters, not bytes. */</comment>

        <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <for>for <control>(<init><expr><name>rc</name> <operator>=</operator> <name>rc</name><operator>*</operator><literal type="number">2</literal> <operator>-</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>rc</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>rc</name> <operator>-=</operator> <literal type="number">2</literal></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>charcount</name> <init>= <expr><name><name>local_offsets</name><index>[<expr><name>rc</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>local_offsets</name><index>[<expr><name>rc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
            <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
              <block>{<block_content>
              <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>p</name> <init>= <expr><name>start_subject</name> <operator>+</operator> <name><name>local_offsets</name><index>[<expr><name>rc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>pp</name> <init>= <expr><name>start_subject</name> <operator>+</operator> <name><name>local_offsets</name><index>[<expr><name>rc</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
              <while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pp</name></expr>)</condition><block type="pseudo"><block_content> <if_stmt><if>if <condition>(<expr><call><name>NOT_FIRSTCU</name><argument_list>(<argument><expr><operator>*</operator><name>p</name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>charcount</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></while>
              </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if_stmt><if>if <condition>(<expr><name>charcount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name>state_offset</name> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>charcount</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if>
            <else>else
              <block>{<block_content>
              <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>
          </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PCRE2_ERROR_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_BRAPOS</name></expr>:</case>
      <case>case <expr><name>OP_SBRAPOS</name></expr>:</case>
      <case>case <expr><name>OP_CBRAPOS</name></expr>:</case>
      <case>case <expr><name>OP_SCBRAPOS</name></expr>:</case>
      <case>case <expr><name>OP_BRAPOSZERO</name></expr>:</case>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>local_workspace</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>local_offsets</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>charcount</name></decl>, <decl><type ref="prev"/><name>matched_count</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>local_ptr</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RWS_anchor</name> <modifier>*</modifier></type><name>rws</name> <init>= <expr><operator>(</operator><name>RWS_anchor</name> <operator>*</operator><operator>)</operator><name>RWS</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>allow_zero</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>rws</name><operator>-&gt;</operator><name>free</name></name> <operator>&lt;</operator> <name>RWS_RSIZE</name> <operator>+</operator> <name>RWS_OVEC_OSIZE</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>more_workspace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rws</name></expr></argument>, <argument><expr><name>RWS_OVEC_OSIZE</name></expr></argument>, <argument><expr><name>mb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>RWS</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>rws</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>local_offsets</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>RWS</name> <operator>+</operator> <name><name>rws</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>rws</name><operator>-&gt;</operator><name>free</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>local_workspace</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>local_offsets</name><operator>)</operator> <operator>+</operator> <name>RWS_OVEC_OSIZE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rws</name><operator>-&gt;</operator><name>free</name></name> <operator>-=</operator> <name>RWS_RSIZE</name> <operator>+</operator> <name>RWS_OVEC_OSIZE</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>codevalue</name> <operator>==</operator> <name>OP_BRAPOSZERO</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>allow_zero</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>codevalue</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>++</operator><name>code</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Codevalue will be one of above BRAs */</comment>
          </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>allow_zero</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* Loop to match the subpattern as many times as possible as if it were
        a complete pattern. */</comment>

        <for>for <control>(<init><expr><name>matched_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>matched_count</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>internal_dfa_match</name><argument_list>(
            <argument><expr><name>mb</name></expr></argument>,                                   <comment type="block">/* fixed match data */</comment>
            <argument><expr><name>code</name></expr></argument>,                                 <comment type="block">/* this subexpression's code */</comment>
            <argument><expr><name>local_ptr</name></expr></argument>,                            <comment type="block">/* where we currently are */</comment>
            <argument><expr><operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name>start_subject</name><operator>)</operator></expr></argument>,    <comment type="block">/* start offset */</comment>
            <argument><expr><name>local_offsets</name></expr></argument>,                        <comment type="block">/* offset vector */</comment>
            <argument><expr><name>RWS_OVEC_OSIZE</name><operator>/</operator><name>OVEC_UNIT</name></expr></argument>,             <comment type="block">/* size of same */</comment>
            <argument><expr><name>local_workspace</name></expr></argument>,                      <comment type="block">/* workspace vector */</comment>
            <argument><expr><name>RWS_RSIZE</name></expr></argument>,                            <comment type="block">/* size of same */</comment>
            <argument><expr><name>rlevel</name></expr></argument>,                               <comment type="block">/* function recursion level */</comment>
            <argument><expr><name>RWS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                 <comment type="block">/* recursion workspace */</comment>

          <comment type="block">/* Failed to match */</comment>

          <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PCRE2_ERROR_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>
            </block_content>}</block></if></if_stmt>

          <comment type="block">/* Matched: break the loop if zero characters matched. */</comment>

          <expr_stmt><expr><name>charcount</name> <operator>=</operator> <name><name>local_offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>local_offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>charcount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>local_ptr</name> <operator>+=</operator> <name>charcount</name></expr>;</expr_stmt>    <comment type="block">/* Advance temporary position ptr */</comment>
          </block_content>}</block></for>

        <expr_stmt><expr><name><name>rws</name><operator>-&gt;</operator><name>free</name></name> <operator>+=</operator> <name>RWS_RSIZE</name> <operator>+</operator> <name>RWS_OVEC_OSIZE</name></expr>;</expr_stmt>

        <comment type="block">/* At this point we have matched the subpattern matched_count
        times, and local_ptr is pointing to the character after the end of the
        last match. */</comment>

        <if_stmt><if>if <condition>(<expr><name>matched_count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>allow_zero</name></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>end_subpattern</name> <init>= <expr><name>code</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>next_state_offset</name></decl>;</decl_stmt>

          <do>do <block>{<block_content> <expr_stmt><expr><name>end_subpattern</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>end_subpattern</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>
            while <condition>(<expr><operator>*</operator><name>end_subpattern</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
          <expr_stmt><expr><name>next_state_offset</name> <operator>=</operator>
            <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>end_subpattern</name> <operator>-</operator> <name>start_code</name> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

          <comment type="block">/* Optimization: if there are no more active states, and there
          are no new states yet set up, then skip over the subject string
          right here, to save looping. Otherwise, set up the new state to swing
          into action when the end of the matched substring is reached. */</comment>

          <if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>active_count</name> <operator>&amp;&amp;</operator> <name>new_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>local_ptr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>clen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>next_state_offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
          <else>else
            <block>{<block_content>
            <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>p</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>pp</name> <init>= <expr><name>local_ptr</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>charcount</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>pp</name> <operator>-</operator> <name>p</name><operator>)</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
            <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pp</name></expr>)</condition><block type="pseudo"><block_content> <if_stmt><if>if <condition>(<expr><call><name>NOT_FIRSTCU</name><argument_list>(<argument><expr><operator>*</operator><name>p</name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>charcount</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></while></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><name>next_state_offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>charcount</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block>
      <break>break;</break>

      <comment type="block">/*-----------------------------------------------------------------*/</comment>
      <case>case <expr><name>OP_ONCE</name></expr>:</case>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>local_workspace</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>local_offsets</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RWS_anchor</name> <modifier>*</modifier></type><name>rws</name> <init>= <expr><operator>(</operator><name>RWS_anchor</name> <operator>*</operator><operator>)</operator><name>RWS</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>rws</name><operator>-&gt;</operator><name>free</name></name> <operator>&lt;</operator> <name>RWS_RSIZE</name> <operator>+</operator> <name>RWS_OVEC_OSIZE</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>more_workspace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rws</name></expr></argument>, <argument><expr><name>RWS_OVEC_OSIZE</name></expr></argument>, <argument><expr><name>mb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>RWS</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>rws</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>local_offsets</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>RWS</name> <operator>+</operator> <name><name>rws</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name><name>rws</name><operator>-&gt;</operator><name>free</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>local_workspace</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>local_offsets</name><operator>)</operator> <operator>+</operator> <name>RWS_OVEC_OSIZE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rws</name><operator>-&gt;</operator><name>free</name></name> <operator>-=</operator> <name>RWS_RSIZE</name> <operator>+</operator> <name>RWS_OVEC_OSIZE</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>internal_dfa_match</name><argument_list>(
          <argument><expr><name>mb</name></expr></argument>,                                   <comment type="block">/* fixed match data */</comment>
          <argument><expr><name>code</name></expr></argument>,                                 <comment type="block">/* this subexpression's code */</comment>
          <argument><expr><name>ptr</name></expr></argument>,                                  <comment type="block">/* where we currently are */</comment>
          <argument><expr><operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name>start_subject</name><operator>)</operator></expr></argument>,    <comment type="block">/* start offset */</comment>
          <argument><expr><name>local_offsets</name></expr></argument>,                        <comment type="block">/* offset vector */</comment>
          <argument><expr><name>RWS_OVEC_OSIZE</name><operator>/</operator><name>OVEC_UNIT</name></expr></argument>,             <comment type="block">/* size of same */</comment>
          <argument><expr><name>local_workspace</name></expr></argument>,                      <comment type="block">/* workspace vector */</comment>
          <argument><expr><name>RWS_RSIZE</name></expr></argument>,                            <comment type="block">/* size of same */</comment>
          <argument><expr><name>rlevel</name></expr></argument>,                               <comment type="block">/* function recursion level */</comment>
          <argument><expr><name>RWS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                 <comment type="block">/* recursion workspace */</comment>

        <expr_stmt><expr><name><name>rws</name><operator>-&gt;</operator><name>free</name></name> <operator>+=</operator> <name>RWS_RSIZE</name> <operator>+</operator> <name>RWS_OVEC_OSIZE</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>end_subpattern</name> <init>= <expr><name>code</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>charcount</name> <init>= <expr><name><name>local_offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>local_offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>next_state_offset</name></decl>, <decl><type ref="prev"/><name>repeat_state_offset</name></decl>;</decl_stmt>

          <do>do <block>{<block_content> <expr_stmt><expr><name>end_subpattern</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>end_subpattern</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>
            while <condition>(<expr><operator>*</operator><name>end_subpattern</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
          <expr_stmt><expr><name>next_state_offset</name> <operator>=</operator>
            <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>end_subpattern</name> <operator>-</operator> <name>start_code</name> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

          <comment type="block">/* If the end of this subpattern is KETRMAX or KETRMIN, we must
          arrange for the repeat state also to be added to the relevant list.
          Calculate the offset, or set -1 for no repeat. */</comment>

          <expr_stmt><expr><name>repeat_state_offset</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name>end_subpattern</name> <operator>==</operator> <name>OP_KETRMAX</name> <operator>||</operator>
                                 <operator>*</operator><name>end_subpattern</name> <operator>==</operator> <name>OP_KETRMIN</name><operator>)</operator></expr>?</condition><then>
            <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>end_subpattern</name> <operator>-</operator> <name>start_code</name> <operator>-</operator> <call><name>GET</name><argument_list>(<argument><expr><name>end_subpattern</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

          <comment type="block">/* If we have matched an empty string, add the next state at the
          current character pointer. This is important so that the duplicate
          checking kicks in, which is what breaks infinite loops that match an
          empty string. */</comment>

          <if_stmt><if>if <condition>(<expr><name>charcount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>next_state_offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>

          <comment type="block">/* Optimization: if there are no more active states, and there
          are no new states yet set up, then skip over the subject string
          right here, to save looping. Otherwise, set up the new state to swing
          into action when the end of the matched substring is reached. */</comment>

          <if type="elseif">else if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>active_count</name> <operator>&amp;&amp;</operator> <name>new_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>charcount</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>clen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ADD_NEW</name><argument_list>(<argument><expr><name>next_state_offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* If we are adding a repeat state at the new character position,
            we must fudge things so that it is the only current state.
            Otherwise, it might be a duplicate of one we processed before, and
            that would cause it to be skipped. */</comment>

            <if_stmt><if>if <condition>(<expr><name>repeat_state_offset</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><name>next_active_state</name> <operator>=</operator> <name>active_states</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>active_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
              <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>repeat_state_offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
          <else>else
            <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_UNICODE</name> <operator>&amp;&amp;</operator> <name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
            <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
              <block>{<block_content>
              <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>p</name> <init>= <expr><name>start_subject</name> <operator>+</operator> <name><name>local_offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>pp</name> <init>= <expr><name>start_subject</name> <operator>+</operator> <name><name>local_offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
              <while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pp</name></expr>)</condition><block type="pseudo"><block_content> <if_stmt><if>if <condition>(<expr><call><name>NOT_FIRSTCU</name><argument_list>(<argument><expr><operator>*</operator><name>p</name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>charcount</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></while>
              </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><name>next_state_offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>charcount</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>repeat_state_offset</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
              <block>{<block_content> <expr_stmt><expr><call><name>ADD_NEW_DATA</name><argument_list>(<argument><expr><operator>-</operator><name>repeat_state_offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>charcount</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PCRE2_ERROR_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block>
      <break>break;</break>


<comment type="block">/* ========================================================================== */</comment>
      <comment type="block">/* Handle callouts */</comment>

      <case>case <expr><name>OP_CALLOUT</name></expr>:</case>
      <case>case <expr><name>OP_CALLOUT_STR</name></expr>:</case>
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>callout_length</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rrc</name> <operator>=</operator> <call><name>do_callout</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>offsets</name></expr></argument>, <argument><expr><name>current_subject</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>mb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
          <argument><expr><operator>&amp;</operator><name>callout_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>rrc</name></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* Abandon */</comment>
        <if_stmt><if>if <condition>(<expr><name>rrc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content> <expr_stmt><expr><call><name>ADD_ACTIVE</name><argument_list>(<argument><expr><name>state_offset</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><name>callout_length</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if></if_stmt>
        </block_content>}</block>
      <break>break;</break>


<comment type="block">/* ========================================================================== */</comment>
      <default>default:</default>        <comment type="block">/* Unsupported opcode */</comment>
      <return>return <expr><name>PCRE2_ERROR_DFA_UITEM</name></expr>;</return>
      </block_content>}</block></switch>

    <label><name>NEXT_ACTIVE_STATE</name>:</label> <continue>continue;</continue>

    </block_content>}</block></for>      <comment type="block">/* End of loop scanning active states */</comment>

  <comment type="block">/* We have finished the processing at the current subject character. If no
  new states have been set for the next character, we have found all the
  matches that we are going to find. If partial matching has been requested,
  check for appropriate conditions.

  The "forced_ fail" variable counts the number of (*F) encountered for the
  character. If it is equal to the original active_count (saved in
  workspace[1]) it means that (*F) was found on every active state. In this
  case we don't want to give a partial match.

  The "could_continue" variable is true if a state could have continued but
  for the fact that the end of the subject was reached. */</comment>

  <if_stmt><if>if <condition>(<expr><name>new_count</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>could_continue</name> <operator>&amp;&amp;</operator>                            <comment type="block">/* Some could go on, and */</comment>
        <name>forced_fail</name> <operator>!=</operator> <name><name>workspace</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator>               <comment type="block">/* Not all forced fail &amp; */</comment>
        <operator>(</operator>                                            <comment type="block">/* either... */</comment>
        <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_PARTIAL_HARD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal>      <comment type="block">/* Hard partial */</comment>
        <operator>||</operator>                                           <comment type="block">/* or... */</comment>
        <operator>(</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <name>PCRE2_PARTIAL_SOFT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>  <comment type="block">/* Soft partial and */</comment>
         <name>match_count</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator>                             <comment type="block">/* no matches */</comment>
        <operator>)</operator> <operator>&amp;&amp;</operator>                                         <comment type="block">/* And... */</comment>
        <operator>(</operator>
        <name>partial_newline</name> <operator>||</operator>                   <comment type="block">/* Either partial NL */</comment>
          <operator>(</operator>                                  <comment type="block">/* or ... */</comment>
          <name>ptr</name> <operator>&gt;=</operator> <name>end_subject</name> <operator>&amp;&amp;</operator>              <comment type="block">/* End of subject and */</comment>
            <operator>(</operator>                                  <comment type="block">/* either */</comment>
            <name>ptr</name> <operator>&gt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_used_ptr</name></name> <operator>||</operator>        <comment type="block">/* Inspected non-empty string */</comment>
            <name><name>mb</name><operator>-&gt;</operator><name>allowemptypartial</name></name>              <comment type="block">/* or pattern has lookbehind */</comment>
            <operator>)</operator>                                  <comment type="block">/* or could match empty */</comment>
          <operator>)</operator>
        <operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>match_count</name> <operator>=</operator> <name>PCRE2_ERROR_PARTIAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <break>break;</break>  <comment type="block">/* Exit from loop along the subject string */</comment>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* One or more states are active for the next character. */</comment>

  <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>    <comment type="block">/* Advance to next subject character */</comment>
  </block_content>}</block></for>               <comment type="block">/* Loop to move along the subject string */</comment>

<comment type="block">/* Control gets here from "break" a few lines above. If we have a match and
PCRE2_ENDANCHORED is set, the match fails. */</comment>

<if_stmt><if>if <condition>(<expr><name>match_count</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
    <operator>(</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>|</operator> <name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name><operator>)</operator> <operator>&amp;</operator> <name>PCRE2_ENDANCHORED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
    <name>ptr</name> <operator>&lt;</operator> <name>end_subject</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>match_count</name> <operator>=</operator> <name>PCRE2_ERROR_NOMATCH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>match_count</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*     Match a pattern using the DFA algorithm    *
*************************************************/</comment>

<comment type="block">/* This function matches a compiled pattern to a subject string, using the
alternate matching algorithm that finds all matches at once.

Arguments:
  code          points to the compiled pattern
  subject       subject string
  length        length of subject string
  startoffset   where to start matching in the subject
  options       option bits
  match_data    points to a match data structure
  gcontext      points to a match context
  workspace     pointer to workspace
  wscount       size of workspace

Returns:        &gt; 0 =&gt; number of match offset pairs placed in offsets
                = 0 =&gt; offsets overflowed; longest matches are present
                 -1 =&gt; failed to match
               &lt; -1 =&gt; some kind of unexpected problem
*/</comment>

<function><type><name>PCRE2_EXP_DEFN</name> <name>int</name> <name>PCRE2_CALL_CONVENTION</name></type>
<name>pcre2_dfa_match</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pcre2_code</name> <modifier>*</modifier></type><name>code</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>subject</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>length</name></decl></parameter>,
  <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>start_offset</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>pcre2_match_data</name> <modifier>*</modifier></type><name>match_data</name></decl></parameter>,
  <parameter><decl><type><name>pcre2_match_context</name> <modifier>*</modifier></type><name>mcontext</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>workspace</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>wscount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>was_zero_terminated</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>pcre2_real_code</name> <modifier>*</modifier></type><name>re</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>pcre2_real_code</name> <operator>*</operator><operator>)</operator><name>code</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>start_match</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>end_subject</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>bumpalong_limit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>req_cu_ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name></decl>, <decl><type ref="prev"/><name>anchored</name></decl>, <decl><type ref="prev"/><name>startline</name></decl>, <decl><type ref="prev"/><name>firstline</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>has_first_cu</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>has_req_cu</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<decl_stmt><decl><type><name>BOOL</name></type> <name>memchr_not_found_first_cu</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>memchr_not_found_first_cu2</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>first_cu</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>first_cu2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>req_cu</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>req_cu2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>start_bits</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* We need to have mb pointing to a match block, because the IS_NEWLINE macro
is used below, and it expects NLBLOCK to be defined as a pointer. */</comment>

<decl_stmt><decl><type><name>pcre2_callout_block</name></type> <name>cb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dfa_match_block</name></type> <name>actual_match_block</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dfa_match_block</name> <modifier>*</modifier></type><name>mb</name> <init>= <expr><operator>&amp;</operator><name>actual_match_block</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Set up a starting block of memory for use during recursive calls to
internal_dfa_match(). By putting this on the stack, it minimizes resource use
in the case when it is not needed. If this is too small, more memory is
obtained from the heap. At the start of each block is an anchor structure.*/</comment>

<decl_stmt><decl><type><name>int</name></type> <name><name>base_recursion_workspace</name><index>[<expr><name>RWS_BASE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RWS_anchor</name> <modifier>*</modifier></type><name>rws</name> <init>= <expr><operator>(</operator><name>RWS_anchor</name> <operator>*</operator><operator>)</operator><name>base_recursion_workspace</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>rws</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rws</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>RWS_BASE_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rws</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name>RWS_BASE_SIZE</name> <operator>-</operator> <name>RWS_ANCHOR_SIZE</name></expr>;</expr_stmt>

<comment type="block">/* A length equal to PCRE2_ZERO_TERMINATED implies a zero-terminated
subject string. */</comment>

<if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <name>PCRE2_ZERO_TERMINATED</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>length</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>strlen</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>subject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>was_zero_terminated</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Plausibility checks */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <operator>~</operator><name>PUBLIC_DFA_MATCH_OPTIONS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_BADOPTION</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>re</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>subject</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>workspace</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>match_data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>PCRE2_ERROR_NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>wscount</name> <operator>&lt;</operator> <literal type="number">20</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_DFA_WSSIZE</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>start_offset</name> <operator>&gt;</operator> <name>length</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_BADOFFSET</name></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* Partial matching and PCRE2_ENDANCHORED are currently not allowed at the same
time. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_PARTIAL_HARD</name><operator>|</operator><name>PCRE2_PARTIAL_SOFT</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
   <operator>(</operator><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>|</operator> <name>options</name><operator>)</operator> <operator>&amp;</operator> <name>PCRE2_ENDANCHORED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>PCRE2_ERROR_BADOPTION</name></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* Invalid UTF support is not available for DFA matching. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_MATCH_INVALID_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>PCRE2_ERROR_DFA_UINVALID_UTF</name></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* Check that the first field in the block is the magic number. If it is not,
return with PCRE2_ERROR_BADMAGIC. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>magic_number</name></name> <operator>!=</operator> <name>MAGIC_NUMBER</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_BADMAGIC</name></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* Check the code unit width. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_MODE_MASK</name><operator>)</operator> <operator>!=</operator> <name>PCRE2_CODE_UNIT_WIDTH</name><operator>/</operator><literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>PCRE2_ERROR_BADMODE</name></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* PCRE2_NOTEMPTY and PCRE2_NOTEMPTY_ATSTART are match-time flags in the
options variable for this function. Users of PCRE2 who are not calling the
function directly would like to have a way of setting these flags, in the same
way that they can set pcre2_compile() flags like PCRE2_NO_AUTOPOSSESS with
constructions like (*NO_AUTOPOSSESS). To enable this, (*NOTEMPTY) and
(*NOTEMPTY_ATSTART) set bits in the pattern's "flag" function which can now be
transferred to the options for this function. The bits are guaranteed to be
adjacent, but do not have the same values. This bit of Boolean trickery assumes
that the match-time bits are not more significant than the flag bits. If by
accident this is not the case, a compile-time division by zero error will
occur. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FF</name></cpp:macro> <cpp:value>(PCRE2_NOTEMPTY_SET|PCRE2_NE_ATST_SET)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OO</name></cpp:macro> <cpp:value>(PCRE2_NOTEMPTY|PCRE2_NOTEMPTY_ATSTART)</cpp:value></cpp:define>
<expr_stmt><expr><name>options</name> <operator>|=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>FF</name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>FF</name> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><name>FF</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <operator>(</operator><name>OO</name> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><name>OO</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FF</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OO</name></cpp:undef>

<comment type="block">/* If restarting after a partial match, do some sanity checks on the contents
of the workspace. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_DFA_RESTART</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>workspace</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>workspace</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator>
    <name><name>workspace</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>wscount</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator><operator>/</operator><name>INTS_PER_STATEBLOCK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>PCRE2_ERROR_DFA_BADRESTART</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Set some local values */</comment>

<expr_stmt><expr><name>utf</name> <operator>=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>start_match</name> <operator>=</operator> <name>subject</name> <operator>+</operator> <name>start_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end_subject</name> <operator>=</operator> <name>subject</name> <operator>+</operator> <name>length</name></expr>;</expr_stmt>
<expr_stmt><expr><name>req_cu_ptr</name> <operator>=</operator> <name>start_match</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>anchored</name> <operator>=</operator> <operator>(</operator><name>options</name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_ANCHORED</name><operator>|</operator><name>PCRE2_DFA_RESTART</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
  <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_ANCHORED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<comment type="block">/* The "must be at the start of a line" flags are used in a loop when finding
where to start. */</comment>

<expr_stmt><expr><name>startline</name> <operator>=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_STARTLINE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>firstline</name> <operator>=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_FIRSTLINE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>bumpalong_limit</name> <operator>=</operator> <name>end_subject</name></expr>;</expr_stmt>

<comment type="block">/* Initialize and set up the fixed fields in the callout block, with a pointer
in the match block. */</comment>

<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>cb</name></name> <operator>=</operator> <operator>&amp;</operator><name>cb</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>version</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>subject</name></name> <operator>=</operator> <name>subject</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>subject_length</name></name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>end_subject</name> <operator>-</operator> <name>subject</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>callout_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>capture_top</name></name>      <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>      <comment type="block">/* No capture support */</comment>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>capture_last</name></name>     <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>mark</name></name>             <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>   <comment type="block">/* No (*MARK) support */</comment>

<comment type="block">/* Get data from the match context, if present, and fill in the remaining
fields in the match block. It is an error to set an offset limit without
setting the flag at compile time. */</comment>

<if_stmt><if>if <condition>(<expr><name>mcontext</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>callout</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>memctl</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>memctl</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>match_limit</name></name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>default_match_context</name></expr></argument>)</argument_list></call><operator>.</operator><name>match_limit</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>match_limit_depth</name></name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>default_match_context</name></expr></argument>)</argument_list></call><operator>.</operator><name>depth_limit</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>heap_limit</name></name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>default_match_context</name></expr></argument>)</argument_list></call><operator>.</operator><name>heap_limit</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>mcontext</name><operator>-&gt;</operator><name>offset_limit</name></name> <operator>!=</operator> <name>PCRE2_UNSET</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_USE_OFFSET_LIMIT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>PCRE2_ERROR_BADOFFSETLIMIT</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>bumpalong_limit</name> <operator>=</operator> <name>subject</name> <operator>+</operator> <name><name>mcontext</name><operator>-&gt;</operator><name>offset_limit</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>callout</name></name> <operator>=</operator> <name><name>mcontext</name><operator>-&gt;</operator><name>callout</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>callout_data</name></name> <operator>=</operator> <name><name>mcontext</name><operator>-&gt;</operator><name>callout_data</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>memctl</name></name> <operator>=</operator> <name><name>mcontext</name><operator>-&gt;</operator><name>memctl</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>match_limit</name></name> <operator>=</operator> <name><name>mcontext</name><operator>-&gt;</operator><name>match_limit</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>match_limit_depth</name></name> <operator>=</operator> <name><name>mcontext</name><operator>-&gt;</operator><name>depth_limit</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>heap_limit</name></name> <operator>=</operator> <name><name>mcontext</name><operator>-&gt;</operator><name>heap_limit</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>match_limit</name></name> <operator>&gt;</operator> <name><name>re</name><operator>-&gt;</operator><name>limit_match</name></name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>match_limit</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>limit_match</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>match_limit_depth</name></name> <operator>&gt;</operator> <name><name>re</name><operator>-&gt;</operator><name>limit_depth</name></name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>match_limit_depth</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>limit_depth</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mb</name><operator>-&gt;</operator><name>heap_limit</name></name> <operator>&gt;</operator> <name><name>re</name><operator>-&gt;</operator><name>limit_heap</name></name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>heap_limit</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>limit_heap</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>start_code</name></name> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>re</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pcre2_real_code</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>+</operator>
  <name><name>re</name><operator>-&gt;</operator><name>name_count</name></name> <operator>*</operator> <name><name>re</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>tables</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>tables</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name> <operator>=</operator> <name>subject</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name> <operator>=</operator> <name>end_subject</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>start_offset</name></name> <operator>=</operator> <name>start_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>allowemptypartial</name></name> <operator>=</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>max_lookbehind</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
  <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_MATCH_EMPTY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>=</operator> <name>options</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>poptions</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>match_call_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>heap_used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<comment type="block">/* Process the \R and newline settings. */</comment>

<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>bsr_convention</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>bsr_convention</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nltype</name></name> <operator>=</operator> <name>NLTYPE_FIXED</name></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>newline_convention</name></name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><name>PCRE2_NEWLINE_CR</name></expr>:</case>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nllen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_CR</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>PCRE2_NEWLINE_LF</name></expr>:</case>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nllen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_NL</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>PCRE2_NEWLINE_NUL</name></expr>:</case>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nllen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_NUL</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>PCRE2_NEWLINE_CRLF</name></expr>:</case>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nllen</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_CR</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_NL</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>PCRE2_NEWLINE_ANY</name></expr>:</case>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nltype</name></name> <operator>=</operator> <name>NLTYPE_ANY</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>PCRE2_NEWLINE_ANYCRLF</name></expr>:</case>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>nltype</name></name> <operator>=</operator> <name>NLTYPE_ANYCRLF</name></expr>;</expr_stmt>
  <break>break;</break>

  <default>default:</default> <return>return <expr><name>PCRE2_ERROR_INTERNAL</name></expr>;</return>
  </block_content>}</block></switch>

<comment type="block">/* Check a UTF string for validity if required. For 8-bit and 16-bit strings,
we must also check that a starting offset does not point into the middle of a
multiunit character. We check only the portion of the subject that is going to
be inspected during matching - from the offset minus the maximum back reference
to the given length. This saves time when a small part of a large subject is
being matched by the use of a starting offset. Note that the maximum lookbehind
is a number of characters, not code units. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NO_UTF_CHECK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>check_subject</name> <init>= <expr><name>start_match</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* start_match includes offset */</comment>

  <if_stmt><if>if <condition>(<expr><name>start_offset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>start_match</name> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator> <call><name>NOT_FIRSTCU</name><argument_list>(<argument><expr><operator>*</operator><name>start_match</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>PCRE2_ERROR_BADUTFOFFSET</name></expr>;</return></block_content></block></if></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>max_lookbehind</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>check_subject</name> <operator>&gt;</operator> <name>subject</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
      <block>{<block_content>
      <expr_stmt><expr><name>check_subject</name><operator>--</operator></expr>;</expr_stmt>
      <while>while <condition>(<expr><name>check_subject</name> <operator>&gt;</operator> <name>subject</name> <operator>&amp;&amp;</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
      <operator>(</operator><operator>*</operator><name>check_subject</name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* 16-bit */</comment>
      <expr_stmt><expr><operator>(</operator><operator>*</operator><name>check_subject</name> <operator>&amp;</operator> <literal type="number">0xfc00</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xdc00</literal></expr></expr_stmt></block_content></block></while>)</block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 8 */</comment>
        check_subject--</block><empty_stmt>;</empty_stmt></for>
      </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>   <comment type="block">/* In the 32-bit library, one code unit equals one character. */</comment>
    <expr_stmt><expr><name>check_subject</name> <operator>-=</operator> <name><name>re</name><operator>-&gt;</operator><name>max_lookbehind</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>check_subject</name> <operator>&lt;</operator> <name>subject</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>check_subject</name> <operator>=</operator> <name>subject</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* PCRE2_CODE_UNIT_WIDTH != 32 */</comment>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Validate the relevant portion of the subject. After an error, adjust the
  offset to be an absolute offset in the whole string. */</comment>

  <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>valid_utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>check_subject</name></expr></argument>,
    <argument><expr><name>length</name> <operator>-</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>check_subject</name> <operator>-</operator> <name>subject</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>match_data</name><operator>-&gt;</operator><name>startchar</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>match_data</name><operator>-&gt;</operator><name>rc</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>startchar</name></name> <operator>+=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>check_subject</name> <operator>-</operator> <name>subject</name><operator>)</operator></expr>;</expr_stmt>
    <return>return <expr><name><name>match_data</name><operator>-&gt;</operator><name>rc</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

<comment type="block">/* Set up the first code unit to match, if available. If there's no first code
unit there may be a bitmap of possible first characters. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_FIRSTSET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>has_first_cu</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>first_cu</name> <operator>=</operator> <name>first_cu2</name> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name><operator>)</operator><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>first_codeunit</name></name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_FIRSTCASELESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>first_cu2</name> <operator>=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>first_cu</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>tables</name></name> <operator>+</operator> <name>fcc_offset</name></expr></argument>, <argument><expr><name>first_cu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>first_cu</name> <operator>&gt;</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>utf</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>first_cu2</name> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name><operator>)</operator><call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>first_cu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name>first_cu</name> <operator>&gt;</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>utf</name> <operator>||</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>first_cu2</name> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name><operator>)</operator><call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>first_cu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if>
<if type="elseif">else
  if <condition>(<expr><operator>!</operator><name>startline</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_FIRSTMAPSET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>start_bits</name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>start_bitmap</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* There may be a "last known required code unit" set. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_LASTSET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>has_req_cu</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>req_cu</name> <operator>=</operator> <name>req_cu2</name> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name><operator>)</operator><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>last_codeunit</name></name><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_LASTCASELESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>req_cu2</name> <operator>=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>req_cu</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>tables</name></name> <operator>+</operator> <name>fcc_offset</name></expr></argument>, <argument><expr><name>req_cu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>req_cu</name> <operator>&gt;</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>utf</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>req_cu2</name> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name><operator>)</operator><call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>req_cu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name>req_cu</name> <operator>&gt;</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>utf</name> <operator>||</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>req_cu2</name> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name><operator>)</operator><call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>req_cu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* If the match data block was previously used with PCRE2_COPY_MATCHED_SUBJECT,
free the memory that was obtained. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>match_data</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_MD_COPIED_SUBJECT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name><name>match_data</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>free</name></name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>match_data</name><operator>-&gt;</operator><name>subject</name></name></expr></argument>,
    <argument><expr><name><name>match_data</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>PCRE2_MD_COPIED_SUBJECT</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Fill in fields that are always returned in the match data. */</comment>

<expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>re</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>subject</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>  <comment type="block">/* Default for no match */</comment>
<expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>mark</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>matchedby</name></name> <operator>=</operator> <name>PCRE2_MATCHEDBY_DFA_INTERPRETER</name></expr>;</expr_stmt>

<comment type="block">/* Call the main matching function, looping for a non-anchored regex after a
failed match. If not restarting, perform certain optimizations at the start of
a match. */</comment>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <comment type="block">/* ----------------- Start of match optimizations ---------------- */</comment>

  <comment type="block">/* There are some optimizations that avoid running the match if a known
  starting point is not found, or if a known later code unit is not present.
  However, there is an option (settable at compile time) that disables
  these, for testing and for ensuring that all callouts do actually occur.
  The optimizations must also be avoided when restarting a DFA match. */</comment>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_NO_START_OPTIMIZE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
      <operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_DFA_RESTART</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* If firstline is TRUE, the start of the match is constrained to the first
    line of a multiline string. That is, the match must be before or at the
    first newline following the start of matching. Temporarily adjust
    end_subject so that we stop the optimization scans for a first code unit
    immediately after the first character of a newline (the first code unit can
    legitimately be a newline). If the match fails at the newline, later code
    breaks this loop. */</comment>

    <if_stmt><if>if <condition>(<expr><name>firstline</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>t</name> <init>= <expr><name>start_match</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
        <block>{<block_content>
        <while>while <condition>(<expr><name>t</name> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>t</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ACROSSCHAR</name><argument_list>(<argument><expr><name>t</name> <operator>&lt;</operator> <name>end_subject</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></while>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <while>while <condition>(<expr><name>t</name> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>t</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while></block_content></block></else></if_stmt>
      <expr_stmt><expr><name>end_subject</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Anchored: check the first code unit if one is recorded. This may seem
    pointless but it can help in detecting a no match case without scanning for
    the required code unit. */</comment>

    <if_stmt><if>if <condition>(<expr><name>anchored</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>has_first_cu</name> <operator>||</operator> <name>start_bits</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>ok</name> <init>= <expr><name>start_match</name> <operator>&lt;</operator> <name>end_subject</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>ok</name></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>c</name> <init>= <expr><call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>ok</name> <operator>=</operator> <name>has_first_cu</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>==</operator> <name>first_cu</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>first_cu2</name><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name> <operator>&amp;&amp;</operator> <name>start_bits</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>ok</name> <operator>=</operator> <operator>(</operator><name><name>start_bits</name><index>[<expr><name>c</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if>

    <comment type="block">/* Not anchored. Advance to a unique first code unit if there is one. In
    8-bit mode, the use of memchr() gives a big speed up, even though we have
    to call it twice in caseless mode, in order to find the earliest occurrence
    of the character in either of its cases. If a call to memchr() that
    searches the rest of the subject fails to find one case, remember that in
    order not to keep on repeating the search. This can make a huge difference
    when the strings are very long and only one case is present. */</comment>

    <else>else
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>has_first_cu</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>first_cu</name> <operator>!=</operator> <name>first_cu2</name></expr>)</condition>  <comment type="block">/* Caseless */</comment>
          <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
          <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>smc</name></decl>;</decl_stmt>
          <while>while <condition>(<expr><name>start_match</name> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator>
                <operator>(</operator><name>smc</name> <operator>=</operator> <call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>first_cu</name> <operator>&amp;&amp;</operator>
                  <name>smc</name> <operator>!=</operator> <name>first_cu2</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>start_match</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* 8-bit code units */</comment>
          <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>pp1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>pp2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>cu2size</name> <init>= <expr><name>end_subject</name> <operator>-</operator> <name>start_match</name></expr></init></decl>;</decl_stmt>

          <if_stmt><if>if <condition>(<expr><operator>!</operator><name>memchr_not_found_first_cu</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>pp1</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>, <argument><expr><name>first_cu</name></expr></argument>, <argument><expr><name>end_subject</name> <operator>-</operator> <name>start_match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>pp1</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>memchr_not_found_first_cu</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>
              <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>cu2size</name> <operator>=</operator> <name>pp1</name> <operator>-</operator> <name>start_match</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

          <comment type="block">/* If pp1 is not NULL, we have arranged to search only as far as pp1,
          to see if the other case is earlier, so we can set "not found" only
          when both searches have returned NULL. */</comment>

          <if_stmt><if>if <condition>(<expr><operator>!</operator><name>memchr_not_found_first_cu2</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>pp2</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>, <argument><expr><name>first_cu2</name></expr></argument>, <argument><expr><name>cu2size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>memchr_not_found_first_cu2</name> <operator>=</operator> <operator>(</operator><name>pp2</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>pp1</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

          <if_stmt><if>if <condition>(<expr><name>pp1</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>start_match</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>pp2</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then> <expr><name>end_subject</name></expr> </then><else>: <expr><name>pp2</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
          <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>start_match</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>pp2</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>pp1</name> <operator>&lt;</operator> <name>pp2</name><operator>)</operator></expr>?</condition><then> <expr><name>pp1</name></expr> </then><else>: <expr><name>pp2</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          </block_content>}</block></if>

        <comment type="block">/* The caseful case */</comment>

        <else>else
          <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
          <while>while <condition>(<expr><name>start_match</name> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator> <call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>)</argument_list></call> <operator>!=</operator>
                 <name>first_cu</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>start_match</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* 8-bit code units */</comment>
          <expr_stmt><expr><name>start_match</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>, <argument><expr><name>first_cu</name></expr></argument>, <argument><expr><name>end_subject</name> <operator>-</operator> <name>start_match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>start_match</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>start_match</name> <operator>=</operator> <name>end_subject</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          </block_content>}</block></else></if_stmt>

        <comment type="block">/* If we can't find the required code unit, having reached the true end
        of the subject, break the bumpalong loop, to force a match failure,
        except when doing partial matching, when we let the next cycle run at
        the end of the subject. To see why, consider the pattern /(?&lt;=abc)def/,
        which partially matches "abc", even though the string does not contain
        the starting character "d". If we have not reached the true end of the
        subject (PCRE2_FIRSTLINE caused end_subject to be temporarily modified)
        we also let the cycle run, because the matching string is legitimately
        allowed to start with the first code unit of a newline. */</comment>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_PARTIAL_HARD</name><operator>|</operator><name>PCRE2_PARTIAL_SOFT</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name>start_match</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition><block type="pseudo"><block_content>
          <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if>

      <comment type="block">/* If there's no first code unit, advance to just after a linebreak for a
      multiline match if required. */</comment>

      <if type="elseif">else if <condition>(<expr><name>startline</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>start_match</name> <operator>&gt;</operator> <name><name>mb</name><operator>-&gt;</operator><name>start_subject</name></name> <operator>+</operator> <name>start_offset</name></expr>)</condition>
          <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
          <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
            <block>{<block_content>
            <while>while <condition>(<expr><name>start_match</name> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>WAS_NEWLINE</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>)</argument_list></call></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><name>start_match</name><operator>++</operator></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>ACROSSCHAR</name><argument_list>(<argument><expr><name>start_match</name> <operator>&lt;</operator> <name>end_subject</name></expr></argument>, <argument><expr><name>start_match</name></expr></argument>, <argument><expr><name>start_match</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></while>
            </block_content>}</block></if>
          <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <while>while <condition>(<expr><name>start_match</name> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>WAS_NEWLINE</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>start_match</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while></block_content></block></else></if_stmt>

          <comment type="block">/* If we have just passed a CR and the newline option is ANY or
          ANYCRLF, and we are now at a LF, advance the match position by one
          more code unit. */</comment>

          <if_stmt><if>if <condition>(<expr><name><name>start_match</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_CR</name> <operator>&amp;&amp;</operator>
               <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_ANY</name> <operator>||</operator> <name><name>mb</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_ANYCRLF</name><operator>)</operator> <operator>&amp;&amp;</operator>
               <name>start_match</name> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator>
               <call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CHAR_NL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>start_match</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>

      <comment type="block">/* If there's no first code unit or a requirement for a multiline line
      start, advance to a non-unique first code unit if any have been
      identified. The bitmap contains only 256 bits. When code units are 16 or
      32 bits wide, all code units greater than 254 set the 255 bit. */</comment>

      <if type="elseif">else if <condition>(<expr><name>start_bits</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
        <while>while <condition>(<expr><name>start_match</name> <operator>&lt;</operator> <name>end_subject</name></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name> <init>= <expr><call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
          <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>start_bits</name><index>[<expr><name>c</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>c</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>start_match</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></while>

        <comment type="block">/* See comment above in first_cu checking about the next line. */</comment>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_PARTIAL_HARD</name><operator>|</operator><name>PCRE2_PARTIAL_SOFT</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name>start_match</name> <operator>&gt;=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>)</condition><block type="pseudo"><block_content>
          <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>  <comment type="block">/* End of first code unit handling */</comment>

    <comment type="block">/* Restore fudged end_subject */</comment>

    <expr_stmt><expr><name>end_subject</name> <operator>=</operator> <name><name>mb</name><operator>-&gt;</operator><name>end_subject</name></name></expr>;</expr_stmt>

    <comment type="block">/* The following two optimizations are disabled for partial matching. */</comment>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>moptions</name></name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_PARTIAL_HARD</name><operator>|</operator><name>PCRE2_PARTIAL_SOFT</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>p</name></decl>;</decl_stmt>

      <comment type="block">/* The minimum matching length is a lower bound; no actual string of that
      length may actually match the pattern. Although the value is, strictly,
      in characters, we treat it as code units to avoid spending too much time
      in this optimization. */</comment>

      <if_stmt><if>if <condition>(<expr><name>end_subject</name> <operator>-</operator> <name>start_match</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>minlength</name></name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>NOMATCH_EXIT</name>;</goto></block_content></block></if></if_stmt>

      <comment type="block">/* If req_cu is set, we know that that code unit must appear in the
      subject for the match to succeed. If the first code unit is set, req_cu
      must be later in the subject; otherwise the test starts at the match
      point. This optimization can save a huge amount of backtracking in
      patterns with nested unlimited repeats that aren't going to match.
      Writing separate code for cased/caseless versions makes it go faster, as
      does using an autoincrement and backing off on a match. As in the case of
      the first code unit, using memchr() in the 8-bit library gives a big
      speed up. Unlike the first_cu check above, we do not need to call
      memchr() twice in the caseless case because we only need to check for the
      presence of the character in either case, not find the first occurrence.

      The search can be skipped if the code unit was found later than the
      current starting point in a previous iteration of the bumpalong loop.

      HOWEVER: when the subject string is very, very long, searching to its end
      can take a long time, and give bad performance on quite ordinary
      patterns. This showed up when somebody was matching something like
      /^\d+C/ on a 32-megabyte string... so we don't do this when the string is
      sufficiently long, but it's worth searching a lot more for unanchored
      patterns. */</comment>

      <expr_stmt><expr><name>p</name> <operator>=</operator> <name>start_match</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>has_first_cu</name></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>has_req_cu</name> <operator>&amp;&amp;</operator> <name>p</name> <operator>&gt;</operator> <name>req_cu_ptr</name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>check_length</name> <init>= <expr><name>end_subject</name> <operator>-</operator> <name>start_match</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>check_length</name> <operator>&lt;</operator> <name>REQ_CU_MAX</name> <operator>||</operator>
              <operator>(</operator><operator>!</operator><name>anchored</name> <operator>&amp;&amp;</operator> <name>check_length</name> <operator>&lt;</operator> <name>REQ_CU_MAX</name> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>req_cu</name> <operator>!=</operator> <name>req_cu2</name></expr>)</condition>  <comment type="block">/* Caseless */</comment>
            <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
            <while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end_subject</name></expr>)</condition>
              <block>{<block_content>
              <decl_stmt><decl><type><name>uint32_t</name></type> <name>pp</name> <init>= <expr><call><name>UCHAR21INCTEST</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <if_stmt><if>if <condition>(<expr><name>pp</name> <operator>==</operator> <name>req_cu</name> <operator>||</operator> <name>pp</name> <operator>==</operator> <name>req_cu2</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
              </block_content>}</block></while>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* 8-bit code units */</comment>
            <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>pp</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>req_cu</name></expr></argument>, <argument><expr><name>end_subject</name> <operator>-</operator> <name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>req_cu2</name></expr></argument>, <argument><expr><name>end_subject</name> <operator>-</operator> <name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name>end_subject</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
              </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PCRE2_CODE_UNIT_WIDTH != 8 */</comment>
            </block_content>}</block></if>

          <comment type="block">/* The caseful case */</comment>

          <else>else
            <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
            <while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end_subject</name></expr>)</condition>
              <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><call><name>UCHAR21INCTEST</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>req_cu</name></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
              </block_content>}</block></while>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* 8-bit code units */</comment>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>req_cu</name></expr></argument>, <argument><expr><name>end_subject</name> <operator>-</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name>end_subject</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></else></if_stmt>

          <comment type="block">/* If we can't find the required code unit, break the matching loop,
          forcing a match failure. */</comment>

          <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name>end_subject</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

          <comment type="block">/* If we have found the required code unit, save the point where we
          found it, so that we don't search again next time round the loop if
          the start hasn't passed this code unit yet. */</comment>

          <expr_stmt><expr><name>req_cu_ptr</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* ------------ End of start of match optimizations ------------ */</comment>

  <comment type="block">/* Give no match if we have passed the bumpalong limit. */</comment>

  <if_stmt><if>if <condition>(<expr><name>start_match</name> <operator>&gt;</operator> <name>bumpalong_limit</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

  <comment type="block">/* OK, now we can do the business */</comment>

  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>start_used_ptr</name></name> <operator>=</operator> <name>start_match</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name> <operator>=</operator> <name>start_match</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mb</name><operator>-&gt;</operator><name>recursive</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>internal_dfa_match</name><argument_list>(
    <argument><expr><name>mb</name></expr></argument>,                           <comment type="block">/* fixed match data */</comment>
    <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>start_code</name></name></expr></argument>,               <comment type="block">/* this subexpression's code */</comment>
    <argument><expr><name>start_match</name></expr></argument>,                  <comment type="block">/* where we currently are */</comment>
    <argument><expr><name>start_offset</name></expr></argument>,                 <comment type="block">/* start offset in subject */</comment>
    <argument><expr><name><name>match_data</name><operator>-&gt;</operator><name>ovector</name></name></expr></argument>,          <comment type="block">/* offset vector */</comment>
    <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>match_data</name><operator>-&gt;</operator><name>oveccount</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>,  <comment type="block">/* actual size of same */</comment>
    <argument><expr><name>workspace</name></expr></argument>,                    <comment type="block">/* workspace vector */</comment>
    <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>wscount</name></expr></argument>,                 <comment type="block">/* size of same */</comment>
    <argument><expr><literal type="number">0</literal></expr></argument>,                            <comment type="block">/* function recurse level */</comment>
    <argument><expr><name>base_recursion_workspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* initial workspace for recursion */</comment>

  <comment type="block">/* Anything other than "no match" means we are done, always; otherwise, carry
  on only if not anchored. */</comment>

  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PCRE2_ERROR_NOMATCH</name> <operator>||</operator> <name>anchored</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PCRE2_ERROR_PARTIAL</name> <operator>&amp;&amp;</operator> <name><name>match_data</name><operator>-&gt;</operator><name>oveccount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>start_match</name> <operator>-</operator> <name>subject</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>end_subject</name> <operator>-</operator> <name>subject</name><operator>)</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>leftchar</name></name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>start_used_ptr</name></name> <operator>-</operator> <name>subject</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>rightchar</name></name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator> <name><name>mb</name><operator>-&gt;</operator><name>last_used_ptr</name></name> <operator>-</operator> <name>subject</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>startchar</name></name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>start_match</name> <operator>-</operator> <name>subject</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_COPY_MATCHED_SUBJECT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>CU2BYTES</name><argument_list>(<argument><expr><name>length</name> <operator>+</operator> <name>was_zero_terminated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>subject</name></name> <operator>=</operator> <call><name><name>match_data</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>malloc</name></name><argument_list>(<argument><expr><name>length</name></expr></argument>,
        <argument><expr><name><name>match_data</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>match_data</name><operator>-&gt;</operator><name>subject</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>match_data</name><operator>-&gt;</operator><name>subject</name></name></expr></argument>, <argument><expr><name>subject</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PCRE2_MD_COPIED_SUBJECT</name></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>rc</name> <operator>==</operator> <name>PCRE2_ERROR_PARTIAL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>subject</name></name> <operator>=</operator> <name>subject</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    <goto>goto <name>EXIT</name>;</goto>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Advance to the next subject character unless we are at the end of a line
  and firstline is set. */</comment>

  <if_stmt><if>if <condition>(<expr><name>firstline</name> <operator>&amp;&amp;</operator> <call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>start_match</name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>ACROSSCHAR</name><argument_list>(<argument><expr><name>start_match</name> <operator>&lt;</operator> <name>end_subject</name></expr></argument>, <argument><expr><name>start_match</name></expr></argument>, <argument><expr><name>start_match</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if <condition>(<expr><name>start_match</name> <operator>&gt;</operator> <name>end_subject</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

  <comment type="block">/* If we have just passed a CR and we are now at a LF, and the pattern does
  not contain any explicit matches for \r or \n, and the newline option is CRLF
  or ANY or ANYCRLF, advance the match position by one more character. */</comment>

  <if_stmt><if>if <condition>(<expr><call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>start_match</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>CHAR_CR</name> <operator>&amp;&amp;</operator>
      <name>start_match</name> <operator>&lt;</operator> <name>end_subject</name> <operator>&amp;&amp;</operator>
      <call><name>UCHAR21TEST</name><argument_list>(<argument><expr><name>start_match</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CHAR_NL</name> <operator>&amp;&amp;</operator>
      <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_HASCRORLF</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>mb</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_ANY</name> <operator>||</operator>
         <name><name>mb</name><operator>-&gt;</operator><name>nltype</name></name> <operator>==</operator> <name>NLTYPE_ANYCRLF</name> <operator>||</operator>
         <name><name>mb</name><operator>-&gt;</operator><name>nllen</name></name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>start_match</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

  </block_content>}</block></for>   <comment type="block">/* "Bumpalong" loop */</comment>

<label><name>NOMATCH_EXIT</name>:</label>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PCRE2_ERROR_NOMATCH</name></expr>;</expr_stmt>

<label><name>EXIT</name>:</label>
<while>while <condition>(<expr><name><name>rws</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>RWS_anchor</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>rws</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>rws</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>next</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>mb</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>free</name></name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><name><name>mb</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

<return>return <expr><name>rc</name></expr>;</return>
}

<comment type="block">/* End of pcre2_dfa_match.c */</comment>
</unit>
